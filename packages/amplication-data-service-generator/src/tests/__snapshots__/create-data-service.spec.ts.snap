// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`createDataService creates app as expected 1`] = `
Object {
  ".env": "POSTGRESQL_USER=testUsername
POSTGRESQL_PASSWORD=1234
POSTGRESQL_PORT=5433
SERVER_PORT=3000
BCRYPT_SALT=10
",
  "admin-ui/.env": "PORT=3001",
  "admin-ui/src/App.tsx": "import React, { useEffect, useState } from \\"react\\";
import { Admin, DataProvider, Resource } from \\"react-admin\\";
import buildGraphQLProvider from \\"./data-provider/graphqlDataProvider\\";
import basicHttpAuthProvider from \\"./auth-provider/ra-auth-basic-http\\";
import { theme } from \\"./theme/theme\\";
import Login from \\"./Login\\";
import \\"./App.scss\\";
import Dashboard from \\"./pages/Dashboard\\";
import { UserList } from \\"./user/UserList\\";
import { UserCreate } from \\"./user/UserCreate\\";
import { UserEdit } from \\"./user/UserEdit\\";
import { UserShow } from \\"./user/UserShow\\";
import { OrderList } from \\"./order/OrderList\\";
import { OrderCreate } from \\"./order/OrderCreate\\";
import { OrderEdit } from \\"./order/OrderEdit\\";
import { OrderShow } from \\"./order/OrderShow\\";
import { OrganizationList } from \\"./organization/OrganizationList\\";
import { OrganizationCreate } from \\"./organization/OrganizationCreate\\";
import { OrganizationEdit } from \\"./organization/OrganizationEdit\\";
import { OrganizationShow } from \\"./organization/OrganizationShow\\";
import { CustomerList } from \\"./customer/CustomerList\\";
import { CustomerCreate } from \\"./customer/CustomerCreate\\";
import { CustomerEdit } from \\"./customer/CustomerEdit\\";
import { CustomerShow } from \\"./customer/CustomerShow\\";
import { EmptyList } from \\"./empty/EmptyList\\";
import { EmptyCreate } from \\"./empty/EmptyCreate\\";
import { EmptyEdit } from \\"./empty/EmptyEdit\\";
import { EmptyShow } from \\"./empty/EmptyShow\\";

const App = (): React.ReactElement => {
  const [dataProvider, setDataProvider] = useState<DataProvider | null>(null);
  useEffect(() => {
    buildGraphQLProvider
      .then((provider: any) => {
        setDataProvider(() => provider);
      })
      .catch((error: any) => {
        console.log(error);
      });
  }, []);
  if (!dataProvider) {
    return <div>Loading</div>;
  }
  return (
    <div className=\\"App\\">
      <Admin
        title={\\"Sample Application\\"}
        dataProvider={dataProvider}
        authProvider={basicHttpAuthProvider}
        theme={theme}
        dashboard={Dashboard}
        loginPage={Login}
      >
        <Resource
          name=\\"User\\"
          list={UserList}
          edit={UserEdit}
          create={UserCreate}
          show={UserShow}
        />
        <Resource
          name=\\"Order\\"
          list={OrderList}
          edit={OrderEdit}
          create={OrderCreate}
          show={OrderShow}
        />
        <Resource
          name=\\"Organization\\"
          list={OrganizationList}
          edit={OrganizationEdit}
          create={OrganizationCreate}
          show={OrganizationShow}
        />
        <Resource
          name=\\"Customer\\"
          list={CustomerList}
          edit={CustomerEdit}
          create={CustomerCreate}
          show={CustomerShow}
        />
        <Resource
          name=\\"Empty\\"
          list={EmptyList}
          edit={EmptyEdit}
          create={EmptyCreate}
          show={EmptyShow}
        />
      </Admin>
    </div>
  );
};

export default App;
",
  "admin-ui/src/Components/Pagination.tsx": "import React from \\"react\\";
import { Pagination as RAPagination, PaginationProps } from \\"react-admin\\";

const PAGINATION_OPTIONS = [10, 25, 50, 100, 200];

const Pagination = (props: PaginationProps) => (
  <RAPagination rowsPerPageOptions={PAGINATION_OPTIONS} {...props} />
);

export default Pagination;
",
  "admin-ui/src/Login.tsx": "import * as React from \\"react\\";
import { useState } from \\"react\\";
import { useLogin, useNotify, Notification, defaultTheme } from \\"react-admin\\";
import { ThemeProvider } from \\"@material-ui/styles\\";
import { createMuiTheme } from \\"@material-ui/core/styles\\";
import { Button } from \\"@material-ui/core\\";
import \\"./login.scss\\";

const CLASS_NAME = \\"login-page\\";

const Login = ({ theme }: { theme?: object }) => {
  const [username, setUsername] = useState(\\"\\");
  const [password, setPassword] = useState(\\"\\");
  const login = useLogin();
  const notify = useNotify();
  const submit = (e: any) => {
    e.preventDefault();
    login({ username, password }).catch(() =>
      notify(\\"Invalid email or password\\")
    );
  };

  return (
    <ThemeProvider theme={createMuiTheme(defaultTheme)}>
      <div className={\`\${CLASS_NAME}\`}>
        <div className={\`\${CLASS_NAME}__wrapper\`}>
          <div className={\`\${CLASS_NAME}__box\`}>
            <img
              src=\\"https://amplication.com/assets/graphql.png\\"
              alt=\\"GraphQL API\\"
            />
            <h2>Connect via GraphQL</h2>
            <div className={\`\${CLASS_NAME}__box__message\`}>
              Connect to the server using GraphQL API with a complete and
              understandable description of the data in your API
            </div>
            <Button
              type=\\"button\\"
              variant=\\"contained\\"
              color=\\"primary\\"
              href=\\"/graphql\\"
            >
              Continue
            </Button>
          </div>
          <div className={\`\${CLASS_NAME}__box\`}>
            <img
              src=\\"https://amplication.com/assets/react-admin.png\\"
              alt=\\"React-Admin\\"
            />
            <h2>Admin UI</h2>
            <div className={\`\${CLASS_NAME}__box__message\`}>
              Sign in to a React-Admin client with ready-made forms for creating
              and editing all the data models of your application.
            </div>
            <form onSubmit={submit}>
              <label>
                <span>Username</span>

                <input
                  name=\\"username\\"
                  type=\\"textbox\\"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                />
              </label>
              <label>
                <span>password</span>

                <input
                  name=\\"password\\"
                  type=\\"password\\"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                />
              </label>
              <Button type=\\"submit\\" variant=\\"contained\\" color=\\"primary\\">
                Log in
              </Button>
            </form>
          </div>
          <div className={\`\${CLASS_NAME}__box\`}>
            <img
              src=\\"https://amplication.com/assets/restapi.png\\"
              alt=\\"REST API\\"
            />
            <h2>Connect via REST API</h2>
            <div className={\`\${CLASS_NAME}__box__message\`}>
              Connect to the server using REST API with a built-in Swagger
              documentation
            </div>
            <Button
              type=\\"button\\"
              variant=\\"contained\\"
              color=\\"primary\\"
              href=\\"/api\\"
            >
              Continue
            </Button>
          </div>

          <Notification />
        </div>
        <div className={\`\${CLASS_NAME}__read-more\`}>
          <span>Read </span>
          <a href=\\"https://docs.amplication.com/docs/api\\" target=\\"docs\\">
            Amplication docs
          </a>
          <span> to learn more</span>
        </div>
      </div>
    </ThemeProvider>
  );
};

export default Login;
",
  "admin-ui/src/api/customer/CreateCustomerArgs.ts": "import { CustomerCreateInput } from \\"./CustomerCreateInput\\";

export type CreateCustomerArgs = {
  data: CustomerCreateInput;
};
",
  "admin-ui/src/api/customer/Customer.ts": "import { Organization } from \\"../organization/Organization\\";
import { Order } from \\"../order/Order\\";

export type Customer = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  email: string;
  firstName: string | null;
  lastName: string | null;
  isVip: boolean | null;
  birthData: Date | null;
  averageSale: number | null;
  favoriteNumber: number | null;
  geoLocation: string | null;
  comments: string | null;
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  organization?: Organization | null;
  vipOrganization?: Organization | null;
  orders?: Array<Order>;
};
",
  "admin-ui/src/api/customer/CustomerCreateInput.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type CustomerCreateInput = {
  email: string;
  firstName?: string | null;
  lastName?: string | null;
  isVip?: boolean | null;
  birthData?: Date | null;
  averageSale?: number | null;
  favoriteNumber?: number | null;
  geoLocation?: string | null;
  comments?: string | null;
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  organization?: OrganizationWhereUniqueInput | null;
  vipOrganization?: OrganizationWhereUniqueInput | null;
};
",
  "admin-ui/src/api/customer/CustomerFindManyArgs.ts": "import { CustomerWhereInput } from \\"./CustomerWhereInput\\";
import { CustomerOrderByInput } from \\"./CustomerOrderByInput\\";

export type CustomerFindManyArgs = {
  where?: CustomerWhereInput;
  orderBy?: CustomerOrderByInput;
  skip?: number;
  take?: number;
};
",
  "admin-ui/src/api/customer/CustomerFindUniqueArgs.ts": "import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";

export type CustomerFindUniqueArgs = {
  where: CustomerWhereUniqueInput;
};
",
  "admin-ui/src/api/customer/CustomerOrderByInput.ts": "import { SortOrder } from \\"../../util/SortOrder\\";

export type CustomerOrderByInput = {
  id?: SortOrder;
  createdAt?: SortOrder;
  updatedAt?: SortOrder;
  email?: SortOrder;
  firstName?: SortOrder;
  lastName?: SortOrder;
  isVip?: SortOrder;
  birthData?: SortOrder;
  averageSale?: SortOrder;
  favoriteNumber?: SortOrder;
  geoLocation?: SortOrder;
  comments?: SortOrder;
  favoriteColors?: SortOrder;
  customerType?: SortOrder;
  organizationId?: SortOrder;
  vipOrganizationId?: SortOrder;
};
",
  "admin-ui/src/api/customer/CustomerUpdateInput.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type CustomerUpdateInput = {
  email?: string;
  firstName?: string | null;
  lastName?: string | null;
  isVip?: boolean | null;
  birthData?: Date | null;
  averageSale?: number | null;
  favoriteNumber?: number | null;
  geoLocation?: string | null;
  comments?: string | null;
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  organization?: OrganizationWhereUniqueInput | null;
  vipOrganization?: OrganizationWhereUniqueInput | null;
};
",
  "admin-ui/src/api/customer/CustomerWhereInput.ts": "import { StringFilter } from \\"../../util/StringFilter\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";
import { StringNullableFilter } from \\"../../util/StringNullableFilter\\";
import { BooleanNullableFilter } from \\"../../util/BooleanNullableFilter\\";
import { DateTimeNullableFilter } from \\"../../util/DateTimeNullableFilter\\";
import { FloatNullableFilter } from \\"../../util/FloatNullableFilter\\";
import { IntNullableFilter } from \\"../../util/IntNullableFilter\\";
import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type CustomerWhereInput = {
  id?: StringFilter;
  createdAt?: DateTimeFilter;
  updatedAt?: DateTimeFilter;
  email?: StringFilter;
  firstName?: StringNullableFilter;
  lastName?: StringNullableFilter;
  isVip?: BooleanNullableFilter;
  birthData?: DateTimeNullableFilter;
  averageSale?: FloatNullableFilter;
  favoriteNumber?: IntNullableFilter;
  geoLocation?: StringNullableFilter;
  comments?: StringNullableFilter;
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\";
  organization?: OrganizationWhereUniqueInput;
  vipOrganization?: OrganizationWhereUniqueInput;
};
",
  "admin-ui/src/api/customer/CustomerWhereUniqueInput.ts": "export type CustomerWhereUniqueInput = {
  id: string;
};
",
  "admin-ui/src/api/customer/DeleteCustomerArgs.ts": "import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";

export type DeleteCustomerArgs = {
  where: CustomerWhereUniqueInput;
};
",
  "admin-ui/src/api/customer/EnumCustomerCustomerType.ts": "export enum EnumCustomerCustomerType {
  Platinum = \\"platinum\\",
  Gold = \\"gold\\",
  Bronze = \\"bronze\\",
  Regular = \\"regular\\",
}
",
  "admin-ui/src/api/customer/EnumCustomerFavoriteColors.ts": "export enum EnumCustomerFavoriteColors {
  Red = \\"red\\",
  Green = \\"green\\",
  Purple = \\"purple\\",
  Yellow = \\"yellow\\",
}
",
  "admin-ui/src/api/customer/UpdateCustomerArgs.ts": "import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";
import { CustomerUpdateInput } from \\"./CustomerUpdateInput\\";

export type UpdateCustomerArgs = {
  where: CustomerWhereUniqueInput;
  data: CustomerUpdateInput;
};
",
  "admin-ui/src/api/empty/DeleteEmptyArgs.ts": "import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";

export type DeleteEmptyArgs = {
  where: EmptyWhereUniqueInput;
};
",
  "admin-ui/src/api/empty/Empty.ts": "export type Empty = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
};
",
  "admin-ui/src/api/empty/EmptyCreateInput.ts": "export type EmptyCreateInput = {};
",
  "admin-ui/src/api/empty/EmptyFindManyArgs.ts": "import { EmptyWhereInput } from \\"./EmptyWhereInput\\";
import { EmptyOrderByInput } from \\"./EmptyOrderByInput\\";

export type EmptyFindManyArgs = {
  where?: EmptyWhereInput;
  orderBy?: EmptyOrderByInput;
  skip?: number;
  take?: number;
};
",
  "admin-ui/src/api/empty/EmptyFindUniqueArgs.ts": "import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";

export type EmptyFindUniqueArgs = {
  where: EmptyWhereUniqueInput;
};
",
  "admin-ui/src/api/empty/EmptyOrderByInput.ts": "import { SortOrder } from \\"../../util/SortOrder\\";

export type EmptyOrderByInput = {
  id?: SortOrder;
  createdAt?: SortOrder;
  updatedAt?: SortOrder;
};
",
  "admin-ui/src/api/empty/EmptyUpdateInput.ts": "export type EmptyUpdateInput = {};
",
  "admin-ui/src/api/empty/EmptyWhereInput.ts": "import { StringFilter } from \\"../../util/StringFilter\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";

export type EmptyWhereInput = {
  id?: StringFilter;
  createdAt?: DateTimeFilter;
  updatedAt?: DateTimeFilter;
};
",
  "admin-ui/src/api/empty/EmptyWhereUniqueInput.ts": "export type EmptyWhereUniqueInput = {
  id: string;
};
",
  "admin-ui/src/api/order/CreateOrderArgs.ts": "import { OrderCreateInput } from \\"./OrderCreateInput\\";

export type CreateOrderArgs = {
  data: OrderCreateInput;
};
",
  "admin-ui/src/api/order/DeleteOrderArgs.ts": "import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";

export type DeleteOrderArgs = {
  where: OrderWhereUniqueInput;
};
",
  "admin-ui/src/api/order/EnumOrderLabel.ts": "export enum EnumOrderLabel {
  Fragile = \\"fragile\\",
}
",
  "admin-ui/src/api/order/EnumOrderStatus.ts": "export enum EnumOrderStatus {
  Pending = \\"pending\\",
  InProgress = \\"inProgress\\",
  Done = \\"done\\",
}
",
  "admin-ui/src/api/order/Order.ts": "import { Customer } from \\"../customer/Customer\\";

export type Order = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  customer?: Customer;
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  label?: \\"fragile\\" | null;
};
",
  "admin-ui/src/api/order/OrderCreateInput.ts": "import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";

export type OrderCreateInput = {
  customer: CustomerWhereUniqueInput;
  status: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  label?: \\"fragile\\" | null;
};
",
  "admin-ui/src/api/order/OrderFindManyArgs.ts": "import { OrderWhereInput } from \\"./OrderWhereInput\\";
import { OrderOrderByInput } from \\"./OrderOrderByInput\\";

export type OrderFindManyArgs = {
  where?: OrderWhereInput;
  orderBy?: OrderOrderByInput;
  skip?: number;
  take?: number;
};
",
  "admin-ui/src/api/order/OrderFindUniqueArgs.ts": "import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";

export type OrderFindUniqueArgs = {
  where: OrderWhereUniqueInput;
};
",
  "admin-ui/src/api/order/OrderOrderByInput.ts": "import { SortOrder } from \\"../../util/SortOrder\\";

export type OrderOrderByInput = {
  id?: SortOrder;
  createdAt?: SortOrder;
  updatedAt?: SortOrder;
  customerId?: SortOrder;
  status?: SortOrder;
  label?: SortOrder;
};
",
  "admin-ui/src/api/order/OrderUpdateInput.ts": "import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";

export type OrderUpdateInput = {
  customer?: CustomerWhereUniqueInput;
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  label?: \\"fragile\\" | null;
};
",
  "admin-ui/src/api/order/OrderWhereInput.ts": "import { StringFilter } from \\"../../util/StringFilter\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";
import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";

export type OrderWhereInput = {
  id?: StringFilter;
  createdAt?: DateTimeFilter;
  updatedAt?: DateTimeFilter;
  customer?: CustomerWhereUniqueInput;
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  label?: \\"fragile\\";
};
",
  "admin-ui/src/api/order/OrderWhereUniqueInput.ts": "export type OrderWhereUniqueInput = {
  id: string;
};
",
  "admin-ui/src/api/order/UpdateOrderArgs.ts": "import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";
import { OrderUpdateInput } from \\"./OrderUpdateInput\\";

export type UpdateOrderArgs = {
  where: OrderWhereUniqueInput;
  data: OrderUpdateInput;
};
",
  "admin-ui/src/api/organization/CreateOrganizationArgs.ts": "import { OrganizationCreateInput } from \\"./OrganizationCreateInput\\";

export type CreateOrganizationArgs = {
  data: OrganizationCreateInput;
};
",
  "admin-ui/src/api/organization/DeleteOrganizationArgs.ts": "import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";

export type DeleteOrganizationArgs = {
  where: OrganizationWhereUniqueInput;
};
",
  "admin-ui/src/api/organization/Organization.ts": "import { User } from \\"../user/User\\";
import { Customer } from \\"../customer/Customer\\";

export type Organization = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  name: string;
  users?: Array<User>;
  customers?: Array<Customer>;
  vipCustomers?: Array<Customer>;
};
",
  "admin-ui/src/api/organization/OrganizationCreateInput.ts": "export type OrganizationCreateInput = {
  name: string;
};
",
  "admin-ui/src/api/organization/OrganizationFindManyArgs.ts": "import { OrganizationWhereInput } from \\"./OrganizationWhereInput\\";
import { OrganizationOrderByInput } from \\"./OrganizationOrderByInput\\";

export type OrganizationFindManyArgs = {
  where?: OrganizationWhereInput;
  orderBy?: OrganizationOrderByInput;
  skip?: number;
  take?: number;
};
",
  "admin-ui/src/api/organization/OrganizationFindUniqueArgs.ts": "import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";

export type OrganizationFindUniqueArgs = {
  where: OrganizationWhereUniqueInput;
};
",
  "admin-ui/src/api/organization/OrganizationOrderByInput.ts": "import { SortOrder } from \\"../../util/SortOrder\\";

export type OrganizationOrderByInput = {
  id?: SortOrder;
  createdAt?: SortOrder;
  updatedAt?: SortOrder;
  name?: SortOrder;
};
",
  "admin-ui/src/api/organization/OrganizationUpdateInput.ts": "export type OrganizationUpdateInput = {
  name?: string;
};
",
  "admin-ui/src/api/organization/OrganizationWhereInput.ts": "import { StringFilter } from \\"../../util/StringFilter\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";

export type OrganizationWhereInput = {
  id?: StringFilter;
  createdAt?: DateTimeFilter;
  updatedAt?: DateTimeFilter;
  name?: StringFilter;
};
",
  "admin-ui/src/api/organization/OrganizationWhereUniqueInput.ts": "export type OrganizationWhereUniqueInput = {
  id: string;
};
",
  "admin-ui/src/api/organization/UpdateOrganizationArgs.ts": "import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";
import { OrganizationUpdateInput } from \\"./OrganizationUpdateInput\\";

export type UpdateOrganizationArgs = {
  where: OrganizationWhereUniqueInput;
  data: OrganizationUpdateInput;
};
",
  "admin-ui/src/api/user/CreateUserArgs.ts": "import { UserCreateInput } from \\"./UserCreateInput\\";

export type CreateUserArgs = {
  data: UserCreateInput;
};
",
  "admin-ui/src/api/user/DeleteUserArgs.ts": "import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";

export type DeleteUserArgs = {
  where: UserWhereUniqueInput;
};
",
  "admin-ui/src/api/user/EnumUserInterests.ts": "export enum EnumUserInterests {
  Programming = \\"programming\\",
  Design = \\"design\\",
}
",
  "admin-ui/src/api/user/EnumUserPriority.ts": "export enum EnumUserPriority {
  High = \\"high\\",
  Medium = \\"medium\\",
  Low = \\"low\\",
}
",
  "admin-ui/src/api/user/UpdateUserArgs.ts": "import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { UserUpdateInput } from \\"./UserUpdateInput\\";

export type UpdateUserArgs = {
  where: UserWhereUniqueInput;
  data: UserUpdateInput;
};
",
  "admin-ui/src/api/user/User.ts": "import { Organization } from \\"../organization/Organization\\";
import { JsonValue } from \\"type-fest\\";

export type User = {
  username: string;
  roles: Array<string>;
  id: string;
  name: string;
  bio: string;
  email: string;
  age: number;
  birthDate: Date;
  score: number;
  manager?: User | null;
  employees?: Array<User>;
  organizations?: Array<Organization>;
  interests?: Array<\\"programming\\" | \\"design\\">;
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";
  isCurious: boolean;
  location: string;
  extendedProperties: JsonValue;
};
",
  "admin-ui/src/api/user/UserCreateInput.ts": "import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { JsonValue } from \\"type-fest\\";

export type UserCreateInput = {
  username: string;
  password: string;
  roles: Array<string>;
  name: string;
  bio: string;
  email: string;
  age: number;
  birthDate: Date;
  score: number;
  manager?: UserWhereUniqueInput | null;
  interests?: Array<\\"programming\\" | \\"design\\">;
  priority: \\"high\\" | \\"medium\\" | \\"low\\";
  isCurious: boolean;
  location: string;
  extendedProperties: JsonValue;
};
",
  "admin-ui/src/api/user/UserFindManyArgs.ts": "import { UserWhereInput } from \\"./UserWhereInput\\";
import { UserOrderByInput } from \\"./UserOrderByInput\\";

export type UserFindManyArgs = {
  where?: UserWhereInput;
  orderBy?: UserOrderByInput;
  skip?: number;
  take?: number;
};
",
  "admin-ui/src/api/user/UserFindUniqueArgs.ts": "import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";

export type UserFindUniqueArgs = {
  where: UserWhereUniqueInput;
};
",
  "admin-ui/src/api/user/UserOrderByInput.ts": "import { SortOrder } from \\"../../util/SortOrder\\";

export type UserOrderByInput = {
  username?: SortOrder;
  password?: SortOrder;
  roles?: SortOrder;
  id?: SortOrder;
  name?: SortOrder;
  bio?: SortOrder;
  email?: SortOrder;
  age?: SortOrder;
  birthDate?: SortOrder;
  score?: SortOrder;
  managerId?: SortOrder;
  interests?: SortOrder;
  priority?: SortOrder;
  isCurious?: SortOrder;
  location?: SortOrder;
  extendedProperties?: SortOrder;
};
",
  "admin-ui/src/api/user/UserUpdateInput.ts": "import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { JsonValue } from \\"type-fest\\";

export type UserUpdateInput = {
  username?: string;
  password?: string;
  roles?: Array<string>;
  name?: string;
  bio?: string;
  email?: string;
  age?: number;
  birthDate?: Date;
  score?: number;
  manager?: UserWhereUniqueInput | null;
  interests?: Array<\\"programming\\" | \\"design\\">;
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";
  isCurious?: boolean;
  location?: string;
  extendedProperties?: JsonValue;
};
",
  "admin-ui/src/api/user/UserWhereInput.ts": "import { StringFilter } from \\"../../util/StringFilter\\";
import { IntFilter } from \\"../../util/IntFilter\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { BooleanFilter } from \\"../../util/BooleanFilter\\";
import { JsonNullableFilter } from \\"../../util/JsonNullableFilter\\";

export type UserWhereInput = {
  id?: StringFilter;
  name?: StringFilter;
  bio?: StringFilter;
  age?: IntFilter;
  birthDate?: DateTimeFilter;
  manager?: UserWhereUniqueInput;
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";
  isCurious?: BooleanFilter;
  location?: StringFilter;
  extendedProperties?: JsonNullableFilter;
};
",
  "admin-ui/src/api/user/UserWhereUniqueInput.ts": "export type UserWhereUniqueInput = {
  id: string;
};
",
  "admin-ui/src/auth-provider/basic-auth.util.ts": "export function createBasicAuthorizationHeader(
  username: string,
  password: string
): string {
  return \`Basic \${btoa(\`\${username}:\${password}\`)}\`;
}
",
  "admin-ui/src/auth-provider/ra-auth-basic-http.ts": "import { ApolloClient, InMemoryCache, gql } from \\"@apollo/client/core\\";
import { createBasicAuthorizationHeader } from \\"./basic-auth.util\\";
import { AuthProvider } from \\"react-admin\\";

export const CREDENTIALS_LOCAL_STORAGE_ITEM = \\"credentials\\";
const USER_DATA_LOCAL_STORAGE_ITEM = \\"userData\\";

type TData = {
  login: {
    username: string;
  };
};

export type Credentials = {
  username: string;
  password: string;
};

const LOGIN = gql\`
  mutation login($username: String!, $password: String!) {
    login(credentials: { username: $username, password: $password }) {
      username
      roles
    }
  }
\`;

const basicHttpAuthProvider: AuthProvider = {
  login: async (credentials: Credentials) => {
    const apolloClient = new ApolloClient({
      uri: \\"/graphql\\",
      cache: new InMemoryCache(),
    });

    const userData = await apolloClient.mutate<TData>({
      mutation: LOGIN,
      variables: {
        ...credentials,
      },
    });

    if (userData && userData.data?.login.username) {
      localStorage.setItem(
        CREDENTIALS_LOCAL_STORAGE_ITEM,
        createBasicAuthorizationHeader(
          credentials.username,
          credentials.password
        )
      );
      localStorage.setItem(
        USER_DATA_LOCAL_STORAGE_ITEM,
        JSON.stringify(userData.data)
      );
      return Promise.resolve();
    }
    return Promise.reject();
  },
  logout: () => {
    localStorage.removeItem(CREDENTIALS_LOCAL_STORAGE_ITEM);
    return Promise.resolve();
  },
  checkError: ({ status }: any) => {
    if (status === 401 || status === 403) {
      localStorage.removeItem(CREDENTIALS_LOCAL_STORAGE_ITEM);
      return Promise.reject();
    }
    return Promise.resolve();
  },
  checkAuth: () => {
    return localStorage.getItem(CREDENTIALS_LOCAL_STORAGE_ITEM)
      ? Promise.resolve()
      : Promise.reject();
  },
  getPermissions: () => Promise.reject(\\"Unknown method\\"),
  getIdentity: () => {
    const str = localStorage.getItem(USER_DATA_LOCAL_STORAGE_ITEM);
    const userData: TData = JSON.parse(str || \\"\\");

    return Promise.resolve({
      id: userData.login.username,
      fullName: userData.login.username,
      avatar: undefined,
    });
  },
};
export default basicHttpAuthProvider;
",
  "admin-ui/src/auth.ts": "import { EventEmitter } from \\"events\\";

export type Credentials = {
  username: string;
  password: string;
};

const CREDENTIALS_LOCAL_STORAGE_ITEM = \\"credentials\\";

const eventEmitter = new EventEmitter();

export function isAuthenticated(): boolean {
  return Boolean(getCredentials());
}

export function listen(listener: (authenticated: boolean) => void): void {
  eventEmitter.on(\\"change\\", () => {
    listener(isAuthenticated());
  });
}

export function setCredentials(credentials: Credentials) {
  localStorage.setItem(
    CREDENTIALS_LOCAL_STORAGE_ITEM,
    JSON.stringify(credentials)
  );
}

export function getCredentials(): Credentials | null {
  const raw = localStorage.getItem(CREDENTIALS_LOCAL_STORAGE_ITEM);
  if (raw === null) {
    return null;
  }
  return JSON.parse(raw);
}

export function removeCredentials(): void {
  localStorage.removeItem(CREDENTIALS_LOCAL_STORAGE_ITEM);
}
",
  "admin-ui/src/customer/CustomerCreate.tsx": "import * as React from \\"react\\";

import {
  Create,
  SimpleForm,
  CreateProps,
  TextInput,
  BooleanInput,
  DateInput,
  NumberInput,
  SelectArrayInput,
  SelectInput,
  ReferenceInput,
} from \\"react-admin\\";

import { OrganizationTitle } from \\"../organization/OrganizationTitle\\";

export const CustomerCreate = (props: CreateProps): React.ReactElement => {
  return (
    <Create {...props}>
      <SimpleForm>
        <TextInput label=\\"Email\\" source=\\"email\\" type=\\"email\\" />
        <TextInput label=\\"First Name\\" source=\\"firstName\\" />
        <TextInput label=\\"Last Name\\" source=\\"lastName\\" />
        <BooleanInput label=\\"VIP\\" source=\\"isVip\\" />
        <DateInput label=\\"Birth Data\\" source=\\"birthData\\" />
        <NumberInput
          label=\\"Average Sale (-1500.00 - 1500.00)\\"
          source=\\"averageSale\\"
        />
        <NumberInput
          step={1}
          label=\\"Favorite Number (1 - 20)\\"
          source=\\"favoriteNumber\\"
        />
        <TextInput label=\\"Geographic Location\\" source=\\"geoLocation\\" />
        <TextInput
          label=\\"Comments (up to 500 characters)\\"
          multiline
          source=\\"comments\\"
        />
        <SelectArrayInput
          label=\\"Favorite Colors (multi-select)\\"
          source=\\"favoriteColors\\"
          choices={[
            { label: \\"Red\\", value: \\"red\\" },
            { label: \\"Green\\", value: \\"green\\" },
            { label: \\"Purple\\", value: \\"purple\\" },
            { label: \\"yellow\\", value: \\"yellow\\" },
          ]}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <SelectInput
          source=\\"customerType\\"
          label=\\"Customer Type\\"
          choices={[
            { label: \\"Platinum\\", value: \\"platinum\\" },
            { label: \\"Gold\\", value: \\"gold\\" },
            { label: \\"Bronze\\", value: \\"bronze\\" },
            { label: \\"Regular\\", value: \\"regular\\" },
          ]}
          optionText=\\"label\\"
          allowEmpty
          optionValue=\\"value\\"
        />
        <ReferenceInput
          source=\\"organization.id\\"
          reference=\\"Organization\\"
          label=\\"Organization\\"
        >
          <SelectInput optionText={OrganizationTitle} />
        </ReferenceInput>
        <ReferenceInput
          source=\\"organization.id\\"
          reference=\\"Organization\\"
          label=\\"VIP Organization\\"
        >
          <SelectInput optionText={OrganizationTitle} />
        </ReferenceInput>
      </SimpleForm>
    </Create>
  );
};
",
  "admin-ui/src/customer/CustomerEdit.tsx": "import * as React from \\"react\\";

import {
  Edit,
  SimpleForm,
  EditProps,
  TextInput,
  BooleanInput,
  DateInput,
  NumberInput,
  SelectArrayInput,
  SelectInput,
  ReferenceInput,
} from \\"react-admin\\";

import { OrganizationTitle } from \\"../organization/OrganizationTitle\\";

export const CustomerEdit = (props: EditProps): React.ReactElement => {
  return (
    <Edit {...props}>
      <SimpleForm>
        <TextInput label=\\"Email\\" source=\\"email\\" type=\\"email\\" />
        <TextInput label=\\"First Name\\" source=\\"firstName\\" />
        <TextInput label=\\"Last Name\\" source=\\"lastName\\" />
        <BooleanInput label=\\"VIP\\" source=\\"isVip\\" />
        <DateInput label=\\"Birth Data\\" source=\\"birthData\\" />
        <NumberInput
          label=\\"Average Sale (-1500.00 - 1500.00)\\"
          source=\\"averageSale\\"
        />
        <NumberInput
          step={1}
          label=\\"Favorite Number (1 - 20)\\"
          source=\\"favoriteNumber\\"
        />
        <TextInput label=\\"Geographic Location\\" source=\\"geoLocation\\" />
        <TextInput
          label=\\"Comments (up to 500 characters)\\"
          multiline
          source=\\"comments\\"
        />
        <SelectArrayInput
          label=\\"Favorite Colors (multi-select)\\"
          source=\\"favoriteColors\\"
          choices={[
            { label: \\"Red\\", value: \\"red\\" },
            { label: \\"Green\\", value: \\"green\\" },
            { label: \\"Purple\\", value: \\"purple\\" },
            { label: \\"yellow\\", value: \\"yellow\\" },
          ]}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <SelectInput
          source=\\"customerType\\"
          label=\\"Customer Type\\"
          choices={[
            { label: \\"Platinum\\", value: \\"platinum\\" },
            { label: \\"Gold\\", value: \\"gold\\" },
            { label: \\"Bronze\\", value: \\"bronze\\" },
            { label: \\"Regular\\", value: \\"regular\\" },
          ]}
          optionText=\\"label\\"
          allowEmpty
          optionValue=\\"value\\"
        />
        <ReferenceInput
          source=\\"organization.id\\"
          reference=\\"Organization\\"
          label=\\"Organization\\"
        >
          <SelectInput optionText={OrganizationTitle} />
        </ReferenceInput>
        <ReferenceInput
          source=\\"organization.id\\"
          reference=\\"Organization\\"
          label=\\"VIP Organization\\"
        >
          <SelectInput optionText={OrganizationTitle} />
        </ReferenceInput>
      </SimpleForm>
    </Edit>
  );
};
",
  "admin-ui/src/customer/CustomerList.tsx": "import * as React from \\"react\\";

import {
  List,
  Datagrid,
  ListProps,
  TextField,
  DateField,
  BooleanField,
  ReferenceField,
} from \\"react-admin\\";

import Pagination from \\"../Components/Pagination\\";
import { ORGANIZATION_TITLE_FIELD } from \\"../organization/OrganizationTitle\\";

export const CustomerList = (props: ListProps): React.ReactElement => {
  return (
    <List
      {...props}
      bulkActionButtons={false}
      title={\\"Customers\\"}
      perPage={50}
      pagination={<Pagination />}
    >
      <Datagrid rowClick=\\"show\\">
        <TextField label=\\"Id\\" source=\\"id\\" />
        <DateField source=\\"createdAt\\" label=\\"Created At\\" />
        <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
        <TextField label=\\"Email\\" source=\\"email\\" />
        <TextField label=\\"First Name\\" source=\\"firstName\\" />
        <TextField label=\\"Last Name\\" source=\\"lastName\\" />
        <BooleanField label=\\"VIP\\" source=\\"isVip\\" />
        <TextField label=\\"Birth Data\\" source=\\"birthData\\" />
        <TextField
          label=\\"Average Sale (-1500.00 - 1500.00)\\"
          source=\\"averageSale\\"
        />
        <TextField label=\\"Favorite Number (1 - 20)\\" source=\\"favoriteNumber\\" />
        <TextField label=\\"Geographic Location\\" source=\\"geoLocation\\" />
        <TextField label=\\"Comments (up to 500 characters)\\" source=\\"comments\\" />
        <TextField
          label=\\"Favorite Colors (multi-select)\\"
          source=\\"favoriteColors\\"
        />
        <TextField label=\\"Customer Type\\" source=\\"customerType\\" />
        <ReferenceField
          label=\\"Organization\\"
          source=\\"organization.id\\"
          reference=\\"Organization\\"
        >
          <TextField source={ORGANIZATION_TITLE_FIELD} />
        </ReferenceField>
        <ReferenceField
          label=\\"VIP Organization\\"
          source=\\"organization.id\\"
          reference=\\"Organization\\"
        >
          <TextField source={ORGANIZATION_TITLE_FIELD} />
        </ReferenceField>
      </Datagrid>
    </List>
  );
};
",
  "admin-ui/src/customer/CustomerShow.tsx": "import * as React from \\"react\\";

import {
  Show,
  SimpleShowLayout,
  ShowProps,
  TextField,
  DateField,
  BooleanField,
  ReferenceField,
  ReferenceManyField,
  Datagrid,
} from \\"react-admin\\";

import { CUSTOMER_TITLE_FIELD } from \\"./CustomerTitle\\";
import { ORGANIZATION_TITLE_FIELD } from \\"../organization/OrganizationTitle\\";

export const CustomerShow = (props: ShowProps): React.ReactElement => {
  return (
    <Show {...props}>
      <SimpleShowLayout>
        <TextField label=\\"Id\\" source=\\"id\\" />
        <DateField source=\\"createdAt\\" label=\\"Created At\\" />
        <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
        <TextField label=\\"Email\\" source=\\"email\\" />
        <TextField label=\\"First Name\\" source=\\"firstName\\" />
        <TextField label=\\"Last Name\\" source=\\"lastName\\" />
        <BooleanField label=\\"VIP\\" source=\\"isVip\\" />
        <TextField label=\\"Birth Data\\" source=\\"birthData\\" />
        <TextField
          label=\\"Average Sale (-1500.00 - 1500.00)\\"
          source=\\"averageSale\\"
        />
        <TextField label=\\"Favorite Number (1 - 20)\\" source=\\"favoriteNumber\\" />
        <TextField label=\\"Geographic Location\\" source=\\"geoLocation\\" />
        <TextField label=\\"Comments (up to 500 characters)\\" source=\\"comments\\" />
        <TextField
          label=\\"Favorite Colors (multi-select)\\"
          source=\\"favoriteColors\\"
        />
        <TextField label=\\"Customer Type\\" source=\\"customerType\\" />
        <ReferenceField
          label=\\"Organization\\"
          source=\\"organization.id\\"
          reference=\\"Organization\\"
        >
          <TextField source={ORGANIZATION_TITLE_FIELD} />
        </ReferenceField>
        <ReferenceField
          label=\\"VIP Organization\\"
          source=\\"organization.id\\"
          reference=\\"Organization\\"
        >
          <TextField source={ORGANIZATION_TITLE_FIELD} />
        </ReferenceField>
        <ReferenceManyField
          reference=\\"Order\\"
          target=\\"CustomerId\\"
          label=\\"Orders\\"
        >
          <Datagrid rowClick=\\"show\\">
            <TextField label=\\"Id\\" source=\\"id\\" />
            <DateField source=\\"createdAt\\" label=\\"Created At\\" />
            <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
            <ReferenceField
              label=\\"Customer\\"
              source=\\"customer.id\\"
              reference=\\"Customer\\"
            >
              <TextField source={CUSTOMER_TITLE_FIELD} />
            </ReferenceField>
            <TextField label=\\"Status\\" source=\\"status\\" />
            <TextField label=\\"Label\\" source=\\"label\\" />
          </Datagrid>
        </ReferenceManyField>
      </SimpleShowLayout>
    </Show>
  );
};
",
  "admin-ui/src/customer/CustomerTitle.ts": "import { Customer as TCustomer } from \\"../api/customer/Customer\\";

export const CUSTOMER_TITLE_FIELD = \\"firstName\\";

export const CustomerTitle = (record: TCustomer) => {
  return record.firstName;
};
",
  "admin-ui/src/data-provider/graphqlDataProvider.ts": "import buildGraphQLProvider from \\"ra-data-graphql-amplication\\";
import { ApolloClient, InMemoryCache, createHttpLink } from \\"@apollo/client\\";
import { setContext } from \\"@apollo/client/link/context\\";
import { CREDENTIALS_LOCAL_STORAGE_ITEM } from \\"../auth-provider/ra-auth-basic-http\\";

const httpLink = createHttpLink({
  uri: \\"/graphql\\",
});

const authLink = setContext((_, { headers }) => {
  const token = localStorage.getItem(CREDENTIALS_LOCAL_STORAGE_ITEM);
  return {
    headers: {
      ...headers,
      authorization: token ? token : \\"\\",
    },
  };
});

const apolloClient = new ApolloClient({
  cache: new InMemoryCache(),
  link: authLink.concat(httpLink),
});

export default buildGraphQLProvider({
  client: apolloClient,
});
",
  "admin-ui/src/empty/EmptyCreate.tsx": "import * as React from \\"react\\";
import { Create, SimpleForm, CreateProps } from \\"react-admin\\";

export const EmptyCreate = (props: CreateProps): React.ReactElement => {
  return (
    <Create {...props}>
      <SimpleForm>
        <div />
      </SimpleForm>
    </Create>
  );
};
",
  "admin-ui/src/empty/EmptyEdit.tsx": "import * as React from \\"react\\";
import { Edit, SimpleForm, EditProps } from \\"react-admin\\";

export const EmptyEdit = (props: EditProps): React.ReactElement => {
  return (
    <Edit {...props}>
      <SimpleForm>
        <div />
      </SimpleForm>
    </Edit>
  );
};
",
  "admin-ui/src/empty/EmptyList.tsx": "import * as React from \\"react\\";
import { List, Datagrid, ListProps, TextField, DateField } from \\"react-admin\\";
import Pagination from \\"../Components/Pagination\\";

export const EmptyList = (props: ListProps): React.ReactElement => {
  return (
    <List
      {...props}
      bulkActionButtons={false}
      title={\\"Empties\\"}
      perPage={50}
      pagination={<Pagination />}
    >
      <Datagrid rowClick=\\"show\\">
        <TextField label=\\"Id\\" source=\\"id\\" />
        <DateField source=\\"createdAt\\" label=\\"Created At\\" />
        <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
      </Datagrid>
    </List>
  );
};
",
  "admin-ui/src/empty/EmptyShow.tsx": "import * as React from \\"react\\";
import {
  Show,
  SimpleShowLayout,
  ShowProps,
  TextField,
  DateField,
} from \\"react-admin\\";

export const EmptyShow = (props: ShowProps): React.ReactElement => {
  return (
    <Show {...props}>
      <SimpleShowLayout>
        <TextField label=\\"Id\\" source=\\"id\\" />
        <DateField source=\\"createdAt\\" label=\\"Created At\\" />
        <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
      </SimpleShowLayout>
    </Show>
  );
};
",
  "admin-ui/src/empty/EmptyTitle.ts": "import { Empty as TEmpty } from \\"../api/empty/Empty\\";

export const EMPTY_TITLE_FIELD = \\"id\\";

export const EmptyTitle = (record: TEmpty) => {
  return record.id;
};
",
  "admin-ui/src/index.tsx": "import React from \\"react\\";
import ReactDOM from \\"react-dom\\";
import \\"./index.css\\";
// @ts-ignore
import App from \\"./App\\";
import reportWebVitals from \\"./reportWebVitals\\";

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById(\\"root\\")
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
",
  "admin-ui/src/order/OrderCreate.tsx": "import * as React from \\"react\\";
import {
  Create,
  SimpleForm,
  CreateProps,
  ReferenceInput,
  SelectInput,
} from \\"react-admin\\";
import { CustomerTitle } from \\"../customer/CustomerTitle\\";

export const OrderCreate = (props: CreateProps): React.ReactElement => {
  return (
    <Create {...props}>
      <SimpleForm>
        <ReferenceInput
          source=\\"customer.id\\"
          reference=\\"Customer\\"
          label=\\"Customer\\"
        >
          <SelectInput optionText={CustomerTitle} />
        </ReferenceInput>
        <SelectInput
          source=\\"status\\"
          label=\\"Status\\"
          choices={[
            { label: \\"Pending\\", value: \\"pending\\" },
            { label: \\"In Progress\\", value: \\"inProgress\\" },
            { label: \\"Done\\", value: \\"done\\" },
          ]}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <SelectInput
          source=\\"label\\"
          label=\\"Label\\"
          choices={[{ label: \\"Fragile\\", value: \\"fragile\\" }]}
          optionText=\\"label\\"
          allowEmpty
          optionValue=\\"value\\"
        />
      </SimpleForm>
    </Create>
  );
};
",
  "admin-ui/src/order/OrderEdit.tsx": "import * as React from \\"react\\";
import {
  Edit,
  SimpleForm,
  EditProps,
  ReferenceInput,
  SelectInput,
} from \\"react-admin\\";
import { CustomerTitle } from \\"../customer/CustomerTitle\\";

export const OrderEdit = (props: EditProps): React.ReactElement => {
  return (
    <Edit {...props}>
      <SimpleForm>
        <ReferenceInput
          source=\\"customer.id\\"
          reference=\\"Customer\\"
          label=\\"Customer\\"
        >
          <SelectInput optionText={CustomerTitle} />
        </ReferenceInput>
        <SelectInput
          source=\\"status\\"
          label=\\"Status\\"
          choices={[
            { label: \\"Pending\\", value: \\"pending\\" },
            { label: \\"In Progress\\", value: \\"inProgress\\" },
            { label: \\"Done\\", value: \\"done\\" },
          ]}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <SelectInput
          source=\\"label\\"
          label=\\"Label\\"
          choices={[{ label: \\"Fragile\\", value: \\"fragile\\" }]}
          optionText=\\"label\\"
          allowEmpty
          optionValue=\\"value\\"
        />
      </SimpleForm>
    </Edit>
  );
};
",
  "admin-ui/src/order/OrderList.tsx": "import * as React from \\"react\\";
import {
  List,
  Datagrid,
  ListProps,
  TextField,
  DateField,
  ReferenceField,
} from \\"react-admin\\";
import Pagination from \\"../Components/Pagination\\";
import { CUSTOMER_TITLE_FIELD } from \\"../customer/CustomerTitle\\";

export const OrderList = (props: ListProps): React.ReactElement => {
  return (
    <List
      {...props}
      bulkActionButtons={false}
      title={\\"Orders\\"}
      perPage={50}
      pagination={<Pagination />}
    >
      <Datagrid rowClick=\\"show\\">
        <TextField label=\\"Id\\" source=\\"id\\" />
        <DateField source=\\"createdAt\\" label=\\"Created At\\" />
        <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
        <ReferenceField
          label=\\"Customer\\"
          source=\\"customer.id\\"
          reference=\\"Customer\\"
        >
          <TextField source={CUSTOMER_TITLE_FIELD} />
        </ReferenceField>
        <TextField label=\\"Status\\" source=\\"status\\" />
        <TextField label=\\"Label\\" source=\\"label\\" />
      </Datagrid>
    </List>
  );
};
",
  "admin-ui/src/order/OrderShow.tsx": "import * as React from \\"react\\";
import {
  Show,
  SimpleShowLayout,
  ShowProps,
  TextField,
  DateField,
  ReferenceField,
} from \\"react-admin\\";
import { CUSTOMER_TITLE_FIELD } from \\"../customer/CustomerTitle\\";

export const OrderShow = (props: ShowProps): React.ReactElement => {
  return (
    <Show {...props}>
      <SimpleShowLayout>
        <TextField label=\\"Id\\" source=\\"id\\" />
        <DateField source=\\"createdAt\\" label=\\"Created At\\" />
        <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
        <ReferenceField
          label=\\"Customer\\"
          source=\\"customer.id\\"
          reference=\\"Customer\\"
        >
          <TextField source={CUSTOMER_TITLE_FIELD} />
        </ReferenceField>
        <TextField label=\\"Status\\" source=\\"status\\" />
        <TextField label=\\"Label\\" source=\\"label\\" />
      </SimpleShowLayout>
    </Show>
  );
};
",
  "admin-ui/src/order/OrderTitle.ts": "import { Order as TOrder } from \\"../api/order/Order\\";

export const ORDER_TITLE_FIELD = \\"id\\";

export const OrderTitle = (record: TOrder) => {
  return record.id;
};
",
  "admin-ui/src/organization/OrganizationCreate.tsx": "import * as React from \\"react\\";
import { Create, SimpleForm, CreateProps, TextInput } from \\"react-admin\\";

export const OrganizationCreate = (props: CreateProps): React.ReactElement => {
  return (
    <Create {...props}>
      <SimpleForm>
        <TextInput label=\\"Name\\" source=\\"name\\" />
      </SimpleForm>
    </Create>
  );
};
",
  "admin-ui/src/organization/OrganizationEdit.tsx": "import * as React from \\"react\\";
import { Edit, SimpleForm, EditProps, TextInput } from \\"react-admin\\";

export const OrganizationEdit = (props: EditProps): React.ReactElement => {
  return (
    <Edit {...props}>
      <SimpleForm>
        <TextInput label=\\"Name\\" source=\\"name\\" />
      </SimpleForm>
    </Edit>
  );
};
",
  "admin-ui/src/organization/OrganizationList.tsx": "import * as React from \\"react\\";
import { List, Datagrid, ListProps, TextField, DateField } from \\"react-admin\\";
import Pagination from \\"../Components/Pagination\\";

export const OrganizationList = (props: ListProps): React.ReactElement => {
  return (
    <List
      {...props}
      bulkActionButtons={false}
      title={\\"Organizations\\"}
      perPage={50}
      pagination={<Pagination />}
    >
      <Datagrid rowClick=\\"show\\">
        <TextField label=\\"Id\\" source=\\"id\\" />
        <DateField source=\\"createdAt\\" label=\\"Created At\\" />
        <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
        <TextField label=\\"Name\\" source=\\"name\\" />
      </Datagrid>
    </List>
  );
};
",
  "admin-ui/src/organization/OrganizationShow.tsx": "import * as React from \\"react\\";

import {
  Show,
  SimpleShowLayout,
  ShowProps,
  TextField,
  DateField,
  ReferenceManyField,
  Datagrid,
  BooleanField,
  ReferenceField,
} from \\"react-admin\\";

import { ORGANIZATION_TITLE_FIELD } from \\"./OrganizationTitle\\";

export const OrganizationShow = (props: ShowProps): React.ReactElement => {
  return (
    <Show {...props}>
      <SimpleShowLayout>
        <TextField label=\\"Id\\" source=\\"id\\" />
        <DateField source=\\"createdAt\\" label=\\"Created At\\" />
        <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
        <TextField label=\\"Name\\" source=\\"name\\" />
        <ReferenceManyField
          reference=\\"Customer\\"
          target=\\"OrganizationId\\"
          label=\\"Customers\\"
        >
          <Datagrid rowClick=\\"show\\">
            <TextField label=\\"Id\\" source=\\"id\\" />
            <DateField source=\\"createdAt\\" label=\\"Created At\\" />
            <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
            <TextField label=\\"Email\\" source=\\"email\\" />
            <TextField label=\\"First Name\\" source=\\"firstName\\" />
            <TextField label=\\"Last Name\\" source=\\"lastName\\" />
            <BooleanField label=\\"VIP\\" source=\\"isVip\\" />
            <TextField label=\\"Birth Data\\" source=\\"birthData\\" />
            <TextField
              label=\\"Average Sale (-1500.00 - 1500.00)\\"
              source=\\"averageSale\\"
            />
            <TextField
              label=\\"Favorite Number (1 - 20)\\"
              source=\\"favoriteNumber\\"
            />
            <TextField label=\\"Geographic Location\\" source=\\"geoLocation\\" />
            <TextField
              label=\\"Comments (up to 500 characters)\\"
              source=\\"comments\\"
            />
            <TextField
              label=\\"Favorite Colors (multi-select)\\"
              source=\\"favoriteColors\\"
            />
            <TextField label=\\"Customer Type\\" source=\\"customerType\\" />
            <ReferenceField
              label=\\"Organization\\"
              source=\\"organization.id\\"
              reference=\\"Organization\\"
            >
              <TextField source={ORGANIZATION_TITLE_FIELD} />
            </ReferenceField>
            <ReferenceField
              label=\\"VIP Organization\\"
              source=\\"organization.id\\"
              reference=\\"Organization\\"
            >
              <TextField source={ORGANIZATION_TITLE_FIELD} />
            </ReferenceField>
          </Datagrid>
        </ReferenceManyField>
        <ReferenceManyField
          reference=\\"Customer\\"
          target=\\"OrganizationId\\"
          label=\\"Customers\\"
        >
          <Datagrid rowClick=\\"show\\">
            <TextField label=\\"Id\\" source=\\"id\\" />
            <DateField source=\\"createdAt\\" label=\\"Created At\\" />
            <DateField source=\\"updatedAt\\" label=\\"Updated At\\" />
            <TextField label=\\"Email\\" source=\\"email\\" />
            <TextField label=\\"First Name\\" source=\\"firstName\\" />
            <TextField label=\\"Last Name\\" source=\\"lastName\\" />
            <BooleanField label=\\"VIP\\" source=\\"isVip\\" />
            <TextField label=\\"Birth Data\\" source=\\"birthData\\" />
            <TextField
              label=\\"Average Sale (-1500.00 - 1500.00)\\"
              source=\\"averageSale\\"
            />
            <TextField
              label=\\"Favorite Number (1 - 20)\\"
              source=\\"favoriteNumber\\"
            />
            <TextField label=\\"Geographic Location\\" source=\\"geoLocation\\" />
            <TextField
              label=\\"Comments (up to 500 characters)\\"
              source=\\"comments\\"
            />
            <TextField
              label=\\"Favorite Colors (multi-select)\\"
              source=\\"favoriteColors\\"
            />
            <TextField label=\\"Customer Type\\" source=\\"customerType\\" />
            <ReferenceField
              label=\\"Organization\\"
              source=\\"organization.id\\"
              reference=\\"Organization\\"
            >
              <TextField source={ORGANIZATION_TITLE_FIELD} />
            </ReferenceField>
            <ReferenceField
              label=\\"VIP Organization\\"
              source=\\"organization.id\\"
              reference=\\"Organization\\"
            >
              <TextField source={ORGANIZATION_TITLE_FIELD} />
            </ReferenceField>
          </Datagrid>
        </ReferenceManyField>
      </SimpleShowLayout>
    </Show>
  );
};
",
  "admin-ui/src/organization/OrganizationTitle.ts": "import { Organization as TOrganization } from \\"../api/organization/Organization\\";

export const ORGANIZATION_TITLE_FIELD = \\"name\\";

export const OrganizationTitle = (record: TOrganization) => {
  return record.name;
};
",
  "admin-ui/src/pages/Dashboard.tsx": "import * as React from \\"react\\";
import Card from \\"@material-ui/core/Card\\";
import CardContent from \\"@material-ui/core/CardContent\\";
import { Title } from \\"react-admin\\";
const Dashboard = () => (
  <Card>
    <Title title=\\"Welcome to the administration\\" />
    <CardContent>Welcome</CardContent>
  </Card>
);

export default Dashboard;
",
  "admin-ui/src/reportWebVitals.ts": "import { ReportHandler } from \\"web-vitals\\";

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import(\\"web-vitals\\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
",
  "admin-ui/src/setupTests.ts": "// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import \\"@testing-library/jest-dom\\";
",
  "admin-ui/src/theme/theme.ts": "import { defaultTheme } from \\"react-admin\\";
import { createTheme, ThemeOptions } from \\"@material-ui/core/styles\\";
import { merge } from \\"lodash\\";
import createPalette from \\"@material-ui/core/styles/createPalette\\";

const palette = createPalette(
  merge({}, defaultTheme.palette, {
    primary: {
      main: \\"#20a4f3\\",
    },
    secondary: {
      main: \\"#7950ed\\",
    },
    error: {
      main: \\"#e93c51\\",
    },
    warning: {
      main: \\"#f6aa50\\",
    },
    info: {
      main: \\"#144bc1\\",
    },
    success: {
      main: \\"#31c587\\",
    },
  })
);

const themeOptions: ThemeOptions = {
  palette,
};

export const theme = createTheme(merge({}, defaultTheme, themeOptions));
",
  "admin-ui/src/user/EnumRoles.ts": "export enum EnumRoles {
  User = \\"user\\",
  Admin = \\"admin\\",
  AreaManager = \\"areaManager\\",
}
",
  "admin-ui/src/user/RolesOptions.ts": "//@ts-ignore
import { ROLES } from \\"./roles\\";

declare interface Role {
  name: string;
  displayName: string;
}

export const ROLES_OPTIONS = ROLES.map((role: Role) => ({
  value: role.name,
  label: role.displayName,
}));
",
  "admin-ui/src/user/UserCreate.tsx": "import * as React from \\"react\\";

import {
  Create,
  SimpleForm,
  CreateProps,
  TextInput,
  PasswordInput,
  SelectArrayInput,
  NumberInput,
  DateTimeInput,
  ReferenceInput,
  SelectInput,
  BooleanInput,
} from \\"react-admin\\";

import { UserTitle } from \\"./UserTitle\\";
import { ROLES_OPTIONS } from \\"../user/RolesOptions\\";

export const UserCreate = (props: CreateProps): React.ReactElement => {
  return (
    <Create {...props}>
      <SimpleForm>
        <TextInput label=\\"Username\\" source=\\"username\\" />
        <PasswordInput label=\\"Password\\" source=\\"password\\" />
        <SelectArrayInput
          source=\\"roles\\"
          choices={ROLES_OPTIONS}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <TextInput label=\\"Name\\" source=\\"name\\" />
        <TextInput label=\\"Bio\\" multiline source=\\"bio\\" />
        <TextInput label=\\"Email\\" source=\\"email\\" type=\\"email\\" />
        <NumberInput step={1} label=\\"Age\\" source=\\"age\\" />
        <DateTimeInput label=\\"Birth Date\\" source=\\"birthDate\\" />
        <NumberInput label=\\"Score\\" source=\\"score\\" />
        <ReferenceInput source=\\"user.id\\" reference=\\"User\\" label=\\"Manager\\">
          <SelectInput optionText={UserTitle} />
        </ReferenceInput>
        <SelectArrayInput
          label=\\"Interests\\"
          source=\\"interests\\"
          choices={[
            { label: \\"Programming\\", value: \\"programming\\" },
            { label: \\"Design\\", value: \\"design\\" },
          ]}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <SelectInput
          source=\\"priority\\"
          label=\\"Priority\\"
          choices={[
            { label: \\"High\\", value: \\"high\\" },
            { label: \\"Medium\\", value: \\"medium\\" },
            { label: \\"Low\\", value: \\"low\\" },
          ]}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <BooleanInput label=\\"Is Curious\\" source=\\"isCurious\\" />
        <TextInput label=\\"Location\\" source=\\"location\\" />
        <div />
      </SimpleForm>
    </Create>
  );
};
",
  "admin-ui/src/user/UserEdit.tsx": "import * as React from \\"react\\";

import {
  Edit,
  SimpleForm,
  EditProps,
  TextInput,
  PasswordInput,
  SelectArrayInput,
  NumberInput,
  DateTimeInput,
  ReferenceInput,
  SelectInput,
  BooleanInput,
} from \\"react-admin\\";

import { UserTitle } from \\"./UserTitle\\";
import { ROLES_OPTIONS } from \\"../user/RolesOptions\\";

export const UserEdit = (props: EditProps): React.ReactElement => {
  return (
    <Edit {...props}>
      <SimpleForm>
        <TextInput label=\\"Username\\" source=\\"username\\" />
        <PasswordInput label=\\"Password\\" source=\\"password\\" />
        <SelectArrayInput
          source=\\"roles\\"
          choices={ROLES_OPTIONS}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <TextInput label=\\"Name\\" source=\\"name\\" />
        <TextInput label=\\"Bio\\" multiline source=\\"bio\\" />
        <TextInput label=\\"Email\\" source=\\"email\\" type=\\"email\\" />
        <NumberInput step={1} label=\\"Age\\" source=\\"age\\" />
        <DateTimeInput label=\\"Birth Date\\" source=\\"birthDate\\" />
        <NumberInput label=\\"Score\\" source=\\"score\\" />
        <ReferenceInput source=\\"user.id\\" reference=\\"User\\" label=\\"Manager\\">
          <SelectInput optionText={UserTitle} />
        </ReferenceInput>
        <SelectArrayInput
          label=\\"Interests\\"
          source=\\"interests\\"
          choices={[
            { label: \\"Programming\\", value: \\"programming\\" },
            { label: \\"Design\\", value: \\"design\\" },
          ]}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <SelectInput
          source=\\"priority\\"
          label=\\"Priority\\"
          choices={[
            { label: \\"High\\", value: \\"high\\" },
            { label: \\"Medium\\", value: \\"medium\\" },
            { label: \\"Low\\", value: \\"low\\" },
          ]}
          optionText=\\"label\\"
          optionValue=\\"value\\"
        />
        <BooleanInput label=\\"Is Curious\\" source=\\"isCurious\\" />
        <TextInput label=\\"Location\\" source=\\"location\\" />
        <div />
      </SimpleForm>
    </Edit>
  );
};
",
  "admin-ui/src/user/UserList.tsx": "import * as React from \\"react\\";
import {
  List,
  Datagrid,
  ListProps,
  TextField,
  ReferenceField,
  BooleanField,
} from \\"react-admin\\";
import Pagination from \\"../Components/Pagination\\";
import { USER_TITLE_FIELD } from \\"./UserTitle\\";

export const UserList = (props: ListProps): React.ReactElement => {
  return (
    <List
      {...props}
      bulkActionButtons={false}
      title={\\"Users\\"}
      perPage={50}
      pagination={<Pagination />}
    >
      <Datagrid rowClick=\\"show\\">
        <TextField label=\\"Username\\" source=\\"username\\" />
        <TextField label=\\"Roles\\" source=\\"roles\\" />
        <TextField label=\\"Id\\" source=\\"id\\" />
        <TextField label=\\"Name\\" source=\\"name\\" />
        <TextField label=\\"Bio\\" source=\\"bio\\" />
        <TextField label=\\"Email\\" source=\\"email\\" />
        <TextField label=\\"Age\\" source=\\"age\\" />
        <TextField label=\\"Birth Date\\" source=\\"birthDate\\" />
        <TextField label=\\"Score\\" source=\\"score\\" />
        <ReferenceField label=\\"Manager\\" source=\\"user.id\\" reference=\\"User\\">
          <TextField source={USER_TITLE_FIELD} />
        </ReferenceField>
        <TextField label=\\"Interests\\" source=\\"interests\\" />
        <TextField label=\\"Priority\\" source=\\"priority\\" />
        <BooleanField label=\\"Is Curious\\" source=\\"isCurious\\" />
        <TextField label=\\"Location\\" source=\\"location\\" />
        <TextField label=\\"Extended Properties\\" source=\\"extendedProperties\\" />
      </Datagrid>
    </List>
  );
};
",
  "admin-ui/src/user/UserShow.tsx": "import * as React from \\"react\\";
import {
  Show,
  SimpleShowLayout,
  ShowProps,
  TextField,
  ReferenceField,
  BooleanField,
} from \\"react-admin\\";
import { USER_TITLE_FIELD } from \\"./UserTitle\\";

export const UserShow = (props: ShowProps): React.ReactElement => {
  return (
    <Show {...props}>
      <SimpleShowLayout>
        <TextField label=\\"Username\\" source=\\"username\\" />
        <TextField label=\\"Roles\\" source=\\"roles\\" />
        <TextField label=\\"Id\\" source=\\"id\\" />
        <TextField label=\\"Name\\" source=\\"name\\" />
        <TextField label=\\"Bio\\" source=\\"bio\\" />
        <TextField label=\\"Email\\" source=\\"email\\" />
        <TextField label=\\"Age\\" source=\\"age\\" />
        <TextField label=\\"Birth Date\\" source=\\"birthDate\\" />
        <TextField label=\\"Score\\" source=\\"score\\" />
        <ReferenceField label=\\"Manager\\" source=\\"user.id\\" reference=\\"User\\">
          <TextField source={USER_TITLE_FIELD} />
        </ReferenceField>
        <TextField label=\\"Interests\\" source=\\"interests\\" />
        <TextField label=\\"Priority\\" source=\\"priority\\" />
        <BooleanField label=\\"Is Curious\\" source=\\"isCurious\\" />
        <TextField label=\\"Location\\" source=\\"location\\" />
        <TextField label=\\"Extended Properties\\" source=\\"extendedProperties\\" />
      </SimpleShowLayout>
    </Show>
  );
};
",
  "admin-ui/src/user/UserTitle.ts": "import { User as TUser } from \\"../api/user/User\\";

export const USER_TITLE_FIELD = \\"username\\";

export const UserTitle = (record: TUser) => {
  return record.username;
};
",
  "admin-ui/src/user/roles.ts": "export const ROLES = [
  {
    name: \\"user\\",
    displayName: \\"User\\",
  },
  {
    name: \\"admin\\",
    displayName: \\"Admin\\",
  },
  {
    name: \\"areaManager\\",
    displayName: \\"Area Manager\\",
  },
];
",
  "admin-ui/src/util/BooleanFilter.ts": "export class BooleanFilter {
  equals?: boolean;
  not?: boolean;
}
",
  "admin-ui/src/util/BooleanNullableFilter.ts": "export class BooleanNullableFilter {
  equals?: boolean | null;
  not?: boolean | null;
}
",
  "admin-ui/src/util/DateTimeFilter.ts": "export class DateTimeFilter {
  equals?: Date;
  not?: Date;
  in?: Date[];
  notIn?: Date[];
  lt?: Date;
  lte?: Date;
  gt?: Date;
  gte?: Date;
}
",
  "admin-ui/src/util/DateTimeNullableFilter.ts": "export class DateTimeNullableFilter {
  equals?: Date | null;
  in?: Date[] | null;
  notIn?: Date[] | null;
  lt?: Date;
  lte?: Date;
  gt?: Date;
  gte?: Date;
  not?: Date;
}
",
  "admin-ui/src/util/FloatFilter.ts": "export class FloatFilter {
  equals?: number;
  in?: number[];
  notIn?: number[];
  lt?: number;
  lte?: number;
  gt?: number;
  gte?: number;
  not?: number;
}
",
  "admin-ui/src/util/FloatNullableFilter.ts": "export class FloatNullableFilter {
  equals?: number | null;
  in?: number[] | null;
  notIn?: number[] | null;
  lt?: number;
  lte?: number;
  gt?: number;
  gte?: number;
  not?: number;
}
",
  "admin-ui/src/util/IntFilter.ts": "export class IntFilter {
  equals?: number;
  in?: number[];
  notIn?: number[];
  lt?: number;
  lte?: number;
  gt?: number;
  gte?: number;
  not?: number;
}
",
  "admin-ui/src/util/IntNullableFilter.ts": "export class IntNullableFilter {
  equals?: number | null;
  in?: number[] | null;
  notIn?: number[] | null;
  lt?: number;
  lte?: number;
  gt?: number;
  gte?: number;
  not?: number;
}
",
  "admin-ui/src/util/JsonNullableFilter.ts": "import { JsonValue } from \\"type-fest\\";
export class JsonNullableFilter {
  equals?: JsonValue | null;
  not?: JsonValue | null;
}
",
  "admin-ui/src/util/MetaQueryPayload.ts": "export class MetaQueryPayload {
  count!: number;
}
",
  "admin-ui/src/util/QueryMode.ts": "export enum QueryMode {
  Default = \\"default\\",
  Insensitive = \\"insensitive\\",
}
",
  "admin-ui/src/util/SortOrder.ts": "export enum SortOrder {
  Asc = \\"asc\\",
  Desc = \\"desc\\",
}
",
  "admin-ui/src/util/StringFilter.ts": "import { QueryMode } from \\"./QueryMode\\";

export class StringFilter {
  equals?: string;
  in?: string[];
  notIn?: string[];
  lt?: string;
  lte?: string;
  gt?: string;
  gte?: string;
  contains?: string;
  startsWith?: string;
  endsWith?: string;
  mode?: QueryMode;
  not?: string;
}
",
  "admin-ui/src/util/StringNullableFilter.ts": "import { QueryMode } from \\"./QueryMode\\";
export class StringNullableFilter {
  equals?: string | null;
  in?: string[] | null;
  notIn?: string[] | null;
  lt?: string;
  lte?: string;
  gt?: string;
  gte?: string;
  contains?: string;
  startsWith?: string;
  endsWith?: string;
  mode?: QueryMode;
  not?: string;
}
",
  "server/.env": "POSTGRESQL_USER=testUsername
POSTGRESQL_PASSWORD=1234
POSTGRESQL_PORT=5433
POSTGRESQL_URL=postgres://testUsername:1234@localhost:5433/db-name
BCRYPT_SALT=10
COMPOSE_PROJECT_NAME=amp_\${appId}
",
  "server/prisma/schema.prisma": "datasource postgres {
  provider = \\"postgresql\\"
  url      = env(\\"POSTGRESQL_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  username           String              @unique
  password           String
  roles              String[]
  id                 String              @id @default(cuid())
  name               String
  bio                String
  email              String
  age                Int
  birthDate          DateTime
  score              Float
  manager            User?               @relation(name: \\"employees\\", fields: [managerId], references: [id])
  managerId          String?
  employees          User[]              @relation(name: \\"employees\\")
  organizations      Organization[]
  interests          EnumUserInterests[]
  priority           EnumUserPriority
  isCurious          Boolean
  location           String
  extendedProperties Json
}

model Order {
  id         String          @id @default(cuid())
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  customer   Customer        @relation(fields: [customerId], references: [id])
  customerId String
  status     EnumOrderStatus
  label      EnumOrderLabel?
}

model Organization {
  id           String     @id @default(cuid())
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  name         String
  users        User[]
  customers    Customer[] @relation(name: \\"CustomersOnOrganization\\")
  vipCustomers Customer[] @relation(name: \\"vipCustomers\\")
}

model Customer {
  id                String                       @id @default(cuid())
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt
  email             String
  firstName         String?
  lastName          String?
  isVip             Boolean?
  birthData         DateTime?
  averageSale       Float?
  favoriteNumber    Int?
  geoLocation       String?
  comments          String?
  favoriteColors    EnumCustomerFavoriteColors[]
  customerType      EnumCustomerCustomerType?
  organization      Organization?                @relation(name: \\"CustomersOnOrganization\\", fields: [organizationId], references: [id])
  organizationId    String?
  vipOrganization   Organization?                @relation(name: \\"vipCustomers\\", fields: [vipOrganizationId], references: [id])
  vipOrganizationId String?
  orders            Order[]
}

model Empty {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum EnumUserInterests {
  programming
  design
}

enum EnumUserPriority {
  high
  medium
  low
}

enum EnumOrderStatus {
  pending
  inProgress
  done
}

enum EnumOrderLabel {
  fragile
}

enum EnumCustomerFavoriteColors {
  red
  green
  purple
  yellow
}

enum EnumCustomerCustomerType {
  platinum
  gold
  bronze
  regular
}",
  "server/scripts/clean.ts": "/**
 * Clean all the tables and types created by Prisma in the database
 */

import { PrismaClient } from \\"@prisma/client\\";

if (require.main === module) {
  clean().catch((error) => {
    console.error(error);
    process.exit(1);
  });
}

async function clean() {
  console.info(\\"Dropping all tables in the database...\\");
  const prisma = new PrismaClient();
  const tables = await getTables(prisma);
  const types = await getTypes(prisma);
  await dropTables(prisma, tables);
  await dropTypes(prisma, types);
  console.info(\\"Cleaned database successfully\\");
  await prisma.$disconnect();
}

async function dropTables(
  prisma: PrismaClient,
  tables: string[]
): Promise<void> {
  for (const table of tables) {
    await prisma.$executeRaw(\`DROP TABLE public.\\"\${table}\\" CASCADE;\`);
  }
}

async function dropTypes(prisma: PrismaClient, types: string[]) {
  for (const type of types) {
    await prisma.$executeRaw(\`DROP TYPE IF EXISTS \\"\${type}\\" CASCADE;\`);
  }
}

async function getTables(prisma: PrismaClient): Promise<string[]> {
  const results: Array<{
    tablename: string;
  }> = await prisma.$queryRaw\`SELECT tablename from pg_tables where schemaname = 'public';\`;
  return results.map((result) => result.tablename);
}

async function getTypes(prisma: PrismaClient): Promise<string[]> {
  const results: Array<{
    typname: string;
  }> = await prisma.$queryRaw\`
SELECT t.typname
FROM pg_type t 
JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
WHERE n.nspname = 'public';
\`;
  return results.map((result) => result.typname);
}
",
  "server/scripts/seed.ts": "import * as dotenv from \\"dotenv\\";
import { PrismaClient } from \\"@prisma/client\\";
import { Salt, parseSalt } from \\"../src/auth/password.service\\";
import { hash } from \\"bcrypt\\";
import { EnumUserPriority } from \\"../src/user/base/EnumUserPriority\\";

if (require.main === module) {
  dotenv.config();

  const { BCRYPT_SALT } = process.env;

  if (!BCRYPT_SALT) {
    throw new Error(\\"BCRYPT_SALT environment variable must be defined\\");
  }

  const salt = parseSalt(BCRYPT_SALT);

  seed(salt).catch((error) => {
    console.error(error);
    process.exit(1);
  });
}

async function seed(bcryptSalt: Salt) {
  console.info(\\"Seeding database...\\");

  const client = new PrismaClient();
  const data = {
    username: \\"admin\\",
    password: await hash(\\"admin\\", bcryptSalt),
    roles: [\\"user\\"],
    name: \\"\\",
    bio: \\"\\",
    email: \\"example@example.com\\",
    age: 0,
    birthDate: new Date(),
    score: 0,
    interests: [],
    priority: EnumUserPriority.High,
    isCurious: false,
    location: \\"(32.085300, 34.781769)\\",
    extendedProperties: false,
  };
  await client.user.upsert({
    where: { username: data.username },
    update: {},
    create: data,
  });
  client.$disconnect();
  console.info(\\"Seeded database successfully\\");
}
",
  "server/src/app.module.ts": "import { Module } from \\"@nestjs/common\\";
import { UserModule } from \\"./user/user.module\\";
import { OrderModule } from \\"./order/order.module\\";
import { OrganizationModule } from \\"./organization/organization.module\\";
import { CustomerModule } from \\"./customer/customer.module\\";
import { EmptyModule } from \\"./empty/empty.module\\";
import { ACLModule } from \\"./auth/acl.module\\";
import { AuthModule } from \\"./auth/auth.module\\";
import { MorganModule } from \\"nest-morgan\\";
import { ConfigModule, ConfigService } from \\"@nestjs/config\\";
import { ServeStaticModule } from \\"@nestjs/serve-static\\";
import { ServeStaticOptionsService } from \\"./serveStaticOptions.service\\";
import { GraphQLModule } from \\"@nestjs/graphql\\";

@Module({
  controllers: [],
  imports: [
    UserModule,
    OrderModule,
    OrganizationModule,
    CustomerModule,
    EmptyModule,
    ACLModule,
    AuthModule,
    MorganModule,
    ConfigModule.forRoot({ isGlobal: true }),
    ServeStaticModule.forRootAsync({
      useClass: ServeStaticOptionsService,
    }),
    GraphQLModule.forRootAsync({
      useFactory: (configService) => {
        const playground = configService.get(\\"GRAPHQL_PLAYGROUND\\");
        const introspection = configService.get(\\"GRAPHQL_INTROSPECTION\\");
        return {
          autoSchemaFile: true,
          playground,
          introspection: playground || introspection,
        };
      },
      inject: [ConfigService],
      imports: [ConfigModule],
    }),
  ],
  providers: [],
})
export class AppModule {}
",
  "server/src/auth/Credentials.ts": "import { ApiProperty } from \\"@nestjs/swagger\\";
import { InputType, Field } from \\"@nestjs/graphql\\";
import { IsString } from \\"class-validator\\";

@InputType()
export class Credentials {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String, { nullable: false })
  username!: string;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String, { nullable: false })
  password!: string;
}
",
  "server/src/auth/LoginArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { Credentials } from \\"./Credentials\\";

@ArgsType()
export class LoginArgs {
  @Field(() => Credentials, { nullable: false })
  credentials!: Credentials;
}
",
  "server/src/auth/UserInfo.ts": "import { Field, ObjectType } from \\"@nestjs/graphql\\";
// @ts-ignore
// eslint-disable-next-line
import { User } from \\"../user/user\\";

@ObjectType()
export class UserInfo implements Partial<User> {
  @Field(() => String)
  username!: string;
  @Field(() => [String])
  roles!: string[];
}
",
  "server/src/auth/abac.util.ts": "import { Permission } from \\"accesscontrol\\";

/**
 * @returns attributes not allowed to appear on given data according to given
 * attributeMatchers
 */
export function getInvalidAttributes(
  permission: Permission,
  // eslint-disable-next-line @typescript-eslint/ban-types
  data: Object
): string[] {
  const filteredData = permission.filter(data);
  return Object.keys(data).filter((key) => !(key in filteredData));
}
",
  "server/src/auth/acl.module.ts": "import { AccessControlModule, RolesBuilder } from \\"nest-access-control\\";
// @ts-ignore
// eslint-disable-next-line import/no-unresolved
import grants from \\"../grants.json\\";

// eslint-disable-next-line @typescript-eslint/naming-convention
export const ACLModule = AccessControlModule.forRoles(new RolesBuilder(grants));
",
  "server/src/auth/auth.controller.ts": "import { Controller, Post, Body, UnauthorizedException } from \\"@nestjs/common\\";
import { ApiTags } from \\"@nestjs/swagger\\";
import { AuthService } from \\"./auth.service\\";
import { UserInfo } from \\"./UserInfo\\";
import { Credentials } from \\"./Credentials\\";

@ApiTags(\\"auth\\")
@Controller()
export class AuthController {
  constructor(private readonly authService: AuthService) {}
  @Post(\\"login\\")
  async login(@Body() body: Credentials): Promise<UserInfo> {
    const user = await this.authService.validateUser(
      body.username,
      body.password
    );
    if (!user) {
      throw new UnauthorizedException(\\"The passed credentials are incorrect\\");
    }
    return user;
  }
}
",
  "server/src/auth/auth.module.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { PassportModule } from \\"@nestjs/passport\\";
// @ts-ignore
// eslint-disable-next-line
import { UserModule } from \\"../user/user.module\\";
import { AuthController } from \\"./auth.controller\\";
import { AuthResolver } from \\"./auth.resolver\\";
import { AuthService } from \\"./auth.service\\";
import { BasicStrategy } from \\"./basic.strategy\\";
import { PasswordService } from \\"./password.service\\";

@Module({
  imports: [forwardRef(() => UserModule), PassportModule],
  providers: [AuthService, BasicStrategy, PasswordService, AuthResolver],
  controllers: [AuthController],
  exports: [AuthService, PasswordService],
})
export class AuthModule {}
",
  "server/src/auth/auth.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import { Args, Mutation, Resolver, Query } from \\"@nestjs/graphql\\";
import { ApolloError } from \\"apollo-server-express\\";
import { AuthService } from \\"./auth.service\\";
import { UserInfo } from \\"./UserInfo\\";
import { LoginArgs } from \\"./LoginArgs\\";
import { UserData } from \\"./gqlUserData.decorator\\";

@Resolver(UserInfo)
export class AuthResolver {
  constructor(private readonly authService: AuthService) {}
  @Mutation(() => UserInfo)
  async login(@Args() args: LoginArgs): Promise<UserInfo> {
    const user = await this.authService.validateUser(
      args.credentials.username,
      args.credentials.password
    );
    if (!user) {
      throw new ApolloError(\\"The passed credentials are incorrect\\");
    }
    return user;
  }

  @Query(() => UserInfo)
  @common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
  async userInfo(@UserData() userInfo: UserInfo): Promise<UserInfo> {
    return userInfo;
  }
}
",
  "server/src/auth/auth.service.spec.ts": "import { Test, TestingModule } from \\"@nestjs/testing\\";
import { AuthService } from \\"./auth.service\\";
// @ts-ignore
// eslint-disable-next-line
import { UserService, User } from \\"../user/user.service\\";
import { PasswordService } from \\"./password.service\\";

const VALID_USER: User = {
  username: \\"Valid User\\",
  password: \\"Valid User Password\\",
};
const INVALID_USER: User = {
  username: \\"Invalid User\\",
  password: \\"Invalid User Password\\",
};

const userService = {
  findOne(args: { where: { username: string } }): User | null {
    if (args.where.username === VALID_USER.username) {
      return VALID_USER;
    }
    return null;
  },
};

const passwordService = {
  compare(password: string, encrypted: string) {
    return true;
  },
};

describe(\\"AuthService\\", () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        {
          provide: UserService,
          useValue: userService,
        },
        {
          provide: PasswordService,
          useValue: passwordService,
        },
        AuthService,
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it(\\"should be defined\\", () => {
    expect(service).toBeDefined();
  });

  it(\\"should validate a valid user\\", async () => {
    await expect(
      service.validateUser(VALID_USER.username, VALID_USER.password)
    ).resolves.toEqual({
      username: VALID_USER.username,
    });
  });

  it(\\"should not validate a invalid user\\", async () => {
    await expect(
      service.validateUser(INVALID_USER.username, INVALID_USER.password)
    ).resolves.toBe(null);
  });
});
",
  "server/src/auth/auth.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PasswordService } from \\"./password.service\\";
// @ts-ignore
// eslint-disable-next-line
import { UserService } from \\"../user/user.service\\";
import { UserInfo } from \\"./UserInfo\\";

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly passwordService: PasswordService
  ) {}

  async validateUser(
    username: string,
    password: string
  ): Promise<UserInfo | null> {
    const user = await this.userService.findOne({
      where: { username },
    });
    if (user && (await this.passwordService.compare(password, user.password))) {
      const { roles } = user;
      return { username, roles };
    }
    return null;
  }
}
",
  "server/src/auth/basic.strategy.ts": "import { BasicStrategy as Strategy } from \\"passport-http\\";
import { PassportStrategy } from \\"@nestjs/passport\\";
import { Injectable, UnauthorizedException } from \\"@nestjs/common\\";
import { AuthService } from \\"./auth.service\\";
import { UserInfo } from \\"./UserInfo\\";

@Injectable()
export class BasicStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super();
  }

  async validate(username: string, password: string): Promise<UserInfo> {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}
",
  "server/src/auth/basicAuth.guard.ts": "import { AuthGuard } from \\"@nestjs/passport\\";

export class BasicAuthGuard extends AuthGuard(\\"basic\\") {}
",
  "server/src/auth/gqlAC.guard.ts": "import { ExecutionContext } from \\"@nestjs/common\\";
import { GqlExecutionContext } from \\"@nestjs/graphql\\";
import { ACGuard } from \\"nest-access-control\\";

export class GqlACGuard<User extends any = any> extends ACGuard<User> {
  async getUser(context: ExecutionContext): Promise<User> {
    const ctx = GqlExecutionContext.create(context);
    const request = ctx.getContext<{ req: { user: User } }>().req;
    return request.user;
  }
}
",
  "server/src/auth/gqlBasicAuth.guard.ts": "import { Injectable, ExecutionContext } from \\"@nestjs/common\\";
import { GqlExecutionContext } from \\"@nestjs/graphql\\";
import type { Request } from \\"express\\";
import { BasicAuthGuard } from \\"./basicAuth.guard\\";

@Injectable()
export class GqlBasicAuthGuard extends BasicAuthGuard {
  // This method is required for the interface - do not delete it.
  getRequest(context: ExecutionContext): Request {
    const ctx = GqlExecutionContext.create(context);
    return ctx.getContext<{ req: Request }>().req;
  }
}
",
  "server/src/auth/gqlUserData.decorator.ts": "import { createParamDecorator, ExecutionContext } from \\"@nestjs/common\\";
import { GqlExecutionContext } from \\"@nestjs/graphql\\";
import { UserInfo } from \\"./UserInfo\\";

/**
 * Access the user data from the request object i.e \`req.user\`.
 */
export function getUser(executionContext: ExecutionContext): UserInfo {
  const gqlExecutionContext = GqlExecutionContext.create(executionContext);
  return gqlExecutionContext.getContext().req.user;
}

export const UserData = createParamDecorator((data, ctx: ExecutionContext) =>
  getUser(ctx)
);
",
  "server/src/auth/gqlUserRoles.decorator.ts": "import { createParamDecorator, ExecutionContext } from \\"@nestjs/common\\";
import { GqlExecutionContext } from \\"@nestjs/graphql\\";

/**
 * Access the user roles from the request object i.e \`req.user.roles\`.
 *
 * You can pass an optional property key to the decorator to get it from the user object
 * e.g \`@UserRoles('permissions')\` will return the \`req.user.permissions\` instead.
 */
export const UserRoles = createParamDecorator(
  (data: string, context: ExecutionContext) => {
    const ctx = GqlExecutionContext.create(context);
    const request = ctx.getContext<{ req: { user: any } }>().req;
    return data ? request.user[data] : request.user.roles;
  }
);
",
  "server/src/auth/password.service.spec.ts": "import { ConfigService } from \\"@nestjs/config\\";
import { Test, TestingModule } from \\"@nestjs/testing\\";
import { PasswordService } from \\"./password.service\\";
import * as bcrypt from \\"bcrypt\\";

const EXAMPLE_PASSWORD = \\"examplePassword\\";
const EXAMPLE_HASHED_PASSWORD = \\"exampleHashedPassword\\";

const EXAMPLE_SALT_OR_ROUNDS = 1;

const configServiceGetMock = jest.fn(() => {
  return EXAMPLE_SALT_OR_ROUNDS;
});

jest.mock(\\"bcrypt\\");

//@ts-ignore
bcrypt.hash.mockImplementation(async () => EXAMPLE_HASHED_PASSWORD);

//@ts-ignore
bcrypt.compare.mockImplementation(async () => true);

describe(\\"PasswordService\\", () => {
  let service: PasswordService;

  beforeEach(async () => {
    jest.clearAllMocks();
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PasswordService,
        {
          provide: ConfigService,
          useClass: jest.fn(() => ({
            get: configServiceGetMock,
          })),
        },
      ],
      imports: [],
    }).compile();

    service = module.get<PasswordService>(PasswordService);
  });

  it(\\"should be defined\\", () => {
    expect(service).toBeDefined();
  });

  it(\\"should have salt defined\\", () => {
    expect(service.salt).toEqual(EXAMPLE_SALT_OR_ROUNDS);
  });

  it(\\"should compare a password\\", async () => {
    const args = {
      password: EXAMPLE_PASSWORD,
      hashedPassword: EXAMPLE_HASHED_PASSWORD,
    };
    await expect(
      service.compare(args.password, args.hashedPassword)
    ).resolves.toEqual(true);
  });

  it(\\"should hash a password\\", async () => {
    await expect(service.hash(EXAMPLE_PASSWORD)).resolves.toEqual(
      EXAMPLE_HASHED_PASSWORD
    );
  });
});
",
  "server/src/auth/password.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { hash, compare } from \\"bcrypt\\";
import { ConfigService } from \\"@nestjs/config\\";

/** Salt or number of rounds to generate a salt */
export type Salt = string | number;

const BCRYPT_SALT_VAR = \\"BCRYPT_SALT\\";
const UNDEFINED_SALT_OR_ROUNDS_ERROR = \`\${BCRYPT_SALT_VAR} is not defined\`;
const SALT_OR_ROUNDS_TYPE_ERROR = \`\${BCRYPT_SALT_VAR} must be a positive integer or text\`;

@Injectable()
export class PasswordService {
  /**
   * the salt to be used to hash the password. if specified as a number then a
   * salt will be generated with the specified number of rounds and used
   */
  salt: Salt;

  constructor(private configService: ConfigService) {
    const saltOrRounds = this.configService.get(BCRYPT_SALT_VAR);
    this.salt = parseSalt(saltOrRounds);
  }

  /**
   *
   * @param password the password to be encrypted.
   * @param encrypted the encrypted password to be compared against.
   * @returns whether the password match the encrypted password
   */
  compare(password: string, encrypted: string): Promise<boolean> {
    return compare(password, encrypted);
  }

  /**
   * @param password the password to be encrypted
   * @return encrypted password
   */
  hash(password: string): Promise<string> {
    return hash(password, this.salt);
  }
}

/**
 * Parses a salt environment variable value.
 * If a number string value is given tries to parse it as a number of rounds to generate a salt
 * @param value salt environment variable value
 * @returns salt or number of rounds to generate a salt
 */
export function parseSalt(value: string | undefined): Salt {
  if (value === undefined) {
    throw new Error(UNDEFINED_SALT_OR_ROUNDS_ERROR);
  }

  const rounds = Number(value);

  if (Number.isNaN(rounds)) {
    return value;
  }
  if (!Number.isInteger(rounds) || rounds < 0) {
    throw new Error(SALT_OR_ROUNDS_TYPE_ERROR);
  }
  return rounds;
}
",
  "server/src/customer/base/CreateCustomerArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { CustomerCreateInput } from \\"./CustomerCreateInput\\";

@ArgsType()
class CreateCustomerArgs {
  @Field(() => CustomerCreateInput, { nullable: false })
  data!: CustomerCreateInput;
}

export { CreateCustomerArgs };
",
  "server/src/customer/base/Customer.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsDate,
  IsOptional,
  IsBoolean,
  IsNumber,
  IsInt,
  IsEnum,
  ValidateNested,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { EnumCustomerFavoriteColors } from \\"./EnumCustomerFavoriteColors\\";
import { EnumCustomerCustomerType } from \\"./EnumCustomerCustomerType\\";
import { Organization } from \\"../../organization/base/Organization\\";
import { Order } from \\"../../order/base/Order\\";
@ObjectType()
class Customer {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName!: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName!: string | null;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip!: boolean | null;

  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData!: Date | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  averageSale!: number | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  favoriteNumber!: number | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation!: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments!: string | null;

  @ApiProperty({
    required: false,
    enum: EnumCustomerFavoriteColors,
    isArray: true,
  })
  @IsEnum(EnumCustomerFavoriteColors, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumCustomerFavoriteColors], {
    nullable: true,
  })
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;

  @ApiProperty({
    required: false,
    enum: EnumCustomerCustomerType,
  })
  @IsEnum(EnumCustomerCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;

  @ApiProperty({
    required: false,
    type: () => Organization,
  })
  @ValidateNested()
  @Type(() => Organization)
  @IsOptional()
  organization?: Organization | null;

  @ApiProperty({
    required: false,
    type: () => Organization,
  })
  @ValidateNested()
  @Type(() => Organization)
  @IsOptional()
  vipOrganization?: Organization | null;

  @ApiProperty({
    required: false,
    type: () => [Order],
  })
  @ValidateNested()
  @Type(() => Order)
  @IsOptional()
  orders?: Array<Order>;
}
export { Customer };
",
  "server/src/customer/base/CustomerCreateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsOptional,
  IsBoolean,
  IsDate,
  IsNumber,
  IsInt,
  IsEnum,
  ValidateNested,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { EnumCustomerFavoriteColors } from \\"./EnumCustomerFavoriteColors\\";
import { EnumCustomerCustomerType } from \\"./EnumCustomerCustomerType\\";
import { OrganizationWhereUniqueInput } from \\"../../organization/base/OrganizationWhereUniqueInput\\";
@InputType()
class CustomerCreateInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName?: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName?: string | null;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip?: boolean | null;

  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData?: Date | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  averageSale?: number | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  favoriteNumber?: number | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation?: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments?: string | null;

  @ApiProperty({
    required: false,
    enum: EnumCustomerFavoriteColors,
    isArray: true,
  })
  @IsEnum(EnumCustomerFavoriteColors, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumCustomerFavoriteColors], {
    nullable: true,
  })
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;

  @ApiProperty({
    required: false,
    enum: EnumCustomerCustomerType,
  })
  @IsEnum(EnumCustomerCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput | null;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  vipOrganization?: OrganizationWhereUniqueInput | null;
}
export { CustomerCreateInput };
",
  "server/src/customer/base/CustomerFindManyArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { CustomerWhereInput } from \\"./CustomerWhereInput\\";
import { Type } from \\"class-transformer\\";
import { CustomerOrderByInput } from \\"./CustomerOrderByInput\\";

@ArgsType()
class CustomerFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => CustomerWhereInput,
  })
  @Field(() => CustomerWhereInput, { nullable: true })
  @Type(() => CustomerWhereInput)
  where?: CustomerWhereInput;

  @ApiProperty({
    required: false,
    type: CustomerOrderByInput,
  })
  @Field(() => CustomerOrderByInput, { nullable: true })
  @Type(() => CustomerOrderByInput)
  orderBy?: CustomerOrderByInput;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { CustomerFindManyArgs };
",
  "server/src/customer/base/CustomerFindUniqueArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";

@ArgsType()
class CustomerFindUniqueArgs {
  @Field(() => CustomerWhereUniqueInput, { nullable: false })
  where!: CustomerWhereUniqueInput;
}

export { CustomerFindUniqueArgs };
",
  "server/src/customer/base/CustomerOrderByInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { SortOrder } from \\"../../util/SortOrder\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
class CustomerOrderByInput {
  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  email?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  firstName?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  lastName?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  isVip?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  birthData?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  averageSale?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  favoriteNumber?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  geoLocation?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  comments?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  favoriteColors?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  customerType?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  organizationId?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  vipOrganizationId?: SortOrder;
}

export { CustomerOrderByInput };
",
  "server/src/customer/base/CustomerUpdateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsOptional,
  IsBoolean,
  IsDate,
  IsNumber,
  IsInt,
  IsEnum,
  ValidateNested,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { EnumCustomerFavoriteColors } from \\"./EnumCustomerFavoriteColors\\";
import { EnumCustomerCustomerType } from \\"./EnumCustomerCustomerType\\";
import { OrganizationWhereUniqueInput } from \\"../../organization/base/OrganizationWhereUniqueInput\\";
@InputType()
class CustomerUpdateInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  email?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName?: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName?: string | null;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip?: boolean | null;

  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData?: Date | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  averageSale?: number | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  favoriteNumber?: number | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation?: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments?: string | null;

  @ApiProperty({
    required: false,
    enum: EnumCustomerFavoriteColors,
    isArray: true,
  })
  @IsEnum(EnumCustomerFavoriteColors, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumCustomerFavoriteColors], {
    nullable: true,
  })
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;

  @ApiProperty({
    required: false,
    enum: EnumCustomerCustomerType,
  })
  @IsEnum(EnumCustomerCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput | null;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  vipOrganization?: OrganizationWhereUniqueInput | null;
}
export { CustomerUpdateInput };
",
  "server/src/customer/base/CustomerWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { StringFilter } from \\"../../util/StringFilter\\";
import { Type } from \\"class-transformer\\";
import { IsOptional, IsEnum, ValidateNested } from \\"class-validator\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";
import { StringNullableFilter } from \\"../../util/StringNullableFilter\\";
import { BooleanNullableFilter } from \\"../../util/BooleanNullableFilter\\";
import { DateTimeNullableFilter } from \\"../../util/DateTimeNullableFilter\\";
import { FloatNullableFilter } from \\"../../util/FloatNullableFilter\\";
import { IntNullableFilter } from \\"../../util/IntNullableFilter\\";
import { EnumCustomerCustomerType } from \\"./EnumCustomerCustomerType\\";
import { OrganizationWhereUniqueInput } from \\"../../organization/base/OrganizationWhereUniqueInput\\";
@InputType()
class CustomerWhereInput {
  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  id?: StringFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  email?: StringFilter;

  @ApiProperty({
    required: false,
    type: StringNullableFilter,
  })
  @Type(() => StringNullableFilter)
  @IsOptional()
  @Field(() => StringNullableFilter, {
    nullable: true,
  })
  firstName?: StringNullableFilter;

  @ApiProperty({
    required: false,
    type: StringNullableFilter,
  })
  @Type(() => StringNullableFilter)
  @IsOptional()
  @Field(() => StringNullableFilter, {
    nullable: true,
  })
  lastName?: StringNullableFilter;

  @ApiProperty({
    required: false,
    type: BooleanNullableFilter,
  })
  @Type(() => BooleanNullableFilter)
  @IsOptional()
  @Field(() => BooleanNullableFilter, {
    nullable: true,
  })
  isVip?: BooleanNullableFilter;

  @ApiProperty({
    required: false,
    type: DateTimeNullableFilter,
  })
  @Type(() => DateTimeNullableFilter)
  @IsOptional()
  @Field(() => DateTimeNullableFilter, {
    nullable: true,
  })
  birthData?: DateTimeNullableFilter;

  @ApiProperty({
    required: false,
    type: FloatNullableFilter,
  })
  @Type(() => FloatNullableFilter)
  @IsOptional()
  @Field(() => FloatNullableFilter, {
    nullable: true,
  })
  averageSale?: FloatNullableFilter;

  @ApiProperty({
    required: false,
    type: IntNullableFilter,
  })
  @Type(() => IntNullableFilter)
  @IsOptional()
  @Field(() => IntNullableFilter, {
    nullable: true,
  })
  favoriteNumber?: IntNullableFilter;

  @ApiProperty({
    required: false,
    type: StringNullableFilter,
  })
  @Type(() => StringNullableFilter)
  @IsOptional()
  @Field(() => StringNullableFilter, {
    nullable: true,
  })
  geoLocation?: StringNullableFilter;

  @ApiProperty({
    required: false,
    type: StringNullableFilter,
  })
  @Type(() => StringNullableFilter)
  @IsOptional()
  @Field(() => StringNullableFilter, {
    nullable: true,
  })
  comments?: StringNullableFilter;

  @ApiProperty({
    required: false,
    enum: EnumCustomerCustomerType,
  })
  @IsEnum(EnumCustomerCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\";

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  vipOrganization?: OrganizationWhereUniqueInput;
}
export { CustomerWhereInput };
",
  "server/src/customer/base/CustomerWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class CustomerWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { CustomerWhereUniqueInput };
",
  "server/src/customer/base/DeleteCustomerArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";

@ArgsType()
class DeleteCustomerArgs {
  @Field(() => CustomerWhereUniqueInput, { nullable: false })
  where!: CustomerWhereUniqueInput;
}

export { DeleteCustomerArgs };
",
  "server/src/customer/base/EnumCustomerCustomerType.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumCustomerCustomerType {
  Platinum = \\"platinum\\",
  Gold = \\"gold\\",
  Bronze = \\"bronze\\",
  Regular = \\"regular\\",
}

registerEnumType(EnumCustomerCustomerType, {
  name: \\"EnumCustomerCustomerType\\",
});
",
  "server/src/customer/base/EnumCustomerFavoriteColors.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumCustomerFavoriteColors {
  Red = \\"red\\",
  Green = \\"green\\",
  Purple = \\"purple\\",
  Yellow = \\"yellow\\",
}

registerEnumType(EnumCustomerFavoriteColors, {
  name: \\"EnumCustomerFavoriteColors\\",
});
",
  "server/src/customer/base/UpdateCustomerArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";
import { CustomerUpdateInput } from \\"./CustomerUpdateInput\\";

@ArgsType()
class UpdateCustomerArgs {
  @Field(() => CustomerWhereUniqueInput, { nullable: false })
  where!: CustomerWhereUniqueInput;
  @Field(() => CustomerUpdateInput, { nullable: false })
  data!: CustomerUpdateInput;
}

export { UpdateCustomerArgs };
",
  "server/src/customer/base/customer.controller.base.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../../auth/basicAuth.guard\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { CustomerController } from \\"../customer.controller\\";
import { CustomerService } from \\"../customer.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  email: \\"exampleEmail\\",
  firstName: \\"exampleFirstName\\",
  lastName: \\"exampleLastName\\",
  isVip: \\"true\\",
  birthData: new Date(),
  averageSale: 42.42,
  favoriteNumber: 42,
  geoLocation: \\"exampleGeoLocation\\",
  comments: \\"exampleComments\\",
};
const CREATE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  email: \\"exampleEmail\\",
  firstName: \\"exampleFirstName\\",
  lastName: \\"exampleLastName\\",
  isVip: \\"true\\",
  birthData: new Date(),
  averageSale: 42.42,
  favoriteNumber: 42,
  geoLocation: \\"exampleGeoLocation\\",
  comments: \\"exampleComments\\",
};
const FIND_MANY_RESULT = [
  {
    id: \\"exampleId\\",
    createdAt: new Date(),
    updatedAt: new Date(),
    email: \\"exampleEmail\\",
    firstName: \\"exampleFirstName\\",
    lastName: \\"exampleLastName\\",
    isVip: \\"true\\",
    birthData: new Date(),
    averageSale: 42.42,
    favoriteNumber: 42,
    geoLocation: \\"exampleGeoLocation\\",
    comments: \\"exampleComments\\",
  },
];
const FIND_ONE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  email: \\"exampleEmail\\",
  firstName: \\"exampleFirstName\\",
  lastName: \\"exampleLastName\\",
  isVip: \\"true\\",
  birthData: new Date(),
  averageSale: 42.42,
  favoriteNumber: 42,
  geoLocation: \\"exampleGeoLocation\\",
  comments: \\"exampleComments\\",
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"Customer\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: CustomerService,
          useValue: service,
        },
      ],
      controllers: [CustomerController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /customers\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/customers\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
        birthData: CREATE_RESULT.birthData.toISOString(),
      });
  });

  test(\\"GET /customers\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/customers\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
          birthData: FIND_MANY_RESULT[0].birthData.toISOString(),
        },
      ]);
  });

  test(\\"GET /customers/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/customers\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /customers/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/customers\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
        birthData: FIND_ONE_RESULT.birthData.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/customer/base/customer.controller.base.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../../auth/basicAuth.guard\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import * as errors from \\"../../errors\\";
import { Request } from \\"express\\";
import { plainToClass } from \\"class-transformer\\";
import { CustomerService } from \\"../customer.service\\";
import { CustomerCreateInput } from \\"./CustomerCreateInput\\";
import { CustomerWhereInput } from \\"./CustomerWhereInput\\";
import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";
import { CustomerFindManyArgs } from \\"./CustomerFindManyArgs\\";
import { CustomerUpdateInput } from \\"./CustomerUpdateInput\\";
import { Customer } from \\"./Customer\\";
import { OrderWhereInput } from \\"../../order/base/OrderWhereInput\\";
import { Order } from \\"../../order/base/Order\\";

export class CustomerControllerBase {
  constructor(
    protected readonly service: CustomerService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: Customer })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Body() data: CustomerCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Customer\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    return await this.service.create({
      data: {
        ...data,

        organization: data.organization
          ? {
              connect: data.organization,
            }
          : undefined,

        vipOrganization: data.vipOrganization
          ? {
              connect: data.vipOrganization,
            }
          : undefined,
      },
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [Customer] })
  @swagger.ApiForbiddenResponse()
  @swagger.ApiQuery({
    type: () => CustomerFindManyArgs,
    style: \\"deepObject\\",
    explode: true,
  })
  async findMany(
    @common.Req() request: Request,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const args = plainToClass(CustomerFindManyArgs, request.query);

    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findMany({
      ...args,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: Customer })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Param() params: CustomerWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Customer\\",
    });
    const result = await this.service.findOne({
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Customer })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body()
    data: CustomerUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Customer\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      return await this.service.update({
        where: params,
        data: {
          ...data,

          organization: data.organization
            ? {
                connect: data.organization,
              }
            : undefined,

          vipOrganization: data.vipOrganization
            ? {
                connect: data.vipOrganization,
              }
            : undefined,
        },
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          email: true,
          firstName: true,
          lastName: true,
          isVip: true,
          birthData: true,
          averageSale: true,
          favoriteNumber: true,
          geoLocation: true,
          comments: true,
          favoriteColors: true,
          customerType: true,

          organization: {
            select: {
              id: true,
            },
          },

          vipOrganization: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Customer })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Param() params: CustomerWhereUniqueInput
  ): Promise<Customer | null> {
    try {
      return await this.service.delete({
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          email: true,
          firstName: true,
          lastName: true,
          isVip: true,
          birthData: true,
          averageSale: true,
          favoriteNumber: true,
          geoLocation: true,
          comments: true,
          favoriteColors: true,
          customerType: true,

          organization: {
            select: {
              id: true,
            },
          },

          vipOrganization: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/orders\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiQuery({
    type: () => OrderWhereInput,
    style: \\"deepObject\\",
    explode: true,
  })
  async findManyOrders(
    @common.Req() request: Request,
    @common.Param() params: CustomerWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order[]> {
    const query: OrderWhereInput = request.query;
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const results = await this.service.findOrders(params.id, {
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/orders\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      orders: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Customer\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/orders\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      orders: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Customer\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/orders\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      orders: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Customer\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }
}
",
  "server/src/customer/base/customer.module.base.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { AuthModule } from \\"../../auth/auth.module\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],

  exports: [ACLModule, AuthModule, MorganModule, PrismaModule],
})
export class CustomerModuleBase {}
",
  "server/src/customer/base/customer.resolver.base.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import { MetaQueryPayload } from \\"../../util/MetaQueryPayload\\";
import { CreateCustomerArgs } from \\"./CreateCustomerArgs\\";
import { UpdateCustomerArgs } from \\"./UpdateCustomerArgs\\";
import { DeleteCustomerArgs } from \\"./DeleteCustomerArgs\\";
import { CustomerFindManyArgs } from \\"./CustomerFindManyArgs\\";
import { CustomerFindUniqueArgs } from \\"./CustomerFindUniqueArgs\\";
import { Customer } from \\"./Customer\\";
import { OrderFindManyArgs } from \\"../../order/base/OrderFindManyArgs\\";
import { Order } from \\"../../order/base/Order\\";
import { Organization } from \\"../../organization/base/Organization\\";
import { CustomerService } from \\"../customer.service\\";

@graphql.Resolver(() => Customer)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class CustomerResolverBase {
  constructor(
    protected readonly service: CustomerService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => MetaQueryPayload)
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async _customersMeta(
    @graphql.Args() args: CustomerFindManyArgs
  ): Promise<MetaQueryPayload> {
    const results = await this.service.count({
      ...args,
      skip: undefined,
      take: undefined,
    });
    return {
      count: results,
    };
  }

  @graphql.Query(() => [Customer])
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async customers(
    @graphql.Args() args: CustomerFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => Customer, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async customer(
    @graphql.Args() args: CustomerFindUniqueArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Customer\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => Customer)
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  async createCustomer(
    @graphql.Args() args: CreateCustomerArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Customer\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...args,
      data: {
        ...args.data,

        organization: args.data.organization
          ? {
              connect: args.data.organization,
            }
          : undefined,

        vipOrganization: args.data.vipOrganization
          ? {
              connect: args.data.vipOrganization,
            }
          : undefined,
      },
    });
  }

  @graphql.Mutation(() => Customer)
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateCustomer(
    @graphql.Args() args: UpdateCustomerArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Customer\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...args,
        data: {
          ...args.data,

          organization: args.data.organization
            ? {
                connect: args.data.organization,
              }
            : undefined,

          vipOrganization: args.data.vipOrganization
            ? {
                connect: args.data.vipOrganization,
              }
            : undefined,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => Customer)
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteCustomer(
    @graphql.Args() args: DeleteCustomerArgs
  ): Promise<Customer | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => [Order])
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async orders(
    @graphql.Parent() parent: Customer,
    @graphql.Args() args: OrderFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const results = await this.service.findOrders(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => Organization, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async organization(
    @graphql.Parent() parent: Customer,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const result = await this.service.getOrganization(parent.id);

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.ResolveField(() => Organization, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async vipOrganization(
    @graphql.Parent() parent: Customer,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const result = await this.service.getVipOrganization(parent.id);

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }
}
",
  "server/src/customer/base/customer.service.base.ts": "import { PrismaService } from \\"nestjs-prisma\\";
import { Prisma, Customer, Order, Organization } from \\"@prisma/client\\";

export class CustomerServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.CustomerFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerFindManyArgs>
  ): Promise<number> {
    return this.prisma.customer.count(args);
  }

  async findMany<T extends Prisma.CustomerFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerFindManyArgs>
  ): Promise<Customer[]> {
    return this.prisma.customer.findMany(args);
  }
  async findOne<T extends Prisma.CustomerFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerFindUniqueArgs>
  ): Promise<Customer | null> {
    return this.prisma.customer.findUnique(args);
  }
  async create<T extends Prisma.CustomerCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerCreateArgs>
  ): Promise<Customer> {
    return this.prisma.customer.create<T>(args);
  }
  async update<T extends Prisma.CustomerUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerUpdateArgs>
  ): Promise<Customer> {
    return this.prisma.customer.update<T>(args);
  }
  async delete<T extends Prisma.CustomerDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerDeleteArgs>
  ): Promise<Customer> {
    return this.prisma.customer.delete(args);
  }

  async findOrders(
    parentId: string,
    args: Prisma.OrderFindManyArgs
  ): Promise<Order[]> {
    return this.prisma.customer
      .findUnique({
        where: { id: parentId },
      })
      .orders(args);
  }

  async getOrganization(parentId: string): Promise<Organization | null> {
    return this.prisma.customer
      .findUnique({
        where: { id: parentId },
      })
      .organization();
  }

  async getVipOrganization(parentId: string): Promise<Organization | null> {
    return this.prisma.customer
      .findUnique({
        where: { id: parentId },
      })
      .vipOrganization();
  }
}
",
  "server/src/customer/customer.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestAccessControl from \\"nest-access-control\\";
import { CustomerService } from \\"./customer.service\\";
import { CustomerControllerBase } from \\"./base/customer.controller.base\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"customers\\")
@common.Controller(\\"customers\\")
export class CustomerController extends CustomerControllerBase {
  constructor(
    protected readonly service: CustomerService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/customer/customer.module.ts": "import { Module } from \\"@nestjs/common\\";
import { CustomerModuleBase } from \\"./base/customer.module.base\\";
import { CustomerService } from \\"./customer.service\\";
import { CustomerController } from \\"./customer.controller\\";
import { CustomerResolver } from \\"./customer.resolver\\";

@Module({
  imports: [CustomerModuleBase],
  controllers: [CustomerController],
  providers: [CustomerService, CustomerResolver],
  exports: [CustomerService],
})
export class CustomerModule {}
",
  "server/src/customer/customer.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import { CustomerResolverBase } from \\"./base/customer.resolver.base\\";
import { Customer } from \\"./base/Customer\\";
import { CustomerService } from \\"./customer.service\\";

@graphql.Resolver(() => Customer)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class CustomerResolver extends CustomerResolverBase {
  constructor(
    protected readonly service: CustomerService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/customer/customer.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";
import { CustomerServiceBase } from \\"./base/customer.service.base\\";

@Injectable()
export class CustomerService extends CustomerServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/empty/base/DeleteEmptyArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";

@ArgsType()
class DeleteEmptyArgs {
  @Field(() => EmptyWhereUniqueInput, { nullable: false })
  where!: EmptyWhereUniqueInput;
}

export { DeleteEmptyArgs };
",
  "server/src/empty/base/Empty.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString, IsDate } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
@ObjectType()
class Empty {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;
}
export { Empty };
",
  "server/src/empty/base/EmptyCreateInput.ts": "class EmptyCreateInput {}
export { EmptyCreateInput };
",
  "server/src/empty/base/EmptyFindManyArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { EmptyWhereInput } from \\"./EmptyWhereInput\\";
import { Type } from \\"class-transformer\\";
import { EmptyOrderByInput } from \\"./EmptyOrderByInput\\";

@ArgsType()
class EmptyFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => EmptyWhereInput,
  })
  @Field(() => EmptyWhereInput, { nullable: true })
  @Type(() => EmptyWhereInput)
  where?: EmptyWhereInput;

  @ApiProperty({
    required: false,
    type: EmptyOrderByInput,
  })
  @Field(() => EmptyOrderByInput, { nullable: true })
  @Type(() => EmptyOrderByInput)
  orderBy?: EmptyOrderByInput;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { EmptyFindManyArgs };
",
  "server/src/empty/base/EmptyFindUniqueArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";

@ArgsType()
class EmptyFindUniqueArgs {
  @Field(() => EmptyWhereUniqueInput, { nullable: false })
  where!: EmptyWhereUniqueInput;
}

export { EmptyFindUniqueArgs };
",
  "server/src/empty/base/EmptyOrderByInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { SortOrder } from \\"../../util/SortOrder\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
class EmptyOrderByInput {
  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedAt?: SortOrder;
}

export { EmptyOrderByInput };
",
  "server/src/empty/base/EmptyUpdateInput.ts": "class EmptyUpdateInput {}
export { EmptyUpdateInput };
",
  "server/src/empty/base/EmptyWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { StringFilter } from \\"../../util/StringFilter\\";
import { Type } from \\"class-transformer\\";
import { IsOptional } from \\"class-validator\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";
@InputType()
class EmptyWhereInput {
  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  id?: StringFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedAt?: DateTimeFilter;
}
export { EmptyWhereInput };
",
  "server/src/empty/base/EmptyWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class EmptyWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { EmptyWhereUniqueInput };
",
  "server/src/empty/base/empty.controller.base.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../../auth/basicAuth.guard\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { EmptyController } from \\"../empty.controller\\";
import { EmptyService } from \\"../empty.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const CREATE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const FIND_MANY_RESULT = [
  {
    id: \\"exampleId\\",
    createdAt: new Date(),
    updatedAt: new Date(),
  },
];
const FIND_ONE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"Empty\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: EmptyService,
          useValue: service,
        },
      ],
      controllers: [EmptyController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /empties\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/empties\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test(\\"GET /empties\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/empties\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test(\\"GET /empties/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/empties\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /empties/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/empties\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/empty/base/empty.controller.base.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../../auth/basicAuth.guard\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import * as errors from \\"../../errors\\";
import { Request } from \\"express\\";
import { plainToClass } from \\"class-transformer\\";
import { EmptyService } from \\"../empty.service\\";
import { EmptyCreateInput } from \\"./EmptyCreateInput\\";
import { EmptyWhereInput } from \\"./EmptyWhereInput\\";
import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";
import { EmptyFindManyArgs } from \\"./EmptyFindManyArgs\\";
import { EmptyUpdateInput } from \\"./EmptyUpdateInput\\";
import { Empty } from \\"./Empty\\";

export class EmptyControllerBase {
  constructor(
    protected readonly service: EmptyService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: Empty })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Body() data: EmptyCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Empty> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Empty\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Empty\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    return await this.service.create({
      data: data,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [Empty] })
  @swagger.ApiForbiddenResponse()
  @swagger.ApiQuery({
    type: () => EmptyFindManyArgs,
    style: \\"deepObject\\",
    explode: true,
  })
  async findMany(
    @common.Req() request: Request,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Empty[]> {
    const args = plainToClass(EmptyFindManyArgs, request.query);

    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Empty\\",
    });
    const results = await this.service.findMany({
      ...args,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: Empty })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Param() params: EmptyWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Empty | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Empty\\",
    });
    const result = await this.service.findOne({
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Empty })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Param() params: EmptyWhereUniqueInput,
    @common.Body()
    data: EmptyUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Empty | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Empty\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Empty\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      return await this.service.update({
        where: params,
        data: data,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Empty })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Param() params: EmptyWhereUniqueInput
  ): Promise<Empty | null> {
    try {
      return await this.service.delete({
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/empty/base/empty.module.base.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { AuthModule } from \\"../../auth/auth.module\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],

  exports: [ACLModule, AuthModule, MorganModule, PrismaModule],
})
export class EmptyModuleBase {}
",
  "server/src/empty/base/empty.resolver.base.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import { MetaQueryPayload } from \\"../../util/MetaQueryPayload\\";
import { DeleteEmptyArgs } from \\"./DeleteEmptyArgs\\";
import { EmptyFindManyArgs } from \\"./EmptyFindManyArgs\\";
import { EmptyFindUniqueArgs } from \\"./EmptyFindUniqueArgs\\";
import { Empty } from \\"./Empty\\";
import { EmptyService } from \\"../empty.service\\";

@graphql.Resolver(() => Empty)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class EmptyResolverBase {
  constructor(
    protected readonly service: EmptyService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => MetaQueryPayload)
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async _emptiesMeta(
    @graphql.Args() args: EmptyFindManyArgs
  ): Promise<MetaQueryPayload> {
    const results = await this.service.count({
      ...args,
      skip: undefined,
      take: undefined,
    });
    return {
      count: results,
    };
  }

  @graphql.Query(() => [Empty])
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async empties(
    @graphql.Args() args: EmptyFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Empty[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Empty\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => Empty, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async empty(
    @graphql.Args() args: EmptyFindUniqueArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Empty | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Empty\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => Empty)
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteEmpty(
    @graphql.Args() args: DeleteEmptyArgs
  ): Promise<Empty | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/empty/base/empty.service.base.ts": "import { PrismaService } from \\"nestjs-prisma\\";
import { Prisma, Empty } from \\"@prisma/client\\";

export class EmptyServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.EmptyFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyFindManyArgs>
  ): Promise<number> {
    return this.prisma.empty.count(args);
  }

  async findMany<T extends Prisma.EmptyFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyFindManyArgs>
  ): Promise<Empty[]> {
    return this.prisma.empty.findMany(args);
  }
  async findOne<T extends Prisma.EmptyFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyFindUniqueArgs>
  ): Promise<Empty | null> {
    return this.prisma.empty.findUnique(args);
  }
  async create<T extends Prisma.EmptyCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyCreateArgs>
  ): Promise<Empty> {
    return this.prisma.empty.create<T>(args);
  }
  async update<T extends Prisma.EmptyUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyUpdateArgs>
  ): Promise<Empty> {
    return this.prisma.empty.update<T>(args);
  }
  async delete<T extends Prisma.EmptyDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyDeleteArgs>
  ): Promise<Empty> {
    return this.prisma.empty.delete(args);
  }
}
",
  "server/src/empty/empty.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestAccessControl from \\"nest-access-control\\";
import { EmptyService } from \\"./empty.service\\";
import { EmptyControllerBase } from \\"./base/empty.controller.base\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"empties\\")
@common.Controller(\\"empties\\")
export class EmptyController extends EmptyControllerBase {
  constructor(
    protected readonly service: EmptyService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/empty/empty.module.ts": "import { Module } from \\"@nestjs/common\\";
import { EmptyModuleBase } from \\"./base/empty.module.base\\";
import { EmptyService } from \\"./empty.service\\";
import { EmptyController } from \\"./empty.controller\\";
import { EmptyResolver } from \\"./empty.resolver\\";

@Module({
  imports: [EmptyModuleBase],
  controllers: [EmptyController],
  providers: [EmptyService, EmptyResolver],
  exports: [EmptyService],
})
export class EmptyModule {}
",
  "server/src/empty/empty.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import { EmptyResolverBase } from \\"./base/empty.resolver.base\\";
import { Empty } from \\"./base/Empty\\";
import { EmptyService } from \\"./empty.service\\";

@graphql.Resolver(() => Empty)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class EmptyResolver extends EmptyResolverBase {
  constructor(
    protected readonly service: EmptyService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/empty/empty.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";
import { EmptyServiceBase } from \\"./base/empty.service.base\\";

@Injectable()
export class EmptyService extends EmptyServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/errors.ts": "import * as common from \\"@nestjs/common\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

export class ForbiddenException extends common.ForbiddenException {
  @ApiProperty()
  statusCode!: number;
  @ApiProperty()
  message!: string;
}

export class NotFoundException extends common.NotFoundException {
  @ApiProperty()
  statusCode!: number;
  @ApiProperty()
  message!: string;
}
",
  "server/src/main.ts": "import { ValidationPipe } from \\"@nestjs/common\\";
import { NestFactory } from \\"@nestjs/core\\";
import { SwaggerModule } from \\"@nestjs/swagger\\";
// @ts-ignore
// eslint-disable-next-line
import { AppModule } from \\"./app.module\\";
import {
  swaggerPath,
  swaggerDocumentOptions,
  swaggerSetupOptions,
  // @ts-ignore
  // eslint-disable-next-line
} from \\"./swagger\\";

const { PORT = 3000 } = process.env;

async function main() {
  const app = await NestFactory.create(AppModule, { cors: true });

  app.setGlobalPrefix(\\"api\\");
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
    })
  );

  const document = SwaggerModule.createDocument(app, swaggerDocumentOptions);

  SwaggerModule.setup(swaggerPath, app, document, swaggerSetupOptions);

  void app.listen(PORT);

  return app;
}

module.exports = main();
",
  "server/src/order/base/CreateOrderArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrderCreateInput } from \\"./OrderCreateInput\\";

@ArgsType()
class CreateOrderArgs {
  @Field(() => OrderCreateInput, { nullable: false })
  data!: OrderCreateInput;
}

export { CreateOrderArgs };
",
  "server/src/order/base/DeleteOrderArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";

@ArgsType()
class DeleteOrderArgs {
  @Field(() => OrderWhereUniqueInput, { nullable: false })
  where!: OrderWhereUniqueInput;
}

export { DeleteOrderArgs };
",
  "server/src/order/base/EnumOrderLabel.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumOrderLabel {
  Fragile = \\"fragile\\",
}

registerEnumType(EnumOrderLabel, {
  name: \\"EnumOrderLabel\\",
});
",
  "server/src/order/base/EnumOrderStatus.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumOrderStatus {
  Pending = \\"pending\\",
  InProgress = \\"inProgress\\",
  Done = \\"done\\",
}

registerEnumType(EnumOrderStatus, {
  name: \\"EnumOrderStatus\\",
});
",
  "server/src/order/base/Order.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import {
  IsString,
  IsDate,
  ValidateNested,
  IsEnum,
  IsOptional,
} from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
import { Customer } from \\"../../customer/base/Customer\\";
import { EnumOrderStatus } from \\"./EnumOrderStatus\\";
import { EnumOrderLabel } from \\"./EnumOrderLabel\\";
@ObjectType()
class Order {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;

  @ApiProperty({
    required: true,
    type: () => Customer,
  })
  @ValidateNested()
  @Type(() => Customer)
  customer?: Customer;

  @ApiProperty({
    required: true,
    enum: EnumOrderStatus,
  })
  @IsEnum(EnumOrderStatus)
  @Field(() => EnumOrderStatus, {
    nullable: true,
  })
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";

  @ApiProperty({
    required: false,
    enum: EnumOrderLabel,
  })
  @IsEnum(EnumOrderLabel)
  @IsOptional()
  @Field(() => EnumOrderLabel, {
    nullable: true,
  })
  label?: \\"fragile\\" | null;
}
export { Order };
",
  "server/src/order/base/OrderCreateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { CustomerWhereUniqueInput } from \\"../../customer/base/CustomerWhereUniqueInput\\";
import { ValidateNested, IsEnum, IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
import { EnumOrderStatus } from \\"./EnumOrderStatus\\";
import { EnumOrderLabel } from \\"./EnumOrderLabel\\";
@InputType()
class OrderCreateInput {
  @ApiProperty({
    required: true,
    type: () => CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @Field(() => CustomerWhereUniqueInput)
  customer!: CustomerWhereUniqueInput;

  @ApiProperty({
    required: true,
    enum: EnumOrderStatus,
  })
  @IsEnum(EnumOrderStatus)
  @Field(() => EnumOrderStatus)
  status!: \\"pending\\" | \\"inProgress\\" | \\"done\\";

  @ApiProperty({
    required: false,
    enum: EnumOrderLabel,
  })
  @IsEnum(EnumOrderLabel)
  @IsOptional()
  @Field(() => EnumOrderLabel, {
    nullable: true,
  })
  label?: \\"fragile\\" | null;
}
export { OrderCreateInput };
",
  "server/src/order/base/OrderFindManyArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { OrderWhereInput } from \\"./OrderWhereInput\\";
import { Type } from \\"class-transformer\\";
import { OrderOrderByInput } from \\"./OrderOrderByInput\\";

@ArgsType()
class OrderFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => OrderWhereInput,
  })
  @Field(() => OrderWhereInput, { nullable: true })
  @Type(() => OrderWhereInput)
  where?: OrderWhereInput;

  @ApiProperty({
    required: false,
    type: OrderOrderByInput,
  })
  @Field(() => OrderOrderByInput, { nullable: true })
  @Type(() => OrderOrderByInput)
  orderBy?: OrderOrderByInput;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { OrderFindManyArgs };
",
  "server/src/order/base/OrderFindUniqueArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";

@ArgsType()
class OrderFindUniqueArgs {
  @Field(() => OrderWhereUniqueInput, { nullable: false })
  where!: OrderWhereUniqueInput;
}

export { OrderFindUniqueArgs };
",
  "server/src/order/base/OrderOrderByInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { SortOrder } from \\"../../util/SortOrder\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
class OrderOrderByInput {
  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  customerId?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  status?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  label?: SortOrder;
}

export { OrderOrderByInput };
",
  "server/src/order/base/OrderUpdateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { CustomerWhereUniqueInput } from \\"../../customer/base/CustomerWhereUniqueInput\\";
import { ValidateNested, IsOptional, IsEnum } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
import { EnumOrderStatus } from \\"./EnumOrderStatus\\";
import { EnumOrderLabel } from \\"./EnumOrderLabel\\";
@InputType()
class OrderUpdateInput {
  @ApiProperty({
    required: false,
    type: () => CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @IsOptional()
  @Field(() => CustomerWhereUniqueInput, {
    nullable: true,
  })
  customer?: CustomerWhereUniqueInput;

  @ApiProperty({
    required: false,
    enum: EnumOrderStatus,
  })
  @IsEnum(EnumOrderStatus)
  @IsOptional()
  @Field(() => EnumOrderStatus, {
    nullable: true,
  })
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";

  @ApiProperty({
    required: false,
    enum: EnumOrderLabel,
  })
  @IsEnum(EnumOrderLabel)
  @IsOptional()
  @Field(() => EnumOrderLabel, {
    nullable: true,
  })
  label?: \\"fragile\\" | null;
}
export { OrderUpdateInput };
",
  "server/src/order/base/OrderWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { StringFilter } from \\"../../util/StringFilter\\";
import { Type } from \\"class-transformer\\";
import { IsOptional, ValidateNested, IsEnum } from \\"class-validator\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";
import { CustomerWhereUniqueInput } from \\"../../customer/base/CustomerWhereUniqueInput\\";
import { EnumOrderStatus } from \\"./EnumOrderStatus\\";
import { EnumOrderLabel } from \\"./EnumOrderLabel\\";
@InputType()
class OrderWhereInput {
  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  id?: StringFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: () => CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @IsOptional()
  @Field(() => CustomerWhereUniqueInput, {
    nullable: true,
  })
  customer?: CustomerWhereUniqueInput;

  @ApiProperty({
    required: false,
    enum: EnumOrderStatus,
  })
  @IsEnum(EnumOrderStatus)
  @IsOptional()
  @Field(() => EnumOrderStatus, {
    nullable: true,
  })
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";

  @ApiProperty({
    required: false,
    enum: EnumOrderLabel,
  })
  @IsEnum(EnumOrderLabel)
  @IsOptional()
  @Field(() => EnumOrderLabel, {
    nullable: true,
  })
  label?: \\"fragile\\";
}
export { OrderWhereInput };
",
  "server/src/order/base/OrderWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class OrderWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { OrderWhereUniqueInput };
",
  "server/src/order/base/UpdateOrderArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";
import { OrderUpdateInput } from \\"./OrderUpdateInput\\";

@ArgsType()
class UpdateOrderArgs {
  @Field(() => OrderWhereUniqueInput, { nullable: false })
  where!: OrderWhereUniqueInput;
  @Field(() => OrderUpdateInput, { nullable: false })
  data!: OrderUpdateInput;
}

export { UpdateOrderArgs };
",
  "server/src/order/base/order.controller.base.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../../auth/basicAuth.guard\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { OrderController } from \\"../order.controller\\";
import { OrderService } from \\"../order.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const CREATE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const FIND_MANY_RESULT = [
  {
    id: \\"exampleId\\",
    createdAt: new Date(),
    updatedAt: new Date(),
  },
];
const FIND_ONE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"Order\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: OrderService,
          useValue: service,
        },
      ],
      controllers: [OrderController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /orders\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/orders\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test(\\"GET /orders\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/orders\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test(\\"GET /orders/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/orders\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /orders/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/orders\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/order/base/order.controller.base.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../../auth/basicAuth.guard\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import * as errors from \\"../../errors\\";
import { Request } from \\"express\\";
import { plainToClass } from \\"class-transformer\\";
import { OrderService } from \\"../order.service\\";
import { OrderCreateInput } from \\"./OrderCreateInput\\";
import { OrderWhereInput } from \\"./OrderWhereInput\\";
import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";
import { OrderFindManyArgs } from \\"./OrderFindManyArgs\\";
import { OrderUpdateInput } from \\"./OrderUpdateInput\\";
import { Order } from \\"./Order\\";

export class OrderControllerBase {
  constructor(
    protected readonly service: OrderService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: Order })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Body() data: OrderCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Order\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    return await this.service.create({
      data: {
        ...data,

        customer: {
          connect: data.customer,
        },
      },
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [Order] })
  @swagger.ApiForbiddenResponse()
  @swagger.ApiQuery({
    type: () => OrderFindManyArgs,
    style: \\"deepObject\\",
    explode: true,
  })
  async findMany(
    @common.Req() request: Request,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order[]> {
    const args = plainToClass(OrderFindManyArgs, request.query);

    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const results = await this.service.findMany({
      ...args,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: Order })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Param() params: OrderWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Order\\",
    });
    const result = await this.service.findOne({
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Order })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Param() params: OrderWhereUniqueInput,
    @common.Body()
    data: OrderUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Order\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      return await this.service.update({
        where: params,
        data: {
          ...data,

          customer: {
            connect: data.customer,
          },
        },
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,

          customer: {
            select: {
              id: true,
            },
          },

          status: true,
          label: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Order })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Param() params: OrderWhereUniqueInput
  ): Promise<Order | null> {
    try {
      return await this.service.delete({
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,

          customer: {
            select: {
              id: true,
            },
          },

          status: true,
          label: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/order/base/order.module.base.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { AuthModule } from \\"../../auth/auth.module\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],

  exports: [ACLModule, AuthModule, MorganModule, PrismaModule],
})
export class OrderModuleBase {}
",
  "server/src/order/base/order.resolver.base.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import { MetaQueryPayload } from \\"../../util/MetaQueryPayload\\";
import { CreateOrderArgs } from \\"./CreateOrderArgs\\";
import { UpdateOrderArgs } from \\"./UpdateOrderArgs\\";
import { DeleteOrderArgs } from \\"./DeleteOrderArgs\\";
import { OrderFindManyArgs } from \\"./OrderFindManyArgs\\";
import { OrderFindUniqueArgs } from \\"./OrderFindUniqueArgs\\";
import { Order } from \\"./Order\\";
import { Customer } from \\"../../customer/base/Customer\\";
import { OrderService } from \\"../order.service\\";

@graphql.Resolver(() => Order)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class OrderResolverBase {
  constructor(
    protected readonly service: OrderService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => MetaQueryPayload)
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async _ordersMeta(
    @graphql.Args() args: OrderFindManyArgs
  ): Promise<MetaQueryPayload> {
    const results = await this.service.count({
      ...args,
      skip: undefined,
      take: undefined,
    });
    return {
      count: results,
    };
  }

  @graphql.Query(() => [Order])
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async orders(
    @graphql.Args() args: OrderFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => Order, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async order(
    @graphql.Args() args: OrderFindUniqueArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Order\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => Order)
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  async createOrder(
    @graphql.Args() args: CreateOrderArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Order\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...args,
      data: {
        ...args.data,

        customer: {
          connect: args.data.customer,
        },
      },
    });
  }

  @graphql.Mutation(() => Order)
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateOrder(
    @graphql.Args() args: UpdateOrderArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Order\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...args,
        data: {
          ...args.data,

          customer: {
            connect: args.data.customer,
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => Order)
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteOrder(
    @graphql.Args() args: DeleteOrderArgs
  ): Promise<Order | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => Customer, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async customer(
    @graphql.Parent() parent: Order,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const result = await this.service.getCustomer(parent.id);

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }
}
",
  "server/src/order/base/order.service.base.ts": "import { PrismaService } from \\"nestjs-prisma\\";
import { Prisma, Order, Customer } from \\"@prisma/client\\";

export class OrderServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.OrderFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderFindManyArgs>
  ): Promise<number> {
    return this.prisma.order.count(args);
  }

  async findMany<T extends Prisma.OrderFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderFindManyArgs>
  ): Promise<Order[]> {
    return this.prisma.order.findMany(args);
  }
  async findOne<T extends Prisma.OrderFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderFindUniqueArgs>
  ): Promise<Order | null> {
    return this.prisma.order.findUnique(args);
  }
  async create<T extends Prisma.OrderCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderCreateArgs>
  ): Promise<Order> {
    return this.prisma.order.create<T>(args);
  }
  async update<T extends Prisma.OrderUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderUpdateArgs>
  ): Promise<Order> {
    return this.prisma.order.update<T>(args);
  }
  async delete<T extends Prisma.OrderDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderDeleteArgs>
  ): Promise<Order> {
    return this.prisma.order.delete(args);
  }

  async getCustomer(parentId: string): Promise<Customer | null> {
    return this.prisma.order
      .findUnique({
        where: { id: parentId },
      })
      .customer();
  }
}
",
  "server/src/order/order.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestAccessControl from \\"nest-access-control\\";
import { OrderService } from \\"./order.service\\";
import { OrderControllerBase } from \\"./base/order.controller.base\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"orders\\")
@common.Controller(\\"orders\\")
export class OrderController extends OrderControllerBase {
  constructor(
    protected readonly service: OrderService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/order/order.module.ts": "import { Module } from \\"@nestjs/common\\";
import { OrderModuleBase } from \\"./base/order.module.base\\";
import { OrderService } from \\"./order.service\\";
import { OrderController } from \\"./order.controller\\";
import { OrderResolver } from \\"./order.resolver\\";

@Module({
  imports: [OrderModuleBase],
  controllers: [OrderController],
  providers: [OrderService, OrderResolver],
  exports: [OrderService],
})
export class OrderModule {}
",
  "server/src/order/order.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import { OrderResolverBase } from \\"./base/order.resolver.base\\";
import { Order } from \\"./base/Order\\";
import { OrderService } from \\"./order.service\\";

@graphql.Resolver(() => Order)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class OrderResolver extends OrderResolverBase {
  constructor(
    protected readonly service: OrderService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/order/order.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";
import { OrderServiceBase } from \\"./base/order.service.base\\";

@Injectable()
export class OrderService extends OrderServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/organization/base/CreateOrganizationArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrganizationCreateInput } from \\"./OrganizationCreateInput\\";

@ArgsType()
class CreateOrganizationArgs {
  @Field(() => OrganizationCreateInput, { nullable: false })
  data!: OrganizationCreateInput;
}

export { CreateOrganizationArgs };
",
  "server/src/organization/base/DeleteOrganizationArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";

@ArgsType()
class DeleteOrganizationArgs {
  @Field(() => OrganizationWhereUniqueInput, { nullable: false })
  where!: OrganizationWhereUniqueInput;
}

export { DeleteOrganizationArgs };
",
  "server/src/organization/base/Organization.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString, IsDate, ValidateNested, IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
import { User } from \\"../../user/base/User\\";
import { Customer } from \\"../../customer/base/Customer\\";
@ObjectType()
class Organization {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;

  @ApiProperty({
    required: true,
    type: () => [User],
  })
  @ValidateNested()
  @Type(() => User)
  @IsOptional()
  users?: Array<User>;

  @ApiProperty({
    required: true,
    type: () => [Customer],
  })
  @ValidateNested()
  @Type(() => Customer)
  @IsOptional()
  customers?: Array<Customer>;

  @ApiProperty({
    required: true,
    type: () => [Customer],
  })
  @ValidateNested()
  @Type(() => Customer)
  @IsOptional()
  vipCustomers?: Array<Customer>;
}
export { Organization };
",
  "server/src/organization/base/OrganizationCreateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class OrganizationCreateInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;
}
export { OrganizationCreateInput };
",
  "server/src/organization/base/OrganizationFindManyArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { OrganizationWhereInput } from \\"./OrganizationWhereInput\\";
import { Type } from \\"class-transformer\\";
import { OrganizationOrderByInput } from \\"./OrganizationOrderByInput\\";

@ArgsType()
class OrganizationFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => OrganizationWhereInput,
  })
  @Field(() => OrganizationWhereInput, { nullable: true })
  @Type(() => OrganizationWhereInput)
  where?: OrganizationWhereInput;

  @ApiProperty({
    required: false,
    type: OrganizationOrderByInput,
  })
  @Field(() => OrganizationOrderByInput, { nullable: true })
  @Type(() => OrganizationOrderByInput)
  orderBy?: OrganizationOrderByInput;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { OrganizationFindManyArgs };
",
  "server/src/organization/base/OrganizationFindUniqueArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";

@ArgsType()
class OrganizationFindUniqueArgs {
  @Field(() => OrganizationWhereUniqueInput, { nullable: false })
  where!: OrganizationWhereUniqueInput;
}

export { OrganizationFindUniqueArgs };
",
  "server/src/organization/base/OrganizationOrderByInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { SortOrder } from \\"../../util/SortOrder\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
class OrganizationOrderByInput {
  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  name?: SortOrder;
}

export { OrganizationOrderByInput };
",
  "server/src/organization/base/OrganizationUpdateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString, IsOptional } from \\"class-validator\\";
@InputType()
class OrganizationUpdateInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  name?: string;
}
export { OrganizationUpdateInput };
",
  "server/src/organization/base/OrganizationWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { StringFilter } from \\"../../util/StringFilter\\";
import { Type } from \\"class-transformer\\";
import { IsOptional } from \\"class-validator\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";
@InputType()
class OrganizationWhereInput {
  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  id?: StringFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  name?: StringFilter;
}
export { OrganizationWhereInput };
",
  "server/src/organization/base/OrganizationWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class OrganizationWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { OrganizationWhereUniqueInput };
",
  "server/src/organization/base/UpdateOrganizationArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";
import { OrganizationUpdateInput } from \\"./OrganizationUpdateInput\\";

@ArgsType()
class UpdateOrganizationArgs {
  @Field(() => OrganizationWhereUniqueInput, { nullable: false })
  where!: OrganizationWhereUniqueInput;
  @Field(() => OrganizationUpdateInput, { nullable: false })
  data!: OrganizationUpdateInput;
}

export { UpdateOrganizationArgs };
",
  "server/src/organization/base/organization.controller.base.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../../auth/basicAuth.guard\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { OrganizationController } from \\"../organization.controller\\";
import { OrganizationService } from \\"../organization.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: \\"exampleName\\",
};
const CREATE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: \\"exampleName\\",
};
const FIND_MANY_RESULT = [
  {
    id: \\"exampleId\\",
    createdAt: new Date(),
    updatedAt: new Date(),
    name: \\"exampleName\\",
  },
];
const FIND_ONE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: \\"exampleName\\",
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"Organization\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: OrganizationService,
          useValue: service,
        },
      ],
      controllers: [OrganizationController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /organizations\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/organizations\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test(\\"GET /organizations\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/organizations\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test(\\"GET /organizations/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/organizations\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /organizations/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/organizations\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/organization/base/organization.controller.base.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../../auth/basicAuth.guard\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import * as errors from \\"../../errors\\";
import { Request } from \\"express\\";
import { plainToClass } from \\"class-transformer\\";
import { OrganizationService } from \\"../organization.service\\";
import { OrganizationCreateInput } from \\"./OrganizationCreateInput\\";
import { OrganizationWhereInput } from \\"./OrganizationWhereInput\\";
import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";
import { OrganizationFindManyArgs } from \\"./OrganizationFindManyArgs\\";
import { OrganizationUpdateInput } from \\"./OrganizationUpdateInput\\";
import { Organization } from \\"./Organization\\";
import { UserWhereInput } from \\"../../user/base/UserWhereInput\\";
import { User } from \\"../../user/base/User\\";
import { CustomerWhereInput } from \\"../../customer/base/CustomerWhereInput\\";
import { Customer } from \\"../../customer/base/Customer\\";

export class OrganizationControllerBase {
  constructor(
    protected readonly service: OrganizationService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: Organization })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Body() data: OrganizationCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Organization> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Organization\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    return await this.service.create({
      data: data,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [Organization] })
  @swagger.ApiForbiddenResponse()
  @swagger.ApiQuery({
    type: () => OrganizationFindManyArgs,
    style: \\"deepObject\\",
    explode: true,
  })
  async findMany(
    @common.Req() request: Request,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Organization[]> {
    const args = plainToClass(OrganizationFindManyArgs, request.query);

    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const results = await this.service.findMany({
      ...args,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: Organization })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Param() params: OrganizationWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Organization\\",
    });
    const result = await this.service.findOne({
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Organization })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body()
    data: OrganizationUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Organization\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      return await this.service.update({
        where: params,
        data: data,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          name: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Organization })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Param() params: OrganizationWhereUniqueInput
  ): Promise<Organization | null> {
    try {
      return await this.service.delete({
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          name: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/users\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiQuery({
    type: () => UserWhereInput,
    style: \\"deepObject\\",
    explode: true,
  })
  async findManyUsers(
    @common.Req() request: Request,
    @common.Param() params: OrganizationWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const query: UserWhereInput = request.query;
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service.findUsers(params.id, {
      where: query,
      select: {
        username: true,
        roles: true,
        id: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/users\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      users: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/users\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      users: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/users\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      users: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/customers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiQuery({
    type: () => CustomerWhereInput,
    style: \\"deepObject\\",
    explode: true,
  })
  async findManyCustomers(
    @common.Req() request: Request,
    @common.Param() params: OrganizationWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const query: CustomerWhereInput = request.query;
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findCustomers(params.id, {
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/customers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      customers: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/customers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      customers: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/customers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      customers: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/vipCustomers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiQuery({
    type: () => CustomerWhereInput,
    style: \\"deepObject\\",
    explode: true,
  })
  async findManyVipCustomers(
    @common.Req() request: Request,
    @common.Param() params: OrganizationWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const query: CustomerWhereInput = request.query;
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findVipCustomers(params.id, {
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/vipCustomers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      vipCustomers: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/vipCustomers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      vipCustomers: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/vipCustomers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      vipCustomers: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }
}
",
  "server/src/organization/base/organization.module.base.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { AuthModule } from \\"../../auth/auth.module\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],

  exports: [ACLModule, AuthModule, MorganModule, PrismaModule],
})
export class OrganizationModuleBase {}
",
  "server/src/organization/base/organization.resolver.base.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import { MetaQueryPayload } from \\"../../util/MetaQueryPayload\\";
import { CreateOrganizationArgs } from \\"./CreateOrganizationArgs\\";
import { UpdateOrganizationArgs } from \\"./UpdateOrganizationArgs\\";
import { DeleteOrganizationArgs } from \\"./DeleteOrganizationArgs\\";
import { OrganizationFindManyArgs } from \\"./OrganizationFindManyArgs\\";
import { OrganizationFindUniqueArgs } from \\"./OrganizationFindUniqueArgs\\";
import { Organization } from \\"./Organization\\";
import { UserFindManyArgs } from \\"../../user/base/UserFindManyArgs\\";
import { User } from \\"../../user/base/User\\";
import { CustomerFindManyArgs } from \\"../../customer/base/CustomerFindManyArgs\\";
import { Customer } from \\"../../customer/base/Customer\\";
import { OrganizationService } from \\"../organization.service\\";

@graphql.Resolver(() => Organization)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class OrganizationResolverBase {
  constructor(
    protected readonly service: OrganizationService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => MetaQueryPayload)
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async _organizationsMeta(
    @graphql.Args() args: OrganizationFindManyArgs
  ): Promise<MetaQueryPayload> {
    const results = await this.service.count({
      ...args,
      skip: undefined,
      take: undefined,
    });
    return {
      count: results,
    };
  }

  @graphql.Query(() => [Organization])
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async organizations(
    @graphql.Args() args: OrganizationFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => Organization, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async organization(
    @graphql.Args() args: OrganizationFindUniqueArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Organization\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => Organization)
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  async createOrganization(
    @graphql.Args() args: CreateOrganizationArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Organization\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...args,
      data: args.data,
    });
  }

  @graphql.Mutation(() => Organization)
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateOrganization(
    @graphql.Args() args: UpdateOrganizationArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Organization\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...args,
        data: args.data,
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => Organization)
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteOrganization(
    @graphql.Args() args: DeleteOrganizationArgs
  ): Promise<Organization | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => [User])
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async users(
    @graphql.Parent() parent: Organization,
    @graphql.Args() args: UserFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service.findUsers(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [Customer])
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async customers(
    @graphql.Parent() parent: Organization,
    @graphql.Args() args: CustomerFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findCustomers(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [Customer])
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async vipCustomers(
    @graphql.Parent() parent: Organization,
    @graphql.Args() args: CustomerFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findVipCustomers(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }
}
",
  "server/src/organization/base/organization.service.base.ts": "import { PrismaService } from \\"nestjs-prisma\\";
import { Prisma, Organization, User, Customer } from \\"@prisma/client\\";

export class OrganizationServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.OrganizationFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationFindManyArgs>
  ): Promise<number> {
    return this.prisma.organization.count(args);
  }

  async findMany<T extends Prisma.OrganizationFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationFindManyArgs>
  ): Promise<Organization[]> {
    return this.prisma.organization.findMany(args);
  }
  async findOne<T extends Prisma.OrganizationFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationFindUniqueArgs>
  ): Promise<Organization | null> {
    return this.prisma.organization.findUnique(args);
  }
  async create<T extends Prisma.OrganizationCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationCreateArgs>
  ): Promise<Organization> {
    return this.prisma.organization.create<T>(args);
  }
  async update<T extends Prisma.OrganizationUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationUpdateArgs>
  ): Promise<Organization> {
    return this.prisma.organization.update<T>(args);
  }
  async delete<T extends Prisma.OrganizationDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationDeleteArgs>
  ): Promise<Organization> {
    return this.prisma.organization.delete(args);
  }

  async findUsers(
    parentId: string,
    args: Prisma.UserFindManyArgs
  ): Promise<User[]> {
    return this.prisma.organization
      .findUnique({
        where: { id: parentId },
      })
      .users(args);
  }

  async findCustomers(
    parentId: string,
    args: Prisma.CustomerFindManyArgs
  ): Promise<Customer[]> {
    return this.prisma.organization
      .findUnique({
        where: { id: parentId },
      })
      .customers(args);
  }

  async findVipCustomers(
    parentId: string,
    args: Prisma.CustomerFindManyArgs
  ): Promise<Customer[]> {
    return this.prisma.organization
      .findUnique({
        where: { id: parentId },
      })
      .vipCustomers(args);
  }
}
",
  "server/src/organization/organization.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestAccessControl from \\"nest-access-control\\";
import { OrganizationService } from \\"./organization.service\\";
import { OrganizationControllerBase } from \\"./base/organization.controller.base\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"organizations\\")
@common.Controller(\\"organizations\\")
export class OrganizationController extends OrganizationControllerBase {
  constructor(
    protected readonly service: OrganizationService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/organization/organization.module.ts": "import { Module } from \\"@nestjs/common\\";
import { OrganizationModuleBase } from \\"./base/organization.module.base\\";
import { OrganizationService } from \\"./organization.service\\";
import { OrganizationController } from \\"./organization.controller\\";
import { OrganizationResolver } from \\"./organization.resolver\\";

@Module({
  imports: [OrganizationModuleBase],
  controllers: [OrganizationController],
  providers: [OrganizationService, OrganizationResolver],
  exports: [OrganizationService],
})
export class OrganizationModule {}
",
  "server/src/organization/organization.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import { OrganizationResolverBase } from \\"./base/organization.resolver.base\\";
import { Organization } from \\"./base/Organization\\";
import { OrganizationService } from \\"./organization.service\\";

@graphql.Resolver(() => Organization)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class OrganizationResolver extends OrganizationResolverBase {
  constructor(
    protected readonly service: OrganizationService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/organization/organization.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";
import { OrganizationServiceBase } from \\"./base/organization.service.base\\";

@Injectable()
export class OrganizationService extends OrganizationServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/prisma.util.spec.ts": "import {
  isRecordNotFoundError,
  PRISMA_QUERY_INTERPRETATION_ERROR,
} from \\"./prisma.util\\";

describe(\\"isRecordNotFoundError\\", () => {
  test(\\"returns true for record not found error\\", () => {
    expect(
      isRecordNotFoundError(
        Object.assign(
          new Error(\`Error occurred during query execution:
        InterpretationError(\\"Error for binding '0': RecordNotFound(\\"Record to update not found.\\")\\")\`),
          {
            code: PRISMA_QUERY_INTERPRETATION_ERROR,
          }
        )
      )
    ).toBe(true);
  });
  test(\\"returns false for any other error\\", () => {
    expect(isRecordNotFoundError(new Error())).toBe(false);
  });
});
",
  "server/src/prisma.util.ts": "export const PRISMA_QUERY_INTERPRETATION_ERROR = \\"P2016\\";
export const PRISMA_RECORD_NOT_FOUND = \\"RecordNotFound\\";

export function isRecordNotFoundError(
  error: Error & { code?: string }
): boolean {
  return (
    \\"code\\" in error &&
    error.code === PRISMA_QUERY_INTERPRETATION_ERROR &&
    error.message.includes(PRISMA_RECORD_NOT_FOUND)
  );
}

export async function transformStringFieldUpdateInput<
  T extends undefined | string | { set?: string }
>(input: T, transform: (input: string) => Promise<string>): Promise<T> {
  if (typeof input === \\"object\\" && typeof input?.set === \\"string\\") {
    return { set: await transform(input.set) } as T;
  }
  if (typeof input === \\"object\\") {
    if (typeof input.set === \\"string\\") {
      return { set: await transform(input.set) } as T;
    }
    return input;
  }
  if (typeof input === \\"string\\") {
    return (await transform(input)) as T;
  }
  return input;
}
",
  "server/src/serveStaticOptions.service.ts": "import * as path from \\"path\\";
import { Injectable, Logger } from \\"@nestjs/common\\";
import { ConfigService } from \\"@nestjs/config\\";
import {
  ServeStaticModuleOptions,
  ServeStaticModuleOptionsFactory,
} from \\"@nestjs/serve-static\\";

const SERVE_STATIC_ROOT_PATH_VAR = \\"SERVE_STATIC_ROOT_PATH\\";
const DEFAULT_STATIC_MODULE_OPTIONS_LIST: ServeStaticModuleOptions[] = [
  {
    serveRoot: \\"/swagger\\",
    rootPath: path.join(__dirname, \\"swagger\\"),
  },
];

@Injectable()
export class ServeStaticOptionsService
  implements ServeStaticModuleOptionsFactory {
  private readonly logger = new Logger(ServeStaticOptionsService.name);

  constructor(private readonly configService: ConfigService) {}

  createLoggerOptions(): ServeStaticModuleOptions[] {
    const serveStaticRootPath = this.configService.get(
      SERVE_STATIC_ROOT_PATH_VAR
    );
    if (serveStaticRootPath) {
      const resolvedPath = path.resolve(serveStaticRootPath);
      this.logger.log(\`Serving static files from \${resolvedPath}\`);
      return [
        ...DEFAULT_STATIC_MODULE_OPTIONS_LIST,
        { rootPath: resolvedPath, exclude: [\\"/api*\\", \\"/graphql\\"] },
      ];
    }
    return DEFAULT_STATIC_MODULE_OPTIONS_LIST;
  }
}
",
  "server/src/swagger.ts": "import { DocumentBuilder } from \\"@nestjs/swagger\\";

export const swaggerPath = \\"api\\";

export const swaggerDocumentOptions = new DocumentBuilder()
  .setTitle(\\"Sample Application\\")
  .setDescription(
    'Sample application for testing\\\\n\\\\n## Congratulations! Your application is ready.\\\\n\\\\nPlease note that all endpoints are secured with HTTP basic authentication.\\\\nBy default, your app comes with one user with the username \\"admin\\" and password \\"admin\\".\\\\nLearn more in [our docs](https://docs.amplication.com)'
  )
  .setVersion(\\"0.1.3\\")
  .addBasicAuth()
  .build();

export const swaggerSetupOptions = {
  swaggerOptions: {
    persistAuthorization: true,
  },
  customCssUrl: \\"../swagger/swagger.css\\",
  customfavIcon: \\"../swagger/favicon.png\\",
  customSiteTitle: \\"Sample Application\\",
};
",
  "server/src/user/base/CreateUserArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { UserCreateInput } from \\"./UserCreateInput\\";

@ArgsType()
class CreateUserArgs {
  @Field(() => UserCreateInput, { nullable: false })
  data!: UserCreateInput;
}

export { CreateUserArgs };
",
  "server/src/user/base/DeleteUserArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";

@ArgsType()
class DeleteUserArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
}

export { DeleteUserArgs };
",
  "server/src/user/base/EnumUserInterests.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumUserInterests {
  Programming = \\"programming\\",
  Design = \\"design\\",
}

registerEnumType(EnumUserInterests, {
  name: \\"EnumUserInterests\\",
});
",
  "server/src/user/base/EnumUserPriority.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumUserPriority {
  High = \\"high\\",
  Medium = \\"medium\\",
  Low = \\"low\\",
}

registerEnumType(EnumUserPriority, {
  name: \\"EnumUserPriority\\",
});
",
  "server/src/user/base/UpdateUserArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { UserUpdateInput } from \\"./UserUpdateInput\\";

@ArgsType()
class UpdateUserArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
  @Field(() => UserUpdateInput, { nullable: false })
  data!: UserUpdateInput;
}

export { UpdateUserArgs };
",
  "server/src/user/base/User.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsOptional,
  IsEnum,
  IsBoolean,
  IsJSON,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { Organization } from \\"../../organization/base/Organization\\";
import { EnumUserInterests } from \\"./EnumUserInterests\\";
import { EnumUserPriority } from \\"./EnumUserPriority\\";
import { GraphQLJSONObject } from \\"graphql-type-json\\";
import { JsonValue } from \\"type-fest\\";
@ObjectType()
class User {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  username!: string;

  @ApiProperty({
    required: true,
    type: [String],
  })
  @IsString({
    each: true,
  })
  @Field(() => [String])
  roles!: Array<string>;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  bio!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Field(() => Number)
  age!: number;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  birthDate!: Date;

  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsNumber()
  @Field(() => Number)
  score!: number;

  @ApiProperty({
    required: false,
    type: () => User,
  })
  @ValidateNested()
  @Type(() => User)
  @IsOptional()
  manager?: User | null;

  @ApiProperty({
    required: false,
    type: () => [User],
  })
  @ValidateNested()
  @Type(() => User)
  @IsOptional()
  employees?: Array<User>;

  @ApiProperty({
    required: false,
    type: () => [Organization],
  })
  @ValidateNested()
  @Type(() => Organization)
  @IsOptional()
  organizations?: Array<Organization>;

  @ApiProperty({
    required: true,
    enum: EnumUserInterests,
    isArray: true,
  })
  @IsEnum(EnumUserInterests, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumUserInterests], {
    nullable: true,
  })
  interests?: Array<\\"programming\\" | \\"design\\">;

  @ApiProperty({
    required: true,
    enum: EnumUserPriority,
  })
  @IsEnum(EnumUserPriority)
  @Field(() => EnumUserPriority, {
    nullable: true,
  })
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";

  @ApiProperty({
    required: true,
    type: Boolean,
  })
  @IsBoolean()
  @Field(() => Boolean)
  isCurious!: boolean;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  location!: string;

  @ApiProperty({
    required: true,
  })
  @IsJSON()
  @Field(() => GraphQLJSONObject)
  extendedProperties!: JsonValue;
}
export { User };
",
  "server/src/user/base/UserCreateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsOptional,
  IsEnum,
  IsBoolean,
  IsJSON,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { EnumUserInterests } from \\"./EnumUserInterests\\";
import { EnumUserPriority } from \\"./EnumUserPriority\\";
import { GraphQLJSONObject } from \\"graphql-type-json\\";
import { JsonValue } from \\"type-fest\\";
@InputType()
class UserCreateInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  username!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  password!: string;

  @ApiProperty({
    required: true,
    type: [String],
  })
  @IsString({
    each: true,
  })
  @Field(() => [String])
  roles!: Array<string>;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  bio!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Field(() => Number)
  age!: number;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  birthDate!: Date;

  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsNumber()
  @Field(() => Number)
  score!: number;

  @ApiProperty({
    required: false,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @IsOptional()
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
  })
  manager?: UserWhereUniqueInput | null;

  @ApiProperty({
    required: true,
    enum: EnumUserInterests,
    isArray: true,
  })
  @IsEnum(EnumUserInterests, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumUserInterests], {
    nullable: true,
  })
  interests?: Array<\\"programming\\" | \\"design\\">;

  @ApiProperty({
    required: true,
    enum: EnumUserPriority,
  })
  @IsEnum(EnumUserPriority)
  @Field(() => EnumUserPriority)
  priority!: \\"high\\" | \\"medium\\" | \\"low\\";

  @ApiProperty({
    required: true,
    type: Boolean,
  })
  @IsBoolean()
  @Field(() => Boolean)
  isCurious!: boolean;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  location!: string;

  @ApiProperty({
    required: true,
  })
  @IsJSON()
  @Field(() => GraphQLJSONObject)
  extendedProperties!: JsonValue;
}
export { UserCreateInput };
",
  "server/src/user/base/UserFindManyArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { UserWhereInput } from \\"./UserWhereInput\\";
import { Type } from \\"class-transformer\\";
import { UserOrderByInput } from \\"./UserOrderByInput\\";

@ArgsType()
class UserFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => UserWhereInput,
  })
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: UserWhereInput;

  @ApiProperty({
    required: false,
    type: UserOrderByInput,
  })
  @Field(() => UserOrderByInput, { nullable: true })
  @Type(() => UserOrderByInput)
  orderBy?: UserOrderByInput;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { UserFindManyArgs };
",
  "server/src/user/base/UserFindUniqueArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";

@ArgsType()
class UserFindUniqueArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
}

export { UserFindUniqueArgs };
",
  "server/src/user/base/UserOrderByInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { SortOrder } from \\"../../util/SortOrder\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
class UserOrderByInput {
  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  username?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  password?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  roles?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  name?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  bio?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  email?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  age?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  birthDate?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  score?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  managerId?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  interests?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  priority?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  isCurious?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  location?: SortOrder;

  @ApiProperty({
    required: false,
    enum: [\\"Asc\\", \\"Desc\\"],
  })
  @Field(() => SortOrder, {
    nullable: true,
  })
  extendedProperties?: SortOrder;
}

export { UserOrderByInput };
",
  "server/src/user/base/UserUpdateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsOptional,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsEnum,
  IsBoolean,
  IsJSON,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { EnumUserInterests } from \\"./EnumUserInterests\\";
import { EnumUserPriority } from \\"./EnumUserPriority\\";
import { GraphQLJSONObject } from \\"graphql-type-json\\";
import { JsonValue } from \\"type-fest\\";
@InputType()
class UserUpdateInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  username?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  password?: string;

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsString({
    each: true,
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  roles?: Array<string>;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  name?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  bio?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  email?: string;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  age?: number;

  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthDate?: Date;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  score?: number;

  @ApiProperty({
    required: false,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @IsOptional()
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
  })
  manager?: UserWhereUniqueInput | null;

  @ApiProperty({
    required: false,
    enum: EnumUserInterests,
    isArray: true,
  })
  @IsEnum(EnumUserInterests, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumUserInterests], {
    nullable: true,
  })
  interests?: Array<\\"programming\\" | \\"design\\">;

  @ApiProperty({
    required: false,
    enum: EnumUserPriority,
  })
  @IsEnum(EnumUserPriority)
  @IsOptional()
  @Field(() => EnumUserPriority, {
    nullable: true,
  })
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isCurious?: boolean;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  location?: string;

  @ApiProperty({
    required: false,
  })
  @IsJSON()
  @IsOptional()
  @Field(() => GraphQLJSONObject, {
    nullable: true,
  })
  extendedProperties?: JsonValue;
}
export { UserUpdateInput };
",
  "server/src/user/base/UserWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { StringFilter } from \\"../../util/StringFilter\\";
import { Type } from \\"class-transformer\\";
import { IsOptional, ValidateNested, IsEnum } from \\"class-validator\\";
import { IntFilter } from \\"../../util/IntFilter\\";
import { DateTimeFilter } from \\"../../util/DateTimeFilter\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { EnumUserPriority } from \\"./EnumUserPriority\\";
import { BooleanFilter } from \\"../../util/BooleanFilter\\";
import { JsonNullableFilter } from \\"../../util/JsonNullableFilter\\";
@InputType()
class UserWhereInput {
  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  id?: StringFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  name?: StringFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  bio?: StringFilter;

  @ApiProperty({
    required: false,
    type: IntFilter,
  })
  @Type(() => IntFilter)
  @IsOptional()
  @Field(() => IntFilter, {
    nullable: true,
  })
  age?: IntFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  birthDate?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @IsOptional()
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
  })
  manager?: UserWhereUniqueInput;

  @ApiProperty({
    required: false,
    enum: EnumUserPriority,
  })
  @IsEnum(EnumUserPriority)
  @IsOptional()
  @Field(() => EnumUserPriority, {
    nullable: true,
  })
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";

  @ApiProperty({
    required: false,
    type: BooleanFilter,
  })
  @Type(() => BooleanFilter)
  @IsOptional()
  @Field(() => BooleanFilter, {
    nullable: true,
  })
  isCurious?: BooleanFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  location?: StringFilter;

  @ApiProperty({
    required: false,
    type: JsonNullableFilter,
  })
  @Type(() => JsonNullableFilter)
  @IsOptional()
  @Field(() => JsonNullableFilter, {
    nullable: true,
  })
  extendedProperties?: JsonNullableFilter;
}
export { UserWhereInput };
",
  "server/src/user/base/UserWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class UserWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { UserWhereUniqueInput };
",
  "server/src/user/base/user.controller.base.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../../auth/basicAuth.guard\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { UserController } from \\"../user.controller\\";
import { UserService } from \\"../user.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  username: \\"exampleUsername\\",
  password: \\"examplePassword\\",
  roles: [\\"exampleRoles\\"],
  id: \\"exampleId\\",
  name: \\"exampleName\\",
  bio: \\"exampleBio\\",
  email: \\"exampleEmail\\",
  age: 42,
  birthDate: new Date(),
  score: 42.42,
  isCurious: \\"true\\",
  location: \\"exampleLocation\\",
};
const CREATE_RESULT = {
  username: \\"exampleUsername\\",
  password: \\"examplePassword\\",
  roles: [\\"exampleRoles\\"],
  id: \\"exampleId\\",
  name: \\"exampleName\\",
  bio: \\"exampleBio\\",
  email: \\"exampleEmail\\",
  age: 42,
  birthDate: new Date(),
  score: 42.42,
  isCurious: \\"true\\",
  location: \\"exampleLocation\\",
};
const FIND_MANY_RESULT = [
  {
    username: \\"exampleUsername\\",
    password: \\"examplePassword\\",
    roles: [\\"exampleRoles\\"],
    id: \\"exampleId\\",
    name: \\"exampleName\\",
    bio: \\"exampleBio\\",
    email: \\"exampleEmail\\",
    age: 42,
    birthDate: new Date(),
    score: 42.42,
    isCurious: \\"true\\",
    location: \\"exampleLocation\\",
  },
];
const FIND_ONE_RESULT = {
  username: \\"exampleUsername\\",
  password: \\"examplePassword\\",
  roles: [\\"exampleRoles\\"],
  id: \\"exampleId\\",
  name: \\"exampleName\\",
  bio: \\"exampleBio\\",
  email: \\"exampleEmail\\",
  age: 42,
  birthDate: new Date(),
  score: 42.42,
  isCurious: \\"true\\",
  location: \\"exampleLocation\\",
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"User\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: UserService,
          useValue: service,
        },
      ],
      controllers: [UserController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /users\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/users\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        birthDate: CREATE_RESULT.birthDate.toISOString(),
      });
  });

  test(\\"GET /users\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/users\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          birthDate: FIND_MANY_RESULT[0].birthDate.toISOString(),
        },
      ]);
  });

  test(\\"GET /users/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/users\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /users/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/users\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        birthDate: FIND_ONE_RESULT.birthDate.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/user/base/user.controller.base.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../../auth/basicAuth.guard\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import * as errors from \\"../../errors\\";
import { Request } from \\"express\\";
import { plainToClass } from \\"class-transformer\\";
import { UserService } from \\"../user.service\\";
import { UserCreateInput } from \\"./UserCreateInput\\";
import { UserWhereInput } from \\"./UserWhereInput\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { UserFindManyArgs } from \\"./UserFindManyArgs\\";
import { UserUpdateInput } from \\"./UserUpdateInput\\";
import { User } from \\"./User\\";
import { OrganizationWhereInput } from \\"../../organization/base/OrganizationWhereInput\\";
import { Organization } from \\"../../organization/base/Organization\\";

export class UserControllerBase {
  constructor(
    protected readonly service: UserService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: User })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Body() data: UserCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"User\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    return await this.service.create({
      data: {
        ...data,

        manager: data.manager
          ? {
              connect: data.manager,
            }
          : undefined,
      },
      select: {
        username: true,
        roles: true,
        id: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [User] })
  @swagger.ApiForbiddenResponse()
  @swagger.ApiQuery({
    type: () => UserFindManyArgs,
    style: \\"deepObject\\",
    explode: true,
  })
  async findMany(
    @common.Req() request: Request,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const args = plainToClass(UserFindManyArgs, request.query);

    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service.findMany({
      ...args,
      select: {
        username: true,
        roles: true,
        id: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Param() params: UserWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"User\\",
    });
    const result = await this.service.findOne({
      where: params,
      select: {
        username: true,
        roles: true,
        id: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body()
    data: UserUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"User\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      return await this.service.update({
        where: params,
        data: {
          ...data,

          manager: data.manager
            ? {
                connect: data.manager,
              }
            : undefined,
        },
        select: {
          username: true,
          roles: true,
          id: true,
          name: true,
          bio: true,
          email: true,
          age: true,
          birthDate: true,
          score: true,

          manager: {
            select: {
              id: true,
            },
          },

          interests: true,
          priority: true,
          isCurious: true,
          location: true,
          extendedProperties: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Param() params: UserWhereUniqueInput
  ): Promise<User | null> {
    try {
      return await this.service.delete({
        where: params,
        select: {
          username: true,
          roles: true,
          id: true,
          name: true,
          bio: true,
          email: true,
          age: true,
          birthDate: true,
          score: true,

          manager: {
            select: {
              id: true,
            },
          },

          interests: true,
          priority: true,
          isCurious: true,
          location: true,
          extendedProperties: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/employees\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiQuery({
    type: () => UserWhereInput,
    style: \\"deepObject\\",
    explode: true,
  })
  async findManyEmployees(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const query: UserWhereInput = request.query;
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service.findEmployees(params.id, {
      where: query,
      select: {
        username: true,
        roles: true,
        id: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/employees\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createEmployees(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      employees: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"User\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/employees\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateEmployees(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      employees: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"User\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/employees\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteEmployees(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      employees: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"User\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/organizations\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiQuery({
    type: () => OrganizationWhereInput,
    style: \\"deepObject\\",
    explode: true,
  })
  async findManyOrganizations(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Organization[]> {
    const query: OrganizationWhereInput = request.query;
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const results = await this.service.findOrganizations(params.id, {
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/organizations\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createOrganizations(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      organizations: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"User\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/organizations\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateOrganizations(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      organizations: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"User\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/organizations\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteOrganizations(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      organizations: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"User\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }
}
",
  "server/src/user/base/user.module.base.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../../auth/acl.module\\";
import { AuthModule } from \\"../../auth/auth.module\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],

  exports: [ACLModule, AuthModule, MorganModule, PrismaModule],
})
export class UserModuleBase {}
",
  "server/src/user/base/user.resolver.base.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../../prisma.util\\";
import { MetaQueryPayload } from \\"../../util/MetaQueryPayload\\";
import { CreateUserArgs } from \\"./CreateUserArgs\\";
import { UpdateUserArgs } from \\"./UpdateUserArgs\\";
import { DeleteUserArgs } from \\"./DeleteUserArgs\\";
import { UserFindManyArgs } from \\"./UserFindManyArgs\\";
import { UserFindUniqueArgs } from \\"./UserFindUniqueArgs\\";
import { User } from \\"./User\\";
import { OrganizationFindManyArgs } from \\"../../organization/base/OrganizationFindManyArgs\\";
import { Organization } from \\"../../organization/base/Organization\\";
import { UserService } from \\"../user.service\\";

@graphql.Resolver(() => User)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class UserResolverBase {
  constructor(
    protected readonly service: UserService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => MetaQueryPayload)
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async _usersMeta(
    @graphql.Args() args: UserFindManyArgs
  ): Promise<MetaQueryPayload> {
    const results = await this.service.count({
      ...args,
      skip: undefined,
      take: undefined,
    });
    return {
      count: results,
    };
  }

  @graphql.Query(() => [User])
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async users(
    @graphql.Args() args: UserFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => User, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async user(
    @graphql.Args() args: UserFindUniqueArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"User\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => User)
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  async createUser(
    @graphql.Args() args: CreateUserArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"User\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...args,
      data: {
        ...args.data,

        manager: args.data.manager
          ? {
              connect: args.data.manager,
            }
          : undefined,
      },
    });
  }

  @graphql.Mutation(() => User)
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateUser(
    @graphql.Args() args: UpdateUserArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"User\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...args,
        data: {
          ...args.data,

          manager: args.data.manager
            ? {
                connect: args.data.manager,
              }
            : undefined,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => User)
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteUser(@graphql.Args() args: DeleteUserArgs): Promise<User | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => [User])
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async employees(
    @graphql.Parent() parent: User,
    @graphql.Args() args: UserFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service.findEmployees(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [Organization])
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async organizations(
    @graphql.Parent() parent: User,
    @graphql.Args() args: OrganizationFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const results = await this.service.findOrganizations(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => User, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async manager(
    @graphql.Parent() parent: User,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const result = await this.service.getManager(parent.id);

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }
}
",
  "server/src/user/base/user.service.base.ts": "import { PrismaService } from \\"nestjs-prisma\\";
import { Prisma, User, Organization } from \\"@prisma/client\\";
import { PasswordService } from \\"../../auth/password.service\\";
import { transformStringFieldUpdateInput } from \\"../../prisma.util\\";

export class UserServiceBase {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly passwordService: PasswordService
  ) {}

  async count<T extends Prisma.UserFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
  ): Promise<number> {
    return this.prisma.user.count(args);
  }

  async findMany<T extends Prisma.UserFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
  ): Promise<User[]> {
    return this.prisma.user.findMany(args);
  }
  async findOne<T extends Prisma.UserFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>
  ): Promise<User | null> {
    return this.prisma.user.findUnique(args);
  }
  async create<T extends Prisma.UserCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserCreateArgs>
  ): Promise<User> {
    return this.prisma.user.create<T>({
      ...args,

      data: {
        ...args.data,
        password: await this.passwordService.hash(args.data.password),
      },
    });
  }
  async update<T extends Prisma.UserUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserUpdateArgs>
  ): Promise<User> {
    return this.prisma.user.update<T>({
      ...args,

      data: {
        ...args.data,

        password:
          args.data.password &&
          (await transformStringFieldUpdateInput(
            args.data.password,
            (password) => this.passwordService.hash(password)
          )),
      },
    });
  }
  async delete<T extends Prisma.UserDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserDeleteArgs>
  ): Promise<User> {
    return this.prisma.user.delete(args);
  }

  async findEmployees(
    parentId: string,
    args: Prisma.UserFindManyArgs
  ): Promise<User[]> {
    return this.prisma.user
      .findUnique({
        where: { id: parentId },
      })
      .employees(args);
  }

  async findOrganizations(
    parentId: string,
    args: Prisma.OrganizationFindManyArgs
  ): Promise<Organization[]> {
    return this.prisma.user
      .findUnique({
        where: { id: parentId },
      })
      .organizations(args);
  }

  async getManager(parentId: string): Promise<User | null> {
    return this.prisma.user
      .findUnique({
        where: { id: parentId },
      })
      .manager();
  }
}
",
  "server/src/user/user.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestAccessControl from \\"nest-access-control\\";
import { UserService } from \\"./user.service\\";
import { UserControllerBase } from \\"./base/user.controller.base\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"users\\")
@common.Controller(\\"users\\")
export class UserController extends UserControllerBase {
  constructor(
    protected readonly service: UserService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/user/user.module.ts": "import { Module } from \\"@nestjs/common\\";
import { UserModuleBase } from \\"./base/user.module.base\\";
import { UserService } from \\"./user.service\\";
import { UserController } from \\"./user.controller\\";
import { UserResolver } from \\"./user.resolver\\";

@Module({
  imports: [UserModuleBase],
  controllers: [UserController],
  providers: [UserService, UserResolver],
  exports: [UserService],
})
export class UserModule {}
",
  "server/src/user/user.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import { UserResolverBase } from \\"./base/user.resolver.base\\";
import { User } from \\"./base/User\\";
import { UserService } from \\"./user.service\\";

@graphql.Resolver(() => User)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class UserResolver extends UserResolverBase {
  constructor(
    protected readonly service: UserService,
    @nestAccessControl.InjectRolesBuilder()
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {
    super(service, rolesBuilder);
  }
}
",
  "server/src/user/user.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";
import { UserServiceBase } from \\"./base/user.service.base\\";
import { PasswordService } from \\"../auth/password.service\\";

@Injectable()
export class UserService extends UserServiceBase {
  constructor(
    protected readonly prisma: PrismaService,
    protected readonly passwordService: PasswordService
  ) {
    super(prisma, passwordService);
  }
}
",
  "server/src/util/BooleanFilter.ts": "import { Field, InputType } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class BooleanFilter {
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  @Type(() => Boolean)
  equals?: boolean;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  @Type(() => Boolean)
  not?: boolean;
}
",
  "server/src/util/BooleanNullableFilter.ts": "import { Field, InputType } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
@InputType({
  isAbstract: true,
  description: undefined,
})
export class BooleanNullableFilter {
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  @Type(() => Boolean)
  equals?: boolean | null;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  @Type(() => Boolean)
  not?: boolean | null;
}
",
  "server/src/util/DateTimeFilter.ts": "import { Field, InputType } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
@InputType({
  isAbstract: true,
  description: undefined,
})
export class DateTimeFilter {
  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  equals?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  not?: Date;

  @ApiProperty({
    required: false,
    type: [Date],
  })
  @IsOptional()
  @Field(() => [Date], {
    nullable: true,
  })
  @Type(() => Date)
  in?: Date[];

  @ApiProperty({
    required: false,
    type: [Date],
  })
  @IsOptional()
  @Field(() => [Date], {
    nullable: true,
  })
  @Type(() => Date)
  notIn?: Date[];

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  lt?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  lte?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  gt?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  gte?: Date;
}
",
  "server/src/util/DateTimeNullableFilter.ts": "import { Field, InputType } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
@InputType({
  isAbstract: true,
  description: undefined,
})
export class DateTimeNullableFilter {
  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  equals?: Date | null;

  @ApiProperty({
    required: false,
    type: [Date],
  })
  @IsOptional()
  @Field(() => [Date], {
    nullable: true,
  })
  @Type(() => Date)
  in?: Date[] | null;

  @ApiProperty({
    required: false,
    type: [Date],
  })
  @IsOptional()
  @Field(() => [Date], {
    nullable: true,
  })
  @Type(() => Date)
  notIn?: Date[] | null;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  lt?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  lte?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  gt?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  gte?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  not?: Date;
}
",
  "server/src/util/FloatFilter.ts": "import { Field, InputType, Float } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FloatFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  in?: number[];

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: number[];

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  not?: number;
}
",
  "server/src/util/FloatNullableFilter.ts": "import { Field, InputType, Float } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FloatNullableFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: number | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  in?: number[] | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: number[] | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  not?: number;
}
",
  "server/src/util/IntFilter.ts": "import { Field, InputType, Int } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class IntFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: number;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Int], {
    nullable: true,
  })
  @Type(() => Number)
  in?: number[];

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Int], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: number[];

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  not?: number;
}
",
  "server/src/util/IntNullableFilter.ts": "import { Field, InputType, Int } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class IntNullableFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: number | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Int], {
    nullable: true,
  })
  @Type(() => Number)
  in?: number[] | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Int], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: number[] | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  not?: number;
}
",
  "server/src/util/JsonNullableFilter.ts": "// @ts-ignore
// eslint-disable-next-line
import { JsonValue } from \\"type-fest\\";
import { Field, InputType } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { GraphQLJSONObject } from \\"graphql-type-json\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class JsonNullableFilter {
  @ApiProperty({
    required: false,
    type: GraphQLJSONObject,
  })
  @IsOptional()
  @Field(() => GraphQLJSONObject, {
    nullable: true,
  })
  equals?: JsonValue | null;

  @ApiProperty({
    required: false,
    type: GraphQLJSONObject,
  })
  @IsOptional()
  @Field(() => GraphQLJSONObject, {
    nullable: true,
  })
  not?: JsonValue | null;
}
",
  "server/src/util/MetaQueryPayload.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

@ObjectType()
class MetaQueryPayload {
  @ApiProperty({
    required: true,
  })
  @Field(() => String)
  count!: number;
}
export { MetaQueryPayload };
",
  "server/src/util/QueryMode.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum QueryMode {
  Default = \\"default\\",
  Insensitive = \\"insensitive\\",
}
registerEnumType(QueryMode, {
  name: \\"QueryMode\\",
  description: undefined,
});
",
  "server/src/util/SortOrder.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum SortOrder {
  Asc = \\"asc\\",
  Desc = \\"desc\\",
}
registerEnumType(SortOrder, {
  name: \\"SortOrder\\",
  description: undefined,
});
",
  "server/src/util/StringFilter.ts": "import { Field, InputType } from \\"@nestjs/graphql\\";
import { QueryMode } from \\"./QueryMode\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";

@InputType({
  isAbstract: true,
})
export class StringFilter {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  equals?: string;

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  @Type(() => String)
  in?: string[];

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  @Type(() => String)
  notIn?: string[];

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  lt?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  lte?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  gt?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  gte?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  contains?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  startsWith?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  endsWith?: string;

  @ApiProperty({
    required: false,
    enum: [\\"Default\\", \\"Insensitive\\"],
  })
  @IsOptional()
  @Field(() => QueryMode, {
    nullable: true,
  })
  mode?: QueryMode;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  not?: string;
}
",
  "server/src/util/StringNullableFilter.ts": "import { Field, InputType } from \\"@nestjs/graphql\\";
import { QueryMode } from \\"./QueryMode\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";

@InputType({
  isAbstract: true,
})
export class StringNullableFilter {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  equals?: string | null;

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  @Type(() => String)
  in?: string[] | null;

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  @Type(() => String)
  notIn?: string[] | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  lt?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  lte?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  gt?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  gte?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  contains?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  startsWith?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  endsWith?: string;

  @ApiProperty({
    required: false,
    enum: [\\"Default\\", \\"Insensitive\\"],
  })
  @IsOptional()
  @Field(() => QueryMode, {
    nullable: true,
  })
  mode?: QueryMode;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  not?: string;
}
",
}
`;
