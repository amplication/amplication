// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`createDataService creates app as expected 1`] = `
Object {
  "admin/src/App.tsx": "import React, { useCallback, useContext } from \\"react\\";
import { Route, Switch, useHistory, Link, NavLink } from \\"react-router-dom\\";
import Navigation from \\"./Navigation\\";
import Login from \\"./Login\\";
import { Credentials, setCredentials, removeCredentials } from \\"./auth\\";
import {
  Menu,
  MainLayout,
  Page,
  CircleBadge,
  Breadcrumbs,
} from \\"@amplication/design-system\\";
import BreadcrumbsContext from \\"./components/breadcrumbs/BreadcrumbsContext\\";
import BreadcrumbsProvider from \\"./components/breadcrumbs/BreadcrumbsProvider\\";
import useBreadcrumbs from \\"./components/breadcrumbs/use-breadcrumbs\\";
import PrivateRoute from \\"./components/PrivateRoute\\";
import { UserIndex } from \\"./user/UserIndex\\";
import { OrderIndex } from \\"./order/OrderIndex\\";
import { OrganizationIndex } from \\"./organization/OrganizationIndex\\";
import { CustomerIndex } from \\"./customer/CustomerIndex\\";
import { EmptyIndex } from \\"./empty/EmptyIndex\\";

const App = (): React.ReactElement => {
  const history = useHistory();
  const handleLogin = useCallback(
    (credentials: Credentials) => {
      setCredentials(credentials);
      history.push(\\"/\\");
    },
    [history]
  );

  return (
    <BreadcrumbsProvider>
      <MainLayout>
        <Switch>
          <Route path=\\"/login\\" render={() => <Login onLogin={handleLogin} />} />
          <PrivateRoute path=\\"/\\" component={AppLayout} />
        </Switch>
      </MainLayout>
    </BreadcrumbsProvider>
  );
};

export default App;

/**@todo: move to a separate template file */
const AppLayout = (): React.ReactElement => {
  const history = useHistory();
  useBreadcrumbs(\\"/\\", \\"Sample Application\\");
  const breadcrumbsContext = useContext(BreadcrumbsContext);

  const signOut = useCallback(() => {
    removeCredentials();
    history.push(\\"/login\\");
  }, [history]);

  // Use navLink for breadcrumbs to prevent page reload
  const ItemLink = ({ href, ...rest }: { href: string }) => (
    <NavLink {...rest} to={href} />
  );

  return (
    <>
      <Menu
        onSignOutClick={signOut}
        logoContent={
          <Link to=\\"/\\">
            <CircleBadge name={\\"Sample Application\\"} />
          </Link>
        }
      ></Menu>
      <MainLayout.Content>
        <Breadcrumbs>
          {}
          {breadcrumbsContext.breadcrumbsItems.map((item, index, items) => (
            <Breadcrumbs.Item
              as={ItemLink}
              key={index}
              selected={index + 1 === items.length}
              href={item.url}
            >
              {item.name}
            </Breadcrumbs.Item>
          ))}
        </Breadcrumbs>
        <Page>
          <Switch>
            <PrivateRoute exact path=\\"/\\" component={Navigation} />
            <PrivateRoute path=\\"/users\\" component={UserIndex} />
            <PrivateRoute path=\\"/orders\\" component={OrderIndex} />
            <PrivateRoute path=\\"/organizations\\" component={OrganizationIndex} />
            <PrivateRoute path=\\"/customers\\" component={CustomerIndex} />
            <PrivateRoute path=\\"/empties\\" component={EmptyIndex} />
          </Switch>
        </Page>
      </MainLayout.Content>
    </>
  );
};
",
  "admin/src/Login.tsx": "import React, { useCallback } from \\"react\\";
import { AxiosError } from \\"axios\\";
import { useMutation } from \\"react-query\\";
import { Formik, Form } from \\"formik\\";
import {
  Panel,
  PanelHeader,
  TextField,
  Button,
  EnumPanelStyle,
  EnumButtonStyle,
} from \\"@amplication/design-system\\";
import { Credentials } from \\"./auth\\";
import { api } from \\"./api\\";
import \\"./login.scss\\";

export type Props = {
  onLogin: (credentials: Credentials) => void;
};

const INITIAL_VALUES = {
  username: \\"\\",
  password: \\"\\",
};

const Login = ({ onLogin }: Props) => {
  const [login, { error }] = useMutation<unknown, AxiosError, Credentials>(
    async (data) => api.post(\\"/api/login\\", data),
    {
      onSuccess: (data, variables) => {
        onLogin(variables);
      },
    }
  );
  const handleSubmit = useCallback(
    (values) => {
      login(values);
    },
    [login]
  );
  return (
    <div className=\\"login-page\\">
      <div className=\\"options-container\\">
        <Panel panelStyle={EnumPanelStyle.Bordered}>
          <PanelHeader>Sign In to Admin UI</PanelHeader>
          <div className=\\"message\\">
            By default, your app comes with one user with the username \\"admin\\"
            and password \\"admin\\".
          </div>
          <Formik initialValues={INITIAL_VALUES} onSubmit={handleSubmit}>
            <Form>
              <TextField label=\\"Username\\" name=\\"username\\" type=\\"text\\" />
              <TextField label=\\"Password\\" name=\\"password\\" type=\\"password\\" />
              <Button type=\\"submit\\">Continue</Button>
            </Form>
          </Formik>
          {error && error.response?.data?.message}
        </Panel>
        <div className=\\"divider\\">Or</div>
        <Panel panelStyle={EnumPanelStyle.Bordered}>
          <PanelHeader>Connect via API</PanelHeader>
          <div className=\\"message\\">
            Choose the type of API for connecting to your app.
          </div>
          <a href=\\"/graphql\\" target=\\"graphql\\">
            <Button type=\\"button\\" buttonStyle={EnumButtonStyle.Secondary}>
              GraphQL API
            </Button>
          </a>
          <a href=\\"/api\\" target=\\"api\\">
            <Button type=\\"button\\" buttonStyle={EnumButtonStyle.Secondary}>
              REST API
            </Button>
          </a>
          <hr />
          <div className=\\"message\\">
            <span>Read </span>
            <a href=\\"https://docs.amplication.com/docs/api\\" target=\\"docs\\">
              Amplication docs
            </a>
            <span> to learn more</span>
          </div>
        </Panel>
      </div>
    </div>
  );
};

export default Login;
",
  "admin/src/Navigation.tsx": "import React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { Panel, PanelHeader, EnumPanelStyle } from \\"@amplication/design-system\\";

const Navigation = (): React.ReactElement => {
  return (
    <>
      <NavigationItem name=\\"Users\\" to=\\"/users\\" />
      <NavigationItem name=\\"Orders\\" to=\\"/orders\\" />
      <NavigationItem name=\\"Organizations\\" to=\\"/organizations\\" />
      <NavigationItem name=\\"Customers\\" to=\\"/customers\\" />
      <NavigationItem name=\\"Empties\\" to=\\"/empties\\" />
    </>
  );
};

export default Navigation;

const NavigationItem = ({
  to,
  name,
}: {
  to: string;
  name: string;
}): React.ReactElement => (
  <Link to={to}>
    <Panel panelStyle={EnumPanelStyle.Bordered}>
      <PanelHeader>{name}</PanelHeader>
      Create, update, search and delete {name}
    </Panel>
  </Link>
);
",
  "admin/src/api/api.ts": "import axios from \\"axios\\";
import { getCredentials } from \\"../auth\\";
import { createBasicAuthorizationHeader } from \\"./http.util\\";

export const api = axios.create({
  headers: {
    \\"Content-Type\\": \\"application/json\\",
  },
});

api.interceptors.request.use((config) => {
  const credentials = getCredentials();
  if (credentials) {
    config.headers[\\"Authorization\\"] = createBasicAuthorizationHeader(
      credentials.username,
      credentials.password
    );
  }
  return config;
});
",
  "admin/src/api/api.util.ts": "import { getCredentials } from \\"../auth\\";
import { createBasicAuthorizationHeader } from \\"./http.util\\";

export function getHeaders(
  init?: Headers | string[][] | Record<string, string> | undefined
) {
  const headers = new Headers(init);
  const credentials = getCredentials();
  if (credentials) {
    headers.append(
      \\"Authorization\\",
      createBasicAuthorizationHeader(credentials.username, credentials.password)
    );
  }
  return headers;
}
",
  "admin/src/api/customer/CreateCustomerArgs.ts": "import { CustomerCreateInput } from \\"./CustomerCreateInput\\";

export type CreateCustomerArgs = {
  data: CustomerCreateInput;
};
",
  "admin/src/api/customer/Customer.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type Customer = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  email: string;
  firstName: string | null;
  lastName: string | null;
  isVip: boolean | null;
  birthData: Date | null;
  averageSale: number | null;
  favoriteNumber: number | null;
  geoLocation: string | null;
  comments: string | null;
  favoriteColors: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;
  customerType: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  organization: OrganizationWhereUniqueInput | null;
  vipOrganization: OrganizationWhereUniqueInput | null;
};
",
  "admin/src/api/customer/CustomerCreateInput.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type CustomerCreateInput = {
  email: string;
  firstName?: string | null;
  lastName?: string | null;
  isVip?: boolean | null;
  birthData?: Date | null;
  averageSale?: number | null;
  favoriteNumber?: number | null;
  geoLocation?: string | null;
  comments?: string | null;
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  organization?: OrganizationWhereUniqueInput | null;
  vipOrganization?: OrganizationWhereUniqueInput | null;
};
",
  "admin/src/api/customer/CustomerUpdateInput.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type CustomerUpdateInput = {
  email?: string;
  firstName?: string | null;
  lastName?: string | null;
  isVip?: boolean | null;
  birthData?: Date | null;
  averageSale?: number | null;
  favoriteNumber?: number | null;
  geoLocation?: string | null;
  comments?: string | null;
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  organization?: OrganizationWhereUniqueInput | null;
  vipOrganization?: OrganizationWhereUniqueInput | null;
};
",
  "admin/src/api/customer/CustomerWhereInput.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type CustomerWhereInput = {
  id?: string;
  createdAt?: Date;
  updatedAt?: Date;
  email?: string;
  firstName?: string | null;
  lastName?: string | null;
  isVip?: boolean | null;
  birthData?: Date | null;
  averageSale?: number | null;
  favoriteNumber?: number | null;
  geoLocation?: string | null;
  comments?: string | null;
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  organization?: OrganizationWhereUniqueInput | null;
  vipOrganization?: OrganizationWhereUniqueInput | null;
};
",
  "admin/src/api/customer/CustomerWhereUniqueInput.ts": "export type CustomerWhereUniqueInput = {
  id: string;
};
",
  "admin/src/api/customer/DeleteCustomerArgs.ts": "import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";

export type DeleteCustomerArgs = {
  where: CustomerWhereUniqueInput;
};
",
  "admin/src/api/customer/EnumCustomerType.ts": "export enum EnumCustomerType {
  Platinum = \\"platinum\\",
  Gold = \\"gold\\",
  Bronze = \\"bronze\\",
  Regular = \\"regular\\",
}
",
  "admin/src/api/customer/EnumFavoriteColors.ts": "export enum EnumFavoriteColors {
  Red = \\"red\\",
  Green = \\"green\\",
  Purple = \\"purple\\",
  Yellow = \\"yellow\\",
}
",
  "admin/src/api/customer/FindManyCustomerArgs.ts": "import { CustomerWhereInput } from \\"./CustomerWhereInput\\";

export type FindManyCustomerArgs = {
  where?: CustomerWhereInput;
};
",
  "admin/src/api/customer/FindOneCustomerArgs.ts": "import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";

export type FindOneCustomerArgs = {
  where: CustomerWhereUniqueInput;
};
",
  "admin/src/api/customer/UpdateCustomerArgs.ts": "import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";
import { CustomerUpdateInput } from \\"./CustomerUpdateInput\\";

export type UpdateCustomerArgs = {
  where: CustomerWhereUniqueInput;
  data: CustomerUpdateInput;
};
",
  "admin/src/api/empty/DeleteEmptyArgs.ts": "import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";

export type DeleteEmptyArgs = {
  where: EmptyWhereUniqueInput;
};
",
  "admin/src/api/empty/Empty.ts": "export type Empty = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
};
",
  "admin/src/api/empty/EmptyCreateInput.ts": "export type EmptyCreateInput = {};
",
  "admin/src/api/empty/EmptyUpdateInput.ts": "export type EmptyUpdateInput = {};
",
  "admin/src/api/empty/EmptyWhereInput.ts": "export type EmptyWhereInput = {
  id?: string;
  createdAt?: Date;
  updatedAt?: Date;
};
",
  "admin/src/api/empty/EmptyWhereUniqueInput.ts": "export type EmptyWhereUniqueInput = {
  id: string;
};
",
  "admin/src/api/empty/FindManyEmptyArgs.ts": "import { EmptyWhereInput } from \\"./EmptyWhereInput\\";

export type FindManyEmptyArgs = {
  where?: EmptyWhereInput;
};
",
  "admin/src/api/empty/FindOneEmptyArgs.ts": "import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";

export type FindOneEmptyArgs = {
  where: EmptyWhereUniqueInput;
};
",
  "admin/src/api/http.util.ts": "export function createBasicAuthorizationHeader(
  username: string,
  password: string
): string {
  return \`Basic \${btoa(\`\${username}:\${password}\`)}\`;
}
",
  "admin/src/api/index.ts": "export { api } from \\"./api\\";
",
  "admin/src/api/order/CreateOrderArgs.ts": "import { OrderCreateInput } from \\"./OrderCreateInput\\";

export type CreateOrderArgs = {
  data: OrderCreateInput;
};
",
  "admin/src/api/order/DeleteOrderArgs.ts": "import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";

export type DeleteOrderArgs = {
  where: OrderWhereUniqueInput;
};
",
  "admin/src/api/order/EnumLabel.ts": "export enum EnumLabel {
  Fragile = \\"fragile\\",
}
",
  "admin/src/api/order/EnumStatus.ts": "export enum EnumStatus {
  Pending = \\"pending\\",
  InProgress = \\"inProgress\\",
  Done = \\"done\\",
}
",
  "admin/src/api/order/FindManyOrderArgs.ts": "import { OrderWhereInput } from \\"./OrderWhereInput\\";

export type FindManyOrderArgs = {
  where?: OrderWhereInput;
};
",
  "admin/src/api/order/FindOneOrderArgs.ts": "import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";

export type FindOneOrderArgs = {
  where: OrderWhereUniqueInput;
};
",
  "admin/src/api/order/Order.ts": "import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";

export type Order = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  customer: CustomerWhereUniqueInput;
  status: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  label: \\"fragile\\" | null;
};
",
  "admin/src/api/order/OrderCreateInput.ts": "import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";

export type OrderCreateInput = {
  customer: CustomerWhereUniqueInput;
  status: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  label?: \\"fragile\\" | null;
};
",
  "admin/src/api/order/OrderUpdateInput.ts": "import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";

export type OrderUpdateInput = {
  customer?: CustomerWhereUniqueInput;
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  label?: \\"fragile\\" | null;
};
",
  "admin/src/api/order/OrderWhereInput.ts": "import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";

export type OrderWhereInput = {
  id?: string;
  createdAt?: Date;
  updatedAt?: Date;
  customer?: CustomerWhereUniqueInput;
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  label?: \\"fragile\\" | null;
};
",
  "admin/src/api/order/OrderWhereUniqueInput.ts": "export type OrderWhereUniqueInput = {
  id: string;
};
",
  "admin/src/api/order/UpdateOrderArgs.ts": "import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";
import { OrderUpdateInput } from \\"./OrderUpdateInput\\";

export type UpdateOrderArgs = {
  where: OrderWhereUniqueInput;
  data: OrderUpdateInput;
};
",
  "admin/src/api/organization/CreateOrganizationArgs.ts": "import { OrganizationCreateInput } from \\"./OrganizationCreateInput\\";

export type CreateOrganizationArgs = {
  data: OrganizationCreateInput;
};
",
  "admin/src/api/organization/DeleteOrganizationArgs.ts": "import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";

export type DeleteOrganizationArgs = {
  where: OrganizationWhereUniqueInput;
};
",
  "admin/src/api/organization/FindManyOrganizationArgs.ts": "import { OrganizationWhereInput } from \\"./OrganizationWhereInput\\";

export type FindManyOrganizationArgs = {
  where?: OrganizationWhereInput;
};
",
  "admin/src/api/organization/FindOneOrganizationArgs.ts": "import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";

export type FindOneOrganizationArgs = {
  where: OrganizationWhereUniqueInput;
};
",
  "admin/src/api/organization/Organization.ts": "export type Organization = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  name: string;
};
",
  "admin/src/api/organization/OrganizationCreateInput.ts": "export type OrganizationCreateInput = {
  name: string;
};
",
  "admin/src/api/organization/OrganizationUpdateInput.ts": "export type OrganizationUpdateInput = {
  name?: string;
};
",
  "admin/src/api/organization/OrganizationWhereInput.ts": "export type OrganizationWhereInput = {
  id?: string;
  createdAt?: Date;
  updatedAt?: Date;
  name?: string;
};
",
  "admin/src/api/organization/OrganizationWhereUniqueInput.ts": "export type OrganizationWhereUniqueInput = {
  id: string;
};
",
  "admin/src/api/organization/UpdateOrganizationArgs.ts": "import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";
import { OrganizationUpdateInput } from \\"./OrganizationUpdateInput\\";

export type UpdateOrganizationArgs = {
  where: OrganizationWhereUniqueInput;
  data: OrganizationUpdateInput;
};
",
  "admin/src/api/user/CreateUserArgs.ts": "import { UserCreateInput } from \\"./UserCreateInput\\";

export type CreateUserArgs = {
  data: UserCreateInput;
};
",
  "admin/src/api/user/DeleteUserArgs.ts": "import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";

export type DeleteUserArgs = {
  where: UserWhereUniqueInput;
};
",
  "admin/src/api/user/EnumInterests.ts": "export enum EnumInterests {
  Programming = \\"programming\\",
  Design = \\"design\\",
}
",
  "admin/src/api/user/EnumPriority.ts": "export enum EnumPriority {
  High = \\"high\\",
  Medium = \\"medium\\",
  Low = \\"low\\",
}
",
  "admin/src/api/user/FindManyUserArgs.ts": "import { UserWhereInput } from \\"./UserWhereInput\\";

export type FindManyUserArgs = {
  where?: UserWhereInput;
};
",
  "admin/src/api/user/FindOneUserArgs.ts": "import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";

export type FindOneUserArgs = {
  where: UserWhereUniqueInput;
};
",
  "admin/src/api/user/UpdateUserArgs.ts": "import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { UserUpdateInput } from \\"./UserUpdateInput\\";

export type UpdateUserArgs = {
  where: UserWhereUniqueInput;
  data: UserUpdateInput;
};
",
  "admin/src/api/user/User.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type User = {
  username: string;
  roles: Array<string>;
  id: string;
  name: string;
  bio: string;
  email: string;
  age: number;
  birthDate: Date;
  score: number;
  organization: OrganizationWhereUniqueInput | null;
  interests: Array<\\"programming\\" | \\"design\\">;
  priority: \\"high\\" | \\"medium\\" | \\"low\\";
  isCurious: boolean;
  location: string;
};
",
  "admin/src/api/user/UserCreateInput.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type UserCreateInput = {
  username: string;
  password: string;
  roles: Array<string>;
  name: string;
  bio: string;
  email: string;
  age: number;
  birthDate: Date;
  score: number;
  organization?: OrganizationWhereUniqueInput | null;
  interests?: Array<\\"programming\\" | \\"design\\">;
  priority: \\"high\\" | \\"medium\\" | \\"low\\";
  isCurious: boolean;
  location: string;
};
",
  "admin/src/api/user/UserUpdateInput.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type UserUpdateInput = {
  username?: string;
  password?: string;
  roles?: Array<string>;
  name?: string;
  bio?: string;
  email?: string;
  age?: number;
  birthDate?: Date;
  score?: number;
  organization?: OrganizationWhereUniqueInput | null;
  interests?: Array<\\"programming\\" | \\"design\\">;
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";
  isCurious?: boolean;
  location?: string;
};
",
  "admin/src/api/user/UserWhereInput.ts": "import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";

export type UserWhereInput = {
  username?: string;
  id?: string;
  name?: string;
  bio?: string;
  email?: string;
  age?: number;
  birthDate?: Date;
  score?: number;
  organization?: OrganizationWhereUniqueInput | null;
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";
  isCurious?: boolean;
  location?: string;
};
",
  "admin/src/api/user/UserWhereUniqueInput.ts": "export type UserWhereUniqueInput = {
  id: string;
};
",
  "admin/src/auth.ts": "import { EventEmitter } from \\"events\\";

export type Credentials = {
  username: string;
  password: string;
};

const CREDENTIALS_LOCAL_STORAGE_ITEM = \\"credentials\\";

const eventEmitter = new EventEmitter();

export function isAuthenticated(): boolean {
  return Boolean(getCredentials());
}

export function listen(listener: (authenticated: boolean) => void): void {
  eventEmitter.on(\\"change\\", () => {
    listener(isAuthenticated());
  });
}

export function setCredentials(credentials: Credentials) {
  localStorage.setItem(
    CREDENTIALS_LOCAL_STORAGE_ITEM,
    JSON.stringify(credentials)
  );
}

export function getCredentials(): Credentials | null {
  const raw = localStorage.getItem(CREDENTIALS_LOCAL_STORAGE_ITEM);
  if (raw === null) {
    return null;
  }
  return JSON.parse(raw);
}

export function removeCredentials(): void {
  localStorage.removeItem(CREDENTIALS_LOCAL_STORAGE_ITEM);
}
",
  "admin/src/components/PrivateRoute.tsx": "import React from \\"react\\";
import { Route, Redirect, RouteProps } from \\"react-router-dom\\";
import useAuthenticated from \\"../use-authenticated\\";

type Props = Omit<RouteProps, \\"render\\">;

// A wrapper for <Route> that redirects to the login
// screen if you're not yet authenticated.
// Based on: https://reacttraining.com/react-router/web/example/auth-workflow
function PrivateRoute({ component, children, ...rest }: Props) {
  const authenticated = useAuthenticated();
  return (
    <Route
      {...rest}
      render={(props) => {
        const { location } = props;
        const childNode = component
          ? React.createElement(component, props)
          : children;
        return authenticated ? (
          childNode
        ) : (
          <Redirect
            to={{
              pathname: \\"/login\\",
              state: { from: location },
            }}
          />
        );
      }}
    />
  );
}

export default PrivateRoute;
",
  "admin/src/components/breadcrumbs/BreadcrumbsContext.ts": "import { createContext } from \\"react\\";

export type BreadcrumbItem = {
  name?: string | null;
  url: string;
};

export type ContextDataType = {
  breadcrumbsItems: BreadcrumbItem[];
  registerItem: (item: BreadcrumbItem) => void;
  unregisterItem: (url: string) => void;
};

const BreadcrumbsContext = createContext<ContextDataType>({
  breadcrumbsItems: [],
  registerItem: (item: BreadcrumbItem) => {
    throw new Error();
  },
  unregisterItem: (url: string) => {
    throw new Error();
  },
});

export default BreadcrumbsContext;
",
  "admin/src/components/breadcrumbs/BreadcrumbsProvider.tsx": "import React, { useState, useCallback, useMemo } from \\"react\\";
import { sortBy } from \\"lodash\\";
import BreadcrumbsContext, { BreadcrumbItem } from \\"./BreadcrumbsContext\\";

type Props = {
  children: React.ReactNode;
};

function BreadcrumbsProvider({ children }: Props) {
  const [breadcrumbsItems, setBreadcrumbsItems] = useState<BreadcrumbItem[]>(
    []
  );

  const registerBreadcrumbItem = useCallback(
    (addItem: BreadcrumbItem) => {
      setBreadcrumbsItems((items) => {
        return sortBy(
          [...items.filter((item) => item.url !== addItem.url), addItem],
          (sortItem) => sortItem.url
        );
      });
    },
    [setBreadcrumbsItems]
  );

  const unregisterBreadcrumbItem = useCallback(
    (url: string) => {
      setBreadcrumbsItems((items) => {
        return sortBy(
          items.filter((item) => item.url !== url),
          (sortItem) => sortItem.url
        );
      });
    },
    [setBreadcrumbsItems]
  );

  const breadcrumbsContextValue = useMemo(
    () => ({
      breadcrumbsItems,
      registerItem: registerBreadcrumbItem,
      unregisterItem: unregisterBreadcrumbItem,
    }),
    [breadcrumbsItems, registerBreadcrumbItem, unregisterBreadcrumbItem]
  );

  return (
    <BreadcrumbsContext.Provider value={breadcrumbsContextValue}>
      {children}
    </BreadcrumbsContext.Provider>
  );
}

export default BreadcrumbsProvider;
",
  "admin/src/components/breadcrumbs/use-breadcrumbs.ts": "import { useEffect, useContext } from \\"react\\";
import BreadcrumbsContext from \\"./BreadcrumbsContext\\";

export default function useBreadcrumbs(url: string, name?: string | null) {
  const breadcrumbsContext = useContext(BreadcrumbsContext);

  useEffect(() => {
    breadcrumbsContext.registerItem({
      name,
      url,
    });
    return () => {
      breadcrumbsContext.unregisterItem(url);
    };
    // eslint-disable-next-line  react-hooks/exhaustive-deps
  }, [
    name,
    url,
    breadcrumbsContext.registerItem,
    breadcrumbsContext.unregisterItem,
  ]);
}
",
  "admin/src/customer/CreateCustomer.tsx": "import * as React from \\"react\\";
import { useMutation } from \\"react-query\\";
import { useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { Formik } from \\"formik\\";

import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
  TextField,
  ToggleField,
  SelectField,
} from \\"@amplication/design-system\\";

import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { OrganizationSelect } from \\"../organization/OrganizationSelect\\";
import { Customer } from \\"../api/customer/Customer\\";
import { CustomerCreateInput } from \\"../api/customer/CustomerCreateInput\\";

const INITIAL_VALUES = {} as CustomerCreateInput;

export const CreateCustomer = (): React.ReactElement => {
  useBreadcrumbs(\\"/customers/new\\", \\"Create Customer\\");
  const history = useHistory();

  const [create, { error, isError, isLoading }] = useMutation<
    Customer,
    AxiosError,
    CustomerCreateInput
  >(
    async (data) => {
      const response = await api.post(\\"/api/customers\\", data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\`\${\\"/customers\\"}/\${data.id}\`);
      },
    }
  );
  const handleSubmit = React.useCallback(
    (values: CustomerCreateInput) => {
      void create(values);
    },
    [create]
  );
  return (
    <>
      <Formik initialValues={INITIAL_VALUES} onSubmit={handleSubmit}>
        <Form
          formStyle={EnumFormStyle.Horizontal}
          formHeaderContent={
            <FormHeader title={\\"Create Customer\\"}>
              <Button type=\\"submit\\" disabled={isLoading}>
                Save
              </Button>
            </FormHeader>
          }
        >
          <div>
            <TextField type=\\"email\\" label=\\"Email\\" name=\\"email\\" />
          </div>
          <div>
            <TextField label=\\"First Name\\" name=\\"firstName\\" />
          </div>
          <div>
            <TextField label=\\"Last Name\\" name=\\"lastName\\" />
          </div>
          <div>
            <ToggleField label=\\"VIP\\" name=\\"isVip\\" />
          </div>
          <div>
            <TextField type=\\"date\\" label=\\"Birth Data\\" name=\\"birthData\\" />
          </div>
          <div>
            <TextField
              type=\\"number\\"
              label=\\"Average Sale (-1500.00 - 1500.00)\\"
              name=\\"averageSale\\"
            />
          </div>
          <div>
            <TextField
              type=\\"number\\"
              step={1}
              label=\\"Favorite Number (1 - 20)\\"
              name=\\"favoriteNumber\\"
            />
          </div>
          <div>
            <TextField label=\\"Geographic Location\\" name=\\"geoLocation\\" />
          </div>
          <div>
            <TextField
              label=\\"Comments (up to 500 characters)\\"
              name=\\"comments\\"
              textarea
            />
          </div>
          <div>
            <SelectField
              label=\\"Favorite Colors (multi-select)\\"
              name=\\"favoriteColors\\"
              options={[
                { label: \\"Red\\", value: \\"red\\" },
                { label: \\"Green\\", value: \\"green\\" },
                { label: \\"Purple\\", value: \\"purple\\" },
                { label: \\"yellow\\", value: \\"yellow\\" },
              ]}
              isMulti
            />
          </div>
          <div>
            <SelectField
              label=\\"Customer Type\\"
              name=\\"customerType\\"
              options={[
                { label: \\"Platinum\\", value: \\"platinum\\" },
                { label: \\"Gold\\", value: \\"gold\\" },
                { label: \\"Bronze\\", value: \\"bronze\\" },
                { label: \\"Regular\\", value: \\"regular\\" },
              ]}
            />
          </div>
          <div>
            <OrganizationSelect label=\\"Organization\\" name=\\"organization.id\\" />
          </div>
          <div>
            <OrganizationSelect
              label=\\"VIP Organization\\"
              name=\\"vipOrganization.id\\"
            />
          </div>
        </Form>
      </Formik>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/customer/Customer.tsx": "import * as React from \\"react\\";
import { useRouteMatch, useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery, useMutation } from \\"react-query\\";
import { Formik } from \\"formik\\";
import pick from \\"lodash.pick\\";

import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
  EnumButtonStyle,
  TextField,
  ToggleField,
  SelectField,
} from \\"@amplication/design-system\\";

import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { OrganizationSelect } from \\"../organization/OrganizationSelect\\";
import { Customer as TCustomer } from \\"../api/customer/Customer\\";
import { CustomerUpdateInput } from \\"../api/customer/CustomerUpdateInput\\";

export const Customer = (): React.ReactElement => {
  const match = useRouteMatch<{ id: string }>(\\"/customers/:id/\\");
  const id = match?.params?.id;
  const history = useHistory();

  const { data, isLoading, isError, error } = useQuery<
    TCustomer,
    AxiosError,
    [string, string]
  >([\\"get-/api/customers\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/customers\\"}/\${id}\`);
    return response.data;
  });

  const [deleteEntity] = useMutation<TCustomer, AxiosError>(
    async (data) => {
      const response = await api.delete(\`\${\\"/api/customers\\"}/\${id}\`, data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\\"//customers\\");
      },
    }
  );

  const [
    update,
    { error: updateError, isError: updateIsError, isLoading: updateIsLoading },
  ] = useMutation<TCustomer, AxiosError, CustomerUpdateInput>(async (data) => {
    const response = await api.patch(\`\${\\"/api/customers\\"}/\${id}\`, data);
    return response.data;
  });

  const handleSubmit = React.useCallback(
    (values: CustomerUpdateInput) => {
      void update(values);
    },
    [update]
  );

  useBreadcrumbs(match?.url, data?.firstName);

  const handleDelete = React.useCallback(() => {
    void deleteEntity();
  }, [deleteEntity]);

  const errorMessage =
    updateError?.response?.data?.message || error?.response?.data?.message;

  const initialValues = React.useMemo(
    () =>
      pick(data, [
        \\"email\\",
        \\"firstName\\",
        \\"lastName\\",
        \\"isVip\\",
        \\"birthData\\",
        \\"averageSale\\",
        \\"favoriteNumber\\",
        \\"geoLocation\\",
        \\"comments\\",
        \\"favoriteColors\\",
        \\"customerType\\",
        \\"organization\\",
        \\"vipOrganization\\",
      ]),
    [data]
  );

  if (isLoading) {
    return <span>Loading...</span>;
  }

  return (
    <>
      {data && (
        <Formik initialValues={initialValues} onSubmit={handleSubmit}>
          <Form
            formStyle={EnumFormStyle.Horizontal}
            formHeaderContent={
              <FormHeader
                title={\`\${\\"Customer\\"} \${
                  data?.firstName && data?.firstName.length
                    ? data.firstName
                    : data?.id
                }\`}
              >
                <Button
                  type=\\"button\\"
                  disabled={updateIsLoading}
                  buttonStyle={EnumButtonStyle.Secondary}
                  icon=\\"trash_2\\"
                  onClick={handleDelete}
                >
                  Delete
                </Button>
                <Button type=\\"submit\\" disabled={updateIsLoading}>
                  Save
                </Button>
              </FormHeader>
            }
          >
            <div>
              <TextField type=\\"email\\" label=\\"Email\\" name=\\"email\\" />
            </div>
            <div>
              <TextField label=\\"First Name\\" name=\\"firstName\\" />
            </div>
            <div>
              <TextField label=\\"Last Name\\" name=\\"lastName\\" />
            </div>
            <div>
              <ToggleField label=\\"VIP\\" name=\\"isVip\\" />
            </div>
            <div>
              <TextField type=\\"date\\" label=\\"Birth Data\\" name=\\"birthData\\" />
            </div>
            <div>
              <TextField
                type=\\"number\\"
                label=\\"Average Sale (-1500.00 - 1500.00)\\"
                name=\\"averageSale\\"
              />
            </div>
            <div>
              <TextField
                type=\\"number\\"
                step={1}
                label=\\"Favorite Number (1 - 20)\\"
                name=\\"favoriteNumber\\"
              />
            </div>
            <div>
              <TextField label=\\"Geographic Location\\" name=\\"geoLocation\\" />
            </div>
            <div>
              <TextField
                label=\\"Comments (up to 500 characters)\\"
                name=\\"comments\\"
                textarea
              />
            </div>
            <div>
              <SelectField
                label=\\"Favorite Colors (multi-select)\\"
                name=\\"favoriteColors\\"
                options={[
                  { label: \\"Red\\", value: \\"red\\" },
                  { label: \\"Green\\", value: \\"green\\" },
                  { label: \\"Purple\\", value: \\"purple\\" },
                  { label: \\"yellow\\", value: \\"yellow\\" },
                ]}
                isMulti
              />
            </div>
            <div>
              <SelectField
                label=\\"Customer Type\\"
                name=\\"customerType\\"
                options={[
                  { label: \\"Platinum\\", value: \\"platinum\\" },
                  { label: \\"Gold\\", value: \\"gold\\" },
                  { label: \\"Bronze\\", value: \\"bronze\\" },
                  { label: \\"Regular\\", value: \\"regular\\" },
                ]}
              />
            </div>
            <div>
              <OrganizationSelect label=\\"Organization\\" name=\\"organization.id\\" />
            </div>
            <div>
              <OrganizationSelect
                label=\\"VIP Organization\\"
                name=\\"vipOrganization.id\\"
              />
            </div>
          </Form>
        </Formik>
      )}
      <Snackbar open={isError || updateIsError} message={errorMessage} />
    </>
  );
};
",
  "admin/src/customer/CustomerIndex.tsx": "import * as React from \\"react\\";
import { Switch } from \\"react-router-dom\\";
import PrivateRoute from \\"../components/PrivateRoute\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { CustomerList } from \\"./CustomerList\\";
import { CreateCustomer } from \\"./CreateCustomer\\";
import { Customer } from \\"./Customer\\";

export const CustomerIndex = (): React.ReactElement => {
  useBreadcrumbs(\\"/customers/\\", \\"Customers\\");

  return (
    <Switch>
      <PrivateRoute exact path={\\"/customers/\\"} component={CustomerList} />
      <PrivateRoute path={\\"/customers/new\\"} component={CreateCustomer} />
      <PrivateRoute path={\\"/customers/:id\\"} component={Customer} />
    </Switch>
  );
};
",
  "admin/src/customer/CustomerList.tsx": "import * as React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";

import {
  DataGrid,
  DataField,
  SortData,
  DataGridRow,
  DataGridCell,
  EnumTitleType,
  Button,
  Snackbar,
  TimeSince,
  CircleIcon,
  EnumCircleIconStyle,
} from \\"@amplication/design-system\\";

import { OrganizationTitle } from \\"../organization/OrganizationTitle\\";
import { Customer } from \\"../api/customer/Customer\\";

type Data = Customer[];

const SORT_DATA: SortData = {
  field: null,
  order: null,
};

const FIELDS: DataField[] = [
  {
    name: \\"id\\",
    title: \\"Id\\",
    sortable: false,
  },
  {
    name: \\"createdAt\\",
    title: \\"Created At\\",
    sortable: false,
  },
  {
    name: \\"updatedAt\\",
    title: \\"Updated At\\",
    sortable: false,
  },
  {
    name: \\"email\\",
    title: \\"Email\\",
    sortable: false,
  },
  {
    name: \\"firstName\\",
    title: \\"First Name\\",
    sortable: false,
  },
  {
    name: \\"lastName\\",
    title: \\"Last Name\\",
    sortable: false,
  },
  {
    name: \\"isVip\\",
    title: \\"VIP\\",
    sortable: false,
  },
  {
    name: \\"birthData\\",
    title: \\"Birth Data\\",
    sortable: false,
  },
  {
    name: \\"averageSale\\",
    title: \\"Average Sale (-1500.00 - 1500.00)\\",
    sortable: false,
  },
  {
    name: \\"favoriteNumber\\",
    title: \\"Favorite Number (1 - 20)\\",
    sortable: false,
  },
  {
    name: \\"geoLocation\\",
    title: \\"Geographic Location\\",
    sortable: false,
  },
  {
    name: \\"comments\\",
    title: \\"Comments (up to 500 characters)\\",
    sortable: false,
  },
  {
    name: \\"favoriteColors\\",
    title: \\"Favorite Colors (multi-select)\\",
    sortable: false,
  },
  {
    name: \\"customerType\\",
    title: \\"Customer Type\\",
    sortable: false,
  },
  {
    name: \\"organization\\",
    title: \\"Organization\\",
    sortable: false,
  },
  {
    name: \\"vipOrganization\\",
    title: \\"VIP Organization\\",
    sortable: false,
  },
];

export const CustomerList = (): React.ReactElement => {
  const { data, error, isError } = useQuery<Data, AxiosError>(
    \\"list-/api/customers\\",
    async () => {
      const response = await api.get(\\"/api/customers\\");
      return response.data;
    }
  );

  return (
    <>
      <DataGrid
        fields={FIELDS}
        titleType={EnumTitleType.PageTitle}
        title={\\"Customers\\"}
        loading={false}
        sortDir={SORT_DATA}
        toolbarContentEnd={
          <Link to={\\"/customers/new\\"}>
            <Button>Create Customer </Button>
          </Link>
        }
      >
        {data &&
          data.map((item: Customer) => {
            return (
              <DataGridRow key={item.id} clickData={item}>
                <DataGridCell>
                  <Link className=\\"entity-id\\" to={\`\${\\"/customers\\"}/\${item.id}\`}>
                    {item.id}
                  </Link>
                </DataGridCell>
                <DataGridCell>
                  <TimeSince time={item.createdAt} />
                </DataGridCell>
                <DataGridCell>
                  <TimeSince time={item.updatedAt} />
                </DataGridCell>
                <DataGridCell>
                  <>{item.email}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.firstName}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.lastName}</>
                </DataGridCell>
                <DataGridCell>
                  <>
                    {item.isVip && (
                      <CircleIcon
                        icon=\\"check\\"
                        style={EnumCircleIconStyle.positive}
                      />
                    )}
                  </>
                </DataGridCell>
                <DataGridCell>
                  <>{item.birthData}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.averageSale}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.favoriteNumber}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.geoLocation}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.comments}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.favoriteColors}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.customerType}</>
                </DataGridCell>
                <DataGridCell>
                  <OrganizationTitle id={item.organization?.id} />
                </DataGridCell>
                <DataGridCell>
                  <OrganizationTitle id={item.vipOrganization?.id} />
                </DataGridCell>
              </DataGridRow>
            );
          })}
      </DataGrid>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/customer/CustomerSelect.tsx": "import React, { useMemo } from \\"react\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { SelectField, SelectFieldProps } from \\"@amplication/design-system\\";
import { Customer } from \\"../api/customer/Customer\\";

type Data = Customer[];

type Props = Omit<SelectFieldProps, \\"options\\">;

export const CustomerSelect = (props: Props) => {
  const { data } = useQuery<Data, AxiosError>(
    \\"select-/api/customers\\",
    async () => {
      const response = await api.get(\\"/api/customers\\");
      return response.data;
    }
  );

  const options = useMemo(() => {
    return data
      ? data.map((item) => ({
          value: item.id,
          label:
            item.firstName && item.firstName.length ? item.firstName : item.id,
        }))
      : [];
  }, [data]);

  return <SelectField {...props} options={options} />;
};
",
  "admin/src/customer/CustomerTitle.tsx": "import React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { Customer } from \\"../api/customer/Customer\\";

type Props = { id: string };

export const CustomerTitle = ({ id }: Props) => {
  const { data, isLoading, isError, error } = useQuery<
    Customer,
    AxiosError,
    [string, string]
  >([\\"get-/api/customers\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/customers\\"}/\${id}\`);
    return response.data;
  });

  if (isLoading) {
    return <span>Loading...</span>;
  }

  if (isError) {
    return <span>Error: {error?.message}</span>;
  }

  return (
    <Link to={\`\${\\"/api/customers\\"}/\${id}\`} className=\\"entity-id\\">
      {data?.firstName && data?.firstName.length ? data.firstName : data?.id}
    </Link>
  );
};
",
  "admin/src/empty/CreateEmpty.tsx": "import * as React from \\"react\\";
import { useMutation } from \\"react-query\\";
import { useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { Formik } from \\"formik\\";
import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
} from \\"@amplication/design-system\\";
import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { Empty } from \\"../api/empty/Empty\\";
import { EmptyCreateInput } from \\"../api/empty/EmptyCreateInput\\";

const INITIAL_VALUES = {} as EmptyCreateInput;

export const CreateEmpty = (): React.ReactElement => {
  useBreadcrumbs(\\"/empties/new\\", \\"Create Empty\\");
  const history = useHistory();

  const [create, { error, isError, isLoading }] = useMutation<
    Empty,
    AxiosError,
    EmptyCreateInput
  >(
    async (data) => {
      const response = await api.post(\\"/api/empties\\", data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\`\${\\"/empties\\"}/\${data.id}\`);
      },
    }
  );
  const handleSubmit = React.useCallback(
    (values: EmptyCreateInput) => {
      void create(values);
    },
    [create]
  );
  return (
    <>
      <Formik initialValues={INITIAL_VALUES} onSubmit={handleSubmit}>
        <Form
          formStyle={EnumFormStyle.Horizontal}
          formHeaderContent={
            <FormHeader title={\\"Create Empty\\"}>
              <Button type=\\"submit\\" disabled={isLoading}>
                Save
              </Button>
            </FormHeader>
          }
        ></Form>
      </Formik>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/empty/Empty.tsx": "import * as React from \\"react\\";
import { useRouteMatch, useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery, useMutation } from \\"react-query\\";
import { Formik } from \\"formik\\";
import pick from \\"lodash.pick\\";
import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
  EnumButtonStyle,
} from \\"@amplication/design-system\\";
import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { Empty as TEmpty } from \\"../api/empty/Empty\\";
import { EmptyUpdateInput } from \\"../api/empty/EmptyUpdateInput\\";

export const Empty = (): React.ReactElement => {
  const match = useRouteMatch<{ id: string }>(\\"/empties/:id/\\");
  const id = match?.params?.id;
  const history = useHistory();

  const { data, isLoading, isError, error } = useQuery<
    TEmpty,
    AxiosError,
    [string, string]
  >([\\"get-/api/empties\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/empties\\"}/\${id}\`);
    return response.data;
  });

  const [deleteEntity] = useMutation<TEmpty, AxiosError>(
    async (data) => {
      const response = await api.delete(\`\${\\"/api/empties\\"}/\${id}\`, data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\\"//empties\\");
      },
    }
  );

  const [
    update,
    { error: updateError, isError: updateIsError, isLoading: updateIsLoading },
  ] = useMutation<TEmpty, AxiosError, EmptyUpdateInput>(async (data) => {
    const response = await api.patch(\`\${\\"/api/empties\\"}/\${id}\`, data);
    return response.data;
  });

  const handleSubmit = React.useCallback(
    (values: EmptyUpdateInput) => {
      void update(values);
    },
    [update]
  );

  useBreadcrumbs(match?.url, data?.id);

  const handleDelete = React.useCallback(() => {
    void deleteEntity();
  }, [deleteEntity]);

  const errorMessage =
    updateError?.response?.data?.message || error?.response?.data?.message;

  const initialValues = React.useMemo(() => pick(data, []), [data]);

  if (isLoading) {
    return <span>Loading...</span>;
  }

  return (
    <>
      {data && (
        <Formik initialValues={initialValues} onSubmit={handleSubmit}>
          <Form
            formStyle={EnumFormStyle.Horizontal}
            formHeaderContent={
              <FormHeader
                title={\`\${\\"Empty\\"} \${
                  data?.id && data?.id.length ? data.id : data?.id
                }\`}
              >
                <Button
                  type=\\"button\\"
                  disabled={updateIsLoading}
                  buttonStyle={EnumButtonStyle.Secondary}
                  icon=\\"trash_2\\"
                  onClick={handleDelete}
                >
                  Delete
                </Button>
                <Button type=\\"submit\\" disabled={updateIsLoading}>
                  Save
                </Button>
              </FormHeader>
            }
          ></Form>
        </Formik>
      )}
      <Snackbar open={isError || updateIsError} message={errorMessage} />
    </>
  );
};
",
  "admin/src/empty/EmptyIndex.tsx": "import * as React from \\"react\\";
import { Switch } from \\"react-router-dom\\";
import PrivateRoute from \\"../components/PrivateRoute\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { EmptyList } from \\"./EmptyList\\";
import { CreateEmpty } from \\"./CreateEmpty\\";
import { Empty } from \\"./Empty\\";

export const EmptyIndex = (): React.ReactElement => {
  useBreadcrumbs(\\"/empties/\\", \\"Empties\\");

  return (
    <Switch>
      <PrivateRoute exact path={\\"/empties/\\"} component={EmptyList} />
      <PrivateRoute path={\\"/empties/new\\"} component={CreateEmpty} />
      <PrivateRoute path={\\"/empties/:id\\"} component={Empty} />
    </Switch>
  );
};
",
  "admin/src/empty/EmptyList.tsx": "import * as React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";

import {
  DataGrid,
  DataField,
  SortData,
  DataGridRow,
  DataGridCell,
  EnumTitleType,
  Button,
  Snackbar,
  TimeSince,
} from \\"@amplication/design-system\\";

import { Empty } from \\"../api/empty/Empty\\";

type Data = Empty[];

const SORT_DATA: SortData = {
  field: null,
  order: null,
};

const FIELDS: DataField[] = [
  {
    name: \\"id\\",
    title: \\"Id\\",
    sortable: false,
  },
  {
    name: \\"createdAt\\",
    title: \\"Created At\\",
    sortable: false,
  },
  {
    name: \\"updatedAt\\",
    title: \\"Updated At\\",
    sortable: false,
  },
];

export const EmptyList = (): React.ReactElement => {
  const { data, error, isError } = useQuery<Data, AxiosError>(
    \\"list-/api/empties\\",
    async () => {
      const response = await api.get(\\"/api/empties\\");
      return response.data;
    }
  );

  return (
    <>
      <DataGrid
        fields={FIELDS}
        titleType={EnumTitleType.PageTitle}
        title={\\"Empties\\"}
        loading={false}
        sortDir={SORT_DATA}
        toolbarContentEnd={
          <Link to={\\"/empties/new\\"}>
            <Button>Create Empty </Button>
          </Link>
        }
      >
        {data &&
          data.map((item: Empty) => {
            return (
              <DataGridRow key={item.id} clickData={item}>
                <DataGridCell>
                  <Link className=\\"entity-id\\" to={\`\${\\"/empties\\"}/\${item.id}\`}>
                    {item.id}
                  </Link>
                </DataGridCell>
                <DataGridCell>
                  <TimeSince time={item.createdAt} />
                </DataGridCell>
                <DataGridCell>
                  <TimeSince time={item.updatedAt} />
                </DataGridCell>
              </DataGridRow>
            );
          })}
      </DataGrid>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/empty/EmptySelect.tsx": "import React, { useMemo } from \\"react\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { SelectField, SelectFieldProps } from \\"@amplication/design-system\\";
import { Empty } from \\"../api/empty/Empty\\";

type Data = Empty[];

type Props = Omit<SelectFieldProps, \\"options\\">;

export const EmptySelect = (props: Props) => {
  const { data } = useQuery<Data, AxiosError>(
    \\"select-/api/empties\\",
    async () => {
      const response = await api.get(\\"/api/empties\\");
      return response.data;
    }
  );

  const options = useMemo(() => {
    return data
      ? data.map((item) => ({
          value: item.id,
          label: item.id && item.id.length ? item.id : item.id,
        }))
      : [];
  }, [data]);

  return <SelectField {...props} options={options} />;
};
",
  "admin/src/empty/EmptyTitle.tsx": "import React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { Empty } from \\"../api/empty/Empty\\";

type Props = { id: string };

export const EmptyTitle = ({ id }: Props) => {
  const { data, isLoading, isError, error } = useQuery<
    Empty,
    AxiosError,
    [string, string]
  >([\\"get-/api/empties\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/empties\\"}/\${id}\`);
    return response.data;
  });

  if (isLoading) {
    return <span>Loading...</span>;
  }

  if (isError) {
    return <span>Error: {error?.message}</span>;
  }

  return (
    <Link to={\`\${\\"/api/empties\\"}/\${id}\`} className=\\"entity-id\\">
      {data?.id && data?.id.length ? data.id : data?.id}
    </Link>
  );
};
",
  "admin/src/index.tsx": "import React from \\"react\\";
import ReactDOM from \\"react-dom\\";
import { BrowserRouter as Router } from \\"react-router-dom\\";
import \\"./index.css\\";
// @ts-ignore
import App from \\"./App\\";
import reportWebVitals from \\"./reportWebVitals\\";
import * as amplicationDesignSystem from \\"@amplication/design-system\\";
import \\"@amplication/design-system/icons\\";

ReactDOM.render(
  <React.StrictMode>
    <amplicationDesignSystem.Provider>
      <Router>
        <App />
      </Router>
    </amplicationDesignSystem.Provider>
  </React.StrictMode>,
  document.getElementById(\\"root\\")
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
",
  "admin/src/order/CreateOrder.tsx": "import * as React from \\"react\\";
import { useMutation } from \\"react-query\\";
import { useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { Formik } from \\"formik\\";
import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
  SelectField,
} from \\"@amplication/design-system\\";
import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { CustomerSelect } from \\"../customer/CustomerSelect\\";
import { Order } from \\"../api/order/Order\\";
import { OrderCreateInput } from \\"../api/order/OrderCreateInput\\";

const INITIAL_VALUES = {} as OrderCreateInput;

export const CreateOrder = (): React.ReactElement => {
  useBreadcrumbs(\\"/orders/new\\", \\"Create Order\\");
  const history = useHistory();

  const [create, { error, isError, isLoading }] = useMutation<
    Order,
    AxiosError,
    OrderCreateInput
  >(
    async (data) => {
      const response = await api.post(\\"/api/orders\\", data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\`\${\\"/orders\\"}/\${data.id}\`);
      },
    }
  );
  const handleSubmit = React.useCallback(
    (values: OrderCreateInput) => {
      void create(values);
    },
    [create]
  );
  return (
    <>
      <Formik initialValues={INITIAL_VALUES} onSubmit={handleSubmit}>
        <Form
          formStyle={EnumFormStyle.Horizontal}
          formHeaderContent={
            <FormHeader title={\\"Create Order\\"}>
              <Button type=\\"submit\\" disabled={isLoading}>
                Save
              </Button>
            </FormHeader>
          }
        >
          <div>
            <CustomerSelect label=\\"Customer\\" name=\\"customer.id\\" />
          </div>
          <div>
            <SelectField
              label=\\"Status\\"
              name=\\"status\\"
              options={[
                { label: \\"Pending\\", value: \\"pending\\" },
                { label: \\"In Progress\\", value: \\"inProgress\\" },
                { label: \\"Done\\", value: \\"done\\" },
              ]}
            />
          </div>
          <div>
            <SelectField
              label=\\"Label\\"
              name=\\"label\\"
              options={[{ label: \\"Fragile\\", value: \\"fragile\\" }]}
            />
          </div>
        </Form>
      </Formik>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/order/Order.tsx": "import * as React from \\"react\\";
import { useRouteMatch, useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery, useMutation } from \\"react-query\\";
import { Formik } from \\"formik\\";
import pick from \\"lodash.pick\\";

import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
  EnumButtonStyle,
  SelectField,
} from \\"@amplication/design-system\\";

import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { CustomerSelect } from \\"../customer/CustomerSelect\\";
import { Order as TOrder } from \\"../api/order/Order\\";
import { OrderUpdateInput } from \\"../api/order/OrderUpdateInput\\";

export const Order = (): React.ReactElement => {
  const match = useRouteMatch<{ id: string }>(\\"/orders/:id/\\");
  const id = match?.params?.id;
  const history = useHistory();

  const { data, isLoading, isError, error } = useQuery<
    TOrder,
    AxiosError,
    [string, string]
  >([\\"get-/api/orders\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/orders\\"}/\${id}\`);
    return response.data;
  });

  const [deleteEntity] = useMutation<TOrder, AxiosError>(
    async (data) => {
      const response = await api.delete(\`\${\\"/api/orders\\"}/\${id}\`, data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\\"//orders\\");
      },
    }
  );

  const [
    update,
    { error: updateError, isError: updateIsError, isLoading: updateIsLoading },
  ] = useMutation<TOrder, AxiosError, OrderUpdateInput>(async (data) => {
    const response = await api.patch(\`\${\\"/api/orders\\"}/\${id}\`, data);
    return response.data;
  });

  const handleSubmit = React.useCallback(
    (values: OrderUpdateInput) => {
      void update(values);
    },
    [update]
  );

  useBreadcrumbs(match?.url, data?.id);

  const handleDelete = React.useCallback(() => {
    void deleteEntity();
  }, [deleteEntity]);

  const errorMessage =
    updateError?.response?.data?.message || error?.response?.data?.message;

  const initialValues = React.useMemo(
    () => pick(data, [\\"customer\\", \\"status\\", \\"label\\"]),
    [data]
  );

  if (isLoading) {
    return <span>Loading...</span>;
  }

  return (
    <>
      {data && (
        <Formik initialValues={initialValues} onSubmit={handleSubmit}>
          <Form
            formStyle={EnumFormStyle.Horizontal}
            formHeaderContent={
              <FormHeader
                title={\`\${\\"Order\\"} \${
                  data?.id && data?.id.length ? data.id : data?.id
                }\`}
              >
                <Button
                  type=\\"button\\"
                  disabled={updateIsLoading}
                  buttonStyle={EnumButtonStyle.Secondary}
                  icon=\\"trash_2\\"
                  onClick={handleDelete}
                >
                  Delete
                </Button>
                <Button type=\\"submit\\" disabled={updateIsLoading}>
                  Save
                </Button>
              </FormHeader>
            }
          >
            <div>
              <CustomerSelect label=\\"Customer\\" name=\\"customer.id\\" />
            </div>
            <div>
              <SelectField
                label=\\"Status\\"
                name=\\"status\\"
                options={[
                  { label: \\"Pending\\", value: \\"pending\\" },
                  { label: \\"In Progress\\", value: \\"inProgress\\" },
                  { label: \\"Done\\", value: \\"done\\" },
                ]}
              />
            </div>
            <div>
              <SelectField
                label=\\"Label\\"
                name=\\"label\\"
                options={[{ label: \\"Fragile\\", value: \\"fragile\\" }]}
              />
            </div>
          </Form>
        </Formik>
      )}
      <Snackbar open={isError || updateIsError} message={errorMessage} />
    </>
  );
};
",
  "admin/src/order/OrderIndex.tsx": "import * as React from \\"react\\";
import { Switch } from \\"react-router-dom\\";
import PrivateRoute from \\"../components/PrivateRoute\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { OrderList } from \\"./OrderList\\";
import { CreateOrder } from \\"./CreateOrder\\";
import { Order } from \\"./Order\\";

export const OrderIndex = (): React.ReactElement => {
  useBreadcrumbs(\\"/orders/\\", \\"Orders\\");

  return (
    <Switch>
      <PrivateRoute exact path={\\"/orders/\\"} component={OrderList} />
      <PrivateRoute path={\\"/orders/new\\"} component={CreateOrder} />
      <PrivateRoute path={\\"/orders/:id\\"} component={Order} />
    </Switch>
  );
};
",
  "admin/src/order/OrderList.tsx": "import * as React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";

import {
  DataGrid,
  DataField,
  SortData,
  DataGridRow,
  DataGridCell,
  EnumTitleType,
  Button,
  Snackbar,
  TimeSince,
} from \\"@amplication/design-system\\";

import { CustomerTitle } from \\"../customer/CustomerTitle\\";
import { Order } from \\"../api/order/Order\\";

type Data = Order[];

const SORT_DATA: SortData = {
  field: null,
  order: null,
};

const FIELDS: DataField[] = [
  {
    name: \\"id\\",
    title: \\"Id\\",
    sortable: false,
  },
  {
    name: \\"createdAt\\",
    title: \\"Created At\\",
    sortable: false,
  },
  {
    name: \\"updatedAt\\",
    title: \\"Updated At\\",
    sortable: false,
  },
  {
    name: \\"customer\\",
    title: \\"Customer\\",
    sortable: false,
  },
  {
    name: \\"status\\",
    title: \\"Status\\",
    sortable: false,
  },
  {
    name: \\"label\\",
    title: \\"Label\\",
    sortable: false,
  },
];

export const OrderList = (): React.ReactElement => {
  const { data, error, isError } = useQuery<Data, AxiosError>(
    \\"list-/api/orders\\",
    async () => {
      const response = await api.get(\\"/api/orders\\");
      return response.data;
    }
  );

  return (
    <>
      <DataGrid
        fields={FIELDS}
        titleType={EnumTitleType.PageTitle}
        title={\\"Orders\\"}
        loading={false}
        sortDir={SORT_DATA}
        toolbarContentEnd={
          <Link to={\\"/orders/new\\"}>
            <Button>Create Order </Button>
          </Link>
        }
      >
        {data &&
          data.map((item: Order) => {
            return (
              <DataGridRow key={item.id} clickData={item}>
                <DataGridCell>
                  <Link className=\\"entity-id\\" to={\`\${\\"/orders\\"}/\${item.id}\`}>
                    {item.id}
                  </Link>
                </DataGridCell>
                <DataGridCell>
                  <TimeSince time={item.createdAt} />
                </DataGridCell>
                <DataGridCell>
                  <TimeSince time={item.updatedAt} />
                </DataGridCell>
                <DataGridCell>
                  <CustomerTitle id={item.customer?.id} />
                </DataGridCell>
                <DataGridCell>
                  <>{item.status}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.label}</>
                </DataGridCell>
              </DataGridRow>
            );
          })}
      </DataGrid>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/order/OrderSelect.tsx": "import React, { useMemo } from \\"react\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { SelectField, SelectFieldProps } from \\"@amplication/design-system\\";
import { Order } from \\"../api/order/Order\\";

type Data = Order[];

type Props = Omit<SelectFieldProps, \\"options\\">;

export const OrderSelect = (props: Props) => {
  const { data } = useQuery<Data, AxiosError>(
    \\"select-/api/orders\\",
    async () => {
      const response = await api.get(\\"/api/orders\\");
      return response.data;
    }
  );

  const options = useMemo(() => {
    return data
      ? data.map((item) => ({
          value: item.id,
          label: item.id && item.id.length ? item.id : item.id,
        }))
      : [];
  }, [data]);

  return <SelectField {...props} options={options} />;
};
",
  "admin/src/order/OrderTitle.tsx": "import React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { Order } from \\"../api/order/Order\\";

type Props = { id: string };

export const OrderTitle = ({ id }: Props) => {
  const { data, isLoading, isError, error } = useQuery<
    Order,
    AxiosError,
    [string, string]
  >([\\"get-/api/orders\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/orders\\"}/\${id}\`);
    return response.data;
  });

  if (isLoading) {
    return <span>Loading...</span>;
  }

  if (isError) {
    return <span>Error: {error?.message}</span>;
  }

  return (
    <Link to={\`\${\\"/api/orders\\"}/\${id}\`} className=\\"entity-id\\">
      {data?.id && data?.id.length ? data.id : data?.id}
    </Link>
  );
};
",
  "admin/src/organization/CreateOrganization.tsx": "import * as React from \\"react\\";
import { useMutation } from \\"react-query\\";
import { useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { Formik } from \\"formik\\";
import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
  TextField,
} from \\"@amplication/design-system\\";
import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { Organization } from \\"../api/organization/Organization\\";
import { OrganizationCreateInput } from \\"../api/organization/OrganizationCreateInput\\";

const INITIAL_VALUES = {} as OrganizationCreateInput;

export const CreateOrganization = (): React.ReactElement => {
  useBreadcrumbs(\\"/organizations/new\\", \\"Create Organization\\");
  const history = useHistory();

  const [create, { error, isError, isLoading }] = useMutation<
    Organization,
    AxiosError,
    OrganizationCreateInput
  >(
    async (data) => {
      const response = await api.post(\\"/api/organizations\\", data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\`\${\\"/organizations\\"}/\${data.id}\`);
      },
    }
  );
  const handleSubmit = React.useCallback(
    (values: OrganizationCreateInput) => {
      void create(values);
    },
    [create]
  );
  return (
    <>
      <Formik initialValues={INITIAL_VALUES} onSubmit={handleSubmit}>
        <Form
          formStyle={EnumFormStyle.Horizontal}
          formHeaderContent={
            <FormHeader title={\\"Create Organization\\"}>
              <Button type=\\"submit\\" disabled={isLoading}>
                Save
              </Button>
            </FormHeader>
          }
        >
          <div>
            <TextField label=\\"Name\\" name=\\"name\\" />
          </div>
        </Form>
      </Formik>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/organization/Organization.tsx": "import * as React from \\"react\\";
import { useRouteMatch, useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery, useMutation } from \\"react-query\\";
import { Formik } from \\"formik\\";
import pick from \\"lodash.pick\\";

import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
  EnumButtonStyle,
  TextField,
} from \\"@amplication/design-system\\";

import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { Organization as TOrganization } from \\"../api/organization/Organization\\";
import { OrganizationUpdateInput } from \\"../api/organization/OrganizationUpdateInput\\";

export const Organization = (): React.ReactElement => {
  const match = useRouteMatch<{ id: string }>(\\"/organizations/:id/\\");
  const id = match?.params?.id;
  const history = useHistory();

  const { data, isLoading, isError, error } = useQuery<
    TOrganization,
    AxiosError,
    [string, string]
  >([\\"get-/api/organizations\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/organizations\\"}/\${id}\`);
    return response.data;
  });

  const [deleteEntity] = useMutation<TOrganization, AxiosError>(
    async (data) => {
      const response = await api.delete(\`\${\\"/api/organizations\\"}/\${id}\`, data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\\"//organizations\\");
      },
    }
  );

  const [
    update,
    { error: updateError, isError: updateIsError, isLoading: updateIsLoading },
  ] = useMutation<TOrganization, AxiosError, OrganizationUpdateInput>(
    async (data) => {
      const response = await api.patch(\`\${\\"/api/organizations\\"}/\${id}\`, data);
      return response.data;
    }
  );

  const handleSubmit = React.useCallback(
    (values: OrganizationUpdateInput) => {
      void update(values);
    },
    [update]
  );

  useBreadcrumbs(match?.url, data?.name);

  const handleDelete = React.useCallback(() => {
    void deleteEntity();
  }, [deleteEntity]);

  const errorMessage =
    updateError?.response?.data?.message || error?.response?.data?.message;

  const initialValues = React.useMemo(() => pick(data, [\\"name\\"]), [data]);

  if (isLoading) {
    return <span>Loading...</span>;
  }

  return (
    <>
      {data && (
        <Formik initialValues={initialValues} onSubmit={handleSubmit}>
          <Form
            formStyle={EnumFormStyle.Horizontal}
            formHeaderContent={
              <FormHeader
                title={\`\${\\"Organization\\"} \${
                  data?.name && data?.name.length ? data.name : data?.id
                }\`}
              >
                <Button
                  type=\\"button\\"
                  disabled={updateIsLoading}
                  buttonStyle={EnumButtonStyle.Secondary}
                  icon=\\"trash_2\\"
                  onClick={handleDelete}
                >
                  Delete
                </Button>
                <Button type=\\"submit\\" disabled={updateIsLoading}>
                  Save
                </Button>
              </FormHeader>
            }
          >
            <div>
              <TextField label=\\"Name\\" name=\\"name\\" />
            </div>
          </Form>
        </Formik>
      )}
      <Snackbar open={isError || updateIsError} message={errorMessage} />
    </>
  );
};
",
  "admin/src/organization/OrganizationIndex.tsx": "import * as React from \\"react\\";
import { Switch } from \\"react-router-dom\\";
import PrivateRoute from \\"../components/PrivateRoute\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { OrganizationList } from \\"./OrganizationList\\";
import { CreateOrganization } from \\"./CreateOrganization\\";
import { Organization } from \\"./Organization\\";

export const OrganizationIndex = (): React.ReactElement => {
  useBreadcrumbs(\\"/organizations/\\", \\"Organizations\\");

  return (
    <Switch>
      <PrivateRoute
        exact
        path={\\"/organizations/\\"}
        component={OrganizationList}
      />
      <PrivateRoute
        path={\\"/organizations/new\\"}
        component={CreateOrganization}
      />
      <PrivateRoute path={\\"/organizations/:id\\"} component={Organization} />
    </Switch>
  );
};
",
  "admin/src/organization/OrganizationList.tsx": "import * as React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";

import {
  DataGrid,
  DataField,
  SortData,
  DataGridRow,
  DataGridCell,
  EnumTitleType,
  Button,
  Snackbar,
  TimeSince,
} from \\"@amplication/design-system\\";

import { Organization } from \\"../api/organization/Organization\\";

type Data = Organization[];

const SORT_DATA: SortData = {
  field: null,
  order: null,
};

const FIELDS: DataField[] = [
  {
    name: \\"id\\",
    title: \\"Id\\",
    sortable: false,
  },
  {
    name: \\"createdAt\\",
    title: \\"Created At\\",
    sortable: false,
  },
  {
    name: \\"updatedAt\\",
    title: \\"Updated At\\",
    sortable: false,
  },
  {
    name: \\"name\\",
    title: \\"Name\\",
    sortable: false,
  },
];

export const OrganizationList = (): React.ReactElement => {
  const { data, error, isError } = useQuery<Data, AxiosError>(
    \\"list-/api/organizations\\",
    async () => {
      const response = await api.get(\\"/api/organizations\\");
      return response.data;
    }
  );

  return (
    <>
      <DataGrid
        fields={FIELDS}
        titleType={EnumTitleType.PageTitle}
        title={\\"Organizations\\"}
        loading={false}
        sortDir={SORT_DATA}
        toolbarContentEnd={
          <Link to={\\"/organizations/new\\"}>
            <Button>Create Organization </Button>
          </Link>
        }
      >
        {data &&
          data.map((item: Organization) => {
            return (
              <DataGridRow key={item.id} clickData={item}>
                <DataGridCell>
                  <Link
                    className=\\"entity-id\\"
                    to={\`\${\\"/organizations\\"}/\${item.id}\`}
                  >
                    {item.id}
                  </Link>
                </DataGridCell>
                <DataGridCell>
                  <TimeSince time={item.createdAt} />
                </DataGridCell>
                <DataGridCell>
                  <TimeSince time={item.updatedAt} />
                </DataGridCell>
                <DataGridCell>
                  <>{item.name}</>
                </DataGridCell>
              </DataGridRow>
            );
          })}
      </DataGrid>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/organization/OrganizationSelect.tsx": "import React, { useMemo } from \\"react\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { SelectField, SelectFieldProps } from \\"@amplication/design-system\\";
import { Organization } from \\"../api/organization/Organization\\";

type Data = Organization[];

type Props = Omit<SelectFieldProps, \\"options\\">;

export const OrganizationSelect = (props: Props) => {
  const { data } = useQuery<Data, AxiosError>(
    \\"select-/api/organizations\\",
    async () => {
      const response = await api.get(\\"/api/organizations\\");
      return response.data;
    }
  );

  const options = useMemo(() => {
    return data
      ? data.map((item) => ({
          value: item.id,
          label: item.name && item.name.length ? item.name : item.id,
        }))
      : [];
  }, [data]);

  return <SelectField {...props} options={options} />;
};
",
  "admin/src/organization/OrganizationTitle.tsx": "import React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { Organization } from \\"../api/organization/Organization\\";

type Props = { id: string };

export const OrganizationTitle = ({ id }: Props) => {
  const { data, isLoading, isError, error } = useQuery<
    Organization,
    AxiosError,
    [string, string]
  >([\\"get-/api/organizations\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/organizations\\"}/\${id}\`);
    return response.data;
  });

  if (isLoading) {
    return <span>Loading...</span>;
  }

  if (isError) {
    return <span>Error: {error?.message}</span>;
  }

  return (
    <Link to={\`\${\\"/api/organizations\\"}/\${id}\`} className=\\"entity-id\\">
      {data?.name && data?.name.length ? data.name : data?.id}
    </Link>
  );
};
",
  "admin/src/reportWebVitals.ts": "import { ReportHandler } from \\"web-vitals\\";

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import(\\"web-vitals\\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
",
  "admin/src/setupTests.ts": "// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import \\"@testing-library/jest-dom\\";
",
  "admin/src/use-authenticated.ts": "import { useState, useEffect } from \\"react\\";
import { listen, isAuthenticated } from \\"./auth\\";

export default function useAuthenticated() {
  const [authenticated, setAuthenticated] = useState<boolean>(
    isAuthenticated()
  );
  useEffect(() => {
    listen(setAuthenticated);
  }, [setAuthenticated]);
  return authenticated;
}
",
  "admin/src/user/CreateUser.tsx": "import * as React from \\"react\\";
import { useMutation } from \\"react-query\\";
import { useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { Formik } from \\"formik\\";

import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
  TextField,
  SelectField,
  ToggleField,
} from \\"@amplication/design-system\\";

import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { OrganizationSelect } from \\"../organization/OrganizationSelect\\";
import { User } from \\"../api/user/User\\";
import { UserCreateInput } from \\"../api/user/UserCreateInput\\";
import { RoleSelect } from \\"../user/RoleSelect\\";

const INITIAL_VALUES = {} as UserCreateInput;

export const CreateUser = (): React.ReactElement => {
  useBreadcrumbs(\\"/users/new\\", \\"Create User\\");
  const history = useHistory();

  const [create, { error, isError, isLoading }] = useMutation<
    User,
    AxiosError,
    UserCreateInput
  >(
    async (data) => {
      const response = await api.post(\\"/api/users\\", data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\`\${\\"/users\\"}/\${data.id}\`);
      },
    }
  );
  const handleSubmit = React.useCallback(
    (values: UserCreateInput) => {
      void create(values);
    },
    [create]
  );
  return (
    <>
      <Formik initialValues={INITIAL_VALUES} onSubmit={handleSubmit}>
        <Form
          formStyle={EnumFormStyle.Horizontal}
          formHeaderContent={
            <FormHeader title={\\"Create User\\"}>
              <Button type=\\"submit\\" disabled={isLoading}>
                Save
              </Button>
            </FormHeader>
          }
        >
          <div>
            <TextField label=\\"Username\\" name=\\"username\\" />
          </div>
          <div>
            <TextField type=\\"password\\" label=\\"Password\\" name=\\"password\\" />
          </div>
          <div>
            <RoleSelect label=\\"Roles\\" name=\\"roles\\" />
          </div>
          <div>
            <TextField label=\\"Name\\" name=\\"name\\" />
          </div>
          <div>
            <TextField label=\\"Bio\\" name=\\"bio\\" textarea />
          </div>
          <div>
            <TextField type=\\"email\\" label=\\"Email\\" name=\\"email\\" />
          </div>
          <div>
            <TextField type=\\"number\\" step={1} label=\\"Age\\" name=\\"age\\" />
          </div>
          <div>
            <TextField
              type=\\"datetime-local\\"
              label=\\"Birth Date\\"
              name=\\"birthDate\\"
            />
          </div>
          <div>
            <TextField type=\\"number\\" label=\\"Score\\" name=\\"score\\" />
          </div>
          <div>
            <OrganizationSelect label=\\"Organization\\" name=\\"organization.id\\" />
          </div>
          <div>
            <SelectField
              label=\\"Interests\\"
              name=\\"interests\\"
              options={[
                { label: \\"Programming\\", value: \\"programming\\" },
                { label: \\"Design\\", value: \\"design\\" },
              ]}
              isMulti
            />
          </div>
          <div>
            <SelectField
              label=\\"Priority\\"
              name=\\"priority\\"
              options={[
                { label: \\"High\\", value: \\"high\\" },
                { label: \\"Medium\\", value: \\"medium\\" },
                { label: \\"Low\\", value: \\"low\\" },
              ]}
            />
          </div>
          <div>
            <ToggleField label=\\"Is Curious\\" name=\\"isCurious\\" />
          </div>
          <div>
            <TextField label=\\"Location\\" name=\\"location\\" />
          </div>
        </Form>
      </Formik>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/user/EnumRoles.ts": "export enum EnumRoles {
  User = \\"user\\",
  Admin = \\"admin\\",
  AreaManager = \\"areaManager\\",
}
",
  "admin/src/user/RoleSelect.tsx": "import React from \\"react\\";
import { SelectField, SelectFieldProps } from \\"@amplication/design-system\\";
//@ts-ignore
import { ROLES } from \\"./roles\\";

declare interface Role {
  name: string;
  displayName: string;
}

const OPTIONS = ROLES.map((role: Role) => ({
  value: role.name,
  label: role.displayName,
}));

type Props = Omit<SelectFieldProps, \\"options\\">;

export const RoleSelect = (props: Props) => {
  return <SelectField {...props} options={OPTIONS} />;
};
",
  "admin/src/user/User.tsx": "import * as React from \\"react\\";
import { useRouteMatch, useHistory } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery, useMutation } from \\"react-query\\";
import { Formik } from \\"formik\\";
import pick from \\"lodash.pick\\";

import {
  Form,
  EnumFormStyle,
  Button,
  FormHeader,
  Snackbar,
  EnumButtonStyle,
  TextField,
  SelectField,
  ToggleField,
} from \\"@amplication/design-system\\";

import { api } from \\"../api\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { OrganizationSelect } from \\"../organization/OrganizationSelect\\";
import { User as TUser } from \\"../api/user/User\\";
import { UserUpdateInput } from \\"../api/user/UserUpdateInput\\";
import { RoleSelect } from \\"../user/RoleSelect\\";

export const User = (): React.ReactElement => {
  const match = useRouteMatch<{ id: string }>(\\"/users/:id/\\");
  const id = match?.params?.id;
  const history = useHistory();

  const { data, isLoading, isError, error } = useQuery<
    TUser,
    AxiosError,
    [string, string]
  >([\\"get-/api/users\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/users\\"}/\${id}\`);
    return response.data;
  });

  const [deleteEntity] = useMutation<TUser, AxiosError>(
    async (data) => {
      const response = await api.delete(\`\${\\"/api/users\\"}/\${id}\`, data);
      return response.data;
    },
    {
      onSuccess: (data, variables) => {
        history.push(\\"//users\\");
      },
    }
  );

  const [
    update,
    { error: updateError, isError: updateIsError, isLoading: updateIsLoading },
  ] = useMutation<TUser, AxiosError, UserUpdateInput>(async (data) => {
    const response = await api.patch(\`\${\\"/api/users\\"}/\${id}\`, data);
    return response.data;
  });

  const handleSubmit = React.useCallback(
    (values: UserUpdateInput) => {
      void update(values);
    },
    [update]
  );

  useBreadcrumbs(match?.url, data?.username);

  const handleDelete = React.useCallback(() => {
    void deleteEntity();
  }, [deleteEntity]);

  const errorMessage =
    updateError?.response?.data?.message || error?.response?.data?.message;

  const initialValues = React.useMemo(
    () =>
      pick(data, [
        \\"username\\",
        \\"password\\",
        \\"roles\\",
        \\"name\\",
        \\"bio\\",
        \\"email\\",
        \\"age\\",
        \\"birthDate\\",
        \\"score\\",
        \\"organization\\",
        \\"interests\\",
        \\"priority\\",
        \\"isCurious\\",
        \\"location\\",
      ]),
    [data]
  );

  if (isLoading) {
    return <span>Loading...</span>;
  }

  return (
    <>
      {data && (
        <Formik initialValues={initialValues} onSubmit={handleSubmit}>
          <Form
            formStyle={EnumFormStyle.Horizontal}
            formHeaderContent={
              <FormHeader
                title={\`\${\\"User\\"} \${
                  data?.username && data?.username.length
                    ? data.username
                    : data?.id
                }\`}
              >
                <Button
                  type=\\"button\\"
                  disabled={updateIsLoading}
                  buttonStyle={EnumButtonStyle.Secondary}
                  icon=\\"trash_2\\"
                  onClick={handleDelete}
                >
                  Delete
                </Button>
                <Button type=\\"submit\\" disabled={updateIsLoading}>
                  Save
                </Button>
              </FormHeader>
            }
          >
            <div>
              <TextField label=\\"Username\\" name=\\"username\\" />
            </div>
            <div>
              <TextField type=\\"password\\" label=\\"Password\\" name=\\"password\\" />
            </div>
            <div>
              <RoleSelect label=\\"Roles\\" name=\\"roles\\" />
            </div>
            <div>
              <TextField label=\\"Name\\" name=\\"name\\" />
            </div>
            <div>
              <TextField label=\\"Bio\\" name=\\"bio\\" textarea />
            </div>
            <div>
              <TextField type=\\"email\\" label=\\"Email\\" name=\\"email\\" />
            </div>
            <div>
              <TextField type=\\"number\\" step={1} label=\\"Age\\" name=\\"age\\" />
            </div>
            <div>
              <TextField
                type=\\"datetime-local\\"
                label=\\"Birth Date\\"
                name=\\"birthDate\\"
              />
            </div>
            <div>
              <TextField type=\\"number\\" label=\\"Score\\" name=\\"score\\" />
            </div>
            <div>
              <OrganizationSelect label=\\"Organization\\" name=\\"organization.id\\" />
            </div>
            <div>
              <SelectField
                label=\\"Interests\\"
                name=\\"interests\\"
                options={[
                  { label: \\"Programming\\", value: \\"programming\\" },
                  { label: \\"Design\\", value: \\"design\\" },
                ]}
                isMulti
              />
            </div>
            <div>
              <SelectField
                label=\\"Priority\\"
                name=\\"priority\\"
                options={[
                  { label: \\"High\\", value: \\"high\\" },
                  { label: \\"Medium\\", value: \\"medium\\" },
                  { label: \\"Low\\", value: \\"low\\" },
                ]}
              />
            </div>
            <div>
              <ToggleField label=\\"Is Curious\\" name=\\"isCurious\\" />
            </div>
            <div>
              <TextField label=\\"Location\\" name=\\"location\\" />
            </div>
          </Form>
        </Formik>
      )}
      <Snackbar open={isError || updateIsError} message={errorMessage} />
    </>
  );
};
",
  "admin/src/user/UserIndex.tsx": "import * as React from \\"react\\";
import { Switch } from \\"react-router-dom\\";
import PrivateRoute from \\"../components/PrivateRoute\\";
import useBreadcrumbs from \\"../components/breadcrumbs/use-breadcrumbs\\";
import { UserList } from \\"./UserList\\";
import { CreateUser } from \\"./CreateUser\\";
import { User } from \\"./User\\";

export const UserIndex = (): React.ReactElement => {
  useBreadcrumbs(\\"/users/\\", \\"Users\\");

  return (
    <Switch>
      <PrivateRoute exact path={\\"/users/\\"} component={UserList} />
      <PrivateRoute path={\\"/users/new\\"} component={CreateUser} />
      <PrivateRoute path={\\"/users/:id\\"} component={User} />
    </Switch>
  );
};
",
  "admin/src/user/UserList.tsx": "import * as React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";

import {
  DataGrid,
  DataField,
  SortData,
  DataGridRow,
  DataGridCell,
  EnumTitleType,
  Button,
  Snackbar,
  CircleIcon,
  EnumCircleIconStyle,
} from \\"@amplication/design-system\\";

import { OrganizationTitle } from \\"../organization/OrganizationTitle\\";
import { User } from \\"../api/user/User\\";

type Data = User[];

const SORT_DATA: SortData = {
  field: null,
  order: null,
};

const FIELDS: DataField[] = [
  {
    name: \\"id\\",
    title: \\"Id\\",
    sortable: false,
  },
  {
    name: \\"username\\",
    title: \\"Username\\",
    sortable: false,
  },
  {
    name: \\"roles\\",
    title: \\"Roles\\",
    sortable: false,
  },
  {
    name: \\"name\\",
    title: \\"Name\\",
    sortable: false,
  },
  {
    name: \\"bio\\",
    title: \\"Bio\\",
    sortable: false,
  },
  {
    name: \\"email\\",
    title: \\"Email\\",
    sortable: false,
  },
  {
    name: \\"age\\",
    title: \\"Age\\",
    sortable: false,
  },
  {
    name: \\"birthDate\\",
    title: \\"Birth Date\\",
    sortable: false,
  },
  {
    name: \\"score\\",
    title: \\"Score\\",
    sortable: false,
  },
  {
    name: \\"organization\\",
    title: \\"Organization\\",
    sortable: false,
  },
  {
    name: \\"interests\\",
    title: \\"Interests\\",
    sortable: false,
  },
  {
    name: \\"priority\\",
    title: \\"Priority\\",
    sortable: false,
  },
  {
    name: \\"isCurious\\",
    title: \\"Is Curious\\",
    sortable: false,
  },
  {
    name: \\"location\\",
    title: \\"Location\\",
    sortable: false,
  },
];

export const UserList = (): React.ReactElement => {
  const { data, error, isError } = useQuery<Data, AxiosError>(
    \\"list-/api/users\\",
    async () => {
      const response = await api.get(\\"/api/users\\");
      return response.data;
    }
  );

  return (
    <>
      <DataGrid
        fields={FIELDS}
        titleType={EnumTitleType.PageTitle}
        title={\\"Users\\"}
        loading={false}
        sortDir={SORT_DATA}
        toolbarContentEnd={
          <Link to={\\"/users/new\\"}>
            <Button>Create User </Button>
          </Link>
        }
      >
        {data &&
          data.map((item: User) => {
            return (
              <DataGridRow key={item.id} clickData={item}>
                <DataGridCell>
                  <Link className=\\"entity-id\\" to={\`\${\\"/users\\"}/\${item.id}\`}>
                    {item.id}
                  </Link>
                </DataGridCell>
                <DataGridCell>
                  <>{item.username}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.roles}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.name}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.bio}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.email}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.age}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.birthDate}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.score}</>
                </DataGridCell>
                <DataGridCell>
                  <OrganizationTitle id={item.organization?.id} />
                </DataGridCell>
                <DataGridCell>
                  <>{item.interests}</>
                </DataGridCell>
                <DataGridCell>
                  <>{item.priority}</>
                </DataGridCell>
                <DataGridCell>
                  <>
                    {item.isCurious && (
                      <CircleIcon
                        icon=\\"check\\"
                        style={EnumCircleIconStyle.positive}
                      />
                    )}
                  </>
                </DataGridCell>
                <DataGridCell>
                  <>{item.location}</>
                </DataGridCell>
              </DataGridRow>
            );
          })}
      </DataGrid>
      <Snackbar open={isError} message={error?.response?.data?.message} />
    </>
  );
};
",
  "admin/src/user/UserSelect.tsx": "import React, { useMemo } from \\"react\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { SelectField, SelectFieldProps } from \\"@amplication/design-system\\";
import { User } from \\"../api/user/User\\";

type Data = User[];

type Props = Omit<SelectFieldProps, \\"options\\">;

export const UserSelect = (props: Props) => {
  const { data } = useQuery<Data, AxiosError>(\\"select-/api/users\\", async () => {
    const response = await api.get(\\"/api/users\\");
    return response.data;
  });

  const options = useMemo(() => {
    return data
      ? data.map((item) => ({
          value: item.id,
          label:
            item.username && item.username.length ? item.username : item.id,
        }))
      : [];
  }, [data]);

  return <SelectField {...props} options={options} />;
};
",
  "admin/src/user/UserTitle.tsx": "import React from \\"react\\";
import { Link } from \\"react-router-dom\\";
import { AxiosError } from \\"axios\\";
import { useQuery } from \\"react-query\\";
import { api } from \\"../api\\";
import { User } from \\"../api/user/User\\";

type Props = { id: string };

export const UserTitle = ({ id }: Props) => {
  const { data, isLoading, isError, error } = useQuery<
    User,
    AxiosError,
    [string, string]
  >([\\"get-/api/users\\", id], async (key: string, id: string) => {
    const response = await api.get(\`\${\\"/api/users\\"}/\${id}\`);
    return response.data;
  });

  if (isLoading) {
    return <span>Loading...</span>;
  }

  if (isError) {
    return <span>Error: {error?.message}</span>;
  }

  return (
    <Link to={\`\${\\"/api/users\\"}/\${id}\`} className=\\"entity-id\\">
      {data?.username && data?.username.length ? data.username : data?.id}
    </Link>
  );
};
",
  "admin/src/user/roles.ts": "export const ROLES = [
  {
    name: \\"user\\",
    displayName: \\"User\\",
  },
  {
    name: \\"admin\\",
    displayName: \\"Admin\\",
  },
  {
    name: \\"areaManager\\",
    displayName: \\"Area Manager\\",
  },
];
",
  "server/prisma/schema.prisma": "datasource postgres {
  provider = \\"postgresql\\"
  url      = env(\\"POSTGRESQL_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  username       String          @unique
  password       String
  roles          String[]
  id             String          @id @default(cuid())
  name           String
  bio            String
  email          String
  age            Int
  birthDate      DateTime
  score          Float
  organization   Organization?   @relation(fields: [organizationId])
  organizationId String?
  interests      EnumInterests[]
  priority       EnumPriority
  isCurious      Boolean
  location       String
}

model Order {
  id         String     @id @default(cuid())
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  customer   Customer   @relation(fields: [customerId])
  customerId String
  status     EnumStatus
  label      EnumLabel?
}

model Organization {
  id           String     @id @default(cuid())
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  name         String
  users        User[]
  customers    Customer[] @relation(name: \\"CustomersOnOrganization\\")
  vipCustomers Customer[] @relation(name: \\"vipCustomers\\")
}

model Customer {
  id                String               @id @default(cuid())
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  email             String
  firstName         String?
  lastName          String?
  isVip             Boolean?
  birthData         DateTime?
  averageSale       Float?
  favoriteNumber    Int?
  geoLocation       String?
  comments          String?
  favoriteColors    EnumFavoriteColors[]
  customerType      EnumCustomerType?
  organization      Organization?        @relation(name: \\"CustomersOnOrganization\\", fields: [organizationId])
  organizationId    String?
  vipOrganization   Organization?        @relation(name: \\"vipCustomers\\", fields: [vipOrganizationId])
  vipOrganizationId String?
  orders            Order[]
}

model Empty {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum EnumInterests {
  programming
  design
}

enum EnumPriority {
  high
  medium
  low
}

enum EnumStatus {
  pending
  inProgress
  done
}

enum EnumLabel {
  fragile
}

enum EnumFavoriteColors {
  red
  green
  purple
  yellow
}

enum EnumCustomerType {
  platinum
  gold
  bronze
  regular
}",
  "server/scripts/clean.ts": "/**
 * Clean all the tables and types created by Prisma in the database
 */

import { PrismaClient } from \\"@prisma/client\\";

if (require.main === module) {
  clean().catch((error) => {
    console.error(error);
    process.exit(1);
  });
}

async function clean() {
  console.info(\\"Dropping all tables in the database...\\");
  const prisma = new PrismaClient();
  const tables = await getTables(prisma);
  const types = await getTypes(prisma);
  await dropTables(prisma, tables);
  await dropTypes(prisma, types);
  console.info(\\"Cleaned database successfully\\");
  await prisma.$disconnect();
}

async function dropTables(
  prisma: PrismaClient,
  tables: string[]
): Promise<void> {
  for (const table of tables) {
    await prisma.$executeRaw(\`DROP TABLE public.\\"\${table}\\" CASCADE;\`);
  }
}

async function dropTypes(prisma: PrismaClient, types: string[]) {
  for (const type of types) {
    await prisma.$executeRaw(\`DROP TYPE IF EXISTS \\"\${type}\\" CASCADE;\`);
  }
}

async function getTables(prisma: PrismaClient): Promise<string[]> {
  const results: Array<{
    tablename: string;
  }> = await prisma.$queryRaw\`SELECT tablename from pg_tables where schemaname = 'public';\`;
  return results.map((result) => result.tablename);
}

async function getTypes(prisma: PrismaClient): Promise<string[]> {
  const results: Array<{
    typname: string;
  }> = await prisma.$queryRaw\`
SELECT t.typname
FROM pg_type t 
JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
WHERE n.nspname = 'public';
\`;
  return results.map((result) => result.typname);
}
",
  "server/scripts/seed.ts": "import * as dotenv from \\"dotenv\\";
import { PrismaClient } from \\"@prisma/client\\";
import { Salt, parseSalt } from \\"../src/auth/password.service\\";
import { hash } from \\"bcrypt\\";
import { EnumPriority } from \\"../src/user/EnumPriority\\";

if (require.main === module) {
  dotenv.config();

  const { BCRYPT_SALT } = process.env;

  if (!BCRYPT_SALT) {
    throw new Error(\\"BCRYPT_SALT environment variable must be defined\\");
  }

  const salt = parseSalt(BCRYPT_SALT);

  seed(salt).catch((error) => {
    console.error(error);
    process.exit(1);
  });
}

async function seed(bcryptSalt: Salt) {
  console.info(\\"Seeding database...\\");

  const client = new PrismaClient();
  const data = {
    username: \\"admin\\",
    password: await hash(\\"admin\\", bcryptSalt),
    roles: [\\"user\\"],
    name: \\"\\",
    bio: \\"\\",
    email: \\"example@example.com\\",
    age: 0,
    birthDate: new Date(),
    score: 0,
    interests: [],
    priority: EnumPriority.High,
    isCurious: false,
    location: \\"(32.085300, 34.781769)\\",
  };
  await client.user.upsert({
    where: { username: data.username },
    update: {},
    create: data,
  });
  client.$disconnect();
  console.info(\\"Seeded database successfully\\");
}
",
  "server/src/app.module.ts": "import { Module } from \\"@nestjs/common\\";
import { UserModule } from \\"./user/user.module\\";
import { OrderModule } from \\"./order/order.module\\";
import { OrganizationModule } from \\"./organization/organization.module\\";
import { CustomerModule } from \\"./customer/customer.module\\";
import { EmptyModule } from \\"./empty/empty.module\\";
import { ACLModule } from \\"./auth/acl.module\\";
import { AuthModule } from \\"./auth/auth.module\\";
import { MorganModule } from \\"nest-morgan\\";
import { ConfigModule, ConfigService } from \\"@nestjs/config\\";
import { ServeStaticModule } from \\"@nestjs/serve-static\\";
import { ServeStaticOptionsService } from \\"./serveStaticOptions.service\\";
import { GraphQLModule } from \\"@nestjs/graphql\\";

@Module({
  controllers: [],
  imports: [
    UserModule,
    OrderModule,
    OrganizationModule,
    CustomerModule,
    EmptyModule,
    ACLModule,
    AuthModule,
    MorganModule,
    ConfigModule.forRoot({ isGlobal: true }),
    ServeStaticModule.forRootAsync({
      useClass: ServeStaticOptionsService,
    }),
    GraphQLModule.forRootAsync({
      useFactory: (configService) => {
        const playground = configService.get(\\"GRAPHQL_PLAYGROUND\\");
        const introspection = configService.get(\\"GRAPHQL_INTROSPECTION\\");
        return {
          autoSchemaFile: true,
          playground,
          introspection: playground || introspection,
        };
      },
      inject: [ConfigService],
      imports: [ConfigModule],
    }),
  ],
  providers: [],
})
export class AppModule {}
",
  "server/src/auth/Credentials.ts": "import { InputType } from \\"@nestjs/graphql\\";
import { IsString } from \\"class-validator\\";

@InputType()
export class Credentials {
  @IsString()
  username!: string;
  @IsString()
  password!: string;
}
",
  "server/src/auth/LoginArgs.ts": "import { ArgsType } from \\"@nestjs/graphql\\";
import { Credentials } from \\"./Credentials\\";

@ArgsType()
export class LoginArgs {
  credentials!: Credentials;
}
",
  "server/src/auth/UserInfo.ts": "import { Field, ObjectType } from \\"@nestjs/graphql\\";
// @ts-ignore
// eslint-disable-next-line
import { User } from \\"../user/user\\";

@ObjectType()
export class UserInfo implements Partial<User> {
  @Field(() => String)
  username!: string;
  @Field(() => [String])
  roles!: string[];
}
",
  "server/src/auth/abac.util.ts": "import { Permission } from \\"accesscontrol\\";

/**
 * @returns attributes not allowed to appear on given data according to given
 * attributeMatchers
 */
export function getInvalidAttributes(
  permission: Permission,
  // eslint-disable-next-line @typescript-eslint/ban-types
  data: Object
): string[] {
  const filteredData = permission.filter(data);
  return Object.keys(data).filter((key) => !(key in filteredData));
}
",
  "server/src/auth/acl.module.ts": "import { AccessControlModule, RolesBuilder } from \\"nest-access-control\\";
// @ts-ignore
// eslint-disable-next-line import/no-unresolved
import grants from \\"../grants.json\\";

// eslint-disable-next-line @typescript-eslint/naming-convention
export const ACLModule = AccessControlModule.forRoles(new RolesBuilder(grants));
",
  "server/src/auth/auth.controller.ts": "import { Controller, Post, Body, UnauthorizedException } from \\"@nestjs/common\\";
import { ApiTags } from \\"@nestjs/swagger\\";
import { AuthService } from \\"./auth.service\\";
import { UserInfo } from \\"./UserInfo\\";
import { Credentials } from \\"./Credentials\\";

@ApiTags(\\"auth\\")
@Controller()
export class AuthController {
  constructor(private readonly authService: AuthService) {}
  @Post(\\"login\\")
  async login(@Body() body: Credentials): Promise<UserInfo> {
    const user = await this.authService.validateUser(
      body.username,
      body.password
    );
    if (!user) {
      throw new UnauthorizedException(\\"The passed credentials are incorrect\\");
    }
    return user;
  }
}
",
  "server/src/auth/auth.module.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { PassportModule } from \\"@nestjs/passport\\";
// @ts-ignore
// eslint-disable-next-line
import { UserModule } from \\"../user/user.module\\";
import { AuthController } from \\"./auth.controller\\";
import { AuthResolver } from \\"./auth.resolver\\";
import { AuthService } from \\"./auth.service\\";
import { BasicStrategy } from \\"./basic.strategy\\";
import { PasswordService } from \\"./password.service\\";

@Module({
  imports: [forwardRef(() => UserModule), PassportModule],
  providers: [AuthService, BasicStrategy, PasswordService, AuthResolver],
  controllers: [AuthController],
  exports: [AuthService, PasswordService],
})
export class AuthModule {}
",
  "server/src/auth/auth.resolver.ts": "import { Args, Mutation, Resolver } from \\"@nestjs/graphql\\";
import { ApolloError } from \\"apollo-server-express\\";
import { AuthService } from \\"./auth.service\\";
import { UserInfo } from \\"./UserInfo\\";
import { LoginArgs } from \\"./LoginArgs\\";

@Resolver(UserInfo)
export class AuthResolver {
  constructor(private readonly authService: AuthService) {}
  @Mutation(() => UserInfo)
  async login(@Args() args: LoginArgs): Promise<UserInfo> {
    const user = await this.authService.validateUser(
      args.credentials.username,
      args.credentials.password
    );
    if (!user) {
      throw new ApolloError(\\"The passed credentials are incorrect\\");
    }
    return user;
  }
}
",
  "server/src/auth/auth.service.spec.ts": "import { Test, TestingModule } from \\"@nestjs/testing\\";
import { AuthService } from \\"./auth.service\\";
// @ts-ignore
// eslint-disable-next-line
import { UserService, User } from \\"../user/user.service\\";
import { PasswordService } from \\"./password.service\\";

const VALID_USER: User = {
  username: \\"Valid User\\",
  password: \\"Valid User Password\\",
};
const INVALID_USER: User = {
  username: \\"Invalid User\\",
  password: \\"Invalid User Password\\",
};

const userService = {
  findOne(args: { where: { username: string } }): User | null {
    if (args.where.username === VALID_USER.username) {
      return VALID_USER;
    }
    return null;
  },
};

const passwordService = {
  compare(password: string, encrypted: string) {
    return true;
  },
};

describe(\\"AuthService\\", () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        {
          provide: UserService,
          useValue: userService,
        },
        {
          provide: PasswordService,
          useValue: passwordService,
        },
        AuthService,
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it(\\"should be defined\\", () => {
    expect(service).toBeDefined();
  });

  it(\\"should validate a valid user\\", async () => {
    await expect(
      service.validateUser(VALID_USER.username, VALID_USER.password)
    ).resolves.toEqual({
      username: VALID_USER.username,
    });
  });

  it(\\"should not validate a invalid user\\", async () => {
    await expect(
      service.validateUser(INVALID_USER.username, INVALID_USER.password)
    ).resolves.toBe(null);
  });
});
",
  "server/src/auth/auth.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PasswordService } from \\"./password.service\\";
// @ts-ignore
// eslint-disable-next-line
import { UserService } from \\"../user/user.service\\";
import { UserInfo } from \\"./UserInfo\\";

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly passwordService: PasswordService
  ) {}

  async validateUser(
    username: string,
    password: string
  ): Promise<UserInfo | null> {
    const user = await this.userService.findOne({
      where: { username },
    });
    if (user && (await this.passwordService.compare(password, user.password))) {
      const { roles } = user;
      return { username, roles };
    }
    return null;
  }
}
",
  "server/src/auth/basic.strategy.ts": "import { BasicStrategy as Strategy } from \\"passport-http\\";
import { PassportStrategy } from \\"@nestjs/passport\\";
import { Injectable, UnauthorizedException } from \\"@nestjs/common\\";
import { AuthService } from \\"./auth.service\\";
import { UserInfo } from \\"./UserInfo\\";

@Injectable()
export class BasicStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super();
  }

  async validate(username: string, password: string): Promise<UserInfo> {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}
",
  "server/src/auth/basicAuth.guard.ts": "import { AuthGuard } from \\"@nestjs/passport\\";

export class BasicAuthGuard extends AuthGuard(\\"basic\\") {}
",
  "server/src/auth/gqlAC.guard.ts": "import { ExecutionContext } from \\"@nestjs/common\\";
import { GqlExecutionContext } from \\"@nestjs/graphql\\";
import { ACGuard } from \\"nest-access-control\\";

export class GqlACGuard<User extends any = any> extends ACGuard<User> {
  async getUser(context: ExecutionContext): Promise<User> {
    const ctx = GqlExecutionContext.create(context);
    const request = ctx.getContext<{ req: { user: User } }>().req;
    return request.user;
  }
}
",
  "server/src/auth/gqlBasicAuth.guard.ts": "import { Injectable, ExecutionContext } from \\"@nestjs/common\\";
import { GqlExecutionContext } from \\"@nestjs/graphql\\";
import type { Request } from \\"express\\";
import { BasicAuthGuard } from \\"./basicAuth.guard\\";

@Injectable()
export class GqlBasicAuthGuard extends BasicAuthGuard {
  // This method is required for the interface - do not delete it.
  getRequest(context: ExecutionContext): Request {
    const ctx = GqlExecutionContext.create(context);
    return ctx.getContext<{ req: Request }>().req;
  }
}
",
  "server/src/auth/gqlUserRoles.decorator.ts": "import { createParamDecorator, ExecutionContext } from \\"@nestjs/common\\";
import { GqlExecutionContext } from \\"@nestjs/graphql\\";

/**
 * Access the user roles from the request object i.e \`req.user.roles\`.
 *
 * You can pass an optional property key to the decorator to get it from the user object
 * e.g \`@UserRoles('permissions')\` will return the \`req.user.permissions\` instead.
 */
export const UserRoles = createParamDecorator(
  (data: string, context: ExecutionContext) => {
    const ctx = GqlExecutionContext.create(context);
    const request = ctx.getContext<{ req: { user: any } }>().req;
    return data ? request.user[data] : request.user.roles;
  }
);
",
  "server/src/auth/password.service.spec.ts": "import { ConfigService } from \\"@nestjs/config\\";
import { Test, TestingModule } from \\"@nestjs/testing\\";
import { PasswordService } from \\"./password.service\\";
import * as bcrypt from \\"bcrypt\\";

const EXAMPLE_PASSWORD = \\"examplePassword\\";
const EXAMPLE_HASHED_PASSWORD = \\"exampleHashedPassword\\";

const EXAMPLE_SALT_OR_ROUNDS = 1;

const configServiceGetMock = jest.fn(() => {
  return EXAMPLE_SALT_OR_ROUNDS;
});

jest.mock(\\"bcrypt\\");

//@ts-ignore
bcrypt.hash.mockImplementation(async () => EXAMPLE_HASHED_PASSWORD);

//@ts-ignore
bcrypt.compare.mockImplementation(async () => true);

describe(\\"PasswordService\\", () => {
  let service: PasswordService;

  beforeEach(async () => {
    jest.clearAllMocks();
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PasswordService,
        {
          provide: ConfigService,
          useClass: jest.fn(() => ({
            get: configServiceGetMock,
          })),
        },
      ],
      imports: [],
    }).compile();

    service = module.get<PasswordService>(PasswordService);
  });

  it(\\"should be defined\\", () => {
    expect(service).toBeDefined();
  });

  it(\\"should have salt defined\\", () => {
    expect(service.salt).toEqual(EXAMPLE_SALT_OR_ROUNDS);
  });

  it(\\"should compare a password\\", async () => {
    const args = {
      password: EXAMPLE_PASSWORD,
      hashedPassword: EXAMPLE_HASHED_PASSWORD,
    };
    await expect(
      service.compare(args.password, args.hashedPassword)
    ).resolves.toEqual(true);
  });

  it(\\"should hash a password\\", async () => {
    await expect(service.hash(EXAMPLE_PASSWORD)).resolves.toEqual(
      EXAMPLE_HASHED_PASSWORD
    );
  });
});
",
  "server/src/auth/password.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { hash, compare } from \\"bcrypt\\";
import { ConfigService } from \\"@nestjs/config\\";

/** Salt or number of rounds to generate a salt */
export type Salt = string | number;

const BCRYPT_SALT_VAR = \\"BCRYPT_SALT\\";
const UNDEFINED_SALT_OR_ROUNDS_ERROR = \`\${BCRYPT_SALT_VAR} is not defined\`;
const SALT_OR_ROUNDS_TYPE_ERROR = \`\${BCRYPT_SALT_VAR} must be a positive integer or text\`;

@Injectable()
export class PasswordService {
  /**
   * the salt to be used to hash the password. if specified as a number then a
   * salt will be generated with the specified number of rounds and used
   */
  salt: Salt;

  constructor(private configService: ConfigService) {
    const saltOrRounds = this.configService.get(BCRYPT_SALT_VAR);
    this.salt = parseSalt(saltOrRounds);
  }

  /**
   *
   * @param password the password to be encrypted.
   * @param encrypted the encrypted password to be compared against.
   * @returns whether the password match the encrypted password
   */
  compare(password: string, encrypted: string): Promise<boolean> {
    return compare(password, encrypted);
  }

  /**
   * @param password the password to be encrypted
   * @return encrypted password
   */
  hash(password: string): Promise<string> {
    return hash(password, this.salt);
  }
}

/**
 * Parses a salt environment variable value.
 * If a number string value is given tries to parse it as a number of rounds to generate a salt
 * @param value salt environment variable value
 * @returns salt or number of rounds to generate a salt
 */
export function parseSalt(value: string | undefined): Salt {
  if (value === undefined) {
    throw new Error(UNDEFINED_SALT_OR_ROUNDS_ERROR);
  }

  const rounds = Number(value);

  if (Number.isNaN(rounds)) {
    return value;
  }
  if (!Number.isInteger(rounds) || rounds < 0) {
    throw new Error(SALT_OR_ROUNDS_TYPE_ERROR);
  }
  return rounds;
}
",
  "server/src/customer/CreateCustomerArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { CustomerCreateInput } from \\"./CustomerCreateInput\\";

@ArgsType()
class CreateCustomerArgs {
  @Field(() => CustomerCreateInput, { nullable: false })
  data!: CustomerCreateInput;
}

export { CreateCustomerArgs };
",
  "server/src/customer/Customer.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsDate,
  IsOptional,
  IsBoolean,
  IsNumber,
  IsInt,
  IsEnum,
  ValidateNested,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { EnumFavoriteColors } from \\"./EnumFavoriteColors\\";
import { EnumCustomerType } from \\"./EnumCustomerType\\";
import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";
@ObjectType()
class Customer {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName!: string | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName!: string | null;
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip!: boolean | null;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData!: Date | null;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  averageSale!: number | null;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  favoriteNumber!: number | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation!: string | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments!: string | null;
  @ApiProperty({
    required: false,
    enum: EnumFavoriteColors,
    isArray: true,
  })
  @IsEnum(EnumFavoriteColors, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumFavoriteColors], {
    nullable: true,
  })
  favoriteColors!: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;
  @ApiProperty({
    required: false,
    enum: EnumCustomerType,
  })
  @IsEnum(EnumCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerType, {
    nullable: true,
  })
  customerType!: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  organization!: OrganizationWhereUniqueInput | null;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  vipOrganization!: OrganizationWhereUniqueInput | null;
}
export { Customer };
",
  "server/src/customer/CustomerCreateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsOptional,
  IsBoolean,
  IsDate,
  IsNumber,
  IsInt,
  IsEnum,
  ValidateNested,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { EnumFavoriteColors } from \\"./EnumFavoriteColors\\";
import { EnumCustomerType } from \\"./EnumCustomerType\\";
import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";
@InputType()
class CustomerCreateInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName?: string | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName?: string | null;
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip?: boolean | null;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData?: Date | null;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  averageSale?: number | null;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  favoriteNumber?: number | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation?: string | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments?: string | null;
  @ApiProperty({
    required: false,
    enum: EnumFavoriteColors,
    isArray: true,
  })
  @IsEnum(EnumFavoriteColors, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumFavoriteColors], {
    nullable: true,
  })
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;
  @ApiProperty({
    required: false,
    enum: EnumCustomerType,
  })
  @IsEnum(EnumCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerType, {
    nullable: true,
  })
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput | null;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  vipOrganization?: OrganizationWhereUniqueInput | null;
}
export { CustomerCreateInput };
",
  "server/src/customer/CustomerUpdateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsOptional,
  IsBoolean,
  IsDate,
  IsNumber,
  IsInt,
  IsEnum,
  ValidateNested,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { EnumFavoriteColors } from \\"./EnumFavoriteColors\\";
import { EnumCustomerType } from \\"./EnumCustomerType\\";
import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";
@InputType()
class CustomerUpdateInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  email?: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName?: string | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName?: string | null;
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip?: boolean | null;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData?: Date | null;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  averageSale?: number | null;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  favoriteNumber?: number | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation?: string | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments?: string | null;
  @ApiProperty({
    required: false,
    enum: EnumFavoriteColors,
    isArray: true,
  })
  @IsEnum(EnumFavoriteColors, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumFavoriteColors], {
    nullable: true,
  })
  favoriteColors?: Array<\\"red\\" | \\"green\\" | \\"purple\\" | \\"yellow\\">;
  @ApiProperty({
    required: false,
    enum: EnumCustomerType,
  })
  @IsEnum(EnumCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerType, {
    nullable: true,
  })
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput | null;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  vipOrganization?: OrganizationWhereUniqueInput | null;
}
export { CustomerUpdateInput };
",
  "server/src/customer/CustomerWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsOptional,
  IsDate,
  IsBoolean,
  IsNumber,
  IsInt,
  IsEnum,
  ValidateNested,
} from \\"class-validator\\";

import { Type, Transform } from \\"class-transformer\\";
import { EnumCustomerType } from \\"./EnumCustomerType\\";
import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";
@InputType()
class CustomerWhereInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  id?: string;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  createdAt?: Date;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  updatedAt?: Date;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  email?: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName?: string | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName?: string | null;
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip?: boolean | null;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData?: Date | null;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  averageSale?: number | null;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  favoriteNumber?: number | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation?: string | null;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments?: string | null;
  @ApiProperty({
    required: false,
    enum: EnumCustomerType,
  })
  @IsEnum(EnumCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerType, {
    nullable: true,
  })
  customerType?: \\"platinum\\" | \\"gold\\" | \\"bronze\\" | \\"regular\\" | null;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @Transform(JSON.parse)
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  organization?: OrganizationWhereUniqueInput | null;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @Transform(JSON.parse)
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  vipOrganization?: OrganizationWhereUniqueInput | null;
}
export { CustomerWhereInput };
",
  "server/src/customer/CustomerWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class CustomerWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { CustomerWhereUniqueInput };
",
  "server/src/customer/DeleteCustomerArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";

@ArgsType()
class DeleteCustomerArgs {
  @Field(() => CustomerWhereUniqueInput, { nullable: false })
  where!: CustomerWhereUniqueInput;
}

export { DeleteCustomerArgs };
",
  "server/src/customer/EnumCustomerType.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumCustomerType {
  Platinum = \\"platinum\\",
  Gold = \\"gold\\",
  Bronze = \\"bronze\\",
  Regular = \\"regular\\",
}

registerEnumType(EnumCustomerType, {
  name: \\"EnumCustomerType\\",
});
",
  "server/src/customer/EnumFavoriteColors.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumFavoriteColors {
  Red = \\"red\\",
  Green = \\"green\\",
  Purple = \\"purple\\",
  Yellow = \\"yellow\\",
}

registerEnumType(EnumFavoriteColors, {
  name: \\"EnumFavoriteColors\\",
});
",
  "server/src/customer/FindManyCustomerArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { CustomerWhereInput } from \\"./CustomerWhereInput\\";

@ArgsType()
class FindManyCustomerArgs {
  @Field(() => CustomerWhereInput, { nullable: true })
  where?: CustomerWhereInput;
}

export { FindManyCustomerArgs };
",
  "server/src/customer/FindOneCustomerArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";

@ArgsType()
class FindOneCustomerArgs {
  @Field(() => CustomerWhereUniqueInput, { nullable: false })
  where!: CustomerWhereUniqueInput;
}

export { FindOneCustomerArgs };
",
  "server/src/customer/UpdateCustomerArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";
import { CustomerUpdateInput } from \\"./CustomerUpdateInput\\";

@ArgsType()
class UpdateCustomerArgs {
  @Field(() => CustomerWhereUniqueInput, { nullable: false })
  where!: CustomerWhereUniqueInput;
  @Field(() => CustomerUpdateInput, { nullable: false })
  data!: CustomerUpdateInput;
}

export { UpdateCustomerArgs };
",
  "server/src/customer/customer.controller.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../auth/basicAuth.guard\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { CustomerController } from \\"./customer.controller\\";
import { CustomerService } from \\"./customer.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  email: \\"exampleEmail\\",
  firstName: \\"exampleFirstName\\",
  lastName: \\"exampleLastName\\",
  isVip: \\"true\\",
  birthData: new Date(),
  averageSale: 42.42,
  favoriteNumber: 42,
  geoLocation: \\"exampleGeoLocation\\",
  comments: \\"exampleComments\\",
};
const CREATE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  email: \\"exampleEmail\\",
  firstName: \\"exampleFirstName\\",
  lastName: \\"exampleLastName\\",
  isVip: \\"true\\",
  birthData: new Date(),
  averageSale: 42.42,
  favoriteNumber: 42,
  geoLocation: \\"exampleGeoLocation\\",
  comments: \\"exampleComments\\",
};
const FIND_MANY_RESULT = [
  {
    id: \\"exampleId\\",
    createdAt: new Date(),
    updatedAt: new Date(),
    email: \\"exampleEmail\\",
    firstName: \\"exampleFirstName\\",
    lastName: \\"exampleLastName\\",
    isVip: \\"true\\",
    birthData: new Date(),
    averageSale: 42.42,
    favoriteNumber: 42,
    geoLocation: \\"exampleGeoLocation\\",
    comments: \\"exampleComments\\",
  },
];
const FIND_ONE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  email: \\"exampleEmail\\",
  firstName: \\"exampleFirstName\\",
  lastName: \\"exampleLastName\\",
  isVip: \\"true\\",
  birthData: new Date(),
  averageSale: 42.42,
  favoriteNumber: 42,
  geoLocation: \\"exampleGeoLocation\\",
  comments: \\"exampleComments\\",
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"Customer\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: CustomerService,
          useValue: service,
        },
      ],
      controllers: [CustomerController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /customers\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/customers\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
        birthData: CREATE_RESULT.birthData.toISOString(),
      });
  });

  test(\\"GET /customers\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/customers\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
          birthData: FIND_MANY_RESULT[0].birthData.toISOString(),
        },
      ]);
  });

  test(\\"GET /customers/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/customers\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /customers/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/customers\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
        birthData: FIND_ONE_RESULT.birthData.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/customer/customer.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../auth/basicAuth.guard\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import * as errors from \\"../errors\\";
import { CustomerService } from \\"./customer.service\\";
import { CustomerCreateInput } from \\"./CustomerCreateInput\\";
import { CustomerWhereInput } from \\"./CustomerWhereInput\\";
import { CustomerWhereUniqueInput } from \\"./CustomerWhereUniqueInput\\";
import { CustomerUpdateInput } from \\"./CustomerUpdateInput\\";
import { Customer } from \\"./Customer\\";
import { OrderWhereInput } from \\"../order/OrderWhereInput\\";
import { Order } from \\"../order/Order\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"customers\\")
@common.Controller(\\"customers\\")
export class CustomerController {
  constructor(
    private readonly service: CustomerService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: Customer })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Query() query: {},
    @common.Body() data: CustomerCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Customer\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...query,
      data: {
        ...data,

        organization: data.organization
          ? {
              connect: data.organization,
            }
          : undefined,

        vipOrganization: data.vipOrganization
          ? {
              connect: data.vipOrganization,
            }
          : undefined,
      },
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [Customer] })
  @swagger.ApiForbiddenResponse()
  async findMany(
    @common.Query() query: CustomerWhereInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findMany({
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: Customer })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Query() query: {},
    @common.Param() params: CustomerWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Customer\\",
    });
    const result = await this.service.findOne({
      ...query,
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Customer })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Query() query: {},
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body()
    data: CustomerUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Customer\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...query,
        where: params,
        data: {
          ...data,

          organization: data.organization
            ? {
                connect: data.organization,
              }
            : undefined,

          vipOrganization: data.vipOrganization
            ? {
                connect: data.vipOrganization,
              }
            : undefined,
        },
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          email: true,
          firstName: true,
          lastName: true,
          isVip: true,
          birthData: true,
          averageSale: true,
          favoriteNumber: true,
          geoLocation: true,
          comments: true,
          favoriteColors: true,
          customerType: true,

          organization: {
            select: {
              id: true,
            },
          },

          vipOrganization: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Customer })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Query() query: {},
    @common.Param() params: CustomerWhereUniqueInput
  ): Promise<Customer | null> {
    try {
      return await this.service.delete({
        ...query,
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          email: true,
          firstName: true,
          lastName: true,
          isVip: true,
          birthData: true,
          averageSale: true,
          favoriteNumber: true,
          geoLocation: true,
          comments: true,
          favoriteColors: true,
          customerType: true,

          organization: {
            select: {
              id: true,
            },
          },

          vipOrganization: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/orders\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async findManyOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Query() query: OrderWhereInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const results = await this.service.findOne({ where: params }).orders({
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/orders\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      orders: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Customer\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/orders\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      orders: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Customer\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/orders\\")
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      orders: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Customer\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }
}
",
  "server/src/customer/customer.module.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { AuthModule } from \\"../auth/auth.module\\";
import { CustomerService } from \\"./customer.service\\";
import { CustomerController } from \\"./customer.controller\\";
import { CustomerResolver } from \\"./customer.resolver\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],
  controllers: [CustomerController],
  providers: [CustomerService, CustomerResolver],
  exports: [CustomerService],
})
export class CustomerModule {}
",
  "server/src/customer/customer.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import { CustomerService } from \\"./customer.service\\";
import { CreateCustomerArgs } from \\"./CreateCustomerArgs\\";
import { UpdateCustomerArgs } from \\"./UpdateCustomerArgs\\";
import { DeleteCustomerArgs } from \\"./DeleteCustomerArgs\\";
import { FindManyCustomerArgs } from \\"./FindManyCustomerArgs\\";
import { FindOneCustomerArgs } from \\"./FindOneCustomerArgs\\";
import { Customer } from \\"./Customer\\";
import { FindManyOrderArgs } from \\"../order/FindManyOrderArgs\\";
import { Order } from \\"../order/Order\\";
import { Organization } from \\"../organization/Organization\\";

@graphql.Resolver(() => Customer)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class CustomerResolver {
  constructor(
    private readonly service: CustomerService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => [Customer])
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async customers(
    @graphql.Args() args: FindManyCustomerArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => Customer, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async customer(
    @graphql.Args() args: FindOneCustomerArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Customer\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => Customer)
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  async createCustomer(
    @graphql.Args() args: CreateCustomerArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Customer\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...args,
      data: {
        ...args.data,

        organization: args.data.organization
          ? {
              connect: args.data.organization,
            }
          : undefined,

        vipOrganization: args.data.vipOrganization
          ? {
              connect: args.data.vipOrganization,
            }
          : undefined,
      },
    });
  }

  @graphql.Mutation(() => Customer)
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateCustomer(
    @graphql.Args() args: UpdateCustomerArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Customer\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...args,
        data: {
          ...args.data,

          organization: args.data.organization
            ? {
                connect: args.data.organization,
              }
            : undefined,

          vipOrganization: args.data.vipOrganization
            ? {
                connect: args.data.vipOrganization,
              }
            : undefined,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => Customer)
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteCustomer(
    @graphql.Args() args: DeleteCustomerArgs
  ): Promise<Customer | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => [Order])
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async orders(
    @graphql.Parent() parent: Customer,
    @graphql.Args() args: FindManyOrderArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const results = await this.service
      .findOne({ where: { id: parent.id } })
      // @ts-ignore
      .orders(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => Organization, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async organization(
    @graphql.Parent() parent: Customer,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const result = await this.service
      .findOne({ where: { id: parent.id } })
      .organization();

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.ResolveField(() => Organization, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Customer\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async organization(
    @graphql.Parent() parent: Customer,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const result = await this.service
      .findOne({ where: { id: parent.id } })
      .vipOrganization();

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }
}
",
  "server/src/customer/customer.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";
import {
  FindOneCustomerArgs,
  FindManyCustomerArgs,
  CustomerCreateArgs,
  CustomerUpdateArgs,
  CustomerDeleteArgs,
  Subset,
} from \\"@prisma/client\\";

@Injectable()
export class CustomerService {
  constructor(private readonly prisma: PrismaService) {}
  findMany<T extends FindManyCustomerArgs>(
    args: Subset<T, FindManyCustomerArgs>
  ) {
    return this.prisma.customer.findMany(args);
  }
  findOne<T extends FindOneCustomerArgs>(args: Subset<T, FindOneCustomerArgs>) {
    return this.prisma.customer.findOne(args);
  }
  create<T extends CustomerCreateArgs>(args: Subset<T, CustomerCreateArgs>) {
    return this.prisma.customer.create<T>(args);
  }
  update<T extends CustomerUpdateArgs>(args: Subset<T, CustomerUpdateArgs>) {
    return this.prisma.customer.update<T>(args);
  }
  delete<T extends CustomerDeleteArgs>(args: Subset<T, CustomerDeleteArgs>) {
    return this.prisma.customer.delete(args);
  }
}
",
  "server/src/empty/DeleteEmptyArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";

@ArgsType()
class DeleteEmptyArgs {
  @Field(() => EmptyWhereUniqueInput, { nullable: false })
  where!: EmptyWhereUniqueInput;
}

export { DeleteEmptyArgs };
",
  "server/src/empty/Empty.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString, IsDate } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
@ObjectType()
class Empty {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;
}
export { Empty };
",
  "server/src/empty/EmptyCreateInput.ts": "class EmptyCreateInput {}
export { EmptyCreateInput };
",
  "server/src/empty/EmptyUpdateInput.ts": "class EmptyUpdateInput {}
export { EmptyUpdateInput };
",
  "server/src/empty/EmptyWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString, IsOptional, IsDate } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
@InputType()
class EmptyWhereInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  id?: string;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  createdAt?: Date;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  updatedAt?: Date;
}
export { EmptyWhereInput };
",
  "server/src/empty/EmptyWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class EmptyWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { EmptyWhereUniqueInput };
",
  "server/src/empty/FindManyEmptyArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { EmptyWhereInput } from \\"./EmptyWhereInput\\";

@ArgsType()
class FindManyEmptyArgs {
  @Field(() => EmptyWhereInput, { nullable: true })
  where?: EmptyWhereInput;
}

export { FindManyEmptyArgs };
",
  "server/src/empty/FindOneEmptyArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";

@ArgsType()
class FindOneEmptyArgs {
  @Field(() => EmptyWhereUniqueInput, { nullable: false })
  where!: EmptyWhereUniqueInput;
}

export { FindOneEmptyArgs };
",
  "server/src/empty/empty.controller.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../auth/basicAuth.guard\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { EmptyController } from \\"./empty.controller\\";
import { EmptyService } from \\"./empty.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const CREATE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const FIND_MANY_RESULT = [
  {
    id: \\"exampleId\\",
    createdAt: new Date(),
    updatedAt: new Date(),
  },
];
const FIND_ONE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"Empty\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: EmptyService,
          useValue: service,
        },
      ],
      controllers: [EmptyController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /empties\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/empties\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test(\\"GET /empties\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/empties\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test(\\"GET /empties/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/empties\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /empties/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/empties\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/empty/empty.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../auth/basicAuth.guard\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import * as errors from \\"../errors\\";
import { EmptyService } from \\"./empty.service\\";
import { EmptyCreateInput } from \\"./EmptyCreateInput\\";
import { EmptyWhereInput } from \\"./EmptyWhereInput\\";
import { EmptyWhereUniqueInput } from \\"./EmptyWhereUniqueInput\\";
import { EmptyUpdateInput } from \\"./EmptyUpdateInput\\";
import { Empty } from \\"./Empty\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"empties\\")
@common.Controller(\\"empties\\")
export class EmptyController {
  constructor(
    private readonly service: EmptyService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: Empty })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Query() query: {},
    @common.Body() data: EmptyCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Empty> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Empty\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Empty\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...query,
      data: data,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [Empty] })
  @swagger.ApiForbiddenResponse()
  async findMany(
    @common.Query() query: EmptyWhereInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Empty[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Empty\\",
    });
    const results = await this.service.findMany({
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: Empty })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Query() query: {},
    @common.Param() params: EmptyWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Empty | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Empty\\",
    });
    const result = await this.service.findOne({
      ...query,
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Empty })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Query() query: {},
    @common.Param() params: EmptyWhereUniqueInput,
    @common.Body()
    data: EmptyUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Empty | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Empty\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Empty\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...query,
        where: params,
        data: data,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Empty })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Query() query: {},
    @common.Param() params: EmptyWhereUniqueInput
  ): Promise<Empty | null> {
    try {
      return await this.service.delete({
        ...query,
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/empty/empty.module.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { AuthModule } from \\"../auth/auth.module\\";
import { EmptyService } from \\"./empty.service\\";
import { EmptyController } from \\"./empty.controller\\";
import { EmptyResolver } from \\"./empty.resolver\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],
  controllers: [EmptyController],
  providers: [EmptyService, EmptyResolver],
  exports: [EmptyService],
})
export class EmptyModule {}
",
  "server/src/empty/empty.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import { EmptyService } from \\"./empty.service\\";
import { DeleteEmptyArgs } from \\"./DeleteEmptyArgs\\";
import { FindManyEmptyArgs } from \\"./FindManyEmptyArgs\\";
import { FindOneEmptyArgs } from \\"./FindOneEmptyArgs\\";
import { Empty } from \\"./Empty\\";

@graphql.Resolver(() => Empty)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class EmptyResolver {
  constructor(
    private readonly service: EmptyService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => [Empty])
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async empties(
    @graphql.Args() args: FindManyEmptyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Empty[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Empty\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => Empty, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async empty(
    @graphql.Args() args: FindOneEmptyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Empty | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Empty\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => Empty)
  @nestAccessControl.UseRoles({
    resource: \\"Empty\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteEmpty(
    @graphql.Args() args: DeleteEmptyArgs
  ): Promise<Empty | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/empty/empty.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";
import {
  FindOneEmptyArgs,
  FindManyEmptyArgs,
  EmptyCreateArgs,
  EmptyUpdateArgs,
  EmptyDeleteArgs,
  Subset,
} from \\"@prisma/client\\";

@Injectable()
export class EmptyService {
  constructor(private readonly prisma: PrismaService) {}
  findMany<T extends FindManyEmptyArgs>(args: Subset<T, FindManyEmptyArgs>) {
    return this.prisma.empty.findMany(args);
  }
  findOne<T extends FindOneEmptyArgs>(args: Subset<T, FindOneEmptyArgs>) {
    return this.prisma.empty.findOne(args);
  }
  create<T extends EmptyCreateArgs>(args: Subset<T, EmptyCreateArgs>) {
    return this.prisma.empty.create<T>(args);
  }
  update<T extends EmptyUpdateArgs>(args: Subset<T, EmptyUpdateArgs>) {
    return this.prisma.empty.update<T>(args);
  }
  delete<T extends EmptyDeleteArgs>(args: Subset<T, EmptyDeleteArgs>) {
    return this.prisma.empty.delete(args);
  }
}
",
  "server/src/errors.ts": "import * as common from \\"@nestjs/common\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

export class ForbiddenException extends common.ForbiddenException {
  @ApiProperty()
  statusCode!: number;
  @ApiProperty()
  message!: string;
}

export class NotFoundException extends common.NotFoundException {
  @ApiProperty()
  statusCode!: number;
  @ApiProperty()
  message!: string;
}
",
  "server/src/main.ts": "import { ValidationPipe } from \\"@nestjs/common\\";
import { NestFactory } from \\"@nestjs/core\\";
import { SwaggerModule } from \\"@nestjs/swagger\\";
// @ts-ignore
// eslint-disable-next-line
import { AppModule } from \\"./app.module\\";
import {
  swaggerPath,
  swaggerDocumentOptions,
  swaggerSetupOptions,
  // @ts-ignore
  // eslint-disable-next-line
} from \\"./swagger\\";

const { PORT = 3000 } = process.env;

async function main() {
  const app = await NestFactory.create(AppModule, { cors: true });

  app.setGlobalPrefix(\\"api\\");
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
    })
  );

  const document = SwaggerModule.createDocument(app, swaggerDocumentOptions);

  SwaggerModule.setup(swaggerPath, app, document, swaggerSetupOptions);

  void app.listen(PORT);

  return app;
}

module.exports = main();
",
  "server/src/order/CreateOrderArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrderCreateInput } from \\"./OrderCreateInput\\";

@ArgsType()
class CreateOrderArgs {
  @Field(() => OrderCreateInput, { nullable: false })
  data!: OrderCreateInput;
}

export { CreateOrderArgs };
",
  "server/src/order/DeleteOrderArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";

@ArgsType()
class DeleteOrderArgs {
  @Field(() => OrderWhereUniqueInput, { nullable: false })
  where!: OrderWhereUniqueInput;
}

export { DeleteOrderArgs };
",
  "server/src/order/EnumLabel.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumLabel {
  Fragile = \\"fragile\\",
}

registerEnumType(EnumLabel, {
  name: \\"EnumLabel\\",
});
",
  "server/src/order/EnumStatus.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumStatus {
  Pending = \\"pending\\",
  InProgress = \\"inProgress\\",
  Done = \\"done\\",
}

registerEnumType(EnumStatus, {
  name: \\"EnumStatus\\",
});
",
  "server/src/order/FindManyOrderArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrderWhereInput } from \\"./OrderWhereInput\\";

@ArgsType()
class FindManyOrderArgs {
  @Field(() => OrderWhereInput, { nullable: true })
  where?: OrderWhereInput;
}

export { FindManyOrderArgs };
",
  "server/src/order/FindOneOrderArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";

@ArgsType()
class FindOneOrderArgs {
  @Field(() => OrderWhereUniqueInput, { nullable: false })
  where!: OrderWhereUniqueInput;
}

export { FindOneOrderArgs };
",
  "server/src/order/Order.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import {
  IsString,
  IsDate,
  ValidateNested,
  IsEnum,
  IsOptional,
} from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";
import { EnumStatus } from \\"./EnumStatus\\";
import { EnumLabel } from \\"./EnumLabel\\";
@ObjectType()
class Order {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;
  @ApiProperty({
    required: true,
    type: CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  customer!: CustomerWhereUniqueInput;
  @ApiProperty({
    required: true,
    enum: EnumStatus,
  })
  @IsEnum(EnumStatus)
  @Field(() => EnumStatus)
  status!: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  @ApiProperty({
    required: false,
    enum: EnumLabel,
  })
  @IsEnum(EnumLabel)
  @IsOptional()
  @Field(() => EnumLabel, {
    nullable: true,
  })
  label!: \\"fragile\\" | null;
}
export { Order };
",
  "server/src/order/OrderCreateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";
import { ValidateNested, IsEnum, IsOptional } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
import { EnumStatus } from \\"./EnumStatus\\";
import { EnumLabel } from \\"./EnumLabel\\";
@InputType()
class OrderCreateInput {
  @ApiProperty({
    required: true,
    type: CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @Field(() => CustomerWhereUniqueInput)
  customer!: CustomerWhereUniqueInput;
  @ApiProperty({
    required: true,
    enum: EnumStatus,
  })
  @IsEnum(EnumStatus)
  @Field(() => EnumStatus)
  status!: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  @ApiProperty({
    required: false,
    enum: EnumLabel,
  })
  @IsEnum(EnumLabel)
  @IsOptional()
  @Field(() => EnumLabel, {
    nullable: true,
  })
  label?: \\"fragile\\" | null;
}
export { OrderCreateInput };
",
  "server/src/order/OrderUpdateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";
import { ValidateNested, IsOptional, IsEnum } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
import { EnumStatus } from \\"./EnumStatus\\";
import { EnumLabel } from \\"./EnumLabel\\";
@InputType()
class OrderUpdateInput {
  @ApiProperty({
    required: false,
    type: CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @IsOptional()
  @Field(() => CustomerWhereUniqueInput, {
    nullable: true,
  })
  customer?: CustomerWhereUniqueInput;
  @ApiProperty({
    required: false,
    enum: EnumStatus,
  })
  @IsEnum(EnumStatus)
  @IsOptional()
  @Field(() => EnumStatus, {
    nullable: true,
  })
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  @ApiProperty({
    required: false,
    enum: EnumLabel,
  })
  @IsEnum(EnumLabel)
  @IsOptional()
  @Field(() => EnumLabel, {
    nullable: true,
  })
  label?: \\"fragile\\" | null;
}
export { OrderUpdateInput };
",
  "server/src/order/OrderWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import {
  IsString,
  IsOptional,
  IsDate,
  ValidateNested,
  IsEnum,
} from \\"class-validator\\";
import { Type, Transform } from \\"class-transformer\\";
import { CustomerWhereUniqueInput } from \\"../customer/CustomerWhereUniqueInput\\";
import { EnumStatus } from \\"./EnumStatus\\";
import { EnumLabel } from \\"./EnumLabel\\";
@InputType()
class OrderWhereInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  id?: string;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  createdAt?: Date;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  updatedAt?: Date;
  @ApiProperty({
    required: false,
    type: CustomerWhereUniqueInput,
  })
  @Transform(JSON.parse)
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @IsOptional()
  customer?: CustomerWhereUniqueInput;
  @ApiProperty({
    required: false,
    enum: EnumStatus,
  })
  @IsEnum(EnumStatus)
  @IsOptional()
  @Field(() => EnumStatus, {
    nullable: true,
  })
  status?: \\"pending\\" | \\"inProgress\\" | \\"done\\";
  @ApiProperty({
    required: false,
    enum: EnumLabel,
  })
  @IsEnum(EnumLabel)
  @IsOptional()
  @Field(() => EnumLabel, {
    nullable: true,
  })
  label?: \\"fragile\\" | null;
}
export { OrderWhereInput };
",
  "server/src/order/OrderWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class OrderWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { OrderWhereUniqueInput };
",
  "server/src/order/UpdateOrderArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";
import { OrderUpdateInput } from \\"./OrderUpdateInput\\";

@ArgsType()
class UpdateOrderArgs {
  @Field(() => OrderWhereUniqueInput, { nullable: false })
  where!: OrderWhereUniqueInput;
  @Field(() => OrderUpdateInput, { nullable: false })
  data!: OrderUpdateInput;
}

export { UpdateOrderArgs };
",
  "server/src/order/order.controller.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../auth/basicAuth.guard\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { OrderController } from \\"./order.controller\\";
import { OrderService } from \\"./order.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const CREATE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const FIND_MANY_RESULT = [
  {
    id: \\"exampleId\\",
    createdAt: new Date(),
    updatedAt: new Date(),
  },
];
const FIND_ONE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"Order\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: OrderService,
          useValue: service,
        },
      ],
      controllers: [OrderController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /orders\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/orders\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test(\\"GET /orders\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/orders\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test(\\"GET /orders/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/orders\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /orders/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/orders\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/order/order.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../auth/basicAuth.guard\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import * as errors from \\"../errors\\";
import { OrderService } from \\"./order.service\\";
import { OrderCreateInput } from \\"./OrderCreateInput\\";
import { OrderWhereInput } from \\"./OrderWhereInput\\";
import { OrderWhereUniqueInput } from \\"./OrderWhereUniqueInput\\";
import { OrderUpdateInput } from \\"./OrderUpdateInput\\";
import { Order } from \\"./Order\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"orders\\")
@common.Controller(\\"orders\\")
export class OrderController {
  constructor(
    private readonly service: OrderService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: Order })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Query() query: {},
    @common.Body() data: OrderCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Order\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...query,
      data: {
        ...data,

        customer: {
          connect: data.customer,
        },
      },
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [Order] })
  @swagger.ApiForbiddenResponse()
  async findMany(
    @common.Query() query: OrderWhereInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const results = await this.service.findMany({
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: Order })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Query() query: {},
    @common.Param() params: OrderWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Order\\",
    });
    const result = await this.service.findOne({
      ...query,
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Order })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Query() query: {},
    @common.Param() params: OrderWhereUniqueInput,
    @common.Body()
    data: OrderUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Order | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Order\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...query,
        where: params,
        data: {
          ...data,

          customer: {
            connect: data.customer,
          },
        },
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,

          customer: {
            select: {
              id: true,
            },
          },

          status: true,
          label: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Order })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Query() query: {},
    @common.Param() params: OrderWhereUniqueInput
  ): Promise<Order | null> {
    try {
      return await this.service.delete({
        ...query,
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,

          customer: {
            select: {
              id: true,
            },
          },

          status: true,
          label: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/order/order.module.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { AuthModule } from \\"../auth/auth.module\\";
import { OrderService } from \\"./order.service\\";
import { OrderController } from \\"./order.controller\\";
import { OrderResolver } from \\"./order.resolver\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],
  controllers: [OrderController],
  providers: [OrderService, OrderResolver],
  exports: [OrderService],
})
export class OrderModule {}
",
  "server/src/order/order.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import { OrderService } from \\"./order.service\\";
import { CreateOrderArgs } from \\"./CreateOrderArgs\\";
import { UpdateOrderArgs } from \\"./UpdateOrderArgs\\";
import { DeleteOrderArgs } from \\"./DeleteOrderArgs\\";
import { FindManyOrderArgs } from \\"./FindManyOrderArgs\\";
import { FindOneOrderArgs } from \\"./FindOneOrderArgs\\";
import { Order } from \\"./Order\\";
import { Customer } from \\"../customer/Customer\\";

@graphql.Resolver(() => Order)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class OrderResolver {
  constructor(
    private readonly service: OrderService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => [Order])
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async orders(
    @graphql.Args() args: FindManyOrderArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => Order, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async order(
    @graphql.Args() args: FindOneOrderArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Order\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => Order)
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  async createOrder(
    @graphql.Args() args: CreateOrderArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Order\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...args,
      data: {
        ...args.data,

        customer: {
          connect: args.data.customer,
        },
      },
    });
  }

  @graphql.Mutation(() => Order)
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateOrder(
    @graphql.Args() args: UpdateOrderArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Order | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Order\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Order\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...args,
        data: {
          ...args.data,

          customer: {
            connect: args.data.customer,
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => Order)
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteOrder(
    @graphql.Args() args: DeleteOrderArgs
  ): Promise<Order | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => Customer, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Order\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async customer(
    @graphql.Parent() parent: Order,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const result = await this.service
      .findOne({ where: { id: parent.id } })
      .customer();

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }
}
",
  "server/src/order/order.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";
import {
  FindOneOrderArgs,
  FindManyOrderArgs,
  OrderCreateArgs,
  OrderUpdateArgs,
  OrderDeleteArgs,
  Subset,
} from \\"@prisma/client\\";

@Injectable()
export class OrderService {
  constructor(private readonly prisma: PrismaService) {}
  findMany<T extends FindManyOrderArgs>(args: Subset<T, FindManyOrderArgs>) {
    return this.prisma.order.findMany(args);
  }
  findOne<T extends FindOneOrderArgs>(args: Subset<T, FindOneOrderArgs>) {
    return this.prisma.order.findOne(args);
  }
  create<T extends OrderCreateArgs>(args: Subset<T, OrderCreateArgs>) {
    return this.prisma.order.create<T>(args);
  }
  update<T extends OrderUpdateArgs>(args: Subset<T, OrderUpdateArgs>) {
    return this.prisma.order.update<T>(args);
  }
  delete<T extends OrderDeleteArgs>(args: Subset<T, OrderDeleteArgs>) {
    return this.prisma.order.delete(args);
  }
}
",
  "server/src/organization/CreateOrganizationArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrganizationCreateInput } from \\"./OrganizationCreateInput\\";

@ArgsType()
class CreateOrganizationArgs {
  @Field(() => OrganizationCreateInput, { nullable: false })
  data!: OrganizationCreateInput;
}

export { CreateOrganizationArgs };
",
  "server/src/organization/DeleteOrganizationArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";

@ArgsType()
class DeleteOrganizationArgs {
  @Field(() => OrganizationWhereUniqueInput, { nullable: false })
  where!: OrganizationWhereUniqueInput;
}

export { DeleteOrganizationArgs };
",
  "server/src/organization/FindManyOrganizationArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrganizationWhereInput } from \\"./OrganizationWhereInput\\";

@ArgsType()
class FindManyOrganizationArgs {
  @Field(() => OrganizationWhereInput, { nullable: true })
  where?: OrganizationWhereInput;
}

export { FindManyOrganizationArgs };
",
  "server/src/organization/FindOneOrganizationArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";

@ArgsType()
class FindOneOrganizationArgs {
  @Field(() => OrganizationWhereUniqueInput, { nullable: false })
  where!: OrganizationWhereUniqueInput;
}

export { FindOneOrganizationArgs };
",
  "server/src/organization/Organization.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString, IsDate } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
@ObjectType()
class Organization {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;
}
export { Organization };
",
  "server/src/organization/OrganizationCreateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class OrganizationCreateInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;
}
export { OrganizationCreateInput };
",
  "server/src/organization/OrganizationUpdateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString, IsOptional } from \\"class-validator\\";
@InputType()
class OrganizationUpdateInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  name?: string;
}
export { OrganizationUpdateInput };
",
  "server/src/organization/OrganizationWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString, IsOptional, IsDate } from \\"class-validator\\";
import { Type } from \\"class-transformer\\";
@InputType()
class OrganizationWhereInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  id?: string;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  createdAt?: Date;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  updatedAt?: Date;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  name?: string;
}
export { OrganizationWhereInput };
",
  "server/src/organization/OrganizationWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class OrganizationWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { OrganizationWhereUniqueInput };
",
  "server/src/organization/UpdateOrganizationArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";
import { OrganizationUpdateInput } from \\"./OrganizationUpdateInput\\";

@ArgsType()
class UpdateOrganizationArgs {
  @Field(() => OrganizationWhereUniqueInput, { nullable: false })
  where!: OrganizationWhereUniqueInput;
  @Field(() => OrganizationUpdateInput, { nullable: false })
  data!: OrganizationUpdateInput;
}

export { UpdateOrganizationArgs };
",
  "server/src/organization/organization.controller.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../auth/basicAuth.guard\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { OrganizationController } from \\"./organization.controller\\";
import { OrganizationService } from \\"./organization.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: \\"exampleName\\",
};
const CREATE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: \\"exampleName\\",
};
const FIND_MANY_RESULT = [
  {
    id: \\"exampleId\\",
    createdAt: new Date(),
    updatedAt: new Date(),
    name: \\"exampleName\\",
  },
];
const FIND_ONE_RESULT = {
  id: \\"exampleId\\",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: \\"exampleName\\",
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"Organization\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: OrganizationService,
          useValue: service,
        },
      ],
      controllers: [OrganizationController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /organizations\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/organizations\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test(\\"GET /organizations\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/organizations\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test(\\"GET /organizations/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/organizations\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /organizations/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/organizations\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/organization/organization.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../auth/basicAuth.guard\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import * as errors from \\"../errors\\";
import { OrganizationService } from \\"./organization.service\\";
import { OrganizationCreateInput } from \\"./OrganizationCreateInput\\";
import { OrganizationWhereInput } from \\"./OrganizationWhereInput\\";
import { OrganizationWhereUniqueInput } from \\"./OrganizationWhereUniqueInput\\";
import { OrganizationUpdateInput } from \\"./OrganizationUpdateInput\\";
import { Organization } from \\"./Organization\\";
import { UserWhereInput } from \\"../user/UserWhereInput\\";
import { User } from \\"../user/User\\";
import { CustomerWhereInput } from \\"../customer/CustomerWhereInput\\";
import { Customer } from \\"../customer/Customer\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"organizations\\")
@common.Controller(\\"organizations\\")
export class OrganizationController {
  constructor(
    private readonly service: OrganizationService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: Organization })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Query() query: {},
    @common.Body() data: OrganizationCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Organization> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Organization\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...query,
      data: data,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [Organization] })
  @swagger.ApiForbiddenResponse()
  async findMany(
    @common.Query() query: OrganizationWhereInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Organization[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const results = await this.service.findMany({
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: Organization })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Query() query: {},
    @common.Param() params: OrganizationWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Organization\\",
    });
    const result = await this.service.findOne({
      ...query,
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Organization })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Query() query: {},
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body()
    data: OrganizationUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"Organization\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...query,
        where: params,
        data: data,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          name: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: Organization })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Query() query: {},
    @common.Param() params: OrganizationWhereUniqueInput
  ): Promise<Organization | null> {
    try {
      return await this.service.delete({
        ...query,
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          name: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/users\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async findManyUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Query() query: UserWhereInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service.findOne({ where: params }).users({
      where: query,
      select: {
        username: true,
        roles: true,
        id: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        organization: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/users\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      users: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/users\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      users: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/users\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      users: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/customers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async findManyCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Query() query: CustomerWhereInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findOne({ where: params }).customers({
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/customers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      customers: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/customers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      customers: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/customers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      customers: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id/vipCustomers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async findManyVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Query() query: CustomerWhereInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service.findOne({ where: params }).vipCustomers({
      where: query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post(\\"/:id/vipCustomers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async createVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      vipCustomers: {
        connect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id/vipCustomers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      vipCustomers: {
        set: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id/vipCustomers\\")
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async deleteVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[],
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<void> {
    const data = {
      vipCustomers: {
        disconnect: body,
      },
    };
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new common.ForbiddenException(
        \`Updating the relationship: \${
          invalidAttributes[0]
        } of \${\\"Organization\\"} is forbidden for roles: \${roles}\`
      );
    }
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }
}
",
  "server/src/organization/organization.module.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { AuthModule } from \\"../auth/auth.module\\";
import { OrganizationService } from \\"./organization.service\\";
import { OrganizationController } from \\"./organization.controller\\";
import { OrganizationResolver } from \\"./organization.resolver\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],
  controllers: [OrganizationController],
  providers: [OrganizationService, OrganizationResolver],
  exports: [OrganizationService],
})
export class OrganizationModule {}
",
  "server/src/organization/organization.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import { OrganizationService } from \\"./organization.service\\";
import { CreateOrganizationArgs } from \\"./CreateOrganizationArgs\\";
import { UpdateOrganizationArgs } from \\"./UpdateOrganizationArgs\\";
import { DeleteOrganizationArgs } from \\"./DeleteOrganizationArgs\\";
import { FindManyOrganizationArgs } from \\"./FindManyOrganizationArgs\\";
import { FindOneOrganizationArgs } from \\"./FindOneOrganizationArgs\\";
import { Organization } from \\"./Organization\\";
import { FindManyUserArgs } from \\"../user/FindManyUserArgs\\";
import { User } from \\"../user/User\\";
import { FindManyCustomerArgs } from \\"../customer/FindManyCustomerArgs\\";
import { Customer } from \\"../customer/Customer\\";

@graphql.Resolver(() => Organization)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class OrganizationResolver {
  constructor(
    private readonly service: OrganizationService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => [Organization])
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async organizations(
    @graphql.Args() args: FindManyOrganizationArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => Organization, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async organization(
    @graphql.Args() args: FindOneOrganizationArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"Organization\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => Organization)
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  async createOrganization(
    @graphql.Args() args: CreateOrganizationArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Organization\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...args,
      data: args.data,
    });
  }

  @graphql.Mutation(() => Organization)
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateOrganization(
    @graphql.Args() args: UpdateOrganizationArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"Organization\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...args,
        data: args.data,
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => Organization)
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteOrganization(
    @graphql.Args() args: DeleteOrganizationArgs
  ): Promise<Organization | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => [User])
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async users(
    @graphql.Parent() parent: Organization,
    @graphql.Args() args: FindManyUserArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service
      .findOne({ where: { id: parent.id } })
      // @ts-ignore
      .users(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [Customer])
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async customers(
    @graphql.Parent() parent: Organization,
    @graphql.Args() args: FindManyCustomerArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service
      .findOne({ where: { id: parent.id } })
      // @ts-ignore
      .customers(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [Customer])
  @nestAccessControl.UseRoles({
    resource: \\"Organization\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async customers(
    @graphql.Parent() parent: Organization,
    @graphql.Args() args: FindManyCustomerArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Customer[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Customer\\",
    });
    const results = await this.service
      .findOne({ where: { id: parent.id } })
      // @ts-ignore
      .vipCustomers(args);
    return results.map((result) => permission.filter(result));
  }
}
",
  "server/src/organization/organization.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";
import {
  FindOneOrganizationArgs,
  FindManyOrganizationArgs,
  OrganizationCreateArgs,
  OrganizationUpdateArgs,
  OrganizationDeleteArgs,
  Subset,
} from \\"@prisma/client\\";

@Injectable()
export class OrganizationService {
  constructor(private readonly prisma: PrismaService) {}
  findMany<T extends FindManyOrganizationArgs>(
    args: Subset<T, FindManyOrganizationArgs>
  ) {
    return this.prisma.organization.findMany(args);
  }
  findOne<T extends FindOneOrganizationArgs>(
    args: Subset<T, FindOneOrganizationArgs>
  ) {
    return this.prisma.organization.findOne(args);
  }
  create<T extends OrganizationCreateArgs>(
    args: Subset<T, OrganizationCreateArgs>
  ) {
    return this.prisma.organization.create<T>(args);
  }
  update<T extends OrganizationUpdateArgs>(
    args: Subset<T, OrganizationUpdateArgs>
  ) {
    return this.prisma.organization.update<T>(args);
  }
  delete<T extends OrganizationDeleteArgs>(
    args: Subset<T, OrganizationDeleteArgs>
  ) {
    return this.prisma.organization.delete(args);
  }
}
",
  "server/src/prisma.util.spec.ts": "import {
  isRecordNotFoundError,
  PRISMA_QUERY_INTERPRETATION_ERROR,
} from \\"./prisma.util\\";

describe(\\"isRecordNotFoundError\\", () => {
  test(\\"returns true for record not found error\\", () => {
    expect(
      isRecordNotFoundError(
        Object.assign(
          new Error(\`Error occurred during query execution:
        InterpretationError(\\"Error for binding '0': RecordNotFound(\\"Record to update not found.\\")\\")\`),
          {
            code: PRISMA_QUERY_INTERPRETATION_ERROR,
          }
        )
      )
    ).toBe(true);
  });
  test(\\"returns false for any other error\\", () => {
    expect(isRecordNotFoundError(new Error())).toBe(false);
  });
});
",
  "server/src/prisma.util.ts": "export const PRISMA_QUERY_INTERPRETATION_ERROR = \\"P2016\\";
export const PRISMA_RECORD_NOT_FOUND = \\"RecordNotFound\\";

export function isRecordNotFoundError(
  error: Error & { code?: string }
): boolean {
  return (
    \\"code\\" in error &&
    error.code === PRISMA_QUERY_INTERPRETATION_ERROR &&
    error.message.includes(PRISMA_RECORD_NOT_FOUND)
  );
}

export async function transformStringFieldUpdateInput<
  T extends undefined | string | { set?: string }
>(input: T, transform: (input: string) => Promise<string>): Promise<T> {
  if (typeof input === \\"object\\" && typeof input?.set === \\"string\\") {
    return { set: await transform(input.set) } as T;
  }
  if (typeof input === \\"object\\") {
    if (typeof input.set === \\"string\\") {
      return { set: await transform(input.set) } as T;
    }
    return input;
  }
  if (typeof input === \\"string\\") {
    return (await transform(input)) as T;
  }
  return input;
}
",
  "server/src/serveStaticOptions.service.ts": "import * as path from \\"path\\";
import { Injectable, Logger } from \\"@nestjs/common\\";
import { ConfigService } from \\"@nestjs/config\\";
import {
  ServeStaticModuleOptions,
  ServeStaticModuleOptionsFactory,
} from \\"@nestjs/serve-static\\";

const SERVE_STATIC_ROOT_PATH_VAR = \\"SERVE_STATIC_ROOT_PATH\\";
const DEFAULT_STATIC_MODULE_OPTIONS_LIST: ServeStaticModuleOptions[] = [
  {
    serveRoot: \\"/swagger\\",
    rootPath: path.join(__dirname, \\"swagger\\"),
  },
];

@Injectable()
export class ServeStaticOptionsService
  implements ServeStaticModuleOptionsFactory {
  private readonly logger = new Logger(ServeStaticOptionsService.name);

  constructor(private readonly configService: ConfigService) {}

  createLoggerOptions(): ServeStaticModuleOptions[] {
    const serveStaticRootPath = this.configService.get(
      SERVE_STATIC_ROOT_PATH_VAR
    );
    if (serveStaticRootPath) {
      const resolvedPath = path.resolve(serveStaticRootPath);
      this.logger.log(\`Serving static files from \${resolvedPath}\`);
      return [
        ...DEFAULT_STATIC_MODULE_OPTIONS_LIST,
        { rootPath: resolvedPath, exclude: [\\"/api*\\", \\"/graphql\\"] },
      ];
    }
    return DEFAULT_STATIC_MODULE_OPTIONS_LIST;
  }
}
",
  "server/src/swagger.ts": "import { DocumentBuilder } from \\"@nestjs/swagger\\";

export const swaggerPath = \\"api\\";

export const swaggerDocumentOptions = new DocumentBuilder()
  .setTitle(\\"Sample Application\\")
  .setDescription(
    'Sample application for testing\\\\n\\\\n## Congratulations! Your application is ready.\\\\n\\\\nPlease note that all endpoints are secured with HTTP basic authentication.\\\\nBy default, your app comes with one user with the username \\"admin\\" and password \\"admin\\".\\\\nLearn more in [our docs](https://docs.amplication.com)'
  )
  .setVersion(\\"0.1.1\\")
  .addBasicAuth()
  .build();

export const swaggerSetupOptions = {
  swaggerOptions: {
    persistAuthorization: true,
  },
  customCssUrl: \\"../swagger/swagger.css\\",
  customfavIcon: \\"../swagger/favicon.png\\",
  customSiteTitle: \\"Sample Application\\",
};
",
  "server/src/user/CreateUserArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { UserCreateInput } from \\"./UserCreateInput\\";

@ArgsType()
class CreateUserArgs {
  @Field(() => UserCreateInput, { nullable: false })
  data!: UserCreateInput;
}

export { CreateUserArgs };
",
  "server/src/user/DeleteUserArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";

@ArgsType()
class DeleteUserArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
}

export { DeleteUserArgs };
",
  "server/src/user/EnumInterests.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumInterests {
  Programming = \\"programming\\",
  Design = \\"design\\",
}

registerEnumType(EnumInterests, {
  name: \\"EnumInterests\\",
});
",
  "server/src/user/EnumPriority.ts": "import { registerEnumType } from \\"@nestjs/graphql\\";

export enum EnumPriority {
  High = \\"high\\",
  Medium = \\"medium\\",
  Low = \\"low\\",
}

registerEnumType(EnumPriority, {
  name: \\"EnumPriority\\",
});
",
  "server/src/user/FindManyUserArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { UserWhereInput } from \\"./UserWhereInput\\";

@ArgsType()
class FindManyUserArgs {
  @Field(() => UserWhereInput, { nullable: true })
  where?: UserWhereInput;
}

export { FindManyUserArgs };
",
  "server/src/user/FindOneUserArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";

@ArgsType()
class FindOneUserArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
}

export { FindOneUserArgs };
",
  "server/src/user/UpdateUserArgs.ts": "import { ArgsType, Field } from \\"@nestjs/graphql\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { UserUpdateInput } from \\"./UserUpdateInput\\";

@ArgsType()
class UpdateUserArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
  @Field(() => UserUpdateInput, { nullable: false })
  data!: UserUpdateInput;
}

export { UpdateUserArgs };
",
  "server/src/user/User.ts": "import { ObjectType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsOptional,
  IsEnum,
  IsBoolean,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";
import { EnumInterests } from \\"./EnumInterests\\";
import { EnumPriority } from \\"./EnumPriority\\";
@ObjectType()
class User {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  username!: string;
  @ApiProperty({
    required: true,
    type: [String],
  })
  @IsString({
    each: true,
  })
  @Field(() => [String])
  roles!: Array<string>;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  bio!: string;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;
  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Field(() => Number)
  age!: number;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  birthDate!: Date;
  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsNumber()
  @Field(() => Number)
  score!: number;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  organization!: OrganizationWhereUniqueInput | null;
  @ApiProperty({
    required: true,
    enum: EnumInterests,
    isArray: true,
  })
  @IsEnum(EnumInterests, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumInterests], {
    nullable: true,
  })
  interests!: Array<\\"programming\\" | \\"design\\">;
  @ApiProperty({
    required: true,
    enum: EnumPriority,
  })
  @IsEnum(EnumPriority)
  @Field(() => EnumPriority)
  priority!: \\"high\\" | \\"medium\\" | \\"low\\";
  @ApiProperty({
    required: true,
    type: Boolean,
  })
  @IsBoolean()
  @Field(() => Boolean)
  isCurious!: boolean;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  location!: string;
}
export { User };
",
  "server/src/user/UserCreateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsOptional,
  IsEnum,
  IsBoolean,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";
import { EnumInterests } from \\"./EnumInterests\\";
import { EnumPriority } from \\"./EnumPriority\\";
@InputType()
class UserCreateInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  username!: string;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  password!: string;
  @ApiProperty({
    required: true,
    type: [String],
  })
  @IsString({
    each: true,
  })
  @Field(() => [String])
  roles!: Array<string>;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  bio!: string;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;
  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Field(() => Number)
  age!: number;
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  birthDate!: Date;
  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsNumber()
  @Field(() => Number)
  score!: number;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput | null;
  @ApiProperty({
    required: true,
    enum: EnumInterests,
    isArray: true,
  })
  @IsEnum(EnumInterests, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumInterests], {
    nullable: true,
  })
  interests?: Array<\\"programming\\" | \\"design\\">;
  @ApiProperty({
    required: true,
    enum: EnumPriority,
  })
  @IsEnum(EnumPriority)
  @Field(() => EnumPriority)
  priority!: \\"high\\" | \\"medium\\" | \\"low\\";
  @ApiProperty({
    required: true,
    type: Boolean,
  })
  @IsBoolean()
  @Field(() => Boolean)
  isCurious!: boolean;
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  location!: string;
}
export { UserCreateInput };
",
  "server/src/user/UserUpdateInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsOptional,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsEnum,
  IsBoolean,
} from \\"class-validator\\";

import { Type } from \\"class-transformer\\";
import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";
import { EnumInterests } from \\"./EnumInterests\\";
import { EnumPriority } from \\"./EnumPriority\\";
@InputType()
class UserUpdateInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  username?: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  password?: string;
  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsString({
    each: true,
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  roles?: Array<string>;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  name?: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  bio?: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  email?: string;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  age?: number;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthDate?: Date;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  score?: number;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput | null;
  @ApiProperty({
    required: false,
    enum: EnumInterests,
    isArray: true,
  })
  @IsEnum(EnumInterests, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumInterests], {
    nullable: true,
  })
  interests?: Array<\\"programming\\" | \\"design\\">;
  @ApiProperty({
    required: false,
    enum: EnumPriority,
  })
  @IsEnum(EnumPriority)
  @IsOptional()
  @Field(() => EnumPriority, {
    nullable: true,
  })
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isCurious?: boolean;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  location?: string;
}
export { UserUpdateInput };
",
  "server/src/user/UserWhereInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";

import {
  IsString,
  IsOptional,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsEnum,
  IsBoolean,
} from \\"class-validator\\";

import { Type, Transform } from \\"class-transformer\\";
import { OrganizationWhereUniqueInput } from \\"../organization/OrganizationWhereUniqueInput\\";
import { EnumPriority } from \\"./EnumPriority\\";
@InputType()
class UserWhereInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  username?: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  id?: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  name?: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  bio?: string;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  email?: string;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  age?: number;
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthDate?: Date;
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  score?: number;
  @ApiProperty({
    required: false,
    type: OrganizationWhereUniqueInput,
  })
  @Transform(JSON.parse)
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  organization?: OrganizationWhereUniqueInput | null;
  @ApiProperty({
    required: false,
    enum: EnumPriority,
  })
  @IsEnum(EnumPriority)
  @IsOptional()
  @Field(() => EnumPriority, {
    nullable: true,
  })
  priority?: \\"high\\" | \\"medium\\" | \\"low\\";
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isCurious?: boolean;
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  location?: string;
}
export { UserWhereInput };
",
  "server/src/user/UserWhereUniqueInput.ts": "import { InputType, Field } from \\"@nestjs/graphql\\";
import { ApiProperty } from \\"@nestjs/swagger\\";
import { IsString } from \\"class-validator\\";
@InputType()
class UserWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}
export { UserWhereUniqueInput };
",
  "server/src/user/user.controller.spec.ts": "import { Test } from \\"@nestjs/testing\\";
import { INestApplication, HttpStatus, ExecutionContext } from \\"@nestjs/common\\";
import request from \\"supertest\\";
import { MorganModule } from \\"nest-morgan\\";
import { ACGuard } from \\"nest-access-control\\";
import { BasicAuthGuard } from \\"../auth/basicAuth.guard\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { UserController } from \\"./user.controller\\";
import { UserService } from \\"./user.service\\";

const nonExistingId = \\"nonExistingId\\";
const existingId = \\"existingId\\";
const CREATE_INPUT = {
  username: \\"exampleUsername\\",
  password: \\"examplePassword\\",
  roles: [\\"exampleRoles\\"],
  id: \\"exampleId\\",
  name: \\"exampleName\\",
  bio: \\"exampleBio\\",
  email: \\"exampleEmail\\",
  age: 42,
  birthDate: new Date(),
  score: 42.42,
  isCurious: \\"true\\",
  location: \\"exampleLocation\\",
};
const CREATE_RESULT = {
  username: \\"exampleUsername\\",
  password: \\"examplePassword\\",
  roles: [\\"exampleRoles\\"],
  id: \\"exampleId\\",
  name: \\"exampleName\\",
  bio: \\"exampleBio\\",
  email: \\"exampleEmail\\",
  age: 42,
  birthDate: new Date(),
  score: 42.42,
  isCurious: \\"true\\",
  location: \\"exampleLocation\\",
};
const FIND_MANY_RESULT = [
  {
    username: \\"exampleUsername\\",
    password: \\"examplePassword\\",
    roles: [\\"exampleRoles\\"],
    id: \\"exampleId\\",
    name: \\"exampleName\\",
    bio: \\"exampleBio\\",
    email: \\"exampleEmail\\",
    age: 42,
    birthDate: new Date(),
    score: 42.42,
    isCurious: \\"true\\",
    location: \\"exampleLocation\\",
  },
];
const FIND_ONE_RESULT = {
  username: \\"exampleUsername\\",
  password: \\"examplePassword\\",
  roles: [\\"exampleRoles\\"],
  id: \\"exampleId\\",
  name: \\"exampleName\\",
  bio: \\"exampleBio\\",
  email: \\"exampleEmail\\",
  age: 42,
  birthDate: new Date(),
  score: 42.42,
  isCurious: \\"true\\",
  location: \\"exampleLocation\\",
};

const service = {
  create() {
    return CREATE_RESULT;
  },
  findMany: () => FIND_MANY_RESULT,
  findOne: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: [\\"user\\"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

describe(\\"User\\", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: UserService,
          useValue: service,
        },
      ],
      controllers: [UserController],
      imports: [MorganModule.forRoot(), ACLModule],
    })
      .overrideGuard(BasicAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test(\\"POST /users\\", async () => {
    await request(app.getHttpServer())
      .post(\\"/users\\")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        birthDate: CREATE_RESULT.birthDate.toISOString(),
      });
  });

  test(\\"GET /users\\", async () => {
    await request(app.getHttpServer())
      .get(\\"/users\\")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          birthDate: FIND_MANY_RESULT[0].birthDate.toISOString(),
        },
      ]);
  });

  test(\\"GET /users/:id non existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/users\\"}/\${nonExistingId}\`)
      .expect(404)
      .expect({
        statusCode: 404,
        message: \`No resource was found for {\\"\${\\"id\\"}\\":\\"\${nonExistingId}\\"}\`,
        error: \\"Not Found\\",
      });
  });

  test(\\"GET /users/:id existing\\", async () => {
    await request(app.getHttpServer())
      .get(\`\${\\"/users\\"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        birthDate: FIND_ONE_RESULT.birthDate.toISOString(),
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/user/user.controller.ts": "import * as common from \\"@nestjs/common\\";
import * as swagger from \\"@nestjs/swagger\\";
import * as nestMorgan from \\"nest-morgan\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as basicAuthGuard from \\"../auth/basicAuth.guard\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import * as errors from \\"../errors\\";
import { UserService } from \\"./user.service\\";
import { UserCreateInput } from \\"./UserCreateInput\\";
import { UserWhereInput } from \\"./UserWhereInput\\";
import { UserWhereUniqueInput } from \\"./UserWhereUniqueInput\\";
import { UserUpdateInput } from \\"./UserUpdateInput\\";
import { User } from \\"./User\\";

@swagger.ApiBasicAuth()
@swagger.ApiTags(\\"users\\")
@common.Controller(\\"users\\")
export class UserController {
  constructor(
    private readonly service: UserService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Post()
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  @swagger.ApiCreatedResponse({ type: User })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async create(
    @common.Query() query: {},
    @common.Body() data: UserCreateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"User\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...query,
      data: {
        ...data,

        organization: data.organization
          ? {
              connect: data.organization,
            }
          : undefined,
      },
      select: {
        username: true,
        roles: true,
        id: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        organization: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
      },
    });
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get()
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: [User] })
  @swagger.ApiForbiddenResponse()
  async findMany(
    @common.Query() query: UserWhereInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service.findMany({
      where: query,
      select: {
        username: true,
        roles: true,
        id: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        organization: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
      },
    });
    return results.map((result) => permission.filter(result));
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Get(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async findOne(
    @common.Query() query: {},
    @common.Param() params: UserWhereUniqueInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"User\\",
    });
    const result = await this.service.findOne({
      ...query,
      where: params,
      select: {
        username: true,
        roles: true,
        id: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        organization: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return permission.filter(result);
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Patch(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async update(
    @common.Query() query: {},
    @common.Param() params: UserWhereUniqueInput,
    @common.Body()
    data: UserUpdateInput,
    @nestAccessControl.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(permission, data);
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new errors.ForbiddenException(
        \`providing the properties: \${properties} on \${\\"User\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...query,
        where: params,
        data: {
          ...data,

          organization: data.organization
            ? {
                connect: data.organization,
              }
            : undefined,
        },
        select: {
          username: true,
          roles: true,
          id: true,
          name: true,
          bio: true,
          email: true,
          age: true,
          birthDate: true,
          score: true,

          organization: {
            select: {
              id: true,
            },
          },

          interests: true,
          priority: true,
          isCurious: true,
          location: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(nestMorgan.MorganInterceptor(\\"combined\\"))
  @common.UseGuards(basicAuthGuard.BasicAuthGuard, nestAccessControl.ACGuard)
  @common.Delete(\\"/:id\\")
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @swagger.ApiForbiddenResponse({ type: errors.ForbiddenException })
  async delete(
    @common.Query() query: {},
    @common.Param() params: UserWhereUniqueInput
  ): Promise<User | null> {
    try {
      return await this.service.delete({
        ...query,
        where: params,
        select: {
          username: true,
          roles: true,
          id: true,
          name: true,
          bio: true,
          email: true,
          age: true,
          birthDate: true,
          score: true,

          organization: {
            select: {
              id: true,
            },
          },

          interests: true,
          priority: true,
          isCurious: true,
          location: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/user/user.module.ts": "import { Module, forwardRef } from \\"@nestjs/common\\";
import { MorganModule } from \\"nest-morgan\\";
import { PrismaModule } from \\"nestjs-prisma\\";
import { ACLModule } from \\"../auth/acl.module\\";
import { AuthModule } from \\"../auth/auth.module\\";
import { UserService } from \\"./user.service\\";
import { UserController } from \\"./user.controller\\";
import { UserResolver } from \\"./user.resolver\\";

@Module({
  imports: [
    ACLModule,
    forwardRef(() => AuthModule),
    MorganModule,
    PrismaModule,
  ],
  controllers: [UserController],
  providers: [UserService, UserResolver],
  exports: [UserService],
})
export class UserModule {}
",
  "server/src/user/user.resolver.ts": "import * as common from \\"@nestjs/common\\";
import * as graphql from \\"@nestjs/graphql\\";
import * as apollo from \\"apollo-server-express\\";
import * as nestAccessControl from \\"nest-access-control\\";
import * as gqlBasicAuthGuard from \\"../auth/gqlBasicAuth.guard\\";
import * as gqlACGuard from \\"../auth/gqlAC.guard\\";
import * as gqlUserRoles from \\"../auth/gqlUserRoles.decorator\\";
import * as abacUtil from \\"../auth/abac.util\\";
import { isRecordNotFoundError } from \\"../prisma.util\\";
import { UserService } from \\"./user.service\\";
import { CreateUserArgs } from \\"./CreateUserArgs\\";
import { UpdateUserArgs } from \\"./UpdateUserArgs\\";
import { DeleteUserArgs } from \\"./DeleteUserArgs\\";
import { FindManyUserArgs } from \\"./FindManyUserArgs\\";
import { FindOneUserArgs } from \\"./FindOneUserArgs\\";
import { User } from \\"./User\\";
import { Organization } from \\"../organization/Organization\\";

@graphql.Resolver(() => User)
@common.UseGuards(gqlBasicAuthGuard.GqlBasicAuthGuard, gqlACGuard.GqlACGuard)
export class UserResolver {
  constructor(
    private readonly service: UserService,
    @nestAccessControl.InjectRolesBuilder()
    private readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => [User])
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async users(
    @graphql.Args() args: FindManyUserArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const results = await this.service.findMany(args);
    return results.map((result) => permission.filter(result));
  }

  @graphql.Query(() => User, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"own\\",
  })
  async user(
    @graphql.Args() args: FindOneUserArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"own\\",
      resource: \\"User\\",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.Mutation(() => User)
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"create\\",
    possession: \\"any\\",
  })
  async createUser(
    @graphql.Args() args: CreateUserArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"create\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"User\\"} creation is forbidden for roles: \${roles}\`
      );
    }
    // @ts-ignore
    return await this.service.create({
      ...args,
      data: {
        ...args.data,

        organization: args.data.organization
          ? {
              connect: args.data.organization,
            }
          : undefined,
      },
    });
  }

  @graphql.Mutation(() => User)
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"update\\",
    possession: \\"any\\",
  })
  async updateUser(
    @graphql.Args() args: UpdateUserArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"update\\",
      possession: \\"any\\",
      resource: \\"User\\",
    });
    const invalidAttributes = abacUtil.getInvalidAttributes(
      permission,
      args.data
    );
    if (invalidAttributes.length) {
      const properties = invalidAttributes
        .map((attribute: string) => JSON.stringify(attribute))
        .join(\\", \\");
      const roles = userRoles
        .map((role: string) => JSON.stringify(role))
        .join(\\",\\");
      throw new apollo.ApolloError(
        \`providing the properties: \${properties} on \${\\"User\\"} update is forbidden for roles: \${roles}\`
      );
    }
    try {
      // @ts-ignore
      return await this.service.update({
        ...args,
        data: {
          ...args.data,

          organization: args.data.organization
            ? {
                connect: args.data.organization,
              }
            : undefined,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => User)
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"delete\\",
    possession: \\"any\\",
  })
  async deleteUser(@graphql.Args() args: DeleteUserArgs): Promise<User | null> {
    try {
      // @ts-ignore
      return await this.service.delete(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new apollo.ApolloError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => Organization, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: \\"User\\",
    action: \\"read\\",
    possession: \\"any\\",
  })
  async organization(
    @graphql.Parent() parent: User,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Organization | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: \\"read\\",
      possession: \\"any\\",
      resource: \\"Organization\\",
    });
    const result = await this.service
      .findOne({ where: { id: parent.id } })
      .organization();

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }
}
",
  "server/src/user/user.service.ts": "import { Injectable } from \\"@nestjs/common\\";
import { PrismaService } from \\"nestjs-prisma\\";

import {
  FindOneUserArgs,
  FindManyUserArgs,
  UserCreateArgs,
  UserUpdateArgs,
  UserDeleteArgs,
  Subset,
} from \\"@prisma/client\\";

import { PasswordService } from \\"../auth/password.service\\";
import { transformStringFieldUpdateInput } from \\"../prisma.util\\";

@Injectable()
export class UserService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly passwordService: PasswordService
  ) {}
  findMany<T extends FindManyUserArgs>(args: Subset<T, FindManyUserArgs>) {
    return this.prisma.user.findMany(args);
  }
  findOne<T extends FindOneUserArgs>(args: Subset<T, FindOneUserArgs>) {
    return this.prisma.user.findOne(args);
  }
  async create<T extends UserCreateArgs>(args: Subset<T, UserCreateArgs>) {
    return this.prisma.user.create<T>({
      ...args,

      data: {
        ...args.data,
        password: await this.passwordService.hash(args.data.password),
      },
    });
  }
  async update<T extends UserUpdateArgs>(args: Subset<T, UserUpdateArgs>) {
    return this.prisma.user.update<T>({
      ...args,

      data: {
        ...args.data,

        password:
          args.data.password &&
          (await transformStringFieldUpdateInput(
            args.data.password,
            (password) => this.passwordService.hash(password)
          )),
      },
    });
  }
  delete<T extends UserDeleteArgs>(args: Subset<T, UserDeleteArgs>) {
    return this.prisma.user.delete(args);
  }
}
",
}
`;
