// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`createDataService when admin-ui is disabled creates app as expected 1`] = `
{
  "server/.env": "BCRYPT_SALT=10
COMPOSE_PROJECT_NAME=amp_\${resourceId}
PORT=3000
DB_URL=postgres://admin:admin@localhost:5432/my-db
DB_USER=admin
DB_PASSWORD=admin
DB_PORT=5432
DB_NAME=my-db",
  "server/.gitignore": "# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.
 
/node_modules
/dist
.DS_Store
",
  "server/docker-compose.dev.yml": "version: "3"
services:
  db:
    image: postgres:12
    ports:
      - \${DB_PORT}:5432
    environment:
      POSTGRES_USER: \${DB_USER}
      POSTGRES_PASSWORD: \${DB_PASSWORD}
    volumes:
      - postgres:/var/lib/postgresql/data
volumes:
  postgres: ~
",
  "server/docker-compose.yml": "version: "3"
services:
  server:
    build:
      context: .
      args:
        NPM_LOG_LEVEL: notice
    ports:
      - \${PORT}:3000
    environment:
      BCRYPT_SALT: \${BCRYPT_SALT}
      DB_URL: postgres://\${DB_USER}:\${DB_PASSWORD}@db:5432/\${DB_NAME}
    depends_on:
      - migrate
    restart: on-failure
  migrate:
    build:
      context: .
      args:
        NPM_LOG_LEVEL: notice
    command: npm run db:init
    working_dir: /app/server
    environment:
      BCRYPT_SALT: \${BCRYPT_SALT}
      DB_URL: postgres://\${DB_USER}:\${DB_PASSWORD}@db:5432/\${DB_NAME}
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres:12
    ports:
      - \${DB_PORT}:5432
    environment:
      POSTGRES_USER: \${DB_USER}
      POSTGRES_PASSWORD: \${DB_PASSWORD}
      POSTGRES_DB: \${DB_NAME}
    volumes:
      - postgres:/var/lib/postgresql/data
    healthcheck:
      test:
        - CMD-SHELL
        - pg_isready -d $\${POSTGRES_DB} -U $\${POSTGRES_USER}
      timeout: 45s
      interval: 10s
      retries: 10
volumes:
  postgres: ~
",
  "server/nest-cli.json": "{
  "sourceRoot": "src",
  "compilerOptions": {
    "assets": ["swagger"]
  }
}
",
  "server/package.json": "{
  "name": "@sample-application/server",
  "version": "0.1.3",
  "private": true,
  "scripts": {
    "start": "nest start",
    "start:watch": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "build": "nest build",
    "test": "jest",
    "seed": "ts-node scripts/seed.ts",
    "db:migrate-save": "prisma migrate dev",
    "db:migrate-up": "prisma migrate deploy",
    "db:clean": "prisma migrate reset",
    "db:init": "run-s \\"db:migrate-save -- --name 'initial version'\\" db:migrate-up seed",
    "prisma:generate": "prisma generate",
    "docker:dev": "docker-compose -f docker-compose.dev.yml up -d",
    "package:container": "docker build .",
    "compose:up": "docker-compose up -d",
    "compose:down": "docker-compose down --volumes"
  },
  "dependencies": {
    "@apollo/server": "^4.9.4",
    "@nestjs/apollo": "12.0.9",
    "@nestjs/common": "10.2.7",
    "@nestjs/config": "3.1.1",
    "@nestjs/core": "10.2.7",
    "@nestjs/graphql": "12.0.9",
    "@nestjs/jwt": "^10.1.1",
    "@nestjs/passport": "^10.0.2",
    "@nestjs/platform-express": "10.2.7",
    "@nestjs/serve-static": "4.0.0",
    "@nestjs/swagger": "7.1.13",
    "@prisma/client": "^5.4.2",
    "@types/bcrypt": "5.0.0",
    "bcrypt": "5.1.1",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.0",
    "decimal.js": "10.4.3",
    "dotenv": "16.3.1",
    "graphql": "^16.8.1",
    "graphql-type-json": "0.3.2",
    "npm-run-all": "4.1.5",
    "passport": "0.6.0",
    "passport-http": "0.3.0",
    "passport-jwt": "4.0.1",
    "reflect-metadata": "0.1.13",
    "ts-node": "10.9.1",
    "type-fest": "2.19.0",
    "validator": "13.11.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.1.18",
    "@nestjs/testing": "^10.2.7",
    "@types/express": "^4.17.19",
    "@types/graphql-type-json": "0.3.3",
    "@types/jest": "^29.5.5",
    "@types/normalize-path": "3.0.0",
    "@types/passport-http": "0.3.9",
    "@types/passport-jwt": "3.0.10",
    "@types/supertest": "^2.0.14",
    "@types/validator": "^13.11.2",
    "jest": "^29.7.0",
    "jest-mock-extended": "^3.0.5",
    "prisma": "^5.4.2",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "jest": {
    "preset": "ts-jest",
    "testEnvironment": "node",
    "modulePathIgnorePatterns": ["<rootDir>/dist/"]
  }
}
",
  "server/prisma/schema.prisma": "datasource db {
  provider = "postgresql"
  url      = env("DB_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                 String              @id @default(cuid())
  username           String              @unique
  roles              Json
  password           String
  name               String              @unique @map("name")
  bio                String
  email              String
  age                Int
  birthDate          DateTime
  score              Float
  manager            User?               @relation(name: "employees", fields: [managerId], references: [id])
  managerId          String?
  employees          User[]              @relation(name: "employees")
  organizations      Organization[]
  interests          EnumUserInterests[]
  priority           EnumUserPriority
  isCurious          Boolean
  location           String
  extendedProperties Json
  profile            Profile?            @relation(fields: [profileId], references: [id])
  profileId          Int?                @unique

  @@unique([name(sort: Desc), email])
  @@index([name, email])
  @@map("users")
}

model Profile {
  id        Int      @id @default(autoincrement())
  createdIn DateTime @default(now())
  createdAt DateTime
  updatedIn DateTime @updatedAt
  updatedAt DateTime
  email     String
  user      User?
}

model Order {
  id         String          @id @default(cuid())
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  customer   Customer        @relation(fields: [customerId], references: [id])
  customerId BigInt
  status     EnumOrderStatus
  label      EnumOrderLabel?
}

model Organization {
  id           String     @id @default(cuid())
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  name         String
  users        User[]
  customers    Customer[] @relation(name: "CustomersOnOrganization")
  vipCustomers Customer[] @relation(name: "vipCustomers")
}

model Customer {
  id                BigInt                       @id @default(autoincrement())
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt
  email             String
  firstName         String?
  lastName          String?
  isVip             Boolean?
  birthData         DateTime?
  averageSale       Decimal?
  favoriteNumber    BigInt?
  geoLocation       String?
  comments          String?
  favoriteColors    EnumCustomerFavoriteColors[]
  customerType      EnumCustomerCustomerType?
  organization      Organization?                @relation(name: "CustomersOnOrganization", fields: [organizationId], references: [id])
  organizationId    String?
  vipOrganization   Organization?                @relation(name: "vipCustomers", fields: [vipOrganizationId], references: [id])
  vipOrganizationId String?
  orders            Order[]
}

model Empty {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum EnumUserInterests {
  programming
  design
}

enum EnumUserPriority {
  high
  medium
  low
}

enum EnumOrderStatus {
  pending
  inProgress
  done
}

enum EnumOrderLabel {
  fragile
}

enum EnumCustomerFavoriteColors {
  red
  green
  purple
  yellow
}

enum EnumCustomerCustomerType {
  platinum
  gold
  bronze
  regular
}
",
  "server/scripts/customSeed.ts": "import { PrismaClient } from "@prisma/client";

export async function customSeed() {
  const client = new PrismaClient();

  client.$disconnect();
}
",
  "server/scripts/seed.ts": "import * as dotenv from "dotenv";
import { PrismaClient } from "@prisma/client";
import { customSeed } from "./customSeed";

if (require.main === module) {
  dotenv.config();

  const { BCRYPT_SALT } = process.env;

  if (!BCRYPT_SALT) {
    throw new Error("BCRYPT_SALT environment variable must be defined");
  }
}

async function seed() {
  console.info("Seeding database...");

  const client = new PrismaClient();
  void client.$disconnect();

  console.info("Seeding database with custom seed...");
  customSeed();

  console.info("Seeded database successfully");
}
",
  "server/src/app.module.ts": "import { Module } from "@nestjs/common";
import { UserModule } from "./user/user.module";
import { ProfileModule } from "./profile/profile.module";
import { OrderModule } from "./order/order.module";
import { OrganizationModule } from "./organization/organization.module";
import { CustomerModule } from "./customer/customer.module";
import { EmptyModule } from "./empty/empty.module";
import { HealthModule } from "./health/health.module";
import { PrismaModule } from "./prisma/prisma.module";
import { SecretsManagerModule } from "./providers/secrets/secretsManager.module";
import { ServeStaticModule } from "@nestjs/serve-static";
import { ServeStaticOptionsService } from "./serveStaticOptions.service";
import { ConfigModule, ConfigService } from "@nestjs/config";
import { GraphQLModule } from "@nestjs/graphql";
import { ApolloDriver, ApolloDriverConfig } from "@nestjs/apollo";

@Module({
  controllers: [],
  imports: [
    UserModule,
    ProfileModule,
    OrderModule,
    OrganizationModule,
    CustomerModule,
    EmptyModule,
    HealthModule,
    PrismaModule,
    SecretsManagerModule,
    ConfigModule.forRoot({ isGlobal: true }),
    ServeStaticModule.forRootAsync({
      useClass: ServeStaticOptionsService,
    }),
    GraphQLModule.forRootAsync<ApolloDriverConfig>({
      driver: ApolloDriver,
      useFactory: (configService: ConfigService) => {
        const playground = configService.get("GRAPHQL_PLAYGROUND");
        const introspection = configService.get("GRAPHQL_INTROSPECTION");
        return {
          autoSchemaFile: "schema.graphql",
          sortSchema: true,
          playground,
          introspection: playground || introspection,
        };
      },
      inject: [ConfigService],
      imports: [ConfigModule],
    }),
  ],
  providers: [],
})
export class AppModule {}
",
  "server/src/connectMicroservices.ts": "import { INestApplication } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";

export async function connectMicroservices(app: INestApplication) {
  const configService = app.get(ConfigService);
}
",
  "server/src/customer/base/CreateCustomerArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { CustomerCreateInput } from "./CustomerCreateInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class CreateCustomerArgs {
  @ApiProperty({
    required: true,
    type: () => CustomerCreateInput,
  })
  @ValidateNested()
  @Type(() => CustomerCreateInput)
  @Field(() => CustomerCreateInput, { nullable: false })
  data!: CustomerCreateInput;
}

export { CreateCustomerArgs as CreateCustomerArgs };
",
  "server/src/customer/base/Customer.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ObjectType, Field, Float } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";

import {
  IsInt,
  IsDate,
  IsString,
  IsOptional,
  IsBoolean,
  IsNumber,
  IsEnum,
  ValidateNested,
} from "class-validator";

import { GraphQLBigInt } from "../../util/GraphQLBigInt";
import { Type } from "class-transformer";
import { Decimal } from "decimal.js";
import { EnumCustomerFavoriteColors } from "./EnumCustomerFavoriteColors";
import { EnumCustomerCustomerType } from "./EnumCustomerCustomerType";
import { Organization } from "../../organization/base/Organization";
import { Order } from "../../order/base/Order";

@ObjectType()
class Customer {
  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Field(() => GraphQLBigInt)
  id!: bigint;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName!: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName!: string | null;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip!: boolean | null;

  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData!: Date | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  averageSale!: Decimal | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  favoriteNumber!: bigint | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation!: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments!: string | null;

  @ApiProperty({
    required: false,
    enum: EnumCustomerFavoriteColors,
    isArray: true,
  })
  @IsEnum(EnumCustomerFavoriteColors, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumCustomerFavoriteColors], {
    nullable: true,
  })
  favoriteColors?: Array<"red" | "green" | "purple" | "yellow">;

  @ApiProperty({
    required: false,
    enum: EnumCustomerCustomerType,
  })
  @IsEnum(EnumCustomerCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  customerType?: "platinum" | "gold" | "bronze" | "regular" | null;

  @ApiProperty({
    required: false,
    type: () => Organization,
  })
  @ValidateNested()
  @Type(() => Organization)
  @IsOptional()
  organization?: Organization | null;

  @ApiProperty({
    required: false,
    type: () => Organization,
  })
  @ValidateNested()
  @Type(() => Organization)
  @IsOptional()
  vipOrganization?: Organization | null;

  @ApiProperty({
    required: false,
    type: () => [Order],
  })
  @ValidateNested()
  @Type(() => Order)
  @IsOptional()
  orders?: Array<Order>;
}

export { Customer as Customer };
",
  "server/src/customer/base/CustomerCountArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { CustomerWhereInput } from "./CustomerWhereInput";
import { Type } from "class-transformer";

@ArgsType()
class CustomerCountArgs {
  @ApiProperty({
    required: false,
    type: () => CustomerWhereInput,
  })
  @Field(() => CustomerWhereInput, { nullable: true })
  @Type(() => CustomerWhereInput)
  where?: CustomerWhereInput;
}

export { CustomerCountArgs as CustomerCountArgs };
",
  "server/src/customer/base/CustomerCreateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field, Float } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";

import {
  IsString,
  IsOptional,
  IsBoolean,
  IsDate,
  IsNumber,
  IsInt,
  IsEnum,
  ValidateNested,
} from "class-validator";

import { Type } from "class-transformer";
import { Decimal } from "decimal.js";
import { GraphQLBigInt } from "../../util/GraphQLBigInt";
import { EnumCustomerFavoriteColors } from "./EnumCustomerFavoriteColors";
import { EnumCustomerCustomerType } from "./EnumCustomerCustomerType";
import { OrganizationWhereUniqueInput } from "../../organization/base/OrganizationWhereUniqueInput";
import { OrderCreateNestedManyWithoutCustomersInput } from "./OrderCreateNestedManyWithoutCustomersInput";

@InputType()
class CustomerCreateInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName?: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName?: string | null;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip?: boolean | null;

  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData?: Date | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  averageSale?: Decimal | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  favoriteNumber?: bigint | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation?: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments?: string | null;

  @ApiProperty({
    required: false,
    enum: EnumCustomerFavoriteColors,
    isArray: true,
  })
  @IsEnum(EnumCustomerFavoriteColors, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumCustomerFavoriteColors], {
    nullable: true,
  })
  favoriteColors?: Array<"red" | "green" | "purple" | "yellow">;

  @ApiProperty({
    required: false,
    enum: EnumCustomerCustomerType,
  })
  @IsEnum(EnumCustomerCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  customerType?: "platinum" | "gold" | "bronze" | "regular" | null;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput | null;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  vipOrganization?: OrganizationWhereUniqueInput | null;

  @ApiProperty({
    required: false,
    type: () => OrderCreateNestedManyWithoutCustomersInput,
  })
  @ValidateNested()
  @Type(() => OrderCreateNestedManyWithoutCustomersInput)
  @IsOptional()
  @Field(() => OrderCreateNestedManyWithoutCustomersInput, {
    nullable: true,
  })
  orders?: OrderCreateNestedManyWithoutCustomersInput;
}

export { CustomerCreateInput as CustomerCreateInput };
",
  "server/src/customer/base/CustomerFindManyArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { CustomerWhereInput } from "./CustomerWhereInput";
import { IsOptional, ValidateNested, IsInt } from "class-validator";
import { Type } from "class-transformer";
import { CustomerOrderByInput } from "./CustomerOrderByInput";

@ArgsType()
class CustomerFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => CustomerWhereInput,
  })
  @IsOptional()
  @ValidateNested()
  @Field(() => CustomerWhereInput, { nullable: true })
  @Type(() => CustomerWhereInput)
  where?: CustomerWhereInput;

  @ApiProperty({
    required: false,
    type: [CustomerOrderByInput],
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Field(() => [CustomerOrderByInput], { nullable: true })
  @Type(() => CustomerOrderByInput)
  orderBy?: Array<CustomerOrderByInput>;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { CustomerFindManyArgs as CustomerFindManyArgs };
",
  "server/src/customer/base/CustomerFindUniqueArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { CustomerWhereUniqueInput } from "./CustomerWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class CustomerFindUniqueArgs {
  @ApiProperty({
    required: true,
    type: () => CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @Field(() => CustomerWhereUniqueInput, { nullable: false })
  where!: CustomerWhereUniqueInput;
}

export { CustomerFindUniqueArgs as CustomerFindUniqueArgs };
",
  "server/src/customer/base/CustomerListRelationFilter.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { CustomerWhereInput } from "./CustomerWhereInput";
import { ValidateNested, IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType()
class CustomerListRelationFilter {
  @ApiProperty({
    required: false,
    type: () => CustomerWhereInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereInput)
  @IsOptional()
  @Field(() => CustomerWhereInput, {
    nullable: true,
  })
  every?: CustomerWhereInput;

  @ApiProperty({
    required: false,
    type: () => CustomerWhereInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereInput)
  @IsOptional()
  @Field(() => CustomerWhereInput, {
    nullable: true,
  })
  some?: CustomerWhereInput;

  @ApiProperty({
    required: false,
    type: () => CustomerWhereInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereInput)
  @IsOptional()
  @Field(() => CustomerWhereInput, {
    nullable: true,
  })
  none?: CustomerWhereInput;
}
export { CustomerListRelationFilter as CustomerListRelationFilter };
",
  "server/src/customer/base/CustomerOrderByInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional, IsEnum } from "class-validator";
import { SortOrder } from "../../util/SortOrder";

@InputType({
  isAbstract: true,
  description: undefined,
})
class CustomerOrderByInput {
  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  email?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  firstName?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  lastName?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  isVip?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  birthData?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  averageSale?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  favoriteNumber?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  geoLocation?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  comments?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  favoriteColors?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  customerType?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  organizationId?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  vipOrganizationId?: SortOrder;
}

export { CustomerOrderByInput as CustomerOrderByInput };
",
  "server/src/customer/base/CustomerUpdateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field, Float } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";

import {
  IsString,
  IsOptional,
  IsBoolean,
  IsDate,
  IsNumber,
  IsInt,
  IsEnum,
  ValidateNested,
} from "class-validator";

import { Type } from "class-transformer";
import { Decimal } from "decimal.js";
import { GraphQLBigInt } from "../../util/GraphQLBigInt";
import { EnumCustomerFavoriteColors } from "./EnumCustomerFavoriteColors";
import { EnumCustomerCustomerType } from "./EnumCustomerCustomerType";
import { OrganizationWhereUniqueInput } from "../../organization/base/OrganizationWhereUniqueInput";
import { OrderUpdateManyWithoutCustomersInput } from "./OrderUpdateManyWithoutCustomersInput";

@InputType()
class CustomerUpdateInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  email?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  firstName?: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  lastName?: string | null;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isVip?: boolean | null;

  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthData?: Date | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  averageSale?: Decimal | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  favoriteNumber?: bigint | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  geoLocation?: string | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  comments?: string | null;

  @ApiProperty({
    required: false,
    enum: EnumCustomerFavoriteColors,
    isArray: true,
  })
  @IsEnum(EnumCustomerFavoriteColors, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumCustomerFavoriteColors], {
    nullable: true,
  })
  favoriteColors?: Array<"red" | "green" | "purple" | "yellow">;

  @ApiProperty({
    required: false,
    enum: EnumCustomerCustomerType,
  })
  @IsEnum(EnumCustomerCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  customerType?: "platinum" | "gold" | "bronze" | "regular" | null;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput | null;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  vipOrganization?: OrganizationWhereUniqueInput | null;

  @ApiProperty({
    required: false,
    type: () => OrderUpdateManyWithoutCustomersInput,
  })
  @ValidateNested()
  @Type(() => OrderUpdateManyWithoutCustomersInput)
  @IsOptional()
  @Field(() => OrderUpdateManyWithoutCustomersInput, {
    nullable: true,
  })
  orders?: OrderUpdateManyWithoutCustomersInput;
}

export { CustomerUpdateInput as CustomerUpdateInput };
",
  "server/src/customer/base/CustomerWhereInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { BigIntFilter } from "../../util/BigIntFilter";
import { Type } from "class-transformer";
import { IsOptional, IsEnum, ValidateNested } from "class-validator";
import { DateTimeFilter } from "../../util/DateTimeFilter";
import { StringFilter } from "../../util/StringFilter";
import { StringNullableFilter } from "../../util/StringNullableFilter";
import { BooleanNullableFilter } from "../../util/BooleanNullableFilter";
import { DateTimeNullableFilter } from "../../util/DateTimeNullableFilter";
import { DecimalNullableFilter } from "../../util/DecimalNullableFilter";
import { BigIntNullableFilter } from "../../util/BigIntNullableFilter";
import { EnumCustomerCustomerType } from "./EnumCustomerCustomerType";
import { OrganizationWhereUniqueInput } from "../../organization/base/OrganizationWhereUniqueInput";
import { OrderListRelationFilter } from "../../order/base/OrderListRelationFilter";

@InputType()
class CustomerWhereInput {
  @ApiProperty({
    required: false,
    type: BigIntFilter,
  })
  @Type(() => BigIntFilter)
  @IsOptional()
  @Field(() => BigIntFilter, {
    nullable: true,
  })
  id?: BigIntFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  email?: StringFilter;

  @ApiProperty({
    required: false,
    type: StringNullableFilter,
  })
  @Type(() => StringNullableFilter)
  @IsOptional()
  @Field(() => StringNullableFilter, {
    nullable: true,
  })
  firstName?: StringNullableFilter;

  @ApiProperty({
    required: false,
    type: StringNullableFilter,
  })
  @Type(() => StringNullableFilter)
  @IsOptional()
  @Field(() => StringNullableFilter, {
    nullable: true,
  })
  lastName?: StringNullableFilter;

  @ApiProperty({
    required: false,
    type: BooleanNullableFilter,
  })
  @Type(() => BooleanNullableFilter)
  @IsOptional()
  @Field(() => BooleanNullableFilter, {
    nullable: true,
  })
  isVip?: BooleanNullableFilter;

  @ApiProperty({
    required: false,
    type: DateTimeNullableFilter,
  })
  @Type(() => DateTimeNullableFilter)
  @IsOptional()
  @Field(() => DateTimeNullableFilter, {
    nullable: true,
  })
  birthData?: DateTimeNullableFilter;

  @ApiProperty({
    required: false,
    type: DecimalNullableFilter,
  })
  @Type(() => DecimalNullableFilter)
  @IsOptional()
  @Field(() => DecimalNullableFilter, {
    nullable: true,
  })
  averageSale?: DecimalNullableFilter;

  @ApiProperty({
    required: false,
    type: BigIntNullableFilter,
  })
  @Type(() => BigIntNullableFilter)
  @IsOptional()
  @Field(() => BigIntNullableFilter, {
    nullable: true,
  })
  favoriteNumber?: BigIntNullableFilter;

  @ApiProperty({
    required: false,
    type: StringNullableFilter,
  })
  @Type(() => StringNullableFilter)
  @IsOptional()
  @Field(() => StringNullableFilter, {
    nullable: true,
  })
  geoLocation?: StringNullableFilter;

  @ApiProperty({
    required: false,
    type: StringNullableFilter,
  })
  @Type(() => StringNullableFilter)
  @IsOptional()
  @Field(() => StringNullableFilter, {
    nullable: true,
  })
  comments?: StringNullableFilter;

  @ApiProperty({
    required: false,
    enum: EnumCustomerCustomerType,
  })
  @IsEnum(EnumCustomerCustomerType)
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  customerType?: "platinum" | "gold" | "bronze" | "regular";

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  organization?: OrganizationWhereUniqueInput;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @IsOptional()
  @Field(() => OrganizationWhereUniqueInput, {
    nullable: true,
  })
  vipOrganization?: OrganizationWhereUniqueInput;

  @ApiProperty({
    required: false,
    type: () => OrderListRelationFilter,
  })
  @ValidateNested()
  @Type(() => OrderListRelationFilter)
  @IsOptional()
  @Field(() => OrderListRelationFilter, {
    nullable: true,
  })
  orders?: OrderListRelationFilter;
}

export { CustomerWhereInput as CustomerWhereInput };
",
  "server/src/customer/base/CustomerWhereUniqueInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsInt } from "class-validator";
import { GraphQLBigInt } from "../../util/GraphQLBigInt";

@InputType()
class CustomerWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Field(() => GraphQLBigInt)
  id!: bigint;
}

export { CustomerWhereUniqueInput as CustomerWhereUniqueInput };
",
  "server/src/customer/base/DeleteCustomerArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { CustomerWhereUniqueInput } from "./CustomerWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class DeleteCustomerArgs {
  @ApiProperty({
    required: true,
    type: () => CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @Field(() => CustomerWhereUniqueInput, { nullable: false })
  where!: CustomerWhereUniqueInput;
}

export { DeleteCustomerArgs as DeleteCustomerArgs };
",
  "server/src/customer/base/EnumCustomerCustomerType.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { registerEnumType } from "@nestjs/graphql";

export enum EnumCustomerCustomerType {
  Platinum = "platinum",
  Gold = "gold",
  Bronze = "bronze",
  Regular = "regular",
}

registerEnumType(EnumCustomerCustomerType, {
  name: "EnumCustomerCustomerType",
});
",
  "server/src/customer/base/EnumCustomerFavoriteColors.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { registerEnumType } from "@nestjs/graphql";

export enum EnumCustomerFavoriteColors {
  Red = "red",
  Green = "green",
  Purple = "purple",
  Yellow = "yellow",
}

registerEnumType(EnumCustomerFavoriteColors, {
  name: "EnumCustomerFavoriteColors",
});
",
  "server/src/customer/base/OrderCreateNestedManyWithoutCustomersInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { OrderWhereUniqueInput } from "../../order/base/OrderWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class OrderCreateNestedManyWithoutCustomersInput {
  @Field(() => [OrderWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [OrderWhereUniqueInput],
  })
  connect?: Array<OrderWhereUniqueInput>;
}

export { OrderCreateNestedManyWithoutCustomersInput as OrderCreateNestedManyWithoutCustomersInput };
",
  "server/src/customer/base/OrderUpdateManyWithoutCustomersInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { OrderWhereUniqueInput } from "../../order/base/OrderWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class OrderUpdateManyWithoutCustomersInput {
  @Field(() => [OrderWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [OrderWhereUniqueInput],
  })
  connect?: Array<OrderWhereUniqueInput>;

  @Field(() => [OrderWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [OrderWhereUniqueInput],
  })
  disconnect?: Array<OrderWhereUniqueInput>;

  @Field(() => [OrderWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [OrderWhereUniqueInput],
  })
  set?: Array<OrderWhereUniqueInput>;
}

export { OrderUpdateManyWithoutCustomersInput as OrderUpdateManyWithoutCustomersInput };
",
  "server/src/customer/base/UpdateCustomerArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { CustomerWhereUniqueInput } from "./CustomerWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";
import { CustomerUpdateInput } from "./CustomerUpdateInput";

@ArgsType()
class UpdateCustomerArgs {
  @ApiProperty({
    required: true,
    type: () => CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @Field(() => CustomerWhereUniqueInput, { nullable: false })
  where!: CustomerWhereUniqueInput;

  @ApiProperty({
    required: true,
    type: () => CustomerUpdateInput,
  })
  @ValidateNested()
  @Type(() => CustomerUpdateInput)
  @Field(() => CustomerUpdateInput, { nullable: false })
  data!: CustomerUpdateInput;
}

export { UpdateCustomerArgs as UpdateCustomerArgs };
",
  "server/src/customer/base/customer.controller.base.spec.ts": "import { Test } from "@nestjs/testing";
import {
  INestApplication,
  HttpStatus,
  ExecutionContext,
  CallHandler,
} from "@nestjs/common";
import request from "supertest";
import { ACGuard } from "nest-access-control";
import { DefaultAuthGuard } from "../../auth/defaultAuth.guard";
import { ACLModule } from "../../auth/acl.module";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { map } from "rxjs";
import { CustomerController } from "../customer.controller";
import { CustomerService } from "../customer.service";

const nonExistingId = "nonExistingId";
const existingId = "existingId";
const CREATE_INPUT = {
  id: 42242424,
  createdAt: new Date(),
  updatedAt: new Date(),
  email: "exampleEmail",
  firstName: "exampleFirstName",
  lastName: "exampleLastName",
  isVip: "true",
  birthData: new Date(),
  averageSale: 42.424242424,
  favoriteNumber: 42242424,
  geoLocation: "exampleGeoLocation",
  comments: "exampleComments",
};
const CREATE_RESULT = {
  id: 42242424,
  createdAt: new Date(),
  updatedAt: new Date(),
  email: "exampleEmail",
  firstName: "exampleFirstName",
  lastName: "exampleLastName",
  isVip: "true",
  birthData: new Date(),
  averageSale: 42.424242424,
  favoriteNumber: 42242424,
  geoLocation: "exampleGeoLocation",
  comments: "exampleComments",
};
const FIND_MANY_RESULT = [
  {
    id: 42242424,
    createdAt: new Date(),
    updatedAt: new Date(),
    email: "exampleEmail",
    firstName: "exampleFirstName",
    lastName: "exampleLastName",
    isVip: "true",
    birthData: new Date(),
    averageSale: 42.424242424,
    favoriteNumber: 42242424,
    geoLocation: "exampleGeoLocation",
    comments: "exampleComments",
  },
];
const FIND_ONE_RESULT = {
  id: 42242424,
  createdAt: new Date(),
  updatedAt: new Date(),
  email: "exampleEmail",
  firstName: "exampleFirstName",
  lastName: "exampleLastName",
  isVip: "true",
  birthData: new Date(),
  averageSale: 42.424242424,
  favoriteNumber: 42242424,
  geoLocation: "exampleGeoLocation",
  comments: "exampleComments",
};

const service = {
  createCustomer() {
    return CREATE_RESULT;
  },
  customers: () => FIND_MANY_RESULT,
  customer: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: ["user"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

const aclFilterResponseInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle().pipe(
      map((data) => {
        return data;
      })
    );
  },
};
const aclValidateRequestInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle();
  },
};

describe("Customer", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: CustomerService,
          useValue: service,
        },
      ],
      controllers: [CustomerController],
      imports: [ACLModule],
    })
      .overrideGuard(DefaultAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .overrideInterceptor(AclFilterResponseInterceptor)
      .useValue(aclFilterResponseInterceptor)
      .overrideInterceptor(AclValidateRequestInterceptor)
      .useValue(aclValidateRequestInterceptor)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test("POST /customers", async () => {
    await request(app.getHttpServer())
      .post("/customers")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
        birthData: CREATE_RESULT.birthData.toISOString(),
      });
  });

  test("GET /customers", async () => {
    await request(app.getHttpServer())
      .get("/customers")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
          birthData: FIND_MANY_RESULT[0].birthData.toISOString(),
        },
      ]);
  });

  test("GET /customers/:id non existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/customers"}/\${nonExistingId}\`)
      .expect(HttpStatus.NOT_FOUND)
      .expect({
        statusCode: HttpStatus.NOT_FOUND,
        message: \`No resource was found for {"\${"id"}":"\${nonExistingId}"}\`,
        error: "Not Found",
      });
  });

  test("GET /customers/:id existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/customers"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
        birthData: FIND_ONE_RESULT.birthData.toISOString(),
      });
  });

  test("POST /customers existing resource", async () => {
    const agent = request(app.getHttpServer());
    await agent
      .post("/customers")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
        birthData: CREATE_RESULT.birthData.toISOString(),
      })
      .then(function () {
        agent
          .post("/customers")
          .send(CREATE_INPUT)
          .expect(HttpStatus.CONFLICT)
          .expect({
            statusCode: HttpStatus.CONFLICT,
          });
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/customer/base/customer.controller.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import { CustomerService } from "../customer.service";
import { Public } from "../../decorators/public.decorator";
import { CustomerCreateInput } from "./CustomerCreateInput";
import { Customer } from "./Customer";
import { CustomerFindManyArgs } from "./CustomerFindManyArgs";
import { CustomerWhereUniqueInput } from "./CustomerWhereUniqueInput";
import { CustomerUpdateInput } from "./CustomerUpdateInput";
import { OrderFindManyArgs } from "../../order/base/OrderFindManyArgs";
import { Order } from "../../order/base/Order";
import { OrderWhereUniqueInput } from "../../order/base/OrderWhereUniqueInput";

export class CustomerControllerBase {
  constructor(protected readonly service: CustomerService) {}
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Customer })
  async createCustomer(
    @common.Body() data: CustomerCreateInput
  ): Promise<Customer> {
    return await this.service.createCustomer({
      data: {
        ...data,

        organization: data.organization
          ? {
              connect: data.organization,
            }
          : undefined,

        vipOrganization: data.vipOrganization
          ? {
              connect: data.vipOrganization,
            }
          : undefined,
      },
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.Get()
  @swagger.ApiOkResponse({ type: [Customer] })
  @ApiNestedQuery(CustomerFindManyArgs)
  async customers(@common.Req() request: Request): Promise<Customer[]> {
    const args = plainToClass(CustomerFindManyArgs, request.query);
    return this.service.customers({
      ...args,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Customer })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async customer(
    @common.Param() params: CustomerWhereUniqueInput
  ): Promise<Customer | null> {
    const result = await this.service.customer({
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return result;
  }

  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Customer })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async updateCustomer(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() data: CustomerUpdateInput
  ): Promise<Customer | null> {
    try {
      return await this.service.updateCustomer({
        where: params,
        data: {
          ...data,

          organization: data.organization
            ? {
                connect: data.organization,
              }
            : undefined,

          vipOrganization: data.vipOrganization
            ? {
                connect: data.vipOrganization,
              }
            : undefined,
        },
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          email: true,
          firstName: true,
          lastName: true,
          isVip: true,
          birthData: true,
          averageSale: true,
          favoriteNumber: true,
          geoLocation: true,
          comments: true,
          favoriteColors: true,
          customerType: true,

          organization: {
            select: {
              id: true,
            },
          },

          vipOrganization: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Customer })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async deleteCustomer(
    @common.Param() params: CustomerWhereUniqueInput
  ): Promise<Customer | null> {
    try {
      return await this.service.deleteCustomer({
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          email: true,
          firstName: true,
          lastName: true,
          isVip: true,
          birthData: true,
          averageSale: true,
          favoriteNumber: true,
          geoLocation: true,
          comments: true,
          favoriteColors: true,
          customerType: true,

          organization: {
            select: {
              id: true,
            },
          },

          vipOrganization: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @Public()
  @common.Get("/:id/orders")
  @ApiNestedQuery(OrderFindManyArgs)
  async findOrders(
    @common.Req() request: Request,
    @common.Param() params: CustomerWhereUniqueInput
  ): Promise<Order[]> {
    const query = plainToClass(OrderFindManyArgs, request.query);
    const results = await this.service.findOrders(params.id, {
      ...query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return results;
  }

  @common.Post("/:id/orders")
  async connectOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() body: OrderWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      orders: {
        connect: body,
      },
    };
    await this.service.updateCustomer({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/orders")
  async updateOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() body: OrderWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      orders: {
        set: body,
      },
    };
    await this.service.updateCustomer({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/orders")
  async disconnectOrders(
    @common.Param() params: CustomerWhereUniqueInput,
    @common.Body() body: OrderWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      orders: {
        disconnect: body,
      },
    };
    await this.service.updateCustomer({
      where: params,
      data,
      select: { id: true },
    });
  }
}
",
  "server/src/customer/base/customer.module.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { Module } from "@nestjs/common";

@Module({
  imports: [],
  exports: [],
})
export class CustomerModuleBase {}
",
  "server/src/customer/base/customer.resolver.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as graphql from "@nestjs/graphql";
import { GraphQLError } from "graphql";
import { isRecordNotFoundError } from "../../prisma.util";
import { MetaQueryPayload } from "../../util/MetaQueryPayload";
import { Public } from "../../decorators/public.decorator";
import { Customer } from "./Customer";
import { CustomerCountArgs } from "./CustomerCountArgs";
import { CustomerFindManyArgs } from "./CustomerFindManyArgs";
import { CustomerFindUniqueArgs } from "./CustomerFindUniqueArgs";
import { CreateCustomerArgs } from "./CreateCustomerArgs";
import { UpdateCustomerArgs } from "./UpdateCustomerArgs";
import { DeleteCustomerArgs } from "./DeleteCustomerArgs";
import { OrderFindManyArgs } from "../../order/base/OrderFindManyArgs";
import { Order } from "../../order/base/Order";
import { Organization } from "../../organization/base/Organization";
import { CustomerService } from "../customer.service";
@graphql.Resolver(() => Customer)
export class CustomerResolverBase {
  constructor(protected readonly service: CustomerService) {}

  async _customersMeta(
    @graphql.Args() args: CustomerCountArgs
  ): Promise<MetaQueryPayload> {
    const result = await this.service.count(args);
    return {
      count: result,
    };
  }

  @graphql.Query(() => [Customer])
  async customers(
    @graphql.Args() args: CustomerFindManyArgs
  ): Promise<Customer[]> {
    return this.service.customers(args);
  }

  @graphql.Query(() => Customer, { nullable: true })
  async customer(
    @graphql.Args() args: CustomerFindUniqueArgs
  ): Promise<Customer | null> {
    const result = await this.service.customer(args);
    if (result === null) {
      return null;
    }
    return result;
  }

  @graphql.Mutation(() => Customer)
  async createCustomer(
    @graphql.Args() args: CreateCustomerArgs
  ): Promise<Customer> {
    return await this.service.createCustomer({
      ...args,
      data: {
        ...args.data,

        organization: args.data.organization
          ? {
              connect: args.data.organization,
            }
          : undefined,

        vipOrganization: args.data.vipOrganization
          ? {
              connect: args.data.vipOrganization,
            }
          : undefined,
      },
    });
  }

  @graphql.Mutation(() => Customer)
  async updateCustomer(
    @graphql.Args() args: UpdateCustomerArgs
  ): Promise<Customer | null> {
    try {
      return await this.service.updateCustomer({
        ...args,
        data: {
          ...args.data,

          organization: args.data.organization
            ? {
                connect: args.data.organization,
              }
            : undefined,

          vipOrganization: args.data.vipOrganization
            ? {
                connect: args.data.vipOrganization,
              }
            : undefined,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => Customer)
  async deleteCustomer(
    @graphql.Args() args: DeleteCustomerArgs
  ): Promise<Customer | null> {
    try {
      return await this.service.deleteCustomer(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @Public()
  @graphql.ResolveField(() => [Order], { name: "orders" })
  async findOrders(
    @graphql.Parent() parent: Customer,
    @graphql.Args() args: OrderFindManyArgs
  ): Promise<Order[]> {
    const results = await this.service.findOrders(parent.id, args);

    if (!results) {
      return [];
    }

    return results;
  }

  @graphql.ResolveField(() => Organization, {
    nullable: true,
    name: "organization",
  })
  async getOrganization(
    @graphql.Parent() parent: Customer
  ): Promise<Organization | null> {
    const result = await this.service.getOrganization(parent.id);

    if (!result) {
      return null;
    }
    return result;
  }

  @graphql.ResolveField(() => Organization, {
    nullable: true,
    name: "vipOrganization",
  })
  async getVipOrganization(
    @graphql.Parent() parent: Customer
  ): Promise<Organization | null> {
    const result = await this.service.getVipOrganization(parent.id);

    if (!result) {
      return null;
    }
    return result;
  }
}
",
  "server/src/customer/base/customer.service.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { PrismaService } from "../../prisma/prisma.service";

import {
  Prisma,
  Customer, // @ts-ignore
  Order, // @ts-ignore
  Organization,
} from "@prisma/client";

export class CustomerServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.CustomerCountArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerCountArgs>
  ): Promise<number> {
    return this.prisma.customer.count(args);
  }

  async customers<T extends Prisma.CustomerFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerFindManyArgs>
  ): Promise<Customer[]> {
    return this.prisma.customer.findMany(args);
  }
  async customer<T extends Prisma.CustomerFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerFindUniqueArgs>
  ): Promise<Customer | null> {
    return this.prisma.customer.findUnique(args);
  }
  async createCustomer<T extends Prisma.CustomerCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerCreateArgs>
  ): Promise<Customer> {
    return this.prisma.customer.create<T>(args);
  }
  async updateCustomer<T extends Prisma.CustomerUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerUpdateArgs>
  ): Promise<Customer> {
    return this.prisma.customer.update<T>(args);
  }
  async deleteCustomer<T extends Prisma.CustomerDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.CustomerDeleteArgs>
  ): Promise<Customer> {
    return this.prisma.customer.delete(args);
  }

  async findOrders(
    parentId: number,
    args: Prisma.OrderFindManyArgs
  ): Promise<Order[]> {
    return this.prisma.customer
      .findUniqueOrThrow({
        where: { id: parentId },
      })
      .orders(args);
  }

  async getOrganization(parentId: number): Promise<Organization | null> {
    return this.prisma.customer
      .findUnique({
        where: { id: parentId },
      })
      .organization();
  }

  async getVipOrganization(parentId: number): Promise<Organization | null> {
    return this.prisma.customer
      .findUnique({
        where: { id: parentId },
      })
      .vipOrganization();
  }
}
",
  "server/src/customer/customer.controller.ts": "import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { CustomerService } from "./customer.service";
import { CustomerControllerBase } from "./base/customer.controller.base";

@swagger.ApiTags("customers")
@common.Controller("customers")
export class CustomerController extends CustomerControllerBase {
  constructor(protected readonly service: CustomerService) {
    super(service);
  }
}
",
  "server/src/customer/customer.module.ts": "import { Module } from "@nestjs/common";
import { CustomerModuleBase } from "./base/customer.module.base";
import { CustomerService } from "./customer.service";
import { CustomerController } from "./customer.controller";
import { CustomerResolver } from "./customer.resolver";

@Module({
  imports: [CustomerModuleBase],
  controllers: [CustomerController],
  providers: [CustomerService, CustomerResolver],
  exports: [CustomerService],
})
export class CustomerModule {}
",
  "server/src/customer/customer.resolver.ts": "import * as graphql from "@nestjs/graphql";
import { CustomerResolverBase } from "./base/customer.resolver.base";
import { Customer } from "./base/Customer";
import { CustomerService } from "./customer.service";

@graphql.Resolver(() => Customer)
export class CustomerResolver extends CustomerResolverBase {
  constructor(protected readonly service: CustomerService) {
    super(service);
  }
}
",
  "server/src/customer/customer.service.ts": "import { Injectable } from "@nestjs/common";
import { PrismaService } from "../prisma/prisma.service";
import { CustomerServiceBase } from "./base/customer.service.base";

@Injectable()
export class CustomerService extends CustomerServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/decorators/api-nested-query.decorator.ts": "import { applyDecorators } from "@nestjs/common";
import {
  ApiExtraModels,
  ApiQuery,
  ApiQueryOptions,
  getSchemaPath,
} from "@nestjs/swagger";
import "reflect-metadata";

const generateApiQueryObject = (
  prop: any,
  propType: any,
  required: boolean,
  isArray: boolean
): ApiQueryOptions => {
  if (propType === Number) {
    return {
      required,
      name: prop,
      style: "deepObject",
      explode: true,
      type: "number",
      isArray,
    };
  } else if (propType === String) {
    return {
      required,
      name: prop,
      style: "deepObject",
      explode: true,
      type: "string",
      isArray,
    };
  } else {
    return {
      required,
      name: prop,
      style: "deepObject",
      explode: true,
      type: "object",
      isArray,
      schema: {
        $ref: getSchemaPath(propType),
      },
    };
  }
};

// eslint-disable-next-line @typescript-eslint/ban-types,@typescript-eslint/explicit-module-boundary-types,@typescript-eslint/naming-convention
export function ApiNestedQuery(query: Function) {
  const constructor = query.prototype;
  const properties = Reflect.getMetadata(
    "swagger/apiModelPropertiesArray",
    constructor
  ).map((prop: any) => prop.slice(1));

  const decorators = properties
    .map((property: any) => {
      const { required, isArray } = Reflect.getMetadata(
        "swagger/apiModelProperties",
        constructor,
        property
      );
      const propertyType = Reflect.getMetadata(
        "design:type",
        constructor,
        property
      );
      const typedQuery = generateApiQueryObject(
        property,
        propertyType,
        required,
        isArray
      );
      return [ApiExtraModels(propertyType), ApiQuery(typedQuery)];
    })
    .flat();

  return applyDecorators(...decorators);
}
",
  "server/src/decorators/public.decorator.ts": "import { applyDecorators, SetMetadata } from "@nestjs/common";

export const IS_PUBLIC_KEY = "isPublic";

const PublicAuthMiddleware = SetMetadata(IS_PUBLIC_KEY, true);
const PublicAuthSwagger = SetMetadata("swagger/apiSecurity", ["isPublic"]);

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const Public = () =>
  applyDecorators(PublicAuthMiddleware, PublicAuthSwagger);
",
  "server/src/empty/base/DeleteEmptyArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { EmptyWhereUniqueInput } from "./EmptyWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class DeleteEmptyArgs {
  @ApiProperty({
    required: true,
    type: () => EmptyWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => EmptyWhereUniqueInput)
  @Field(() => EmptyWhereUniqueInput, { nullable: false })
  where!: EmptyWhereUniqueInput;
}

export { DeleteEmptyArgs as DeleteEmptyArgs };
",
  "server/src/empty/base/Empty.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ObjectType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsString, IsDate } from "class-validator";
import { Type } from "class-transformer";

@ObjectType()
class Empty {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;
}

export { Empty as Empty };
",
  "server/src/empty/base/EmptyCountArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { EmptyWhereInput } from "./EmptyWhereInput";
import { Type } from "class-transformer";

@ArgsType()
class EmptyCountArgs {
  @ApiProperty({
    required: false,
    type: () => EmptyWhereInput,
  })
  @Field(() => EmptyWhereInput, { nullable: true })
  @Type(() => EmptyWhereInput)
  where?: EmptyWhereInput;
}

export { EmptyCountArgs as EmptyCountArgs };
",
  "server/src/empty/base/EmptyCreateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
class EmptyCreateInput {}
export { EmptyCreateInput as EmptyCreateInput };
",
  "server/src/empty/base/EmptyFindManyArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { EmptyWhereInput } from "./EmptyWhereInput";
import { IsOptional, ValidateNested, IsInt } from "class-validator";
import { Type } from "class-transformer";
import { EmptyOrderByInput } from "./EmptyOrderByInput";

@ArgsType()
class EmptyFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => EmptyWhereInput,
  })
  @IsOptional()
  @ValidateNested()
  @Field(() => EmptyWhereInput, { nullable: true })
  @Type(() => EmptyWhereInput)
  where?: EmptyWhereInput;

  @ApiProperty({
    required: false,
    type: [EmptyOrderByInput],
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Field(() => [EmptyOrderByInput], { nullable: true })
  @Type(() => EmptyOrderByInput)
  orderBy?: Array<EmptyOrderByInput>;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { EmptyFindManyArgs as EmptyFindManyArgs };
",
  "server/src/empty/base/EmptyFindUniqueArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { EmptyWhereUniqueInput } from "./EmptyWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class EmptyFindUniqueArgs {
  @ApiProperty({
    required: true,
    type: () => EmptyWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => EmptyWhereUniqueInput)
  @Field(() => EmptyWhereUniqueInput, { nullable: false })
  where!: EmptyWhereUniqueInput;
}

export { EmptyFindUniqueArgs as EmptyFindUniqueArgs };
",
  "server/src/empty/base/EmptyListRelationFilter.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { EmptyWhereInput } from "./EmptyWhereInput";
import { ValidateNested, IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType()
class EmptyListRelationFilter {
  @ApiProperty({
    required: false,
    type: () => EmptyWhereInput,
  })
  @ValidateNested()
  @Type(() => EmptyWhereInput)
  @IsOptional()
  @Field(() => EmptyWhereInput, {
    nullable: true,
  })
  every?: EmptyWhereInput;

  @ApiProperty({
    required: false,
    type: () => EmptyWhereInput,
  })
  @ValidateNested()
  @Type(() => EmptyWhereInput)
  @IsOptional()
  @Field(() => EmptyWhereInput, {
    nullable: true,
  })
  some?: EmptyWhereInput;

  @ApiProperty({
    required: false,
    type: () => EmptyWhereInput,
  })
  @ValidateNested()
  @Type(() => EmptyWhereInput)
  @IsOptional()
  @Field(() => EmptyWhereInput, {
    nullable: true,
  })
  none?: EmptyWhereInput;
}
export { EmptyListRelationFilter as EmptyListRelationFilter };
",
  "server/src/empty/base/EmptyOrderByInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional, IsEnum } from "class-validator";
import { SortOrder } from "../../util/SortOrder";

@InputType({
  isAbstract: true,
  description: undefined,
})
class EmptyOrderByInput {
  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedAt?: SortOrder;
}

export { EmptyOrderByInput as EmptyOrderByInput };
",
  "server/src/empty/base/EmptyUpdateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
class EmptyUpdateInput {}
export { EmptyUpdateInput as EmptyUpdateInput };
",
  "server/src/empty/base/EmptyWhereInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { StringFilter } from "../../util/StringFilter";
import { Type } from "class-transformer";
import { IsOptional } from "class-validator";
import { DateTimeFilter } from "../../util/DateTimeFilter";

@InputType()
class EmptyWhereInput {
  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  id?: StringFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedAt?: DateTimeFilter;
}

export { EmptyWhereInput as EmptyWhereInput };
",
  "server/src/empty/base/EmptyWhereUniqueInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsString } from "class-validator";

@InputType()
class EmptyWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}

export { EmptyWhereUniqueInput as EmptyWhereUniqueInput };
",
  "server/src/empty/base/empty.controller.base.spec.ts": "import { Test } from "@nestjs/testing";
import {
  INestApplication,
  HttpStatus,
  ExecutionContext,
  CallHandler,
} from "@nestjs/common";
import request from "supertest";
import { ACGuard } from "nest-access-control";
import { DefaultAuthGuard } from "../../auth/defaultAuth.guard";
import { ACLModule } from "../../auth/acl.module";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { map } from "rxjs";
import { EmptyController } from "../empty.controller";
import { EmptyService } from "../empty.service";

const nonExistingId = "nonExistingId";
const existingId = "existingId";
const CREATE_INPUT = {
  id: "exampleId",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const CREATE_RESULT = {
  id: "exampleId",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const FIND_MANY_RESULT = [
  {
    id: "exampleId",
    createdAt: new Date(),
    updatedAt: new Date(),
  },
];
const FIND_ONE_RESULT = {
  id: "exampleId",
  createdAt: new Date(),
  updatedAt: new Date(),
};

const service = {
  createEmpty() {
    return CREATE_RESULT;
  },
  empties: () => FIND_MANY_RESULT,
  empty: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: ["user"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

const aclFilterResponseInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle().pipe(
      map((data) => {
        return data;
      })
    );
  },
};
const aclValidateRequestInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle();
  },
};

describe("Empty", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: EmptyService,
          useValue: service,
        },
      ],
      controllers: [EmptyController],
      imports: [ACLModule],
    })
      .overrideGuard(DefaultAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .overrideInterceptor(AclFilterResponseInterceptor)
      .useValue(aclFilterResponseInterceptor)
      .overrideInterceptor(AclValidateRequestInterceptor)
      .useValue(aclValidateRequestInterceptor)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test("POST /empties", async () => {
    await request(app.getHttpServer())
      .post("/empties")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test("GET /empties", async () => {
    await request(app.getHttpServer())
      .get("/empties")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test("GET /empties/:id non existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/empties"}/\${nonExistingId}\`)
      .expect(HttpStatus.NOT_FOUND)
      .expect({
        statusCode: HttpStatus.NOT_FOUND,
        message: \`No resource was found for {"\${"id"}":"\${nonExistingId}"}\`,
        error: "Not Found",
      });
  });

  test("GET /empties/:id existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/empties"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  test("POST /empties existing resource", async () => {
    const agent = request(app.getHttpServer());
    await agent
      .post("/empties")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      })
      .then(function () {
        agent
          .post("/empties")
          .send(CREATE_INPUT)
          .expect(HttpStatus.CONFLICT)
          .expect({
            statusCode: HttpStatus.CONFLICT,
          });
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/empty/base/empty.controller.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import { EmptyService } from "../empty.service";
import { EmptyCreateInput } from "./EmptyCreateInput";
import { Empty } from "./Empty";
import { EmptyFindManyArgs } from "./EmptyFindManyArgs";
import { EmptyWhereUniqueInput } from "./EmptyWhereUniqueInput";
import { EmptyUpdateInput } from "./EmptyUpdateInput";

export class EmptyControllerBase {
  constructor(protected readonly service: EmptyService) {}
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Empty })
  async createEmpty(@common.Body() data: EmptyCreateInput): Promise<Empty> {
    return await this.service.createEmpty({
      data: data,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
  }

  @common.Get()
  @swagger.ApiOkResponse({ type: [Empty] })
  @ApiNestedQuery(EmptyFindManyArgs)
  async empties(@common.Req() request: Request): Promise<Empty[]> {
    const args = plainToClass(EmptyFindManyArgs, request.query);
    return this.service.empties({
      ...args,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
  }

  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Empty })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async empty(
    @common.Param() params: EmptyWhereUniqueInput
  ): Promise<Empty | null> {
    const result = await this.service.empty({
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return result;
  }

  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Empty })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async updateEmpty(
    @common.Param() params: EmptyWhereUniqueInput,
    @common.Body() data: EmptyUpdateInput
  ): Promise<Empty | null> {
    try {
      return await this.service.updateEmpty({
        where: params,
        data: data,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Empty })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async deleteEmpty(
    @common.Param() params: EmptyWhereUniqueInput
  ): Promise<Empty | null> {
    try {
      return await this.service.deleteEmpty({
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/empty/base/empty.module.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { Module } from "@nestjs/common";

@Module({
  imports: [],
  exports: [],
})
export class EmptyModuleBase {}
",
  "server/src/empty/base/empty.resolver.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as graphql from "@nestjs/graphql";
import { GraphQLError } from "graphql";
import { isRecordNotFoundError } from "../../prisma.util";
import { MetaQueryPayload } from "../../util/MetaQueryPayload";
import { Empty } from "./Empty";
import { EmptyCountArgs } from "./EmptyCountArgs";
import { EmptyFindManyArgs } from "./EmptyFindManyArgs";
import { EmptyFindUniqueArgs } from "./EmptyFindUniqueArgs";
import { DeleteEmptyArgs } from "./DeleteEmptyArgs";
import { EmptyService } from "../empty.service";
@graphql.Resolver(() => Empty)
export class EmptyResolverBase {
  constructor(protected readonly service: EmptyService) {}

  async _emptiesMeta(
    @graphql.Args() args: EmptyCountArgs
  ): Promise<MetaQueryPayload> {
    const result = await this.service.count(args);
    return {
      count: result,
    };
  }

  @graphql.Query(() => [Empty])
  async empties(@graphql.Args() args: EmptyFindManyArgs): Promise<Empty[]> {
    return this.service.empties(args);
  }

  @graphql.Query(() => Empty, { nullable: true })
  async empty(
    @graphql.Args() args: EmptyFindUniqueArgs
  ): Promise<Empty | null> {
    const result = await this.service.empty(args);
    if (result === null) {
      return null;
    }
    return result;
  }

  @graphql.Mutation(() => Empty)
  async deleteEmpty(
    @graphql.Args() args: DeleteEmptyArgs
  ): Promise<Empty | null> {
    try {
      return await this.service.deleteEmpty(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/empty/base/empty.service.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { PrismaService } from "../../prisma/prisma.service";
import { Prisma, Empty } from "@prisma/client";

export class EmptyServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.EmptyCountArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyCountArgs>
  ): Promise<number> {
    return this.prisma.empty.count(args);
  }

  async empties<T extends Prisma.EmptyFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyFindManyArgs>
  ): Promise<Empty[]> {
    return this.prisma.empty.findMany(args);
  }
  async empty<T extends Prisma.EmptyFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyFindUniqueArgs>
  ): Promise<Empty | null> {
    return this.prisma.empty.findUnique(args);
  }
  async createEmpty<T extends Prisma.EmptyCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyCreateArgs>
  ): Promise<Empty> {
    return this.prisma.empty.create<T>(args);
  }
  async updateEmpty<T extends Prisma.EmptyUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyUpdateArgs>
  ): Promise<Empty> {
    return this.prisma.empty.update<T>(args);
  }
  async deleteEmpty<T extends Prisma.EmptyDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.EmptyDeleteArgs>
  ): Promise<Empty> {
    return this.prisma.empty.delete(args);
  }
}
",
  "server/src/empty/empty.controller.ts": "import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { EmptyService } from "./empty.service";
import { EmptyControllerBase } from "./base/empty.controller.base";

@swagger.ApiTags("empties")
@common.Controller("empties")
export class EmptyController extends EmptyControllerBase {
  constructor(protected readonly service: EmptyService) {
    super(service);
  }
}
",
  "server/src/empty/empty.module.ts": "import { Module } from "@nestjs/common";
import { EmptyModuleBase } from "./base/empty.module.base";
import { EmptyService } from "./empty.service";
import { EmptyController } from "./empty.controller";
import { EmptyResolver } from "./empty.resolver";

@Module({
  imports: [EmptyModuleBase],
  controllers: [EmptyController],
  providers: [EmptyService, EmptyResolver],
  exports: [EmptyService],
})
export class EmptyModule {}
",
  "server/src/empty/empty.resolver.ts": "import * as graphql from "@nestjs/graphql";
import { EmptyResolverBase } from "./base/empty.resolver.base";
import { Empty } from "./base/Empty";
import { EmptyService } from "./empty.service";

@graphql.Resolver(() => Empty)
export class EmptyResolver extends EmptyResolverBase {
  constructor(protected readonly service: EmptyService) {
    super(service);
  }
}
",
  "server/src/empty/empty.service.ts": "import { Injectable } from "@nestjs/common";
import { PrismaService } from "../prisma/prisma.service";
import { EmptyServiceBase } from "./base/empty.service.base";

@Injectable()
export class EmptyService extends EmptyServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/errors.ts": "import * as common from "@nestjs/common";
import { ApiProperty } from "@nestjs/swagger";

export class ForbiddenException extends common.ForbiddenException {
  @ApiProperty()
  statusCode!: number;
  @ApiProperty()
  message!: string;
}

export class NotFoundException extends common.NotFoundException {
  @ApiProperty()
  statusCode!: number;
  @ApiProperty()
  message!: string;
}
",
  "server/src/filters/HttpExceptions.filter.ts": "import {
  ArgumentsHost,
  Catch,
  HttpException,
  HttpServer,
  HttpStatus,
} from "@nestjs/common";
import { BaseExceptionFilter } from "@nestjs/core";
import { Prisma } from "@prisma/client";
import { Response } from "express";

export type ErrorCodesStatusMapping = {
  [key: string]: number;
};

/**
 * {@link PrismaClientExceptionFilter} handling {@link Prisma.PrismaClientKnownRequestError} exceptions.
 */
@Catch(Prisma?.PrismaClientKnownRequestError)
export class HttpExceptionFilter extends BaseExceptionFilter {
  /**
   * default error codes mapping
   *
   * Error codes definition for Prisma Client (Query Engine)
   * @see https://www.prisma.io/docs/reference/api-reference/error-reference#prisma-client-query-engine
   */
  private errorCodesStatusMapping: ErrorCodesStatusMapping = {
    P2000: HttpStatus.BAD_REQUEST,
    P2002: HttpStatus.CONFLICT,
    P2025: HttpStatus.NOT_FOUND,
  };

  /**
   * @param applicationRef
   */
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(applicationRef?: HttpServer) {
    super(applicationRef);
  }

  /**
   * @param exception
   * @param host
   * @returns
   */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  catch(exception: Prisma.PrismaClientKnownRequestError, host: ArgumentsHost) {
    const statusCode = this.errorCodesStatusMapping[exception.code];
    let message;
    if (host.getType() === "http") {
      // for http requests (REST)
      // Todo : Add all other exception types and also add mapping
      const ctx = host.switchToHttp();
      const response = ctx.getResponse<Response>();
      if (exception.code === "P2002") {
        // Handling Unique Key Constraint Violation Error
        const fields = (exception.meta as { target: string[] }).target;
        message = \`Another record with the requested (\${fields.join(
          ", "
        )}) already exists\`;
      } else {
        message =
          \`[\${exception.code}]: \` +
          this.exceptionShortMessage(exception.message);
      }
      if (!Object.keys(this.errorCodesStatusMapping).includes(exception.code)) {
        return super.catch(exception, host);
      }
      const errorResponse = {
        message: message,
        statusCode: statusCode,
      };
      response.status(statusCode).send(errorResponse);
    }
    return new HttpException({ statusCode, message }, statusCode);
  }

  /**
   * @param exception
   * @returns short message for the exception
   */
  exceptionShortMessage(message: string): string {
    const shortMessage = message.substring(message.indexOf("→"));
    return shortMessage
      .substring(shortMessage.indexOf("\\n"))
      .replace(/\\n/g, "")
      .trim();
  }
}
",
  "server/src/health/base/health.controller.base.ts": "import { Get, HttpStatus, Res } from "@nestjs/common";
import { Response } from "express";
import { HealthService } from "../health.service";

export class HealthControllerBase {
  constructor(protected readonly healthService: HealthService) {}
  @Get("live")
  healthLive(@Res() response: Response): Response<void> {
    return response.status(HttpStatus.NO_CONTENT).send();
  }
  @Get("ready")
  async healthReady(@Res() response: Response): Promise<Response<void>> {
    const dbConnection = await this.healthService.isDbReady();
    if (!dbConnection) {
      return response.status(HttpStatus.NOT_FOUND).send();
    }
    return response.status(HttpStatus.NO_CONTENT).send();
  }
}
",
  "server/src/health/base/health.service.base.ts": "import { Injectable } from "@nestjs/common";
import { PrismaService } from "../../prisma/prisma.service";

@Injectable()
export class HealthServiceBase {
  constructor(protected readonly prisma: PrismaService) {}
  async isDbReady(): Promise<boolean> {
    try {
      await this.prisma.$queryRaw\`SELECT 1\`;
      return true;
    } catch (error) {
      return false;
    }
  }
}
",
  "server/src/health/health.controller.ts": "import { Controller } from "@nestjs/common";
import { HealthControllerBase } from "./base/health.controller.base";
import { HealthService } from "./health.service";

@Controller("_health")
export class HealthController extends HealthControllerBase {
  constructor(protected readonly healthService: HealthService) {
    super(healthService);
  }
}
",
  "server/src/health/health.module.ts": "import { Module } from "@nestjs/common";
import { HealthController } from "./health.controller";
import { HealthService } from "./health.service";

@Module({
  controllers: [HealthController],
  providers: [HealthService],
  exports: [HealthService],
})
export class HealthModule {}
",
  "server/src/health/health.service.ts": "import { Injectable } from "@nestjs/common";
import { PrismaService } from "../prisma/prisma.service";
import { HealthServiceBase } from "./base/health.service.base";

@Injectable()
export class HealthService extends HealthServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/main.ts": "import { ValidationPipe } from "@nestjs/common";
import { HttpAdapterHost, NestFactory } from "@nestjs/core";
import { OpenAPIObject, SwaggerModule } from "@nestjs/swagger";
import { HttpExceptionFilter } from "./filters/HttpExceptions.filter";
import { AppModule } from "./app.module";
import { connectMicroservices } from "./connectMicroservices";
import {
  swaggerPath,
  swaggerDocumentOptions,
  swaggerSetupOptions,
} from "./swagger";

const { PORT = 3000 } = process.env;

async function main() {
  const app = await NestFactory.create(AppModule, { cors: true });

  app.setGlobalPrefix("api");
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      forbidUnknownValues: false,
    })
  );

  //This fix is based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  BigInt.prototype.toJSON = function () {
    return this.toString();
  };

  const document = SwaggerModule.createDocument(app, swaggerDocumentOptions);

  /** check if there is Public decorator for each path (action) and its method (findMany / findOne) on each controller */
  Object.values((document as OpenAPIObject).paths).forEach((path: any) => {
    Object.values(path).forEach((method: any) => {
      if (
        Array.isArray(method.security) &&
        method.security.includes("isPublic")
      ) {
        method.security = [];
      }
    });
  });

  await connectMicroservices(app);
  await app.startAllMicroservices();

  SwaggerModule.setup(swaggerPath, app, document, swaggerSetupOptions);

  const { httpAdapter } = app.get(HttpAdapterHost);
  app.useGlobalFilters(new HttpExceptionFilter(httpAdapter));

  void app.listen(PORT);

  return app;
}

module.exports = main();
",
  "server/src/order/base/CreateOrderArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrderCreateInput } from "./OrderCreateInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class CreateOrderArgs {
  @ApiProperty({
    required: true,
    type: () => OrderCreateInput,
  })
  @ValidateNested()
  @Type(() => OrderCreateInput)
  @Field(() => OrderCreateInput, { nullable: false })
  data!: OrderCreateInput;
}

export { CreateOrderArgs as CreateOrderArgs };
",
  "server/src/order/base/DeleteOrderArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrderWhereUniqueInput } from "./OrderWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class DeleteOrderArgs {
  @ApiProperty({
    required: true,
    type: () => OrderWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrderWhereUniqueInput)
  @Field(() => OrderWhereUniqueInput, { nullable: false })
  where!: OrderWhereUniqueInput;
}

export { DeleteOrderArgs as DeleteOrderArgs };
",
  "server/src/order/base/EnumOrderLabel.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { registerEnumType } from "@nestjs/graphql";

export enum EnumOrderLabel {
  Fragile = "fragile",
}

registerEnumType(EnumOrderLabel, {
  name: "EnumOrderLabel",
});
",
  "server/src/order/base/EnumOrderStatus.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { registerEnumType } from "@nestjs/graphql";

export enum EnumOrderStatus {
  Pending = "pending",
  InProgress = "inProgress",
  Done = "done",
}

registerEnumType(EnumOrderStatus, {
  name: "EnumOrderStatus",
});
",
  "server/src/order/base/Order.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ObjectType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import {
  IsString,
  IsDate,
  ValidateNested,
  IsEnum,
  IsOptional,
} from "class-validator";
import { Type } from "class-transformer";
import { Customer } from "../../customer/base/Customer";
import { EnumOrderStatus } from "./EnumOrderStatus";
import { EnumOrderLabel } from "./EnumOrderLabel";

@ObjectType()
class Order {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;

  @ApiProperty({
    required: true,
    type: () => Customer,
  })
  @ValidateNested()
  @Type(() => Customer)
  customer?: Customer;

  @ApiProperty({
    required: true,
    enum: EnumOrderStatus,
  })
  @IsEnum(EnumOrderStatus)
  @Field(() => EnumOrderStatus, {
    nullable: true,
  })
  status?: "pending" | "inProgress" | "done";

  @ApiProperty({
    required: false,
    enum: EnumOrderLabel,
  })
  @IsEnum(EnumOrderLabel)
  @IsOptional()
  @Field(() => EnumOrderLabel, {
    nullable: true,
  })
  label?: "fragile" | null;
}

export { Order as Order };
",
  "server/src/order/base/OrderCountArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrderWhereInput } from "./OrderWhereInput";
import { Type } from "class-transformer";

@ArgsType()
class OrderCountArgs {
  @ApiProperty({
    required: false,
    type: () => OrderWhereInput,
  })
  @Field(() => OrderWhereInput, { nullable: true })
  @Type(() => OrderWhereInput)
  where?: OrderWhereInput;
}

export { OrderCountArgs as OrderCountArgs };
",
  "server/src/order/base/OrderCreateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { CustomerWhereUniqueInput } from "../../customer/base/CustomerWhereUniqueInput";
import { ValidateNested, IsEnum, IsOptional } from "class-validator";
import { Type } from "class-transformer";
import { EnumOrderStatus } from "./EnumOrderStatus";
import { EnumOrderLabel } from "./EnumOrderLabel";

@InputType()
class OrderCreateInput {
  @ApiProperty({
    required: true,
    type: () => CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @Field(() => CustomerWhereUniqueInput)
  customer!: CustomerWhereUniqueInput;

  @ApiProperty({
    required: true,
    enum: EnumOrderStatus,
  })
  @IsEnum(EnumOrderStatus)
  @Field(() => EnumOrderStatus)
  status!: "pending" | "inProgress" | "done";

  @ApiProperty({
    required: false,
    enum: EnumOrderLabel,
  })
  @IsEnum(EnumOrderLabel)
  @IsOptional()
  @Field(() => EnumOrderLabel, {
    nullable: true,
  })
  label?: "fragile" | null;
}

export { OrderCreateInput as OrderCreateInput };
",
  "server/src/order/base/OrderFindManyArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrderWhereInput } from "./OrderWhereInput";
import { IsOptional, ValidateNested, IsInt } from "class-validator";
import { Type } from "class-transformer";
import { OrderOrderByInput } from "./OrderOrderByInput";

@ArgsType()
class OrderFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => OrderWhereInput,
  })
  @IsOptional()
  @ValidateNested()
  @Field(() => OrderWhereInput, { nullable: true })
  @Type(() => OrderWhereInput)
  where?: OrderWhereInput;

  @ApiProperty({
    required: false,
    type: [OrderOrderByInput],
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Field(() => [OrderOrderByInput], { nullable: true })
  @Type(() => OrderOrderByInput)
  orderBy?: Array<OrderOrderByInput>;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { OrderFindManyArgs as OrderFindManyArgs };
",
  "server/src/order/base/OrderFindUniqueArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrderWhereUniqueInput } from "./OrderWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class OrderFindUniqueArgs {
  @ApiProperty({
    required: true,
    type: () => OrderWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrderWhereUniqueInput)
  @Field(() => OrderWhereUniqueInput, { nullable: false })
  where!: OrderWhereUniqueInput;
}

export { OrderFindUniqueArgs as OrderFindUniqueArgs };
",
  "server/src/order/base/OrderListRelationFilter.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrderWhereInput } from "./OrderWhereInput";
import { ValidateNested, IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType()
class OrderListRelationFilter {
  @ApiProperty({
    required: false,
    type: () => OrderWhereInput,
  })
  @ValidateNested()
  @Type(() => OrderWhereInput)
  @IsOptional()
  @Field(() => OrderWhereInput, {
    nullable: true,
  })
  every?: OrderWhereInput;

  @ApiProperty({
    required: false,
    type: () => OrderWhereInput,
  })
  @ValidateNested()
  @Type(() => OrderWhereInput)
  @IsOptional()
  @Field(() => OrderWhereInput, {
    nullable: true,
  })
  some?: OrderWhereInput;

  @ApiProperty({
    required: false,
    type: () => OrderWhereInput,
  })
  @ValidateNested()
  @Type(() => OrderWhereInput)
  @IsOptional()
  @Field(() => OrderWhereInput, {
    nullable: true,
  })
  none?: OrderWhereInput;
}
export { OrderListRelationFilter as OrderListRelationFilter };
",
  "server/src/order/base/OrderOrderByInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional, IsEnum } from "class-validator";
import { SortOrder } from "../../util/SortOrder";

@InputType({
  isAbstract: true,
  description: undefined,
})
class OrderOrderByInput {
  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  customerId?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  status?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  label?: SortOrder;
}

export { OrderOrderByInput as OrderOrderByInput };
",
  "server/src/order/base/OrderUpdateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { CustomerWhereUniqueInput } from "../../customer/base/CustomerWhereUniqueInput";
import { ValidateNested, IsOptional, IsEnum } from "class-validator";
import { Type } from "class-transformer";
import { EnumOrderStatus } from "./EnumOrderStatus";
import { EnumOrderLabel } from "./EnumOrderLabel";

@InputType()
class OrderUpdateInput {
  @ApiProperty({
    required: false,
    type: () => CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @IsOptional()
  @Field(() => CustomerWhereUniqueInput, {
    nullable: true,
  })
  customer?: CustomerWhereUniqueInput;

  @ApiProperty({
    required: false,
    enum: EnumOrderStatus,
  })
  @IsEnum(EnumOrderStatus)
  @IsOptional()
  @Field(() => EnumOrderStatus, {
    nullable: true,
  })
  status?: "pending" | "inProgress" | "done";

  @ApiProperty({
    required: false,
    enum: EnumOrderLabel,
  })
  @IsEnum(EnumOrderLabel)
  @IsOptional()
  @Field(() => EnumOrderLabel, {
    nullable: true,
  })
  label?: "fragile" | null;
}

export { OrderUpdateInput as OrderUpdateInput };
",
  "server/src/order/base/OrderWhereInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { StringFilter } from "../../util/StringFilter";
import { Type } from "class-transformer";
import { IsOptional, ValidateNested, IsEnum } from "class-validator";
import { DateTimeFilter } from "../../util/DateTimeFilter";
import { CustomerWhereUniqueInput } from "../../customer/base/CustomerWhereUniqueInput";
import { EnumOrderStatus } from "./EnumOrderStatus";
import { EnumOrderLabel } from "./EnumOrderLabel";

@InputType()
class OrderWhereInput {
  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  id?: StringFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: () => CustomerWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => CustomerWhereUniqueInput)
  @IsOptional()
  @Field(() => CustomerWhereUniqueInput, {
    nullable: true,
  })
  customer?: CustomerWhereUniqueInput;

  @ApiProperty({
    required: false,
    enum: EnumOrderStatus,
  })
  @IsEnum(EnumOrderStatus)
  @IsOptional()
  @Field(() => EnumOrderStatus, {
    nullable: true,
  })
  status?: "pending" | "inProgress" | "done";

  @ApiProperty({
    required: false,
    enum: EnumOrderLabel,
  })
  @IsEnum(EnumOrderLabel)
  @IsOptional()
  @Field(() => EnumOrderLabel, {
    nullable: true,
  })
  label?: "fragile";
}

export { OrderWhereInput as OrderWhereInput };
",
  "server/src/order/base/OrderWhereUniqueInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsString } from "class-validator";

@InputType()
class OrderWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}

export { OrderWhereUniqueInput as OrderWhereUniqueInput };
",
  "server/src/order/base/UpdateOrderArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrderWhereUniqueInput } from "./OrderWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";
import { OrderUpdateInput } from "./OrderUpdateInput";

@ArgsType()
class UpdateOrderArgs {
  @ApiProperty({
    required: true,
    type: () => OrderWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrderWhereUniqueInput)
  @Field(() => OrderWhereUniqueInput, { nullable: false })
  where!: OrderWhereUniqueInput;

  @ApiProperty({
    required: true,
    type: () => OrderUpdateInput,
  })
  @ValidateNested()
  @Type(() => OrderUpdateInput)
  @Field(() => OrderUpdateInput, { nullable: false })
  data!: OrderUpdateInput;
}

export { UpdateOrderArgs as UpdateOrderArgs };
",
  "server/src/order/base/order.controller.base.spec.ts": "import { Test } from "@nestjs/testing";
import {
  INestApplication,
  HttpStatus,
  ExecutionContext,
  CallHandler,
} from "@nestjs/common";
import request from "supertest";
import { ACGuard } from "nest-access-control";
import { DefaultAuthGuard } from "../../auth/defaultAuth.guard";
import { ACLModule } from "../../auth/acl.module";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { map } from "rxjs";
import { OrderController } from "../order.controller";
import { OrderService } from "../order.service";

const nonExistingId = "nonExistingId";
const existingId = "existingId";
const CREATE_INPUT = {
  id: "exampleId",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const CREATE_RESULT = {
  id: "exampleId",
  createdAt: new Date(),
  updatedAt: new Date(),
};
const FIND_MANY_RESULT = [
  {
    id: "exampleId",
    createdAt: new Date(),
    updatedAt: new Date(),
  },
];
const FIND_ONE_RESULT = {
  id: "exampleId",
  createdAt: new Date(),
  updatedAt: new Date(),
};

const service = {
  createOrder() {
    return CREATE_RESULT;
  },
  orders: () => FIND_MANY_RESULT,
  order: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: ["user"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

const aclFilterResponseInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle().pipe(
      map((data) => {
        return data;
      })
    );
  },
};
const aclValidateRequestInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle();
  },
};

describe("Order", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: OrderService,
          useValue: service,
        },
      ],
      controllers: [OrderController],
      imports: [ACLModule],
    })
      .overrideGuard(DefaultAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .overrideInterceptor(AclFilterResponseInterceptor)
      .useValue(aclFilterResponseInterceptor)
      .overrideInterceptor(AclValidateRequestInterceptor)
      .useValue(aclValidateRequestInterceptor)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test("POST /orders", async () => {
    await request(app.getHttpServer())
      .post("/orders")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test("GET /orders", async () => {
    await request(app.getHttpServer())
      .get("/orders")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test("GET /orders/:id non existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/orders"}/\${nonExistingId}\`)
      .expect(HttpStatus.NOT_FOUND)
      .expect({
        statusCode: HttpStatus.NOT_FOUND,
        message: \`No resource was found for {"\${"id"}":"\${nonExistingId}"}\`,
        error: "Not Found",
      });
  });

  test("GET /orders/:id existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/orders"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  test("POST /orders existing resource", async () => {
    const agent = request(app.getHttpServer());
    await agent
      .post("/orders")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      })
      .then(function () {
        agent
          .post("/orders")
          .send(CREATE_INPUT)
          .expect(HttpStatus.CONFLICT)
          .expect({
            statusCode: HttpStatus.CONFLICT,
          });
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/order/base/order.controller.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import { OrderService } from "../order.service";
import { Public } from "../../decorators/public.decorator";
import { OrderCreateInput } from "./OrderCreateInput";
import { Order } from "./Order";
import { OrderFindManyArgs } from "./OrderFindManyArgs";
import { OrderWhereUniqueInput } from "./OrderWhereUniqueInput";
import { OrderUpdateInput } from "./OrderUpdateInput";

export class OrderControllerBase {
  constructor(protected readonly service: OrderService) {}
  @Public()
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Order })
  async createOrder(@common.Body() data: OrderCreateInput): Promise<Order> {
    return await this.service.createOrder({
      data: {
        ...data,

        customer: {
          connect: data.customer,
        },
      },
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
  }

  @Public()
  @common.Get()
  @swagger.ApiOkResponse({ type: [Order] })
  @ApiNestedQuery(OrderFindManyArgs)
  async orders(@common.Req() request: Request): Promise<Order[]> {
    const args = plainToClass(OrderFindManyArgs, request.query);
    return this.service.orders({
      ...args,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
  }

  @Public()
  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Order })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async order(
    @common.Param() params: OrderWhereUniqueInput
  ): Promise<Order | null> {
    const result = await this.service.order({
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,

        customer: {
          select: {
            id: true,
          },
        },

        status: true,
        label: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return result;
  }

  @Public()
  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Order })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async updateOrder(
    @common.Param() params: OrderWhereUniqueInput,
    @common.Body() data: OrderUpdateInput
  ): Promise<Order | null> {
    try {
      return await this.service.updateOrder({
        where: params,
        data: {
          ...data,

          customer: {
            connect: data.customer,
          },
        },
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,

          customer: {
            select: {
              id: true,
            },
          },

          status: true,
          label: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @Public()
  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Order })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async deleteOrder(
    @common.Param() params: OrderWhereUniqueInput
  ): Promise<Order | null> {
    try {
      return await this.service.deleteOrder({
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,

          customer: {
            select: {
              id: true,
            },
          },

          status: true,
          label: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/order/base/order.module.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { Module } from "@nestjs/common";

@Module({
  imports: [],
  exports: [],
})
export class OrderModuleBase {}
",
  "server/src/order/base/order.resolver.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as graphql from "@nestjs/graphql";
import { GraphQLError } from "graphql";
import { isRecordNotFoundError } from "../../prisma.util";
import { MetaQueryPayload } from "../../util/MetaQueryPayload";
import { Public } from "../../decorators/public.decorator";
import { Order } from "./Order";
import { OrderCountArgs } from "./OrderCountArgs";
import { OrderFindManyArgs } from "./OrderFindManyArgs";
import { OrderFindUniqueArgs } from "./OrderFindUniqueArgs";
import { CreateOrderArgs } from "./CreateOrderArgs";
import { UpdateOrderArgs } from "./UpdateOrderArgs";
import { DeleteOrderArgs } from "./DeleteOrderArgs";
import { Customer } from "../../customer/base/Customer";
import { OrderService } from "../order.service";
@graphql.Resolver(() => Order)
export class OrderResolverBase {
  constructor(protected readonly service: OrderService) {}

  async _ordersMeta(
    @graphql.Args() args: OrderCountArgs
  ): Promise<MetaQueryPayload> {
    const result = await this.service.count(args);
    return {
      count: result,
    };
  }

  @Public()
  @graphql.Query(() => [Order])
  async orders(@graphql.Args() args: OrderFindManyArgs): Promise<Order[]> {
    return this.service.orders(args);
  }

  @Public()
  @graphql.Query(() => Order, { nullable: true })
  async order(
    @graphql.Args() args: OrderFindUniqueArgs
  ): Promise<Order | null> {
    const result = await this.service.order(args);
    if (result === null) {
      return null;
    }
    return result;
  }

  @Public()
  @graphql.Mutation(() => Order)
  async createOrder(@graphql.Args() args: CreateOrderArgs): Promise<Order> {
    return await this.service.createOrder({
      ...args,
      data: {
        ...args.data,

        customer: {
          connect: args.data.customer,
        },
      },
    });
  }

  @Public()
  @graphql.Mutation(() => Order)
  async updateOrder(
    @graphql.Args() args: UpdateOrderArgs
  ): Promise<Order | null> {
    try {
      return await this.service.updateOrder({
        ...args,
        data: {
          ...args.data,

          customer: {
            connect: args.data.customer,
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @Public()
  @graphql.Mutation(() => Order)
  async deleteOrder(
    @graphql.Args() args: DeleteOrderArgs
  ): Promise<Order | null> {
    try {
      return await this.service.deleteOrder(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => Customer, {
    nullable: true,
    name: "customer",
  })
  async getCustomer(@graphql.Parent() parent: Order): Promise<Customer | null> {
    const result = await this.service.getCustomer(parent.id);

    if (!result) {
      return null;
    }
    return result;
  }
}
",
  "server/src/order/base/order.service.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { PrismaService } from "../../prisma/prisma.service";

import {
  Prisma,
  Order, // @ts-ignore
  Customer,
} from "@prisma/client";

export class OrderServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.OrderCountArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderCountArgs>
  ): Promise<number> {
    return this.prisma.order.count(args);
  }

  async orders<T extends Prisma.OrderFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderFindManyArgs>
  ): Promise<Order[]> {
    return this.prisma.order.findMany(args);
  }
  async order<T extends Prisma.OrderFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderFindUniqueArgs>
  ): Promise<Order | null> {
    return this.prisma.order.findUnique(args);
  }
  async createOrder<T extends Prisma.OrderCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderCreateArgs>
  ): Promise<Order> {
    return this.prisma.order.create<T>(args);
  }
  async updateOrder<T extends Prisma.OrderUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderUpdateArgs>
  ): Promise<Order> {
    return this.prisma.order.update<T>(args);
  }
  async deleteOrder<T extends Prisma.OrderDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrderDeleteArgs>
  ): Promise<Order> {
    return this.prisma.order.delete(args);
  }

  async getCustomer(parentId: string): Promise<Customer | null> {
    return this.prisma.order
      .findUnique({
        where: { id: parentId },
      })
      .customer();
  }
}
",
  "server/src/order/order.controller.ts": "import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { OrderService } from "./order.service";
import { OrderControllerBase } from "./base/order.controller.base";

@swagger.ApiTags("orders")
@common.Controller("orders")
export class OrderController extends OrderControllerBase {
  constructor(protected readonly service: OrderService) {
    super(service);
  }
}
",
  "server/src/order/order.module.ts": "import { Module } from "@nestjs/common";
import { OrderModuleBase } from "./base/order.module.base";
import { OrderService } from "./order.service";
import { OrderController } from "./order.controller";
import { OrderResolver } from "./order.resolver";

@Module({
  imports: [OrderModuleBase],
  controllers: [OrderController],
  providers: [OrderService, OrderResolver],
  exports: [OrderService],
})
export class OrderModule {}
",
  "server/src/order/order.resolver.ts": "import * as graphql from "@nestjs/graphql";
import { OrderResolverBase } from "./base/order.resolver.base";
import { Order } from "./base/Order";
import { OrderService } from "./order.service";

@graphql.Resolver(() => Order)
export class OrderResolver extends OrderResolverBase {
  constructor(protected readonly service: OrderService) {
    super(service);
  }
}
",
  "server/src/order/order.service.ts": "import { Injectable } from "@nestjs/common";
import { PrismaService } from "../prisma/prisma.service";
import { OrderServiceBase } from "./base/order.service.base";

@Injectable()
export class OrderService extends OrderServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/organization/base/CreateOrganizationArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrganizationCreateInput } from "./OrganizationCreateInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class CreateOrganizationArgs {
  @ApiProperty({
    required: true,
    type: () => OrganizationCreateInput,
  })
  @ValidateNested()
  @Type(() => OrganizationCreateInput)
  @Field(() => OrganizationCreateInput, { nullable: false })
  data!: OrganizationCreateInput;
}

export { CreateOrganizationArgs as CreateOrganizationArgs };
",
  "server/src/organization/base/CustomerCreateNestedManyWithoutOrganizationsInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { CustomerWhereUniqueInput } from "../../customer/base/CustomerWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class CustomerCreateNestedManyWithoutOrganizationsInput {
  @Field(() => [CustomerWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [CustomerWhereUniqueInput],
  })
  connect?: Array<CustomerWhereUniqueInput>;
}

export { CustomerCreateNestedManyWithoutOrganizationsInput as CustomerCreateNestedManyWithoutOrganizationsInput };
",
  "server/src/organization/base/CustomerUpdateManyWithoutOrganizationsInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { CustomerWhereUniqueInput } from "../../customer/base/CustomerWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class CustomerUpdateManyWithoutOrganizationsInput {
  @Field(() => [CustomerWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [CustomerWhereUniqueInput],
  })
  connect?: Array<CustomerWhereUniqueInput>;

  @Field(() => [CustomerWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [CustomerWhereUniqueInput],
  })
  disconnect?: Array<CustomerWhereUniqueInput>;

  @Field(() => [CustomerWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [CustomerWhereUniqueInput],
  })
  set?: Array<CustomerWhereUniqueInput>;
}

export { CustomerUpdateManyWithoutOrganizationsInput as CustomerUpdateManyWithoutOrganizationsInput };
",
  "server/src/organization/base/DeleteOrganizationArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrganizationWhereUniqueInput } from "./OrganizationWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class DeleteOrganizationArgs {
  @ApiProperty({
    required: true,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @Field(() => OrganizationWhereUniqueInput, { nullable: false })
  where!: OrganizationWhereUniqueInput;
}

export { DeleteOrganizationArgs as DeleteOrganizationArgs };
",
  "server/src/organization/base/Organization.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ObjectType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsString, IsDate, ValidateNested, IsOptional } from "class-validator";
import { Type } from "class-transformer";
import { User } from "../../user/base/User";
import { Customer } from "../../customer/base/Customer";

@ObjectType()
class Organization {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;

  @ApiProperty({
    required: true,
    type: () => [User],
  })
  @ValidateNested()
  @Type(() => User)
  @IsOptional()
  users?: Array<User>;

  @ApiProperty({
    required: true,
    type: () => [Customer],
  })
  @ValidateNested()
  @Type(() => Customer)
  @IsOptional()
  customers?: Array<Customer>;

  @ApiProperty({
    required: true,
    type: () => [Customer],
  })
  @ValidateNested()
  @Type(() => Customer)
  @IsOptional()
  vipCustomers?: Array<Customer>;
}

export { Organization as Organization };
",
  "server/src/organization/base/OrganizationCountArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrganizationWhereInput } from "./OrganizationWhereInput";
import { Type } from "class-transformer";

@ArgsType()
class OrganizationCountArgs {
  @ApiProperty({
    required: false,
    type: () => OrganizationWhereInput,
  })
  @Field(() => OrganizationWhereInput, { nullable: true })
  @Type(() => OrganizationWhereInput)
  where?: OrganizationWhereInput;
}

export { OrganizationCountArgs as OrganizationCountArgs };
",
  "server/src/organization/base/OrganizationCreateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsString, ValidateNested, IsOptional } from "class-validator";
import { UserCreateNestedManyWithoutOrganizationsInput } from "./UserCreateNestedManyWithoutOrganizationsInput";
import { Type } from "class-transformer";
import { CustomerCreateNestedManyWithoutOrganizationsInput } from "./CustomerCreateNestedManyWithoutOrganizationsInput";

@InputType()
class OrganizationCreateInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;

  @ApiProperty({
    required: true,
    type: () => UserCreateNestedManyWithoutOrganizationsInput,
  })
  @ValidateNested()
  @Type(() => UserCreateNestedManyWithoutOrganizationsInput)
  @IsOptional()
  @Field(() => UserCreateNestedManyWithoutOrganizationsInput, {
    nullable: true,
  })
  users?: UserCreateNestedManyWithoutOrganizationsInput;

  @ApiProperty({
    required: true,
    type: () => CustomerCreateNestedManyWithoutOrganizationsInput,
  })
  @ValidateNested()
  @Type(() => CustomerCreateNestedManyWithoutOrganizationsInput)
  @IsOptional()
  @Field(() => CustomerCreateNestedManyWithoutOrganizationsInput, {
    nullable: true,
  })
  customers?: CustomerCreateNestedManyWithoutOrganizationsInput;

  @ApiProperty({
    required: true,
    type: () => CustomerCreateNestedManyWithoutOrganizationsInput,
  })
  @ValidateNested()
  @Type(() => CustomerCreateNestedManyWithoutOrganizationsInput)
  @IsOptional()
  @Field(() => CustomerCreateNestedManyWithoutOrganizationsInput, {
    nullable: true,
  })
  vipCustomers?: CustomerCreateNestedManyWithoutOrganizationsInput;
}

export { OrganizationCreateInput as OrganizationCreateInput };
",
  "server/src/organization/base/OrganizationFindManyArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrganizationWhereInput } from "./OrganizationWhereInput";
import { IsOptional, ValidateNested, IsInt } from "class-validator";
import { Type } from "class-transformer";
import { OrganizationOrderByInput } from "./OrganizationOrderByInput";

@ArgsType()
class OrganizationFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => OrganizationWhereInput,
  })
  @IsOptional()
  @ValidateNested()
  @Field(() => OrganizationWhereInput, { nullable: true })
  @Type(() => OrganizationWhereInput)
  where?: OrganizationWhereInput;

  @ApiProperty({
    required: false,
    type: [OrganizationOrderByInput],
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Field(() => [OrganizationOrderByInput], { nullable: true })
  @Type(() => OrganizationOrderByInput)
  orderBy?: Array<OrganizationOrderByInput>;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { OrganizationFindManyArgs as OrganizationFindManyArgs };
",
  "server/src/organization/base/OrganizationFindUniqueArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrganizationWhereUniqueInput } from "./OrganizationWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class OrganizationFindUniqueArgs {
  @ApiProperty({
    required: true,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @Field(() => OrganizationWhereUniqueInput, { nullable: false })
  where!: OrganizationWhereUniqueInput;
}

export { OrganizationFindUniqueArgs as OrganizationFindUniqueArgs };
",
  "server/src/organization/base/OrganizationListRelationFilter.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrganizationWhereInput } from "./OrganizationWhereInput";
import { ValidateNested, IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType()
class OrganizationListRelationFilter {
  @ApiProperty({
    required: false,
    type: () => OrganizationWhereInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereInput)
  @IsOptional()
  @Field(() => OrganizationWhereInput, {
    nullable: true,
  })
  every?: OrganizationWhereInput;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereInput)
  @IsOptional()
  @Field(() => OrganizationWhereInput, {
    nullable: true,
  })
  some?: OrganizationWhereInput;

  @ApiProperty({
    required: false,
    type: () => OrganizationWhereInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereInput)
  @IsOptional()
  @Field(() => OrganizationWhereInput, {
    nullable: true,
  })
  none?: OrganizationWhereInput;
}
export { OrganizationListRelationFilter as OrganizationListRelationFilter };
",
  "server/src/organization/base/OrganizationOrderByInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional, IsEnum } from "class-validator";
import { SortOrder } from "../../util/SortOrder";

@InputType({
  isAbstract: true,
  description: undefined,
})
class OrganizationOrderByInput {
  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  name?: SortOrder;
}

export { OrganizationOrderByInput as OrganizationOrderByInput };
",
  "server/src/organization/base/OrganizationUpdateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsString, IsOptional, ValidateNested } from "class-validator";
import { UserUpdateManyWithoutOrganizationsInput } from "./UserUpdateManyWithoutOrganizationsInput";
import { Type } from "class-transformer";
import { CustomerUpdateManyWithoutOrganizationsInput } from "./CustomerUpdateManyWithoutOrganizationsInput";

@InputType()
class OrganizationUpdateInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  name?: string;

  @ApiProperty({
    required: false,
    type: () => UserUpdateManyWithoutOrganizationsInput,
  })
  @ValidateNested()
  @Type(() => UserUpdateManyWithoutOrganizationsInput)
  @IsOptional()
  @Field(() => UserUpdateManyWithoutOrganizationsInput, {
    nullable: true,
  })
  users?: UserUpdateManyWithoutOrganizationsInput;

  @ApiProperty({
    required: false,
    type: () => CustomerUpdateManyWithoutOrganizationsInput,
  })
  @ValidateNested()
  @Type(() => CustomerUpdateManyWithoutOrganizationsInput)
  @IsOptional()
  @Field(() => CustomerUpdateManyWithoutOrganizationsInput, {
    nullable: true,
  })
  customers?: CustomerUpdateManyWithoutOrganizationsInput;

  @ApiProperty({
    required: false,
    type: () => CustomerUpdateManyWithoutOrganizationsInput,
  })
  @ValidateNested()
  @Type(() => CustomerUpdateManyWithoutOrganizationsInput)
  @IsOptional()
  @Field(() => CustomerUpdateManyWithoutOrganizationsInput, {
    nullable: true,
  })
  vipCustomers?: CustomerUpdateManyWithoutOrganizationsInput;
}

export { OrganizationUpdateInput as OrganizationUpdateInput };
",
  "server/src/organization/base/OrganizationWhereInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { StringFilter } from "../../util/StringFilter";
import { Type } from "class-transformer";
import { IsOptional, ValidateNested } from "class-validator";
import { DateTimeFilter } from "../../util/DateTimeFilter";
import { UserListRelationFilter } from "../../user/base/UserListRelationFilter";
import { CustomerListRelationFilter } from "../../customer/base/CustomerListRelationFilter";

@InputType()
class OrganizationWhereInput {
  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  id?: StringFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  name?: StringFilter;

  @ApiProperty({
    required: false,
    type: () => UserListRelationFilter,
  })
  @ValidateNested()
  @Type(() => UserListRelationFilter)
  @IsOptional()
  @Field(() => UserListRelationFilter, {
    nullable: true,
  })
  users?: UserListRelationFilter;

  @ApiProperty({
    required: false,
    type: () => CustomerListRelationFilter,
  })
  @ValidateNested()
  @Type(() => CustomerListRelationFilter)
  @IsOptional()
  @Field(() => CustomerListRelationFilter, {
    nullable: true,
  })
  customers?: CustomerListRelationFilter;

  @ApiProperty({
    required: false,
    type: () => CustomerListRelationFilter,
  })
  @ValidateNested()
  @Type(() => CustomerListRelationFilter)
  @IsOptional()
  @Field(() => CustomerListRelationFilter, {
    nullable: true,
  })
  vipCustomers?: CustomerListRelationFilter;
}

export { OrganizationWhereInput as OrganizationWhereInput };
",
  "server/src/organization/base/OrganizationWhereUniqueInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsString } from "class-validator";

@InputType()
class OrganizationWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}

export { OrganizationWhereUniqueInput as OrganizationWhereUniqueInput };
",
  "server/src/organization/base/UpdateOrganizationArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { OrganizationWhereUniqueInput } from "./OrganizationWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";
import { OrganizationUpdateInput } from "./OrganizationUpdateInput";

@ArgsType()
class UpdateOrganizationArgs {
  @ApiProperty({
    required: true,
    type: () => OrganizationWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => OrganizationWhereUniqueInput)
  @Field(() => OrganizationWhereUniqueInput, { nullable: false })
  where!: OrganizationWhereUniqueInput;

  @ApiProperty({
    required: true,
    type: () => OrganizationUpdateInput,
  })
  @ValidateNested()
  @Type(() => OrganizationUpdateInput)
  @Field(() => OrganizationUpdateInput, { nullable: false })
  data!: OrganizationUpdateInput;
}

export { UpdateOrganizationArgs as UpdateOrganizationArgs };
",
  "server/src/organization/base/UserCreateNestedManyWithoutOrganizationsInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { UserWhereUniqueInput } from "../../user/base/UserWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class UserCreateNestedManyWithoutOrganizationsInput {
  @Field(() => [UserWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [UserWhereUniqueInput],
  })
  connect?: Array<UserWhereUniqueInput>;
}

export { UserCreateNestedManyWithoutOrganizationsInput as UserCreateNestedManyWithoutOrganizationsInput };
",
  "server/src/organization/base/UserUpdateManyWithoutOrganizationsInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { UserWhereUniqueInput } from "../../user/base/UserWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class UserUpdateManyWithoutOrganizationsInput {
  @Field(() => [UserWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [UserWhereUniqueInput],
  })
  connect?: Array<UserWhereUniqueInput>;

  @Field(() => [UserWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [UserWhereUniqueInput],
  })
  disconnect?: Array<UserWhereUniqueInput>;

  @Field(() => [UserWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [UserWhereUniqueInput],
  })
  set?: Array<UserWhereUniqueInput>;
}

export { UserUpdateManyWithoutOrganizationsInput as UserUpdateManyWithoutOrganizationsInput };
",
  "server/src/organization/base/organization.controller.base.spec.ts": "import { Test } from "@nestjs/testing";
import {
  INestApplication,
  HttpStatus,
  ExecutionContext,
  CallHandler,
} from "@nestjs/common";
import request from "supertest";
import { ACGuard } from "nest-access-control";
import { DefaultAuthGuard } from "../../auth/defaultAuth.guard";
import { ACLModule } from "../../auth/acl.module";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { map } from "rxjs";
import { OrganizationController } from "../organization.controller";
import { OrganizationService } from "../organization.service";

const nonExistingId = "nonExistingId";
const existingId = "existingId";
const CREATE_INPUT = {
  id: "exampleId",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: "exampleName",
};
const CREATE_RESULT = {
  id: "exampleId",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: "exampleName",
};
const FIND_MANY_RESULT = [
  {
    id: "exampleId",
    createdAt: new Date(),
    updatedAt: new Date(),
    name: "exampleName",
  },
];
const FIND_ONE_RESULT = {
  id: "exampleId",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: "exampleName",
};

const service = {
  createOrganization() {
    return CREATE_RESULT;
  },
  organizations: () => FIND_MANY_RESULT,
  organization: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: ["user"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

const aclFilterResponseInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle().pipe(
      map((data) => {
        return data;
      })
    );
  },
};
const aclValidateRequestInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle();
  },
};

describe("Organization", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: OrganizationService,
          useValue: service,
        },
      ],
      controllers: [OrganizationController],
      imports: [ACLModule],
    })
      .overrideGuard(DefaultAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .overrideInterceptor(AclFilterResponseInterceptor)
      .useValue(aclFilterResponseInterceptor)
      .overrideInterceptor(AclValidateRequestInterceptor)
      .useValue(aclValidateRequestInterceptor)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test("POST /organizations", async () => {
    await request(app.getHttpServer())
      .post("/organizations")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test("GET /organizations", async () => {
    await request(app.getHttpServer())
      .get("/organizations")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test("GET /organizations/:id non existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/organizations"}/\${nonExistingId}\`)
      .expect(HttpStatus.NOT_FOUND)
      .expect({
        statusCode: HttpStatus.NOT_FOUND,
        message: \`No resource was found for {"\${"id"}":"\${nonExistingId}"}\`,
        error: "Not Found",
      });
  });

  test("GET /organizations/:id existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/organizations"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  test("POST /organizations existing resource", async () => {
    const agent = request(app.getHttpServer());
    await agent
      .post("/organizations")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      })
      .then(function () {
        agent
          .post("/organizations")
          .send(CREATE_INPUT)
          .expect(HttpStatus.CONFLICT)
          .expect({
            statusCode: HttpStatus.CONFLICT,
          });
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/organization/base/organization.controller.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import { OrganizationService } from "../organization.service";
import { OrganizationCreateInput } from "./OrganizationCreateInput";
import { Organization } from "./Organization";
import { OrganizationFindManyArgs } from "./OrganizationFindManyArgs";
import { OrganizationWhereUniqueInput } from "./OrganizationWhereUniqueInput";
import { OrganizationUpdateInput } from "./OrganizationUpdateInput";
import { UserFindManyArgs } from "../../user/base/UserFindManyArgs";
import { User } from "../../user/base/User";
import { UserWhereUniqueInput } from "../../user/base/UserWhereUniqueInput";
import { CustomerFindManyArgs } from "../../customer/base/CustomerFindManyArgs";
import { Customer } from "../../customer/base/Customer";
import { CustomerWhereUniqueInput } from "../../customer/base/CustomerWhereUniqueInput";

export class OrganizationControllerBase {
  constructor(protected readonly service: OrganizationService) {}
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Organization })
  async createOrganization(
    @common.Body() data: OrganizationCreateInput
  ): Promise<Organization> {
    return await this.service.createOrganization({
      data: data,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
  }

  @common.Get()
  @swagger.ApiOkResponse({ type: [Organization] })
  @ApiNestedQuery(OrganizationFindManyArgs)
  async organizations(@common.Req() request: Request): Promise<Organization[]> {
    const args = plainToClass(OrganizationFindManyArgs, request.query);
    return this.service.organizations({
      ...args,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
  }

  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Organization })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async organization(
    @common.Param() params: OrganizationWhereUniqueInput
  ): Promise<Organization | null> {
    const result = await this.service.organization({
      where: params,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return result;
  }

  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Organization })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async updateOrganization(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() data: OrganizationUpdateInput
  ): Promise<Organization | null> {
    try {
      return await this.service.updateOrganization({
        where: params,
        data: data,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          name: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Organization })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async deleteOrganization(
    @common.Param() params: OrganizationWhereUniqueInput
  ): Promise<Organization | null> {
    try {
      return await this.service.deleteOrganization({
        where: params,
        select: {
          id: true,
          createdAt: true,
          updatedAt: true,
          name: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.Get("/:id/users")
  @ApiNestedQuery(UserFindManyArgs)
  async findUsers(
    @common.Req() request: Request,
    @common.Param() params: OrganizationWhereUniqueInput
  ): Promise<User[]> {
    const query = plainToClass(UserFindManyArgs, request.query);
    const results = await this.service.findUsers(params.id, {
      ...query,
      select: {
        id: true,
        username: true,
        roles: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,

        profile: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return results;
  }

  @common.Post("/:id/users")
  async connectUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      users: {
        connect: body,
      },
    };
    await this.service.updateOrganization({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/users")
  async updateUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      users: {
        set: body,
      },
    };
    await this.service.updateOrganization({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/users")
  async disconnectUsers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      users: {
        disconnect: body,
      },
    };
    await this.service.updateOrganization({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/customers")
  @ApiNestedQuery(CustomerFindManyArgs)
  async findCustomers(
    @common.Req() request: Request,
    @common.Param() params: OrganizationWhereUniqueInput
  ): Promise<Customer[]> {
    const query = plainToClass(CustomerFindManyArgs, request.query);
    const results = await this.service.findCustomers(params.id, {
      ...query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return results;
  }

  @common.Post("/:id/customers")
  async connectCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customers: {
        connect: body,
      },
    };
    await this.service.updateOrganization({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/customers")
  async updateCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customers: {
        set: body,
      },
    };
    await this.service.updateOrganization({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/customers")
  async disconnectCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customers: {
        disconnect: body,
      },
    };
    await this.service.updateOrganization({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/vipCustomers")
  @ApiNestedQuery(CustomerFindManyArgs)
  async findVipCustomers(
    @common.Req() request: Request,
    @common.Param() params: OrganizationWhereUniqueInput
  ): Promise<Customer[]> {
    const query = plainToClass(CustomerFindManyArgs, request.query);
    const results = await this.service.findVipCustomers(params.id, {
      ...query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        email: true,
        firstName: true,
        lastName: true,
        isVip: true,
        birthData: true,
        averageSale: true,
        favoriteNumber: true,
        geoLocation: true,
        comments: true,
        favoriteColors: true,
        customerType: true,

        organization: {
          select: {
            id: true,
          },
        },

        vipOrganization: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return results;
  }

  @common.Post("/:id/vipCustomers")
  async connectVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      vipCustomers: {
        connect: body,
      },
    };
    await this.service.updateOrganization({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/vipCustomers")
  async updateVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      vipCustomers: {
        set: body,
      },
    };
    await this.service.updateOrganization({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/vipCustomers")
  async disconnectVipCustomers(
    @common.Param() params: OrganizationWhereUniqueInput,
    @common.Body() body: CustomerWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      vipCustomers: {
        disconnect: body,
      },
    };
    await this.service.updateOrganization({
      where: params,
      data,
      select: { id: true },
    });
  }
}
",
  "server/src/organization/base/organization.module.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { Module } from "@nestjs/common";

@Module({
  imports: [],
  exports: [],
})
export class OrganizationModuleBase {}
",
  "server/src/organization/base/organization.resolver.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as graphql from "@nestjs/graphql";
import { GraphQLError } from "graphql";
import { isRecordNotFoundError } from "../../prisma.util";
import { MetaQueryPayload } from "../../util/MetaQueryPayload";
import { Organization } from "./Organization";
import { OrganizationCountArgs } from "./OrganizationCountArgs";
import { OrganizationFindManyArgs } from "./OrganizationFindManyArgs";
import { OrganizationFindUniqueArgs } from "./OrganizationFindUniqueArgs";
import { CreateOrganizationArgs } from "./CreateOrganizationArgs";
import { UpdateOrganizationArgs } from "./UpdateOrganizationArgs";
import { DeleteOrganizationArgs } from "./DeleteOrganizationArgs";
import { UserFindManyArgs } from "../../user/base/UserFindManyArgs";
import { User } from "../../user/base/User";
import { CustomerFindManyArgs } from "../../customer/base/CustomerFindManyArgs";
import { Customer } from "../../customer/base/Customer";
import { OrganizationService } from "../organization.service";
@graphql.Resolver(() => Organization)
export class OrganizationResolverBase {
  constructor(protected readonly service: OrganizationService) {}

  async _organizationsMeta(
    @graphql.Args() args: OrganizationCountArgs
  ): Promise<MetaQueryPayload> {
    const result = await this.service.count(args);
    return {
      count: result,
    };
  }

  @graphql.Query(() => [Organization])
  async organizations(
    @graphql.Args() args: OrganizationFindManyArgs
  ): Promise<Organization[]> {
    return this.service.organizations(args);
  }

  @graphql.Query(() => Organization, { nullable: true })
  async organization(
    @graphql.Args() args: OrganizationFindUniqueArgs
  ): Promise<Organization | null> {
    const result = await this.service.organization(args);
    if (result === null) {
      return null;
    }
    return result;
  }

  @graphql.Mutation(() => Organization)
  async createOrganization(
    @graphql.Args() args: CreateOrganizationArgs
  ): Promise<Organization> {
    return await this.service.createOrganization({
      ...args,
      data: args.data,
    });
  }

  @graphql.Mutation(() => Organization)
  async updateOrganization(
    @graphql.Args() args: UpdateOrganizationArgs
  ): Promise<Organization | null> {
    try {
      return await this.service.updateOrganization({
        ...args,
        data: args.data,
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => Organization)
  async deleteOrganization(
    @graphql.Args() args: DeleteOrganizationArgs
  ): Promise<Organization | null> {
    try {
      return await this.service.deleteOrganization(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => [User], { name: "users" })
  async findUsers(
    @graphql.Parent() parent: Organization,
    @graphql.Args() args: UserFindManyArgs
  ): Promise<User[]> {
    const results = await this.service.findUsers(parent.id, args);

    if (!results) {
      return [];
    }

    return results;
  }

  @graphql.ResolveField(() => [Customer], { name: "customers" })
  async findCustomers(
    @graphql.Parent() parent: Organization,
    @graphql.Args() args: CustomerFindManyArgs
  ): Promise<Customer[]> {
    const results = await this.service.findCustomers(parent.id, args);

    if (!results) {
      return [];
    }

    return results;
  }

  @graphql.ResolveField(() => [Customer], { name: "vipCustomers" })
  async findVipCustomers(
    @graphql.Parent() parent: Organization,
    @graphql.Args() args: CustomerFindManyArgs
  ): Promise<Customer[]> {
    const results = await this.service.findVipCustomers(parent.id, args);

    if (!results) {
      return [];
    }

    return results;
  }
}
",
  "server/src/organization/base/organization.service.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { PrismaService } from "../../prisma/prisma.service";

import {
  Prisma,
  Organization, // @ts-ignore
  User, // @ts-ignore
  Customer,
} from "@prisma/client";

export class OrganizationServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.OrganizationCountArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationCountArgs>
  ): Promise<number> {
    return this.prisma.organization.count(args);
  }

  async organizations<T extends Prisma.OrganizationFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationFindManyArgs>
  ): Promise<Organization[]> {
    return this.prisma.organization.findMany(args);
  }
  async organization<T extends Prisma.OrganizationFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationFindUniqueArgs>
  ): Promise<Organization | null> {
    return this.prisma.organization.findUnique(args);
  }
  async createOrganization<T extends Prisma.OrganizationCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationCreateArgs>
  ): Promise<Organization> {
    return this.prisma.organization.create<T>(args);
  }
  async updateOrganization<T extends Prisma.OrganizationUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationUpdateArgs>
  ): Promise<Organization> {
    return this.prisma.organization.update<T>(args);
  }
  async deleteOrganization<T extends Prisma.OrganizationDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.OrganizationDeleteArgs>
  ): Promise<Organization> {
    return this.prisma.organization.delete(args);
  }

  async findUsers(
    parentId: string,
    args: Prisma.UserFindManyArgs
  ): Promise<User[]> {
    return this.prisma.organization
      .findUniqueOrThrow({
        where: { id: parentId },
      })
      .users(args);
  }

  async findCustomers(
    parentId: string,
    args: Prisma.CustomerFindManyArgs
  ): Promise<Customer[]> {
    return this.prisma.organization
      .findUniqueOrThrow({
        where: { id: parentId },
      })
      .customers(args);
  }

  async findVipCustomers(
    parentId: string,
    args: Prisma.CustomerFindManyArgs
  ): Promise<Customer[]> {
    return this.prisma.organization
      .findUniqueOrThrow({
        where: { id: parentId },
      })
      .vipCustomers(args);
  }
}
",
  "server/src/organization/organization.controller.ts": "import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { OrganizationService } from "./organization.service";
import { OrganizationControllerBase } from "./base/organization.controller.base";

@swagger.ApiTags("organizations")
@common.Controller("organizations")
export class OrganizationController extends OrganizationControllerBase {
  constructor(protected readonly service: OrganizationService) {
    super(service);
  }
}
",
  "server/src/organization/organization.module.ts": "import { Module } from "@nestjs/common";
import { OrganizationModuleBase } from "./base/organization.module.base";
import { OrganizationService } from "./organization.service";
import { OrganizationController } from "./organization.controller";
import { OrganizationResolver } from "./organization.resolver";

@Module({
  imports: [OrganizationModuleBase],
  controllers: [OrganizationController],
  providers: [OrganizationService, OrganizationResolver],
  exports: [OrganizationService],
})
export class OrganizationModule {}
",
  "server/src/organization/organization.resolver.ts": "import * as graphql from "@nestjs/graphql";
import { OrganizationResolverBase } from "./base/organization.resolver.base";
import { Organization } from "./base/Organization";
import { OrganizationService } from "./organization.service";

@graphql.Resolver(() => Organization)
export class OrganizationResolver extends OrganizationResolverBase {
  constructor(protected readonly service: OrganizationService) {
    super(service);
  }
}
",
  "server/src/organization/organization.service.ts": "import { Injectable } from "@nestjs/common";
import { PrismaService } from "../prisma/prisma.service";
import { OrganizationServiceBase } from "./base/organization.service.base";

@Injectable()
export class OrganizationService extends OrganizationServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/prisma.util.spec.ts": "import {
  isRecordNotFoundError,
  PRISMA_QUERY_INTERPRETATION_ERROR,
} from "./prisma.util";

describe("isRecordNotFoundError", () => {
  test("returns true for record not found error", () => {
    expect(
      isRecordNotFoundError(
        Object.assign(
          new Error(\`Error occurred during query execution:
        InterpretationError("Error for binding '0': RecordNotFound("Record to update not found.")")\`),
          {
            code: PRISMA_QUERY_INTERPRETATION_ERROR,
          }
        )
      )
    ).toBe(true);
  });
  test("returns false for any other error", () => {
    expect(isRecordNotFoundError(new Error())).toBe(false);
  });
});
",
  "server/src/prisma.util.ts": "export const PRISMA_QUERY_INTERPRETATION_ERROR = "P2016";
export const PRISMA_RECORD_NOT_FOUND = "RecordNotFound";

export function isRecordNotFoundError(error: any): boolean {
  return (
    error instanceof Error &&
    "code" in error &&
    error.code === PRISMA_QUERY_INTERPRETATION_ERROR &&
    error.message.includes(PRISMA_RECORD_NOT_FOUND)
  );
}

export async function transformStringFieldUpdateInput<
  T extends undefined | string | { set?: string }
>(input: T, transform: (input: string) => Promise<string>): Promise<T> {
  if (typeof input === "object" && typeof input?.set === "string") {
    return { set: await transform(input.set) } as T;
  }
  if (typeof input === "object") {
    if (typeof input.set === "string") {
      return { set: await transform(input.set) } as T;
    }
    return input;
  }
  if (typeof input === "string") {
    return (await transform(input)) as T;
  }
  return input;
}
",
  "server/src/prisma/prisma.module.ts": "import { Global, Module } from "@nestjs/common";
import { PrismaService } from "./prisma.service";

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
",
  "server/src/prisma/prisma.service.ts": "import { Injectable, OnModuleInit, INestApplication } from "@nestjs/common";
import { PrismaClient } from "@prisma/client";

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}
",
  "server/src/profile/base/CreateProfileArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { ProfileCreateInput } from "./ProfileCreateInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class CreateProfileArgs {
  @ApiProperty({
    required: true,
    type: () => ProfileCreateInput,
  })
  @ValidateNested()
  @Type(() => ProfileCreateInput)
  @Field(() => ProfileCreateInput, { nullable: false })
  data!: ProfileCreateInput;
}

export { CreateProfileArgs as CreateProfileArgs };
",
  "server/src/profile/base/DeleteProfileArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { ProfileWhereUniqueInput } from "./ProfileWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class DeleteProfileArgs {
  @ApiProperty({
    required: true,
    type: () => ProfileWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => ProfileWhereUniqueInput)
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  where!: ProfileWhereUniqueInput;
}

export { DeleteProfileArgs as DeleteProfileArgs };
",
  "server/src/profile/base/Profile.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ObjectType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import {
  IsInt,
  IsDate,
  IsString,
  ValidateNested,
  IsOptional,
} from "class-validator";
import { Type } from "class-transformer";
import { User } from "../../user/base/User";

@ObjectType()
class Profile {
  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Field(() => Number)
  id!: number;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdIn!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedIn!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: false,
    type: () => User,
  })
  @ValidateNested()
  @Type(() => User)
  @IsOptional()
  user?: User | null;
}

export { Profile as Profile };
",
  "server/src/profile/base/ProfileCountArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { ProfileWhereInput } from "./ProfileWhereInput";
import { Type } from "class-transformer";

@ArgsType()
class ProfileCountArgs {
  @ApiProperty({
    required: false,
    type: () => ProfileWhereInput,
  })
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: ProfileWhereInput;
}

export { ProfileCountArgs as ProfileCountArgs };
",
  "server/src/profile/base/ProfileCreateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsDate, IsString, ValidateNested, IsOptional } from "class-validator";
import { Type } from "class-transformer";
import { UserWhereUniqueInput } from "../../user/base/UserWhereUniqueInput";

@InputType()
class ProfileCreateInput {
  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  createdAt!: Date;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  updatedAt!: Date;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: false,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @IsOptional()
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
  })
  user?: UserWhereUniqueInput | null;
}

export { ProfileCreateInput as ProfileCreateInput };
",
  "server/src/profile/base/ProfileFindManyArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { ProfileWhereInput } from "./ProfileWhereInput";
import { IsOptional, ValidateNested, IsInt } from "class-validator";
import { Type } from "class-transformer";
import { ProfileOrderByInput } from "./ProfileOrderByInput";

@ArgsType()
class ProfileFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => ProfileWhereInput,
  })
  @IsOptional()
  @ValidateNested()
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: ProfileWhereInput;

  @ApiProperty({
    required: false,
    type: [ProfileOrderByInput],
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Field(() => [ProfileOrderByInput], { nullable: true })
  @Type(() => ProfileOrderByInput)
  orderBy?: Array<ProfileOrderByInput>;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { ProfileFindManyArgs as ProfileFindManyArgs };
",
  "server/src/profile/base/ProfileFindUniqueArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { ProfileWhereUniqueInput } from "./ProfileWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class ProfileFindUniqueArgs {
  @ApiProperty({
    required: true,
    type: () => ProfileWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => ProfileWhereUniqueInput)
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  where!: ProfileWhereUniqueInput;
}

export { ProfileFindUniqueArgs as ProfileFindUniqueArgs };
",
  "server/src/profile/base/ProfileListRelationFilter.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { ProfileWhereInput } from "./ProfileWhereInput";
import { ValidateNested, IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType()
class ProfileListRelationFilter {
  @ApiProperty({
    required: false,
    type: () => ProfileWhereInput,
  })
  @ValidateNested()
  @Type(() => ProfileWhereInput)
  @IsOptional()
  @Field(() => ProfileWhereInput, {
    nullable: true,
  })
  every?: ProfileWhereInput;

  @ApiProperty({
    required: false,
    type: () => ProfileWhereInput,
  })
  @ValidateNested()
  @Type(() => ProfileWhereInput)
  @IsOptional()
  @Field(() => ProfileWhereInput, {
    nullable: true,
  })
  some?: ProfileWhereInput;

  @ApiProperty({
    required: false,
    type: () => ProfileWhereInput,
  })
  @ValidateNested()
  @Type(() => ProfileWhereInput)
  @IsOptional()
  @Field(() => ProfileWhereInput, {
    nullable: true,
  })
  none?: ProfileWhereInput;
}
export { ProfileListRelationFilter as ProfileListRelationFilter };
",
  "server/src/profile/base/ProfileOrderByInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional, IsEnum } from "class-validator";
import { SortOrder } from "../../util/SortOrder";

@InputType({
  isAbstract: true,
  description: undefined,
})
class ProfileOrderByInput {
  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdIn?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  createdAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedIn?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  updatedAt?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  email?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  userId?: SortOrder;
}

export { ProfileOrderByInput as ProfileOrderByInput };
",
  "server/src/profile/base/ProfileUpdateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsDate, IsOptional, IsString, ValidateNested } from "class-validator";
import { Type } from "class-transformer";
import { UserWhereUniqueInput } from "../../user/base/UserWhereUniqueInput";

@InputType()
class ProfileUpdateInput {
  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  createdAt?: Date;

  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  updatedAt?: Date;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  email?: string;

  @ApiProperty({
    required: false,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @IsOptional()
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
  })
  user?: UserWhereUniqueInput | null;
}

export { ProfileUpdateInput as ProfileUpdateInput };
",
  "server/src/profile/base/ProfileWhereInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IntFilter } from "../../util/IntFilter";
import { Type } from "class-transformer";
import { IsOptional, ValidateNested } from "class-validator";
import { DateTimeFilter } from "../../util/DateTimeFilter";
import { StringFilter } from "../../util/StringFilter";
import { UserWhereUniqueInput } from "../../user/base/UserWhereUniqueInput";

@InputType()
class ProfileWhereInput {
  @ApiProperty({
    required: false,
    type: IntFilter,
  })
  @Type(() => IntFilter)
  @IsOptional()
  @Field(() => IntFilter, {
    nullable: true,
  })
  id?: IntFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdIn?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  createdAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedIn?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  updatedAt?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  email?: StringFilter;

  @ApiProperty({
    required: false,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @IsOptional()
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
  })
  user?: UserWhereUniqueInput;
}

export { ProfileWhereInput as ProfileWhereInput };
",
  "server/src/profile/base/ProfileWhereUniqueInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsInt } from "class-validator";
import { Transform } from "class-transformer";

@InputType()
class ProfileWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Transform((prop) => parseInt(prop.value), {
    toClassOnly: true,
  })
  @Field(() => Number)
  id!: number;
}

export { ProfileWhereUniqueInput as ProfileWhereUniqueInput };
",
  "server/src/profile/base/UpdateProfileArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { ProfileWhereUniqueInput } from "./ProfileWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";
import { ProfileUpdateInput } from "./ProfileUpdateInput";

@ArgsType()
class UpdateProfileArgs {
  @ApiProperty({
    required: true,
    type: () => ProfileWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => ProfileWhereUniqueInput)
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  where!: ProfileWhereUniqueInput;

  @ApiProperty({
    required: true,
    type: () => ProfileUpdateInput,
  })
  @ValidateNested()
  @Type(() => ProfileUpdateInput)
  @Field(() => ProfileUpdateInput, { nullable: false })
  data!: ProfileUpdateInput;
}

export { UpdateProfileArgs as UpdateProfileArgs };
",
  "server/src/profile/base/profile.controller.base.spec.ts": "import { Test } from "@nestjs/testing";
import {
  INestApplication,
  HttpStatus,
  ExecutionContext,
  CallHandler,
} from "@nestjs/common";
import request from "supertest";
import { ACGuard } from "nest-access-control";
import { DefaultAuthGuard } from "../../auth/defaultAuth.guard";
import { ACLModule } from "../../auth/acl.module";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { map } from "rxjs";
import { ProfileController } from "../profile.controller";
import { ProfileService } from "../profile.service";

const nonExistingId = "nonExistingId";
const existingId = "existingId";
const CREATE_INPUT = {
  id: 42,
  createdIn: new Date(),
  createdAt: new Date(),
  updatedIn: new Date(),
  updatedAt: new Date(),
  email: "exampleEmail",
};
const CREATE_RESULT = {
  id: 42,
  createdIn: new Date(),
  createdAt: new Date(),
  updatedIn: new Date(),
  updatedAt: new Date(),
  email: "exampleEmail",
};
const FIND_MANY_RESULT = [
  {
    id: 42,
    createdIn: new Date(),
    createdAt: new Date(),
    updatedIn: new Date(),
    updatedAt: new Date(),
    email: "exampleEmail",
  },
];
const FIND_ONE_RESULT = {
  id: 42,
  createdIn: new Date(),
  createdAt: new Date(),
  updatedIn: new Date(),
  updatedAt: new Date(),
  email: "exampleEmail",
};

const service = {
  createProfile() {
    return CREATE_RESULT;
  },
  profiles: () => FIND_MANY_RESULT,
  profile: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: ["user"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

const aclFilterResponseInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle().pipe(
      map((data) => {
        return data;
      })
    );
  },
};
const aclValidateRequestInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle();
  },
};

describe("Profile", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: ProfileService,
          useValue: service,
        },
      ],
      controllers: [ProfileController],
      imports: [ACLModule],
    })
      .overrideGuard(DefaultAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .overrideInterceptor(AclFilterResponseInterceptor)
      .useValue(aclFilterResponseInterceptor)
      .overrideInterceptor(AclValidateRequestInterceptor)
      .useValue(aclValidateRequestInterceptor)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test("POST /profiles", async () => {
    await request(app.getHttpServer())
      .post("/profiles")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdIn: CREATE_RESULT.createdIn.toISOString(),
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedIn: CREATE_RESULT.updatedIn.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      });
  });

  test("GET /profiles", async () => {
    await request(app.getHttpServer())
      .get("/profiles")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          createdIn: FIND_MANY_RESULT[0].createdIn.toISOString(),
          createdAt: FIND_MANY_RESULT[0].createdAt.toISOString(),
          updatedIn: FIND_MANY_RESULT[0].updatedIn.toISOString(),
          updatedAt: FIND_MANY_RESULT[0].updatedAt.toISOString(),
        },
      ]);
  });

  test("GET /profiles/:id non existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/profiles"}/\${nonExistingId}\`)
      .expect(HttpStatus.NOT_FOUND)
      .expect({
        statusCode: HttpStatus.NOT_FOUND,
        message: \`No resource was found for {"\${"id"}":"\${nonExistingId}"}\`,
        error: "Not Found",
      });
  });

  test("GET /profiles/:id existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/profiles"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        createdIn: FIND_ONE_RESULT.createdIn.toISOString(),
        createdAt: FIND_ONE_RESULT.createdAt.toISOString(),
        updatedIn: FIND_ONE_RESULT.updatedIn.toISOString(),
        updatedAt: FIND_ONE_RESULT.updatedAt.toISOString(),
      });
  });

  test("POST /profiles existing resource", async () => {
    const agent = request(app.getHttpServer());
    await agent
      .post("/profiles")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        createdIn: CREATE_RESULT.createdIn.toISOString(),
        createdAt: CREATE_RESULT.createdAt.toISOString(),
        updatedIn: CREATE_RESULT.updatedIn.toISOString(),
        updatedAt: CREATE_RESULT.updatedAt.toISOString(),
      })
      .then(function () {
        agent
          .post("/profiles")
          .send(CREATE_INPUT)
          .expect(HttpStatus.CONFLICT)
          .expect({
            statusCode: HttpStatus.CONFLICT,
          });
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/profile/base/profile.controller.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import { ProfileService } from "../profile.service";
import { ProfileCreateInput } from "./ProfileCreateInput";
import { Profile } from "./Profile";
import { ProfileFindManyArgs } from "./ProfileFindManyArgs";
import { ProfileWhereUniqueInput } from "./ProfileWhereUniqueInput";
import { ProfileUpdateInput } from "./ProfileUpdateInput";

export class ProfileControllerBase {
  constructor(protected readonly service: ProfileService) {}
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Profile })
  async createProfile(
    @common.Body() data: ProfileCreateInput
  ): Promise<Profile> {
    return await this.service.createProfile({
      data: {
        ...data,

        user: data.user
          ? {
              connect: data.user,
            }
          : undefined,
      },
      select: {
        id: true,
        createdIn: true,
        createdAt: true,
        updatedIn: true,
        updatedAt: true,
        email: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.Get()
  @swagger.ApiOkResponse({ type: [Profile] })
  @ApiNestedQuery(ProfileFindManyArgs)
  async profiles(@common.Req() request: Request): Promise<Profile[]> {
    const args = plainToClass(ProfileFindManyArgs, request.query);
    return this.service.profiles({
      ...args,
      select: {
        id: true,
        createdIn: true,
        createdAt: true,
        updatedIn: true,
        updatedAt: true,
        email: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Profile })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async profile(
    @common.Param() params: ProfileWhereUniqueInput
  ): Promise<Profile | null> {
    const result = await this.service.profile({
      where: params,
      select: {
        id: true,
        createdIn: true,
        createdAt: true,
        updatedIn: true,
        updatedAt: true,
        email: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return result;
  }

  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Profile })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async updateProfile(
    @common.Param() params: ProfileWhereUniqueInput,
    @common.Body() data: ProfileUpdateInput
  ): Promise<Profile | null> {
    try {
      return await this.service.updateProfile({
        where: params,
        data: {
          ...data,

          user: data.user
            ? {
                connect: data.user,
              }
            : undefined,
        },
        select: {
          id: true,
          createdIn: true,
          createdAt: true,
          updatedIn: true,
          updatedAt: true,
          email: true,

          user: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Profile })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async deleteProfile(
    @common.Param() params: ProfileWhereUniqueInput
  ): Promise<Profile | null> {
    try {
      return await this.service.deleteProfile({
        where: params,
        select: {
          id: true,
          createdIn: true,
          createdAt: true,
          updatedIn: true,
          updatedAt: true,
          email: true,

          user: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }
}
",
  "server/src/profile/base/profile.module.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { Module } from "@nestjs/common";

@Module({
  imports: [],
  exports: [],
})
export class ProfileModuleBase {}
",
  "server/src/profile/base/profile.resolver.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as graphql from "@nestjs/graphql";
import { GraphQLError } from "graphql";
import { isRecordNotFoundError } from "../../prisma.util";
import { MetaQueryPayload } from "../../util/MetaQueryPayload";
import { Profile } from "./Profile";
import { ProfileCountArgs } from "./ProfileCountArgs";
import { ProfileFindManyArgs } from "./ProfileFindManyArgs";
import { ProfileFindUniqueArgs } from "./ProfileFindUniqueArgs";
import { CreateProfileArgs } from "./CreateProfileArgs";
import { UpdateProfileArgs } from "./UpdateProfileArgs";
import { DeleteProfileArgs } from "./DeleteProfileArgs";
import { User } from "../../user/base/User";
import { ProfileService } from "../profile.service";
@graphql.Resolver(() => Profile)
export class ProfileResolverBase {
  constructor(protected readonly service: ProfileService) {}

  async _profilesMeta(
    @graphql.Args() args: ProfileCountArgs
  ): Promise<MetaQueryPayload> {
    const result = await this.service.count(args);
    return {
      count: result,
    };
  }

  @graphql.Query(() => [Profile])
  async profiles(
    @graphql.Args() args: ProfileFindManyArgs
  ): Promise<Profile[]> {
    return this.service.profiles(args);
  }

  @graphql.Query(() => Profile, { nullable: true })
  async profile(
    @graphql.Args() args: ProfileFindUniqueArgs
  ): Promise<Profile | null> {
    const result = await this.service.profile(args);
    if (result === null) {
      return null;
    }
    return result;
  }

  @graphql.Mutation(() => Profile)
  async createProfile(
    @graphql.Args() args: CreateProfileArgs
  ): Promise<Profile> {
    return await this.service.createProfile({
      ...args,
      data: {
        ...args.data,

        user: args.data.user
          ? {
              connect: args.data.user,
            }
          : undefined,
      },
    });
  }

  @graphql.Mutation(() => Profile)
  async updateProfile(
    @graphql.Args() args: UpdateProfileArgs
  ): Promise<Profile | null> {
    try {
      return await this.service.updateProfile({
        ...args,
        data: {
          ...args.data,

          user: args.data.user
            ? {
                connect: args.data.user,
              }
            : undefined,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => Profile)
  async deleteProfile(
    @graphql.Args() args: DeleteProfileArgs
  ): Promise<Profile | null> {
    try {
      return await this.service.deleteProfile(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => User, {
    nullable: true,
    name: "user",
  })
  async getUser(@graphql.Parent() parent: Profile): Promise<User | null> {
    const result = await this.service.getUser(parent.id);

    if (!result) {
      return null;
    }
    return result;
  }
}
",
  "server/src/profile/base/profile.service.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { PrismaService } from "../../prisma/prisma.service";

import {
  Prisma,
  Profile, // @ts-ignore
  User,
} from "@prisma/client";

export class ProfileServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.ProfileCountArgs>(
    args: Prisma.SelectSubset<T, Prisma.ProfileCountArgs>
  ): Promise<number> {
    return this.prisma.profile.count(args);
  }

  async profiles<T extends Prisma.ProfileFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.ProfileFindManyArgs>
  ): Promise<Profile[]> {
    return this.prisma.profile.findMany(args);
  }
  async profile<T extends Prisma.ProfileFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.ProfileFindUniqueArgs>
  ): Promise<Profile | null> {
    return this.prisma.profile.findUnique(args);
  }
  async createProfile<T extends Prisma.ProfileCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.ProfileCreateArgs>
  ): Promise<Profile> {
    return this.prisma.profile.create<T>(args);
  }
  async updateProfile<T extends Prisma.ProfileUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.ProfileUpdateArgs>
  ): Promise<Profile> {
    return this.prisma.profile.update<T>(args);
  }
  async deleteProfile<T extends Prisma.ProfileDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.ProfileDeleteArgs>
  ): Promise<Profile> {
    return this.prisma.profile.delete(args);
  }

  async getUser(parentId: number): Promise<User | null> {
    return this.prisma.profile
      .findUnique({
        where: { id: parentId },
      })
      .user();
  }
}
",
  "server/src/profile/profile.controller.ts": "import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { ProfileService } from "./profile.service";
import { ProfileControllerBase } from "./base/profile.controller.base";

@swagger.ApiTags("profiles")
@common.Controller("profiles")
export class ProfileController extends ProfileControllerBase {
  constructor(protected readonly service: ProfileService) {
    super(service);
  }
}
",
  "server/src/profile/profile.module.ts": "import { Module } from "@nestjs/common";
import { ProfileModuleBase } from "./base/profile.module.base";
import { ProfileService } from "./profile.service";
import { ProfileController } from "./profile.controller";
import { ProfileResolver } from "./profile.resolver";

@Module({
  imports: [ProfileModuleBase],
  controllers: [ProfileController],
  providers: [ProfileService, ProfileResolver],
  exports: [ProfileService],
})
export class ProfileModule {}
",
  "server/src/profile/profile.resolver.ts": "import * as graphql from "@nestjs/graphql";
import { ProfileResolverBase } from "./base/profile.resolver.base";
import { Profile } from "./base/Profile";
import { ProfileService } from "./profile.service";

@graphql.Resolver(() => Profile)
export class ProfileResolver extends ProfileResolverBase {
  constructor(protected readonly service: ProfileService) {
    super(service);
  }
}
",
  "server/src/profile/profile.service.ts": "import { Injectable } from "@nestjs/common";
import { PrismaService } from "../prisma/prisma.service";
import { ProfileServiceBase } from "./base/profile.service.base";

@Injectable()
export class ProfileService extends ProfileServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/providers/secrets/base/secretsManager.service.base.spec.ts": "import { ConfigService } from "@nestjs/config";
import { mock } from "jest-mock-extended";
import { SecretsManagerServiceBase } from "./secretsManager.service.base";
import { EnumSecretsNameKey } from "../secretsNameKey.enum";

describe("Testing the secrets manager base class", () => {
  const SECRET_KEY = "SECRET_KEY";
  const SECRET_VALUE = "SECRET_VALUE";
  const configService = mock<ConfigService>();
  const secretsManagerServiceBase = new SecretsManagerServiceBase(
    configService
  );
  beforeEach(() => {
    configService.get.mockClear();
  });
  it("should return value from env", async () => {
    //ARRANGE
    configService.get.mockReturnValue(SECRET_VALUE);
    //ACT
    const result = await secretsManagerServiceBase.getSecret(
      SECRET_KEY as unknown as EnumSecretsNameKey
    );
    //ASSERT
    expect(result).toBe(SECRET_VALUE);
  });
  it("should return null for unknown keys", async () => {
    //ARRANGE
    configService.get.mockReturnValue(undefined);
    //ACT
    const result = await secretsManagerServiceBase.getSecret(
      SECRET_KEY as unknown as EnumSecretsNameKey
    );
    //ASSERT
    expect(result).toBeNull();
  });
  it("should throw an exception if getting null key", () => {
    return expect(
      secretsManagerServiceBase.getSecret(null as unknown as EnumSecretsNameKey)
    ).rejects.toThrow();
  });
});
",
  "server/src/providers/secrets/base/secretsManager.service.base.ts": "import { ConfigService } from "@nestjs/config";
import { EnumSecretsNameKey } from "../secretsNameKey.enum";

export interface ISecretsManager {
  getSecret: (key: EnumSecretsNameKey) => Promise<any | null>;
}

export class SecretsManagerServiceBase implements ISecretsManager {
  constructor(protected readonly configService: ConfigService) {}
  async getSecret<T>(key: EnumSecretsNameKey): Promise<T | null> {
    const value = this.configService.get(key.toString());
    if (value) {
      return value;
    }
    return null;
  }
}
",
  "server/src/providers/secrets/secretsManager.module.ts": "import { Module } from "@nestjs/common";
import { SecretsManagerService } from "./secretsManager.service";

@Module({
  providers: [SecretsManagerService],
  exports: [SecretsManagerService],
})
export class SecretsManagerModule {}
",
  "server/src/providers/secrets/secretsManager.service.ts": "import { Injectable } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import { SecretsManagerServiceBase } from "./base/secretsManager.service.base";

@Injectable()
export class SecretsManagerService extends SecretsManagerServiceBase {
  constructor(protected readonly configService: ConfigService) {
    super(configService);
  }
}
",
  "server/src/providers/secrets/secretsNameKey.enum.ts": "export enum EnumSecretsNameKey {}",
  "server/src/serveStaticOptions.service.ts": "import * as path from "path";
import { Injectable, Logger } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import {
  ServeStaticModuleOptions,
  ServeStaticModuleOptionsFactory,
} from "@nestjs/serve-static";

const SERVE_STATIC_ROOT_PATH_VAR = "SERVE_STATIC_ROOT_PATH";
const DEFAULT_STATIC_MODULE_OPTIONS_LIST: ServeStaticModuleOptions[] = [
  {
    serveRoot: "/swagger",
    rootPath: path.join(__dirname, "swagger"),
  },
];

@Injectable()
export class ServeStaticOptionsService
  implements ServeStaticModuleOptionsFactory
{
  private readonly logger = new Logger(ServeStaticOptionsService.name);

  constructor(private readonly configService: ConfigService) {}

  createLoggerOptions(): ServeStaticModuleOptions[] {
    const serveStaticRootPath = this.configService.get(
      SERVE_STATIC_ROOT_PATH_VAR
    );
    if (serveStaticRootPath) {
      const resolvedPath = path.resolve(serveStaticRootPath);
      this.logger.log(\`Serving static files from \${resolvedPath}\`);
      return [
        ...DEFAULT_STATIC_MODULE_OPTIONS_LIST,
        { rootPath: resolvedPath, exclude: ["/api*", "/graphql"] },
      ];
    }
    return DEFAULT_STATIC_MODULE_OPTIONS_LIST;
  }
}
",
  "server/src/swagger.ts": "import { DocumentBuilder, SwaggerCustomOptions } from "@nestjs/swagger";

export const swaggerPath = "api";

export const swaggerDocumentOptions = new DocumentBuilder()
  .setTitle("Sample Application")
  .setDescription(
    'Sample application for testing\\n\\n## Congratulations! Your service resource is ready.\\n  \\nPlease note that all endpoints are secured with HTTP Basic authentication.\\nBy default, your service resource comes with one user with the username "admin" and password "admin".\\nLearn more in [our docs](https://docs.amplication.com)'
  )
  .addBasicAuth()
  .build();

export const swaggerSetupOptions: SwaggerCustomOptions = {
  swaggerOptions: {
    persistAuthorization: true,
  },
  customCssUrl: "../swagger/swagger.css",
  customfavIcon: "../swagger/favicon.png",
  customSiteTitle: "Sample Application",
};
",
  "server/src/tests/health/health.service.spec.ts": "import { mock } from "jest-mock-extended";
import { PrismaService } from "../../prisma/prisma.service";
import { HealthServiceBase } from "../../health/base/health.service.base";

describe("Testing the HealthServiceBase", () => {
  //ARRANGE
  let prismaService: PrismaService;
  let healthServiceBase: HealthServiceBase;

  describe("Testing the isDbReady function in HealthServiceBase class", () => {
    beforeEach(() => {
      prismaService = mock<PrismaService>();
      healthServiceBase = new HealthServiceBase(prismaService);
    });
    it("should return true if allow connection to db", async () => {
      //ARRANGE
      (prismaService.$queryRaw as jest.Mock).mockReturnValue(
        Promise.resolve(true)
      );
      //ACT
      const response = await healthServiceBase.isDbReady();
      //ASSERT
      expect(response).toBe(true);
    });
    it("should return false if db is not available", async () => {
      //ARRANGE
      (prismaService.$queryRaw as jest.Mock).mockReturnValue(
        Promise.reject(false)
      );
      //ACT
      const response = await healthServiceBase.isDbReady();
      //ASSERT
      expect(response).toBe(false);
    });
  });
});
",
  "server/src/types.ts": "import type { JsonValue } from "type-fest";

export type InputJsonValue = Omit<JsonValue, "null">;
",
  "server/src/user/base/CreateUserArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { UserCreateInput } from "./UserCreateInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class CreateUserArgs {
  @ApiProperty({
    required: true,
    type: () => UserCreateInput,
  })
  @ValidateNested()
  @Type(() => UserCreateInput)
  @Field(() => UserCreateInput, { nullable: false })
  data!: UserCreateInput;
}

export { CreateUserArgs as CreateUserArgs };
",
  "server/src/user/base/DeleteUserArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class DeleteUserArgs {
  @ApiProperty({
    required: true,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
}

export { DeleteUserArgs as DeleteUserArgs };
",
  "server/src/user/base/EnumUserInterests.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { registerEnumType } from "@nestjs/graphql";

export enum EnumUserInterests {
  Programming = "programming",
  Design = "design",
}

registerEnumType(EnumUserInterests, {
  name: "EnumUserInterests",
});
",
  "server/src/user/base/EnumUserPriority.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { registerEnumType } from "@nestjs/graphql";

export enum EnumUserPriority {
  High = "high",
  Medium = "medium",
  Low = "low",
}

registerEnumType(EnumUserPriority, {
  name: "EnumUserPriority",
});
",
  "server/src/user/base/OrganizationCreateNestedManyWithoutUsersInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { OrganizationWhereUniqueInput } from "../../organization/base/OrganizationWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class OrganizationCreateNestedManyWithoutUsersInput {
  @Field(() => [OrganizationWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [OrganizationWhereUniqueInput],
  })
  connect?: Array<OrganizationWhereUniqueInput>;
}

export { OrganizationCreateNestedManyWithoutUsersInput as OrganizationCreateNestedManyWithoutUsersInput };
",
  "server/src/user/base/OrganizationUpdateManyWithoutUsersInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { OrganizationWhereUniqueInput } from "../../organization/base/OrganizationWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class OrganizationUpdateManyWithoutUsersInput {
  @Field(() => [OrganizationWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [OrganizationWhereUniqueInput],
  })
  connect?: Array<OrganizationWhereUniqueInput>;

  @Field(() => [OrganizationWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [OrganizationWhereUniqueInput],
  })
  disconnect?: Array<OrganizationWhereUniqueInput>;

  @Field(() => [OrganizationWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [OrganizationWhereUniqueInput],
  })
  set?: Array<OrganizationWhereUniqueInput>;
}

export { OrganizationUpdateManyWithoutUsersInput as OrganizationUpdateManyWithoutUsersInput };
",
  "server/src/user/base/UpdateUserArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";
import { UserUpdateInput } from "./UserUpdateInput";

@ArgsType()
class UpdateUserArgs {
  @ApiProperty({
    required: true,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;

  @ApiProperty({
    required: true,
    type: () => UserUpdateInput,
  })
  @ValidateNested()
  @Type(() => UserUpdateInput)
  @Field(() => UserUpdateInput, { nullable: false })
  data!: UserUpdateInput;
}

export { UpdateUserArgs as UpdateUserArgs };
",
  "server/src/user/base/User.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ObjectType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";

import {
  IsString,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsOptional,
  IsEnum,
  IsBoolean,
} from "class-validator";

import { IsJSONValue } from "../../validators";
import { GraphQLJSON } from "graphql-type-json";
import { JsonValue } from "type-fest";
import { Type } from "class-transformer";
import { Organization } from "../../organization/base/Organization";
import { EnumUserInterests } from "./EnumUserInterests";
import { EnumUserPriority } from "./EnumUserPriority";
import { Profile } from "../../profile/base/Profile";

@ObjectType()
class User {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  username!: string;

  @ApiProperty({
    required: true,
  })
  @IsJSONValue()
  @Field(() => GraphQLJSON)
  roles!: JsonValue;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  bio!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Field(() => Number)
  age!: number;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  birthDate!: Date;

  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsNumber()
  @Field(() => Number)
  score!: number;

  @ApiProperty({
    required: false,
    type: () => User,
  })
  @ValidateNested()
  @Type(() => User)
  @IsOptional()
  manager?: User | null;

  @ApiProperty({
    required: false,
    type: () => [User],
  })
  @ValidateNested()
  @Type(() => User)
  @IsOptional()
  employees?: Array<User>;

  @ApiProperty({
    required: false,
    type: () => [Organization],
  })
  @ValidateNested()
  @Type(() => Organization)
  @IsOptional()
  organizations?: Array<Organization>;

  @ApiProperty({
    required: true,
    enum: EnumUserInterests,
    isArray: true,
  })
  @IsEnum(EnumUserInterests, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumUserInterests], {
    nullable: true,
  })
  interests?: Array<"programming" | "design">;

  @ApiProperty({
    required: true,
    enum: EnumUserPriority,
  })
  @IsEnum(EnumUserPriority)
  @Field(() => EnumUserPriority, {
    nullable: true,
  })
  priority?: "high" | "medium" | "low";

  @ApiProperty({
    required: true,
    type: Boolean,
  })
  @IsBoolean()
  @Field(() => Boolean)
  isCurious!: boolean;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  location!: string;

  @ApiProperty({
    required: true,
  })
  @IsJSONValue()
  @Field(() => GraphQLJSON)
  extendedProperties!: JsonValue;

  @ApiProperty({
    required: false,
    type: () => Profile,
  })
  @ValidateNested()
  @Type(() => Profile)
  @IsOptional()
  profile?: Profile | null;
}

export { User as User };
",
  "server/src/user/base/UserCountArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { UserWhereInput } from "./UserWhereInput";
import { Type } from "class-transformer";

@ArgsType()
class UserCountArgs {
  @ApiProperty({
    required: false,
    type: () => UserWhereInput,
  })
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: UserWhereInput;
}

export { UserCountArgs as UserCountArgs };
",
  "server/src/user/base/UserCreateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";

import {
  IsString,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsOptional,
  IsEnum,
  IsBoolean,
} from "class-validator";

import { IsJSONValue } from "../../validators";
import { GraphQLJSON } from "graphql-type-json";
import { InputJsonValue } from "../../types";
import { Type } from "class-transformer";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { UserCreateNestedManyWithoutUsersInput } from "./UserCreateNestedManyWithoutUsersInput";
import { OrganizationCreateNestedManyWithoutUsersInput } from "./OrganizationCreateNestedManyWithoutUsersInput";
import { EnumUserInterests } from "./EnumUserInterests";
import { EnumUserPriority } from "./EnumUserPriority";
import { ProfileWhereUniqueInput } from "../../profile/base/ProfileWhereUniqueInput";

@InputType()
class UserCreateInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  username!: string;

  @ApiProperty({
    required: true,
  })
  @IsJSONValue()
  @Field(() => GraphQLJSON)
  roles!: InputJsonValue;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  password!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  name!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  bio!: string;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  email!: string;

  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsInt()
  @Field(() => Number)
  age!: number;

  @ApiProperty({
    required: true,
  })
  @IsDate()
  @Type(() => Date)
  @Field(() => Date)
  birthDate!: Date;

  @ApiProperty({
    required: true,
    type: Number,
  })
  @IsNumber()
  @Field(() => Number)
  score!: number;

  @ApiProperty({
    required: false,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @IsOptional()
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
  })
  manager?: UserWhereUniqueInput | null;

  @ApiProperty({
    required: false,
    type: () => UserCreateNestedManyWithoutUsersInput,
  })
  @ValidateNested()
  @Type(() => UserCreateNestedManyWithoutUsersInput)
  @IsOptional()
  @Field(() => UserCreateNestedManyWithoutUsersInput, {
    nullable: true,
  })
  employees?: UserCreateNestedManyWithoutUsersInput;

  @ApiProperty({
    required: false,
    type: () => OrganizationCreateNestedManyWithoutUsersInput,
  })
  @ValidateNested()
  @Type(() => OrganizationCreateNestedManyWithoutUsersInput)
  @IsOptional()
  @Field(() => OrganizationCreateNestedManyWithoutUsersInput, {
    nullable: true,
  })
  organizations?: OrganizationCreateNestedManyWithoutUsersInput;

  @ApiProperty({
    required: true,
    enum: EnumUserInterests,
    isArray: true,
  })
  @IsEnum(EnumUserInterests, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumUserInterests], {
    nullable: true,
  })
  interests?: Array<"programming" | "design">;

  @ApiProperty({
    required: true,
    enum: EnumUserPriority,
  })
  @IsEnum(EnumUserPriority)
  @Field(() => EnumUserPriority)
  priority!: "high" | "medium" | "low";

  @ApiProperty({
    required: true,
    type: Boolean,
  })
  @IsBoolean()
  @Field(() => Boolean)
  isCurious!: boolean;

  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  location!: string;

  @ApiProperty({
    required: true,
  })
  @IsJSONValue()
  @Field(() => GraphQLJSON)
  extendedProperties!: InputJsonValue;

  @ApiProperty({
    required: false,
    type: () => ProfileWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => ProfileWhereUniqueInput)
  @IsOptional()
  @Field(() => ProfileWhereUniqueInput, {
    nullable: true,
  })
  profile?: ProfileWhereUniqueInput | null;
}

export { UserCreateInput as UserCreateInput };
",
  "server/src/user/base/UserCreateNestedManyWithoutUsersInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class UserCreateNestedManyWithoutUsersInput {
  @Field(() => [UserWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [UserWhereUniqueInput],
  })
  connect?: Array<UserWhereUniqueInput>;
}

export { UserCreateNestedManyWithoutUsersInput as UserCreateNestedManyWithoutUsersInput };
",
  "server/src/user/base/UserFindManyArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { UserWhereInput } from "./UserWhereInput";
import { IsOptional, ValidateNested, IsInt } from "class-validator";
import { Type } from "class-transformer";
import { UserOrderByInput } from "./UserOrderByInput";

@ArgsType()
class UserFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => UserWhereInput,
  })
  @IsOptional()
  @ValidateNested()
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: UserWhereInput;

  @ApiProperty({
    required: false,
    type: [UserOrderByInput],
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Field(() => [UserOrderByInput], { nullable: true })
  @Type(() => UserOrderByInput)
  orderBy?: Array<UserOrderByInput>;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  skip?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @IsInt()
  @Field(() => Number, { nullable: true })
  @Type(() => Number)
  take?: number;
}

export { UserFindManyArgs as UserFindManyArgs };
",
  "server/src/user/base/UserFindUniqueArgs.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { ArgsType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { ValidateNested } from "class-validator";
import { Type } from "class-transformer";

@ArgsType()
class UserFindUniqueArgs {
  @ApiProperty({
    required: true,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @Field(() => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
}

export { UserFindUniqueArgs as UserFindUniqueArgs };
",
  "server/src/user/base/UserListRelationFilter.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { UserWhereInput } from "./UserWhereInput";
import { ValidateNested, IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType()
class UserListRelationFilter {
  @ApiProperty({
    required: false,
    type: () => UserWhereInput,
  })
  @ValidateNested()
  @Type(() => UserWhereInput)
  @IsOptional()
  @Field(() => UserWhereInput, {
    nullable: true,
  })
  every?: UserWhereInput;

  @ApiProperty({
    required: false,
    type: () => UserWhereInput,
  })
  @ValidateNested()
  @Type(() => UserWhereInput)
  @IsOptional()
  @Field(() => UserWhereInput, {
    nullable: true,
  })
  some?: UserWhereInput;

  @ApiProperty({
    required: false,
    type: () => UserWhereInput,
  })
  @ValidateNested()
  @Type(() => UserWhereInput)
  @IsOptional()
  @Field(() => UserWhereInput, {
    nullable: true,
  })
  none?: UserWhereInput;
}
export { UserListRelationFilter as UserListRelationFilter };
",
  "server/src/user/base/UserOrderByInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional, IsEnum } from "class-validator";
import { SortOrder } from "../../util/SortOrder";

@InputType({
  isAbstract: true,
  description: undefined,
})
class UserOrderByInput {
  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  id?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  username?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  roles?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  password?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  name?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  bio?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  email?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  age?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  birthDate?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  score?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  managerId?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  interests?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  priority?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  isCurious?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  location?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  extendedProperties?: SortOrder;

  @ApiProperty({
    required: false,
    enum: ["asc", "desc"],
  })
  @IsOptional()
  @IsEnum(SortOrder)
  @Field(() => SortOrder, {
    nullable: true,
  })
  profileId?: SortOrder;
}

export { UserOrderByInput as UserOrderByInput };
",
  "server/src/user/base/UserUpdateInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";

import {
  IsString,
  IsOptional,
  IsInt,
  IsDate,
  IsNumber,
  ValidateNested,
  IsEnum,
  IsBoolean,
} from "class-validator";

import { IsJSONValue } from "../../validators";
import { GraphQLJSON } from "graphql-type-json";
import { InputJsonValue } from "../../types";
import { Type } from "class-transformer";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { UserUpdateManyWithoutUsersInput } from "./UserUpdateManyWithoutUsersInput";
import { OrganizationUpdateManyWithoutUsersInput } from "./OrganizationUpdateManyWithoutUsersInput";
import { EnumUserInterests } from "./EnumUserInterests";
import { EnumUserPriority } from "./EnumUserPriority";
import { ProfileWhereUniqueInput } from "../../profile/base/ProfileWhereUniqueInput";

@InputType()
class UserUpdateInput {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  username?: string;

  @ApiProperty({
    required: false,
  })
  @IsJSONValue()
  @IsOptional()
  @Field(() => GraphQLJSON, {
    nullable: true,
  })
  roles?: InputJsonValue;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  password?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  name?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  bio?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  email?: string;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsInt()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  age?: number;

  @ApiProperty({
    required: false,
  })
  @IsDate()
  @Type(() => Date)
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  birthDate?: Date;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsNumber()
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  score?: number;

  @ApiProperty({
    required: false,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @IsOptional()
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
  })
  manager?: UserWhereUniqueInput | null;

  @ApiProperty({
    required: false,
    type: () => UserUpdateManyWithoutUsersInput,
  })
  @ValidateNested()
  @Type(() => UserUpdateManyWithoutUsersInput)
  @IsOptional()
  @Field(() => UserUpdateManyWithoutUsersInput, {
    nullable: true,
  })
  employees?: UserUpdateManyWithoutUsersInput;

  @ApiProperty({
    required: false,
    type: () => OrganizationUpdateManyWithoutUsersInput,
  })
  @ValidateNested()
  @Type(() => OrganizationUpdateManyWithoutUsersInput)
  @IsOptional()
  @Field(() => OrganizationUpdateManyWithoutUsersInput, {
    nullable: true,
  })
  organizations?: OrganizationUpdateManyWithoutUsersInput;

  @ApiProperty({
    required: false,
    enum: EnumUserInterests,
    isArray: true,
  })
  @IsEnum(EnumUserInterests, {
    each: true,
  })
  @IsOptional()
  @Field(() => [EnumUserInterests], {
    nullable: true,
  })
  interests?: Array<"programming" | "design">;

  @ApiProperty({
    required: false,
    enum: EnumUserPriority,
  })
  @IsEnum(EnumUserPriority)
  @IsOptional()
  @Field(() => EnumUserPriority, {
    nullable: true,
  })
  priority?: "high" | "medium" | "low";

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  isCurious?: boolean;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsString()
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  location?: string;

  @ApiProperty({
    required: false,
  })
  @IsJSONValue()
  @IsOptional()
  @Field(() => GraphQLJSON, {
    nullable: true,
  })
  extendedProperties?: InputJsonValue;

  @ApiProperty({
    required: false,
    type: () => ProfileWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => ProfileWhereUniqueInput)
  @IsOptional()
  @Field(() => ProfileWhereUniqueInput, {
    nullable: true,
  })
  profile?: ProfileWhereUniqueInput | null;
}

export { UserUpdateInput as UserUpdateInput };
",
  "server/src/user/base/UserUpdateManyWithoutUsersInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { ApiProperty } from "@nestjs/swagger";

@InputType()
class UserUpdateManyWithoutUsersInput {
  @Field(() => [UserWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [UserWhereUniqueInput],
  })
  connect?: Array<UserWhereUniqueInput>;

  @Field(() => [UserWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [UserWhereUniqueInput],
  })
  disconnect?: Array<UserWhereUniqueInput>;

  @Field(() => [UserWhereUniqueInput], {
    nullable: true,
  })
  @ApiProperty({
    required: false,
    type: () => [UserWhereUniqueInput],
  })
  set?: Array<UserWhereUniqueInput>;
}

export { UserUpdateManyWithoutUsersInput as UserUpdateManyWithoutUsersInput };
",
  "server/src/user/base/UserWhereInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { StringFilter } from "../../util/StringFilter";
import { Type } from "class-transformer";
import { IsOptional, ValidateNested, IsEnum } from "class-validator";
import { IntFilter } from "../../util/IntFilter";
import { DateTimeFilter } from "../../util/DateTimeFilter";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { OrganizationListRelationFilter } from "../../organization/base/OrganizationListRelationFilter";
import { EnumUserPriority } from "./EnumUserPriority";
import { BooleanFilter } from "../../util/BooleanFilter";
import { JsonFilter } from "../../util/JsonFilter";
import { ProfileWhereUniqueInput } from "../../profile/base/ProfileWhereUniqueInput";

@InputType()
class UserWhereInput {
  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  id?: StringFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  username?: StringFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  name?: StringFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  bio?: StringFilter;

  @ApiProperty({
    required: false,
    type: IntFilter,
  })
  @Type(() => IntFilter)
  @IsOptional()
  @Field(() => IntFilter, {
    nullable: true,
  })
  age?: IntFilter;

  @ApiProperty({
    required: false,
    type: DateTimeFilter,
  })
  @Type(() => DateTimeFilter)
  @IsOptional()
  @Field(() => DateTimeFilter, {
    nullable: true,
  })
  birthDate?: DateTimeFilter;

  @ApiProperty({
    required: false,
    type: () => UserWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => UserWhereUniqueInput)
  @IsOptional()
  @Field(() => UserWhereUniqueInput, {
    nullable: true,
  })
  manager?: UserWhereUniqueInput;

  @ApiProperty({
    required: false,
    type: () => OrganizationListRelationFilter,
  })
  @ValidateNested()
  @Type(() => OrganizationListRelationFilter)
  @IsOptional()
  @Field(() => OrganizationListRelationFilter, {
    nullable: true,
  })
  organizations?: OrganizationListRelationFilter;

  @ApiProperty({
    required: false,
    enum: EnumUserPriority,
  })
  @IsEnum(EnumUserPriority)
  @IsOptional()
  @Field(() => EnumUserPriority, {
    nullable: true,
  })
  priority?: "high" | "medium" | "low";

  @ApiProperty({
    required: false,
    type: BooleanFilter,
  })
  @Type(() => BooleanFilter)
  @IsOptional()
  @Field(() => BooleanFilter, {
    nullable: true,
  })
  isCurious?: BooleanFilter;

  @ApiProperty({
    required: false,
    type: StringFilter,
  })
  @Type(() => StringFilter)
  @IsOptional()
  @Field(() => StringFilter, {
    nullable: true,
  })
  location?: StringFilter;

  @ApiProperty({
    required: false,
    type: JsonFilter,
  })
  @Type(() => JsonFilter)
  @IsOptional()
  @Field(() => JsonFilter, {
    nullable: true,
  })
  extendedProperties?: JsonFilter;

  @ApiProperty({
    required: false,
    type: () => ProfileWhereUniqueInput,
  })
  @ValidateNested()
  @Type(() => ProfileWhereUniqueInput)
  @IsOptional()
  @Field(() => ProfileWhereUniqueInput, {
    nullable: true,
  })
  profile?: ProfileWhereUniqueInput;
}

export { UserWhereInput as UserWhereInput };
",
  "server/src/user/base/UserWhereUniqueInput.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { InputType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsString } from "class-validator";

@InputType()
class UserWhereUniqueInput {
  @ApiProperty({
    required: true,
    type: String,
  })
  @IsString()
  @Field(() => String)
  id!: string;
}

export { UserWhereUniqueInput as UserWhereUniqueInput };
",
  "server/src/user/base/user.controller.base.spec.ts": "import { Test } from "@nestjs/testing";
import {
  INestApplication,
  HttpStatus,
  ExecutionContext,
  CallHandler,
} from "@nestjs/common";
import request from "supertest";
import { ACGuard } from "nest-access-control";
import { DefaultAuthGuard } from "../../auth/defaultAuth.guard";
import { ACLModule } from "../../auth/acl.module";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { map } from "rxjs";
import { UserController } from "../user.controller";
import { UserService } from "../user.service";

const nonExistingId = "nonExistingId";
const existingId = "existingId";
const CREATE_INPUT = {
  id: "exampleId",
  username: "exampleUsername",
  password: "examplePassword",
  name: "exampleName",
  bio: "exampleBio",
  email: "exampleEmail",
  age: 42,
  birthDate: new Date(),
  score: 42.42,
  isCurious: "true",
  location: "exampleLocation",
};
const CREATE_RESULT = {
  id: "exampleId",
  username: "exampleUsername",
  password: "examplePassword",
  name: "exampleName",
  bio: "exampleBio",
  email: "exampleEmail",
  age: 42,
  birthDate: new Date(),
  score: 42.42,
  isCurious: "true",
  location: "exampleLocation",
};
const FIND_MANY_RESULT = [
  {
    id: "exampleId",
    username: "exampleUsername",
    password: "examplePassword",
    name: "exampleName",
    bio: "exampleBio",
    email: "exampleEmail",
    age: 42,
    birthDate: new Date(),
    score: 42.42,
    isCurious: "true",
    location: "exampleLocation",
  },
];
const FIND_ONE_RESULT = {
  id: "exampleId",
  username: "exampleUsername",
  password: "examplePassword",
  name: "exampleName",
  bio: "exampleBio",
  email: "exampleEmail",
  age: 42,
  birthDate: new Date(),
  score: 42.42,
  isCurious: "true",
  location: "exampleLocation",
};

const service = {
  createUser() {
    return CREATE_RESULT;
  },
  users: () => FIND_MANY_RESULT,
  user: ({ where }: { where: { id: string } }) => {
    switch (where.id) {
      case existingId:
        return FIND_ONE_RESULT;
      case nonExistingId:
        return null;
    }
  },
};

const basicAuthGuard = {
  canActivate: (context: ExecutionContext) => {
    const argumentHost = context.switchToHttp();
    const request = argumentHost.getRequest();
    request.user = {
      roles: ["user"],
    };
    return true;
  },
};

const acGuard = {
  canActivate: () => {
    return true;
  },
};

const aclFilterResponseInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle().pipe(
      map((data) => {
        return data;
      })
    );
  },
};
const aclValidateRequestInterceptor = {
  intercept: (context: ExecutionContext, next: CallHandler) => {
    return next.handle();
  },
};

describe("User", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        {
          provide: UserService,
          useValue: service,
        },
      ],
      controllers: [UserController],
      imports: [ACLModule],
    })
      .overrideGuard(DefaultAuthGuard)
      .useValue(basicAuthGuard)
      .overrideGuard(ACGuard)
      .useValue(acGuard)
      .overrideInterceptor(AclFilterResponseInterceptor)
      .useValue(aclFilterResponseInterceptor)
      .overrideInterceptor(AclValidateRequestInterceptor)
      .useValue(aclValidateRequestInterceptor)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  test("POST /users", async () => {
    await request(app.getHttpServer())
      .post("/users")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        birthDate: CREATE_RESULT.birthDate.toISOString(),
      });
  });

  test("GET /users", async () => {
    await request(app.getHttpServer())
      .get("/users")
      .expect(HttpStatus.OK)
      .expect([
        {
          ...FIND_MANY_RESULT[0],
          birthDate: FIND_MANY_RESULT[0].birthDate.toISOString(),
        },
      ]);
  });

  test("GET /users/:id non existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/users"}/\${nonExistingId}\`)
      .expect(HttpStatus.NOT_FOUND)
      .expect({
        statusCode: HttpStatus.NOT_FOUND,
        message: \`No resource was found for {"\${"id"}":"\${nonExistingId}"}\`,
        error: "Not Found",
      });
  });

  test("GET /users/:id existing", async () => {
    await request(app.getHttpServer())
      .get(\`\${"/users"}/\${existingId}\`)
      .expect(HttpStatus.OK)
      .expect({
        ...FIND_ONE_RESULT,
        birthDate: FIND_ONE_RESULT.birthDate.toISOString(),
      });
  });

  test("POST /users existing resource", async () => {
    const agent = request(app.getHttpServer());
    await agent
      .post("/users")
      .send(CREATE_INPUT)
      .expect(HttpStatus.CREATED)
      .expect({
        ...CREATE_RESULT,
        birthDate: CREATE_RESULT.birthDate.toISOString(),
      })
      .then(function () {
        agent
          .post("/users")
          .send(CREATE_INPUT)
          .expect(HttpStatus.CONFLICT)
          .expect({
            statusCode: HttpStatus.CONFLICT,
          });
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
",
  "server/src/user/base/user.controller.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import { UserService } from "../user.service";
import { UserCreateInput } from "./UserCreateInput";
import { User } from "./User";
import { UserFindManyArgs } from "./UserFindManyArgs";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { UserUpdateInput } from "./UserUpdateInput";
import { OrganizationFindManyArgs } from "../../organization/base/OrganizationFindManyArgs";
import { Organization } from "../../organization/base/Organization";
import { OrganizationWhereUniqueInput } from "../../organization/base/OrganizationWhereUniqueInput";

export class UserControllerBase {
  constructor(protected readonly service: UserService) {}
  @common.Post()
  @swagger.ApiCreatedResponse({ type: User })
  async createUser(@common.Body() data: UserCreateInput): Promise<User> {
    return await this.service.createUser({
      data: {
        ...data,

        manager: data.manager
          ? {
              connect: data.manager,
            }
          : undefined,

        profile: data.profile
          ? {
              connect: data.profile,
            }
          : undefined,
      },
      select: {
        id: true,
        username: true,
        roles: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,

        profile: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.Get()
  @swagger.ApiOkResponse({ type: [User] })
  @ApiNestedQuery(UserFindManyArgs)
  async users(@common.Req() request: Request): Promise<User[]> {
    const args = plainToClass(UserFindManyArgs, request.query);
    return this.service.users({
      ...args,
      select: {
        id: true,
        username: true,
        roles: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,

        profile: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async user(
    @common.Param() params: UserWhereUniqueInput
  ): Promise<User | null> {
    const result = await this.service.user({
      where: params,
      select: {
        id: true,
        username: true,
        roles: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,

        profile: {
          select: {
            id: true,
          },
        },
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return result;
  }

  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async updateUser(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() data: UserUpdateInput
  ): Promise<User | null> {
    try {
      return await this.service.updateUser({
        where: params,
        data: {
          ...data,

          manager: data.manager
            ? {
                connect: data.manager,
              }
            : undefined,

          profile: data.profile
            ? {
                connect: data.profile,
              }
            : undefined,
        },
        select: {
          id: true,
          username: true,
          roles: true,
          name: true,
          bio: true,
          email: true,
          age: true,
          birthDate: true,
          score: true,

          manager: {
            select: {
              id: true,
            },
          },

          interests: true,
          priority: true,
          isCurious: true,
          location: true,
          extendedProperties: true,

          profile: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async deleteUser(
    @common.Param() params: UserWhereUniqueInput
  ): Promise<User | null> {
    try {
      return await this.service.deleteUser({
        where: params,
        select: {
          id: true,
          username: true,
          roles: true,
          name: true,
          bio: true,
          email: true,
          age: true,
          birthDate: true,
          score: true,

          manager: {
            select: {
              id: true,
            },
          },

          interests: true,
          priority: true,
          isCurious: true,
          location: true,
          extendedProperties: true,

          profile: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          \`No resource was found for \${JSON.stringify(params)}\`
        );
      }
      throw error;
    }
  }

  @common.Get("/:id/employees")
  @ApiNestedQuery(UserFindManyArgs)
  async findEmployees(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<User[]> {
    const query = plainToClass(UserFindManyArgs, request.query);
    const results = await this.service.findEmployees(params.id, {
      ...query,
      select: {
        id: true,
        username: true,
        roles: true,
        name: true,
        bio: true,
        email: true,
        age: true,
        birthDate: true,
        score: true,

        manager: {
          select: {
            id: true,
          },
        },

        interests: true,
        priority: true,
        isCurious: true,
        location: true,
        extendedProperties: true,

        profile: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return results;
  }

  @common.Post("/:id/employees")
  async connectEmployees(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      employees: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/employees")
  async updateEmployees(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      employees: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/employees")
  async disconnectEmployees(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: UserWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      employees: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/organizations")
  @ApiNestedQuery(OrganizationFindManyArgs)
  async findOrganizations(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Organization[]> {
    const query = plainToClass(OrganizationFindManyArgs, request.query);
    const results = await this.service.findOrganizations(params.id, {
      ...query,
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
        name: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        \`No resource was found for \${JSON.stringify(params)}\`
      );
    }
    return results;
  }

  @common.Post("/:id/organizations")
  async connectOrganizations(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      organizations: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/organizations")
  async updateOrganizations(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      organizations: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/organizations")
  async disconnectOrganizations(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: OrganizationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      organizations: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }
}
",
  "server/src/user/base/user.module.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { Module } from "@nestjs/common";

@Module({
  imports: [],
  exports: [],
})
export class UserModuleBase {}
",
  "server/src/user/base/user.resolver.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as graphql from "@nestjs/graphql";
import { GraphQLError } from "graphql";
import { isRecordNotFoundError } from "../../prisma.util";
import { MetaQueryPayload } from "../../util/MetaQueryPayload";
import { User } from "./User";
import { UserCountArgs } from "./UserCountArgs";
import { UserFindManyArgs } from "./UserFindManyArgs";
import { UserFindUniqueArgs } from "./UserFindUniqueArgs";
import { CreateUserArgs } from "./CreateUserArgs";
import { UpdateUserArgs } from "./UpdateUserArgs";
import { DeleteUserArgs } from "./DeleteUserArgs";
import { OrganizationFindManyArgs } from "../../organization/base/OrganizationFindManyArgs";
import { Organization } from "../../organization/base/Organization";
import { Profile } from "../../profile/base/Profile";
import { UserService } from "../user.service";
@graphql.Resolver(() => User)
export class UserResolverBase {
  constructor(protected readonly service: UserService) {}

  async _usersMeta(
    @graphql.Args() args: UserCountArgs
  ): Promise<MetaQueryPayload> {
    const result = await this.service.count(args);
    return {
      count: result,
    };
  }

  @graphql.Query(() => [User])
  async users(@graphql.Args() args: UserFindManyArgs): Promise<User[]> {
    return this.service.users(args);
  }

  @graphql.Query(() => User, { nullable: true })
  async user(@graphql.Args() args: UserFindUniqueArgs): Promise<User | null> {
    const result = await this.service.user(args);
    if (result === null) {
      return null;
    }
    return result;
  }

  @graphql.Mutation(() => User)
  async createUser(@graphql.Args() args: CreateUserArgs): Promise<User> {
    return await this.service.createUser({
      ...args,
      data: {
        ...args.data,

        manager: args.data.manager
          ? {
              connect: args.data.manager,
            }
          : undefined,

        profile: args.data.profile
          ? {
              connect: args.data.profile,
            }
          : undefined,
      },
    });
  }

  @graphql.Mutation(() => User)
  async updateUser(@graphql.Args() args: UpdateUserArgs): Promise<User | null> {
    try {
      return await this.service.updateUser({
        ...args,
        data: {
          ...args.data,

          manager: args.data.manager
            ? {
                connect: args.data.manager,
              }
            : undefined,

          profile: args.data.profile
            ? {
                connect: args.data.profile,
              }
            : undefined,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.Mutation(() => User)
  async deleteUser(@graphql.Args() args: DeleteUserArgs): Promise<User | null> {
    try {
      return await this.service.deleteUser(args);
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new GraphQLError(
          \`No resource was found for \${JSON.stringify(args.where)}\`
        );
      }
      throw error;
    }
  }

  @graphql.ResolveField(() => [User], { name: "employees" })
  async findEmployees(
    @graphql.Parent() parent: User,
    @graphql.Args() args: UserFindManyArgs
  ): Promise<User[]> {
    const results = await this.service.findEmployees(parent.id, args);

    if (!results) {
      return [];
    }

    return results;
  }

  @graphql.ResolveField(() => [Organization], { name: "organizations" })
  async findOrganizations(
    @graphql.Parent() parent: User,
    @graphql.Args() args: OrganizationFindManyArgs
  ): Promise<Organization[]> {
    const results = await this.service.findOrganizations(parent.id, args);

    if (!results) {
      return [];
    }

    return results;
  }

  @graphql.ResolveField(() => User, {
    nullable: true,
    name: "manager",
  })
  async getManager(@graphql.Parent() parent: User): Promise<User | null> {
    const result = await this.service.getManager(parent.id);

    if (!result) {
      return null;
    }
    return result;
  }

  @graphql.ResolveField(() => Profile, {
    nullable: true,
    name: "profile",
  })
  async getProfile(@graphql.Parent() parent: User): Promise<Profile | null> {
    const result = await this.service.getProfile(parent.id);

    if (!result) {
      return null;
    }
    return result;
  }
}
",
  "server/src/user/base/user.service.base.ts": "/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { PrismaService } from "../../prisma/prisma.service";

import {
  Prisma,
  User, // @ts-ignore
  Organization, // @ts-ignore
  Profile,
} from "@prisma/client";

export class UserServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count<T extends Prisma.UserCountArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserCountArgs>
  ): Promise<number> {
    return this.prisma.user.count(args);
  }

  async users<T extends Prisma.UserFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
  ): Promise<User[]> {
    return this.prisma.user.findMany(args);
  }
  async user<T extends Prisma.UserFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>
  ): Promise<User | null> {
    return this.prisma.user.findUnique(args);
  }
  async createUser<T extends Prisma.UserCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserCreateArgs>
  ): Promise<User> {
    return this.prisma.user.create<T>(args);
  }
  async updateUser<T extends Prisma.UserUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserUpdateArgs>
  ): Promise<User> {
    return this.prisma.user.update<T>(args);
  }
  async deleteUser<T extends Prisma.UserDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserDeleteArgs>
  ): Promise<User> {
    return this.prisma.user.delete(args);
  }

  async findEmployees(
    parentId: string,
    args: Prisma.UserFindManyArgs
  ): Promise<User[]> {
    return this.prisma.user
      .findUniqueOrThrow({
        where: { id: parentId },
      })
      .employees(args);
  }

  async findOrganizations(
    parentId: string,
    args: Prisma.OrganizationFindManyArgs
  ): Promise<Organization[]> {
    return this.prisma.user
      .findUniqueOrThrow({
        where: { id: parentId },
      })
      .organizations(args);
  }

  async getManager(parentId: string): Promise<User | null> {
    return this.prisma.user
      .findUnique({
        where: { id: parentId },
      })
      .manager();
  }

  async getProfile(parentId: string): Promise<Profile | null> {
    return this.prisma.user
      .findUnique({
        where: { id: parentId },
      })
      .profile();
  }
}
",
  "server/src/user/user.controller.ts": "import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { UserService } from "./user.service";
import { UserControllerBase } from "./base/user.controller.base";

@swagger.ApiTags("users")
@common.Controller("users")
export class UserController extends UserControllerBase {
  constructor(protected readonly service: UserService) {
    super(service);
  }
}
",
  "server/src/user/user.module.ts": "import { Module } from "@nestjs/common";
import { UserModuleBase } from "./base/user.module.base";
import { UserService } from "./user.service";
import { UserController } from "./user.controller";
import { UserResolver } from "./user.resolver";

@Module({
  imports: [UserModuleBase],
  controllers: [UserController],
  providers: [UserService, UserResolver],
  exports: [UserService],
})
export class UserModule {}
",
  "server/src/user/user.resolver.ts": "import * as graphql from "@nestjs/graphql";
import { UserResolverBase } from "./base/user.resolver.base";
import { User } from "./base/User";
import { UserService } from "./user.service";

@graphql.Resolver(() => User)
export class UserResolver extends UserResolverBase {
  constructor(protected readonly service: UserService) {
    super(service);
  }
}
",
  "server/src/user/user.service.ts": "import { Injectable } from "@nestjs/common";
import { PrismaService } from "../prisma/prisma.service";
import { UserServiceBase } from "./base/user.service.base";

@Injectable()
export class UserService extends UserServiceBase {
  constructor(protected readonly prisma: PrismaService) {
    super(prisma);
  }
}
",
  "server/src/util/BigIntFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";
import { GraphQLBigInt } from "./GraphQLBigInt";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class BigIntFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: bigint;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [GraphQLBigInt], {
    nullable: true,
  })
  @Type(() => Number)
  in?: bigint[];

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [GraphQLBigInt], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: bigint[];

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: bigint;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: bigint;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: bigint;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: bigint;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  not?: bigint;
}
",
  "server/src/util/BigIntNullableFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";
import { GraphQLBigInt } from "./GraphQLBigInt";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class BigIntNullableFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: bigint | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [GraphQLBigInt], {
    nullable: true,
  })
  @Type(() => Number)
  in?: bigint[] | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [GraphQLBigInt], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: bigint[] | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: bigint;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: bigint;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: bigint;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: bigint;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => GraphQLBigInt, {
    nullable: true,
  })
  @Type(() => Number)
  not?: bigint;
}
",
  "server/src/util/BooleanFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class BooleanFilter {
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  @Type(() => Boolean)
  equals?: boolean;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  @Type(() => Boolean)
  not?: boolean;
}
",
  "server/src/util/BooleanNullableFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";
@InputType({
  isAbstract: true,
  description: undefined,
})
export class BooleanNullableFilter {
  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  @Type(() => Boolean)
  equals?: boolean | null;

  @ApiProperty({
    required: false,
    type: Boolean,
  })
  @IsOptional()
  @Field(() => Boolean, {
    nullable: true,
  })
  @Type(() => Boolean)
  not?: boolean | null;
}
",
  "server/src/util/DateTimeFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";
@InputType({
  isAbstract: true,
  description: undefined,
})
export class DateTimeFilter {
  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  equals?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  not?: Date;

  @ApiProperty({
    required: false,
    type: [Date],
  })
  @IsOptional()
  @Field(() => [Date], {
    nullable: true,
  })
  @Type(() => Date)
  in?: Date[];

  @ApiProperty({
    required: false,
    type: [Date],
  })
  @IsOptional()
  @Field(() => [Date], {
    nullable: true,
  })
  @Type(() => Date)
  notIn?: Date[];

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  lt?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  lte?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  gt?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  gte?: Date;
}
",
  "server/src/util/DateTimeNullableFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";
@InputType({
  isAbstract: true,
  description: undefined,
})
export class DateTimeNullableFilter {
  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  equals?: Date | null;

  @ApiProperty({
    required: false,
    type: [Date],
  })
  @IsOptional()
  @Field(() => [Date], {
    nullable: true,
  })
  @Type(() => Date)
  in?: Date[] | null;

  @ApiProperty({
    required: false,
    type: [Date],
  })
  @IsOptional()
  @Field(() => [Date], {
    nullable: true,
  })
  @Type(() => Date)
  notIn?: Date[] | null;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  lt?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  lte?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  gt?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  gte?: Date;

  @ApiProperty({
    required: false,
    type: Date,
  })
  @IsOptional()
  @Field(() => Date, {
    nullable: true,
  })
  @Type(() => Date)
  not?: Date;
}
",
  "server/src/util/DecimalFilter.ts": "import { Field, InputType, Float } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";
import { Decimal } from "decimal.js";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class DecimalFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: Decimal;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  in?: Decimal[];

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: Decimal[];

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: Decimal;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: Decimal;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: Decimal;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: Decimal;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  not?: Decimal;
}
",
  "server/src/util/DecimalNullableFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";
import { Decimal } from "decimal.js";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class DecimalNullableFilter {
  @ApiProperty({
    required: false,
    type: Decimal,
  })
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  @Type(() => Decimal)
  equals?: Decimal | null;

  @ApiProperty({
    required: false,
    type: [Decimal],
  })
  @IsOptional()
  @Field(() => [Number], {
    nullable: true,
  })
  @Type(() => Number)
  in?: Decimal[] | null;

  @ApiProperty({
    required: false,
    type: [Decimal],
  })
  @IsOptional()
  @Field(() => [Number], {
    nullable: true,
  })
  @Type(() => Decimal)
  notIn?: Decimal[] | null;

  @ApiProperty({
    required: false,
    type: Decimal,
  })
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  @Type(() => Decimal)
  lt?: Decimal;

  @ApiProperty({
    required: false,
    type: Decimal,
  })
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  @Type(() => Decimal)
  lte?: Decimal;

  @ApiProperty({
    required: false,
    type: Decimal,
  })
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  @Type(() => Decimal)
  gt?: Decimal;

  @ApiProperty({
    required: false,
    type: Decimal,
  })
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  @Type(() => Decimal)
  gte?: Decimal;

  @ApiProperty({
    required: false,
    type: Decimal,
  })
  @IsOptional()
  @Field(() => Number, {
    nullable: true,
  })
  @Type(() => Decimal)
  not?: Decimal;
}
",
  "server/src/util/FloatFilter.ts": "import { Field, InputType, Float } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FloatFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  in?: number[];

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: number[];

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  not?: number;
}
",
  "server/src/util/FloatNullableFilter.ts": "import { Field, InputType, Float } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FloatNullableFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: number | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  in?: number[] | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Float], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: number[] | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Float, {
    nullable: true,
  })
  @Type(() => Number)
  not?: number;
}
",
  "server/src/util/GraphQLBigInt.ts": "import { GraphQLScalarType } from "graphql";

const graphQLBigInt = new GraphQLScalarType({
  name: "BigInt",
  description: "GraphQL representation of BigInt",

  parseValue(value: unknown): number | null {
    return typeof value === "string" ||
      typeof value === "number" ||
      typeof value === "bigint"
      ? Number(value)
      : null;
  },

  serialize(value: unknown): string | null {
    return typeof value === "string" ||
      typeof value === "number" ||
      typeof value === "bigint"
      ? value.toString(10)
      : null;
  },
});

export { graphQLBigInt as GraphQLBigInt };
",
  "server/src/util/IntFilter.ts": "import { Field, InputType, Int } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class IntFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: number;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Int], {
    nullable: true,
  })
  @Type(() => Number)
  in?: number[];

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Int], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: number[];

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  not?: number;
}
",
  "server/src/util/IntNullableFilter.ts": "import { Field, InputType, Int } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class IntNullableFilter {
  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  equals?: number | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Int], {
    nullable: true,
  })
  @Type(() => Number)
  in?: number[] | null;

  @ApiProperty({
    required: false,
    type: [Number],
  })
  @IsOptional()
  @Field(() => [Int], {
    nullable: true,
  })
  @Type(() => Number)
  notIn?: number[] | null;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  lt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  lte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  gt?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  gte?: number;

  @ApiProperty({
    required: false,
    type: Number,
  })
  @IsOptional()
  @Field(() => Int, {
    nullable: true,
  })
  @Type(() => Number)
  not?: number;
}
",
  "server/src/util/JsonFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { GraphQLJSONObject } from "graphql-type-json";
import { InputJsonValue } from "../types";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class JsonFilter {
  @ApiProperty({
    required: false,
    type: GraphQLJSONObject,
  })
  @IsOptional()
  @Field(() => GraphQLJSONObject, {
    nullable: true,
  })
  equals?: InputJsonValue;

  @ApiProperty({
    required: false,
    type: GraphQLJSONObject,
  })
  @IsOptional()
  @Field(() => GraphQLJSONObject, {
    nullable: true,
  })
  not?: InputJsonValue;
}
",
  "server/src/util/JsonNullableFilter.ts": "import type { JsonValue } from "type-fest";
import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { GraphQLJSONObject } from "graphql-type-json";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class JsonNullableFilter {
  @ApiProperty({
    required: false,
    type: GraphQLJSONObject,
  })
  @IsOptional()
  @Field(() => GraphQLJSONObject, {
    nullable: true,
  })
  equals?: JsonValue;

  @ApiProperty({
    required: false,
    type: GraphQLJSONObject,
  })
  @IsOptional()
  @Field(() => GraphQLJSONObject, {
    nullable: true,
  })
  not?: JsonValue;
}
",
  "server/src/util/MetaQueryPayload.ts": "import { ObjectType, Field } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";

@ObjectType()
class MetaQueryPayload {
  @ApiProperty({
    required: true,
    type: [Number],
  })
  @Field(() => Number)
  count!: number;
}
export { MetaQueryPayload };
",
  "server/src/util/QueryMode.ts": "import { registerEnumType } from "@nestjs/graphql";

export enum QueryMode {
  Default = "default",
  Insensitive = "insensitive",
}
registerEnumType(QueryMode, {
  name: "QueryMode",
  description: undefined,
});
",
  "server/src/util/SortOrder.ts": "import { registerEnumType } from "@nestjs/graphql";

export enum SortOrder {
  Asc = "asc",
  Desc = "desc",
}
registerEnumType(SortOrder, {
  name: "SortOrder",
  description: undefined,
});
",
  "server/src/util/StringFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { QueryMode } from "./QueryMode";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType({
  isAbstract: true,
})
export class StringFilter {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  equals?: string;

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  @Type(() => String)
  in?: string[];

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  @Type(() => String)
  notIn?: string[];

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  lt?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  lte?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  gt?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  gte?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  contains?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  startsWith?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  endsWith?: string;

  @ApiProperty({
    required: false,
    enum: ["Default", "Insensitive"],
  })
  @IsOptional()
  @Field(() => QueryMode, {
    nullable: true,
  })
  mode?: QueryMode;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  not?: string;
}
",
  "server/src/util/StringNullableFilter.ts": "import { Field, InputType } from "@nestjs/graphql";
import { QueryMode } from "./QueryMode";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";

@InputType({
  isAbstract: true,
})
export class StringNullableFilter {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  equals?: string | null;

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  @Type(() => String)
  in?: string[] | null;

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [String], {
    nullable: true,
  })
  @Type(() => String)
  notIn?: string[] | null;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  lt?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  lte?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  gt?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  gte?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  contains?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  startsWith?: string;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  endsWith?: string;

  @ApiProperty({
    required: false,
    enum: ["Default", "Insensitive"],
  })
  @IsOptional()
  @Field(() => QueryMode, {
    nullable: true,
  })
  mode?: QueryMode;

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => String, {
    nullable: true,
  })
  @Type(() => String)
  not?: string;
}
",
  "server/src/validators/index.ts": "export * from "./is-json-value-validator";
",
  "server/src/validators/is-json-value-validator.spec.ts": "import { validate, ValidationError } from "class-validator";
import { IsJSONValue } from "./is-json-value-validator";

class TestClass {
  @IsJSONValue()
  jsonProperty: unknown;
}

describe("IsJSONValue", () => {
  it("should validate a valid JSON string", async () => {
    const testObj = new TestClass();
    testObj.jsonProperty = '{"name": "John", "age": 30}';
    const errors: ValidationError[] = await validate(testObj);
    expect(errors.length).toBe(0);
  });

  it("should not validate an invalid JSON string", async () => {
    const testObj = new TestClass();
    testObj.jsonProperty = '{name: "John", age: 30}';
    const errors: ValidationError[] = await validate(testObj);
    expect(errors.length).toBe(1);
  });

  it("should not validate an invalid JSON string", async () => {
    const testObj = new TestClass();
    testObj.jsonProperty = "John";
    const errors: ValidationError[] = await validate(testObj);
    expect(errors.length).toBe(1);
  });

  it("should validate a valid JSON object", async () => {
    const testObj = new TestClass();
    testObj.jsonProperty = { name: "John", age: 30 };
    const errors: ValidationError[] = await validate(testObj);
    expect(errors.length).toBe(0);
  });

  it("should validate a valid JSON array", async () => {
    const testObj = new TestClass();
    testObj.jsonProperty = ["John", "30"];
    const errors: ValidationError[] = await validate(testObj);
    expect(errors.length).toBe(0);
  });
});
",
  "server/src/validators/is-json-value-validator.ts": "import {
  ValidationArguments,
  registerDecorator,
  ValidationOptions,
} from "class-validator";
import isJSONValidator from "validator/lib/isJSON";

export function IsJSONValue(validationOptions?: ValidationOptions) {
  return function (object: Record<string, any>, propertyName: string) {
    registerDecorator({
      name: "IsJSONValue",
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          if (typeof value === "string") {
            return isJSONValidator(value);
          }

          return isJSONValidator(JSON.stringify(value));
        },
        defaultMessage(args: ValidationArguments): string {
          return \`\${args.property} must be a valid json\`;
        },
      },
    });
  };
}
",
  "server/tsconfig.build.json": "{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "prisma", "test", "dist", "**/*spec.ts", "admin"]
}
",
  "server/tsconfig.json": "{
  "compilerOptions": {
    "baseUrl": "./",
    "module": "commonjs",
    "declaration": false,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "es2022",
    "lib": ["es2023"],
    "sourceMap": true,
    "outDir": "./dist",
    "incremental": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true
  },
  "include": ["src"]
}
",
}
`;
