


/**
 * Client
 **/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
	[K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Account
 *
 */
export type Account = {
	id: string
	createdAt: Date
	updatedAt: Date
	email: string
	firstName: string
	lastName: string
	password: string
	currentUserId: string | null
	githubId: string | null
}

/**
 * Model Workspace
 *
 */
export type Workspace = {
	id: string
	createdAt: Date
	updatedAt: Date
	name: string
}

/**
 * Model Project
 *
 */
export type Project = {
	id: string
	name: string
	workspaceId: string
	createdAt: Date
	updatedAt: Date
	deletedAt: Date | null
}

/**
 * Model GitOrganization
 *
 */
export type GitOrganization = {
	id: string
	provider: EnumGitProvider
	name: string
	installationId: string
	createdAt: Date
	updatedAt: Date
	workspaceId: string
	type: EnumGitOrganizationType | null
}

/**
 * Model GitRepository
 *
 */
export type GitRepository = {
	id: string
	name: string
	createdAt: Date
	updatedAt: Date
	gitOrganizationId: string
}

/**
 * Model User
 *
 */
export type User = {
	id: string
	createdAt: Date
	updatedAt: Date
	accountId: string
	workspaceId: string
	isOwner: boolean
	deletedAt: Date | null
}

/**
 * Model UserRole
 *
 */
export type UserRole = {
	id: string
	createdAt: Date
	updatedAt: Date
	userId: string
	role: string
}

/**
 * Model ApiToken
 *
 */
export type ApiToken = {
	id: string
	createdAt: Date
	updatedAt: Date
	name: string
	userId: string
	token: string
	previewChars: string
	lastAccessAt: Date
}

/**
 * Model Resource
 *
 */
export type Resource = {
	id: string
	createdAt: Date
	updatedAt: Date
	name: string
	description: string
	gitRepositoryOverride: boolean
	githubLastSync: Date | null
	githubLastMessage: string | null
	deletedAt: Date | null
	gitRepositoryId: string | null
	projectId: string
	resourceType: EnumResourceType
}

/**
 * Model ResourceRole
 *
 */
export type ResourceRole = {
	id: string
	createdAt: Date
	updatedAt: Date
	resourceId: string
	name: string
	displayName: string
	description: string | null
}

/**
 * Model Commit
 *
 */
export type Commit = {
	id: string
	createdAt: Date
	userId: string
	message: string
	projectId: string
}

/**
 * Model Entity
 *
 */
export type Entity = {
	id: string
	createdAt: Date
	updatedAt: Date
	resourceId: string
	name: string
	displayName: string
	pluralDisplayName: string
	description: string | null
	lockedByUserId: string | null
	lockedAt: Date | null
	deletedAt: Date | null
}

/**
 * Model EntityVersion
 *
 */
export type EntityVersion = {
	id: string
	createdAt: Date
	updatedAt: Date
	entityId: string
	versionNumber: number
	name: string
	displayName: string
	pluralDisplayName: string
	description: string | null
	commitId: string | null
	deleted: boolean | null
}

/**
 * Model EntityPermission
 *
 */
export type EntityPermission = {
	id: string
	entityVersionId: string
	action: EnumEntityAction
	type: EnumEntityPermissionType
}

/**
 * Model EntityPermissionRole
 *
 */
export type EntityPermissionRole = {
	id: string
	entityVersionId: string
	action: EnumEntityAction
	resourceRoleId: string
}

/**
 * Model EntityPermissionField
 *
 */
export type EntityPermissionField = {
	id: string
	permissionId: string
	fieldPermanentId: string
	entityVersionId: string
}

/**
 * Model EntityField
 *
 */
export type EntityField = {
	id: string
	createdAt: Date
	updatedAt: Date
	entityVersionId: string
	permanentId: string
	name: string
	displayName: string
	dataType: EnumDataType
	properties: Prisma.JsonValue
	required: boolean
	searchable: boolean
	description: string
	position: number | null
	unique: boolean
}

/**
 * Model Block
 *
 */
export type Block = {
	id: string
	createdAt: Date
	updatedAt: Date
	resourceId: string
	parentBlockId: string | null
	blockType: EnumBlockType
	displayName: string
	description: string | null
	lockedByUserId: string | null
	lockedAt: Date | null
	deletedAt: Date | null
}

/**
 * Model BlockVersion
 *
 */
export type BlockVersion = {
	id: string
	createdAt: Date
	updatedAt: Date
	blockId: string
	versionNumber: number
	inputParameters: Prisma.JsonValue | null
	outputParameters: Prisma.JsonValue | null
	settings: Prisma.JsonValue
	displayName: string
	description: string | null
	commitId: string | null
	deleted: boolean | null
}

/**
 * Model Action
 *
 */
export type Action = {
	id: string
	createdAt: Date
}

/**
 * Model ActionStep
 *
 */
export type ActionStep = {
	id: string
	createdAt: Date
	message: string
	status: ActionStepStatus
	completedAt: Date | null
	actionId: string
	name: string
}

/**
 * Model ActionLog
 *
 */
export type ActionLog = {
	id: string
	createdAt: Date
	message: string
	meta: Prisma.JsonValue
	level: EnumLogLevel
	stepId: string
}

/**
 * Model Build
 *
 */
export type Build = {
	id: string
	createdAt: Date
	resourceId: string
	userId: string
	version: string
	message: string | null
	actionId: string
	images: string[]
	containerStatusQuery: Prisma.JsonValue | null
	containerStatusUpdatedAt: Date | null
	commitId: string | null
}

/**
 * Model Release
 *
 */
export type Release = {
	id: string
	createdAt: Date
	version: string
	description: string | null
	commitId: string
}

/**
 * Model Environment
 *
 */
export type Environment = {
	id: string
	createdAt: Date
	updatedAt: Date
	resourceId: string
	name: string
	description: string | null
	address: string
}

/**
 * Model Deployment
 *
 */
export type Deployment = {
	id: string
	createdAt: Date
	userId: string
	buildId: string
	environmentId: string
	status: EnumDeploymentStatus
	message: string | null
	actionId: string
	statusQuery: Prisma.JsonValue | null
	statusUpdatedAt: Date | null
}

/**
 * Model Invitation
 *
 */
export type Invitation = {
	id: string
	createdAt: Date
	updatedAt: Date
	email: string
	invitedByUserId: string
	workspaceId: string
	newUserId: string | null
	token: string
	tokenExpiration: Date
}

/**
 * Model Subscription
 *
 */
export type Subscription = {
	id: string
	createdAt: Date
	updatedAt: Date
	workspaceId: string
	subscriptionPlan: EnumSubscriptionPlan
	status: EnumSubscriptionStatus
	subscriptionData: Prisma.JsonValue
	cancellationEffectiveDate: Date | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const EnumGitProvider: {
	Github: 'Github'
};

export type EnumGitProvider = (typeof EnumGitProvider)[keyof typeof EnumGitProvider]


export const EnumGitOrganizationType: {
	User: 'User',
	Organization: 'Organization'
};

export type EnumGitOrganizationType = (typeof EnumGitOrganizationType)[keyof typeof EnumGitOrganizationType]


export const EnumResourceType: {
	Service: 'Service',
	ProjectConfiguration: 'ProjectConfiguration'
};

export type EnumResourceType = (typeof EnumResourceType)[keyof typeof EnumResourceType]


export const EnumEntityAction: {
	View: 'View',
	Create: 'Create',
	Update: 'Update',
	Delete: 'Delete',
	Search: 'Search'
};

export type EnumEntityAction = (typeof EnumEntityAction)[keyof typeof EnumEntityAction]


export const EnumEntityPermissionType: {
	AllRoles: 'AllRoles',
	Granular: 'Granular',
	Disabled: 'Disabled',
	Public: 'Public'
};

export type EnumEntityPermissionType = (typeof EnumEntityPermissionType)[keyof typeof EnumEntityPermissionType]


export const EnumDataType: {
	SingleLineText: 'SingleLineText',
	MultiLineText: 'MultiLineText',
	Email: 'Email',
	WholeNumber: 'WholeNumber',
	DateTime: 'DateTime',
	DecimalNumber: 'DecimalNumber',
	Lookup: 'Lookup',
	MultiSelectOptionSet: 'MultiSelectOptionSet',
	OptionSet: 'OptionSet',
	Boolean: 'Boolean',
	Id: 'Id',
	CreatedAt: 'CreatedAt',
	UpdatedAt: 'UpdatedAt',
	GeographicLocation: 'GeographicLocation',
	Roles: 'Roles',
	Username: 'Username',
	Password: 'Password',
	Json: 'Json'
};

export type EnumDataType = (typeof EnumDataType)[keyof typeof EnumDataType]


export const EnumBlockType: {
	ServiceSettings: 'ServiceSettings',
	ProjectConfigurationSettings: 'ProjectConfigurationSettings',
	Flow: 'Flow',
	ConnectorRestApi: 'ConnectorRestApi',
	ConnectorRestApiCall: 'ConnectorRestApiCall',
	ConnectorSoapApi: 'ConnectorSoapApi',
	ConnectorFile: 'ConnectorFile',
	EntityApi: 'EntityApi',
	EntityApiEndpoint: 'EntityApiEndpoint',
	FlowApi: 'FlowApi',
	Layout: 'Layout',
	CanvasPage: 'CanvasPage',
	EntityPage: 'EntityPage',
	Document: 'Document'
};

export type EnumBlockType = (typeof EnumBlockType)[keyof typeof EnumBlockType]


export const ActionStepStatus: {
	Waiting: 'Waiting',
	Running: 'Running',
	Failed: 'Failed',
	Success: 'Success'
};

export type ActionStepStatus = (typeof ActionStepStatus)[keyof typeof ActionStepStatus]


export const EnumLogLevel: {
	Error: 'Error',
	Warning: 'Warning',
	Info: 'Info',
	Debug: 'Debug'
};

export type EnumLogLevel = (typeof EnumLogLevel)[keyof typeof EnumLogLevel]


export const EnumDeploymentStatus: {
	Completed: 'Completed',
	Waiting: 'Waiting',
	Failed: 'Failed',
	Removed: 'Removed'
};

export type EnumDeploymentStatus = (typeof EnumDeploymentStatus)[keyof typeof EnumDeploymentStatus]


export const EnumSubscriptionPlan: {
	Pro: 'Pro',
	Business: 'Business',
	Enterprise: 'Enterprise'
};

export type EnumSubscriptionPlan = (typeof EnumSubscriptionPlan)[keyof typeof EnumSubscriptionPlan]


export const EnumSubscriptionStatus: {
	Active: 'Active',
	Trailing: 'Trailing',
	PastDue: 'PastDue',
	Paused: 'Paused',
	Deleted: 'Deleted'
};

export type EnumSubscriptionStatus = (typeof EnumSubscriptionStatus)[keyof typeof EnumSubscriptionStatus]


/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
	T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
	U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
	GlobalReject = 'rejectOnNotFound' extends keyof T
		? T['rejectOnNotFound']
		: false
	> {
	/**
	 * @private
	 */
	private fetcher;
	/**
	 * @private
	 */
	private readonly dmmf;
	/**
	 * @private
	 */
	private connectionPromise?;
	/**
	 * @private
	 */
	private disconnectionPromise?;
	/**
	 * @private
	 */
	private readonly engineConfig;
	/**
	 * @private
	 */
	private readonly measurePerformance;

	/**
	 * ##  Prisma Client ʲˢ
	 *
	 * Type-safe database client for TypeScript & Node.js
	 * @example
	 * ```
	 * const prisma = new PrismaClient()
	 * // Fetch zero or more Accounts
	 * const accounts = await prisma.account.findMany()
	 * ```
	 *
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
	 */

	constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
	$on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

	/**
	 * Connect with the database
	 */
	$connect(): Promise<void>;

	/**
	 * Disconnect from the database
	 */
	$disconnect(): Promise<void>;

	/**
	 * Add a middleware
	 */
	$use(cb: Prisma.Middleware): void

	/**
	 * Executes a prepared raw query and returns the number of affected rows.
	 * @example
	 * ```
	 * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
	 */
	$executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

	/**
	 * Executes a raw query and returns the number of affected rows.
	 * Susceptible to SQL injections, see documentation.
	 * @example
	 * ```
	 * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
	 */
	$executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

	/**
	 * Performs a prepared raw query and returns the `SELECT` data.
	 * @example
	 * ```
	 * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
	 */
	$queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

	/**
	 * Performs a raw query and returns the `SELECT` data.
	 * Susceptible to SQL injections, see documentation.
	 * @example
	 * ```
	 * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
	 */
	$queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

	/**
	 * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
	 * @example
	 * ```
	 * const [george, bob, alice] = await prisma.$transaction([
	 *   prisma.user.create({ data: { name: 'George' } }),
	 *   prisma.user.create({ data: { name: 'Bob' } }),
	 *   prisma.user.create({ data: { name: 'Alice' } }),
	 * ])
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
	 */
	$transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

	/**
	 * `prisma.account`: Exposes CRUD operations for the **Account** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Accounts
	 * const accounts = await prisma.account.findMany()
	 * ```
	 */
	get account(): Prisma.AccountDelegate<GlobalReject>;

	/**
	 * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Workspaces
	 * const workspaces = await prisma.workspace.findMany()
	 * ```
	 */
	get workspace(): Prisma.WorkspaceDelegate<GlobalReject>;

	/**
	 * `prisma.project`: Exposes CRUD operations for the **Project** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Projects
	 * const projects = await prisma.project.findMany()
	 * ```
	 */
	get project(): Prisma.ProjectDelegate<GlobalReject>;

	/**
	 * `prisma.gitOrganization`: Exposes CRUD operations for the **GitOrganization** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more GitOrganizations
	 * const gitOrganizations = await prisma.gitOrganization.findMany()
	 * ```
	 */
	get gitOrganization(): Prisma.GitOrganizationDelegate<GlobalReject>;

	/**
	 * `prisma.gitRepository`: Exposes CRUD operations for the **GitRepository** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more GitRepositories
	 * const gitRepositories = await prisma.gitRepository.findMany()
	 * ```
	 */
	get gitRepository(): Prisma.GitRepositoryDelegate<GlobalReject>;

	/**
	 * `prisma.user`: Exposes CRUD operations for the **User** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Users
	 * const users = await prisma.user.findMany()
	 * ```
	 */
	get user(): Prisma.UserDelegate<GlobalReject>;

	/**
	 * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more UserRoles
	 * const userRoles = await prisma.userRole.findMany()
	 * ```
	 */
	get userRole(): Prisma.UserRoleDelegate<GlobalReject>;

	/**
	 * `prisma.apiToken`: Exposes CRUD operations for the **ApiToken** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more ApiTokens
	 * const apiTokens = await prisma.apiToken.findMany()
	 * ```
	 */
	get apiToken(): Prisma.ApiTokenDelegate<GlobalReject>;

	/**
	 * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Resources
	 * const resources = await prisma.resource.findMany()
	 * ```
	 */
	get resource(): Prisma.ResourceDelegate<GlobalReject>;

	/**
	 * `prisma.resourceRole`: Exposes CRUD operations for the **ResourceRole** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more ResourceRoles
	 * const resourceRoles = await prisma.resourceRole.findMany()
	 * ```
	 */
	get resourceRole(): Prisma.ResourceRoleDelegate<GlobalReject>;

	/**
	 * `prisma.commit`: Exposes CRUD operations for the **Commit** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Commits
	 * const commits = await prisma.commit.findMany()
	 * ```
	 */
	get commit(): Prisma.CommitDelegate<GlobalReject>;

	/**
	 * `prisma.entity`: Exposes CRUD operations for the **Entity** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Entities
	 * const entities = await prisma.entity.findMany()
	 * ```
	 */
	get entity(): Prisma.EntityDelegate<GlobalReject>;

	/**
	 * `prisma.entityVersion`: Exposes CRUD operations for the **EntityVersion** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more EntityVersions
	 * const entityVersions = await prisma.entityVersion.findMany()
	 * ```
	 */
	get entityVersion(): Prisma.EntityVersionDelegate<GlobalReject>;

	/**
	 * `prisma.entityPermission`: Exposes CRUD operations for the **EntityPermission** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more EntityPermissions
	 * const entityPermissions = await prisma.entityPermission.findMany()
	 * ```
	 */
	get entityPermission(): Prisma.EntityPermissionDelegate<GlobalReject>;

	/**
	 * `prisma.entityPermissionRole`: Exposes CRUD operations for the **EntityPermissionRole** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more EntityPermissionRoles
	 * const entityPermissionRoles = await prisma.entityPermissionRole.findMany()
	 * ```
	 */
	get entityPermissionRole(): Prisma.EntityPermissionRoleDelegate<GlobalReject>;

	/**
	 * `prisma.entityPermissionField`: Exposes CRUD operations for the **EntityPermissionField** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more EntityPermissionFields
	 * const entityPermissionFields = await prisma.entityPermissionField.findMany()
	 * ```
	 */
	get entityPermissionField(): Prisma.EntityPermissionFieldDelegate<GlobalReject>;

	/**
	 * `prisma.entityField`: Exposes CRUD operations for the **EntityField** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more EntityFields
	 * const entityFields = await prisma.entityField.findMany()
	 * ```
	 */
	get entityField(): Prisma.EntityFieldDelegate<GlobalReject>;

	/**
	 * `prisma.block`: Exposes CRUD operations for the **Block** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Blocks
	 * const blocks = await prisma.block.findMany()
	 * ```
	 */
	get block(): Prisma.BlockDelegate<GlobalReject>;

	/**
	 * `prisma.blockVersion`: Exposes CRUD operations for the **BlockVersion** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more BlockVersions
	 * const blockVersions = await prisma.blockVersion.findMany()
	 * ```
	 */
	get blockVersion(): Prisma.BlockVersionDelegate<GlobalReject>;

	/**
	 * `prisma.action`: Exposes CRUD operations for the **Action** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Actions
	 * const actions = await prisma.action.findMany()
	 * ```
	 */
	get action(): Prisma.ActionDelegate<GlobalReject>;

	/**
	 * `prisma.actionStep`: Exposes CRUD operations for the **ActionStep** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more ActionSteps
	 * const actionSteps = await prisma.actionStep.findMany()
	 * ```
	 */
	get actionStep(): Prisma.ActionStepDelegate<GlobalReject>;

	/**
	 * `prisma.actionLog`: Exposes CRUD operations for the **ActionLog** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more ActionLogs
	 * const actionLogs = await prisma.actionLog.findMany()
	 * ```
	 */
	get actionLog(): Prisma.ActionLogDelegate<GlobalReject>;

	/**
	 * `prisma.build`: Exposes CRUD operations for the **Build** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Builds
	 * const builds = await prisma.build.findMany()
	 * ```
	 */
	get build(): Prisma.BuildDelegate<GlobalReject>;

	/**
	 * `prisma.release`: Exposes CRUD operations for the **Release** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Releases
	 * const releases = await prisma.release.findMany()
	 * ```
	 */
	get release(): Prisma.ReleaseDelegate<GlobalReject>;

	/**
	 * `prisma.environment`: Exposes CRUD operations for the **Environment** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Environments
	 * const environments = await prisma.environment.findMany()
	 * ```
	 */
	get environment(): Prisma.EnvironmentDelegate<GlobalReject>;

	/**
	 * `prisma.deployment`: Exposes CRUD operations for the **Deployment** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Deployments
	 * const deployments = await prisma.deployment.findMany()
	 * ```
	 */
	get deployment(): Prisma.DeploymentDelegate<GlobalReject>;

	/**
	 * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Invitations
	 * const invitations = await prisma.invitation.findMany()
	 * ```
	 */
	get invitation(): Prisma.InvitationDelegate<GlobalReject>;

	/**
	 * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Subscriptions
	 * const subscriptions = await prisma.subscription.findMany()
	 * ```
	 */
	get subscription(): Prisma.SubscriptionDelegate<GlobalReject>;
}

export namespace Prisma {
	export import DMMF = runtime.DMMF

	/**
	 * Prisma Errors
	 */
	export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
	export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
	export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
	export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
	export import PrismaClientValidationError = runtime.PrismaClientValidationError

	/**
	 * Re-export of sql-template-tag
	 */
	export import sql = runtime.sqltag
	export import empty = runtime.empty
	export import join = runtime.join
	export import raw = runtime.raw
	export import Sql = runtime.Sql

	/**
	 * Decimal.js
	 */
	export import Decimal = runtime.Decimal

	export type DecimalJsLike = runtime.DecimalJsLike

	/**
	 * Prisma Client JS version: 3.15.2
	 * Query Engine version: 461d6a05159055555eb7dfb337c9fb271cbd4d7e
	 */
	export type PrismaVersion = {
		client: string
	}

	export const prismaVersion: PrismaVersion

	/**
	 * Utility Types
	 */

	/**
	 * From https://github.com/sindresorhus/type-fest/
	 * Matches a JSON object.
	 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.
	 */
	export type JsonObject = {[Key in string]?: JsonValue}

	/**
	 * From https://github.com/sindresorhus/type-fest/
	 * Matches a JSON array.
	 */
	export interface JsonArray extends Array<JsonValue> {}

	/**
	 * From https://github.com/sindresorhus/type-fest/
	 * Matches any valid JSON value.
	 */
	export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

	/**
	 * Matches a JSON object.
	 * Unlike `JsonObject`, this type allows undefined and read-only properties.
	 */
	export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

	/**
	 * Matches a JSON array.
	 * Unlike `JsonArray`, readonly arrays are assignable to this type.
	 */
	export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

	/**
	 * Matches any valid value that can be used as an input for operations like
	 * create and update as the value of a JSON field. Unlike `JsonValue`, this
	 * type allows read-only arrays and read-only object properties and disallows
	 * `null` at the top level.
	 *
	 * `null` cannot be used as the value of a JSON field because its meaning
	 * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
	 * `Prisma.DbNull` to clear the JSON value and set the field to the database
	 * NULL value instead.
	 *
	 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
	 */
	export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

	/**
	 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
	 *
	 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
	 */
	export const DbNull: 'DbNull'

	/**
	 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
	 *
	 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
	 */
	export const JsonNull: 'JsonNull'

	/**
	 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
	 *
	 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
	 */
	export const AnyNull: 'AnyNull'

	type SelectAndInclude = {
		select: any
		include: any
	}
	type HasSelect = {
		select: any
	}
	type HasInclude = {
		include: any
	}
	type CheckSelect<T, S, U> = T extends SelectAndInclude
		? 'Please either choose `select` or `include`'
		: T extends HasSelect
			? U
			: T extends HasInclude
				? U
				: S

	/**
	 * Get the type of the value, that the Promise holds.
	 */
	export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

	/**
	 * Get the return type of a function which returns a Promise.
	 */
	export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

	/**
	 * From T, pick a set of properties whose keys are in the union K
	 */
	type Prisma__Pick<T, K extends keyof T> = {
		[P in K]: T[P];
	};


	export type Enumerable<T> = T | Array<T>;

	export type RequiredKeys<T> = {
		[K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
	}[keyof T]

	export type TruthyKeys<T> = {
		[key in keyof T]: T[key] extends false | undefined | null ? never : key
	}[keyof T]

	export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

	/**
	 * Subset
	 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
	 */
	export type Subset<T, U> = {
		[key in keyof T]: key extends keyof U ? T[key] : never;
	};

	/**
	 * SelectSubset
	 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
	 * Additionally, it validates, if both select and include are present. If the case, it errors.
	 */
	export type SelectSubset<T, U> = {
		[key in keyof T]: key extends keyof U ? T[key] : never
	} &
		(T extends SelectAndInclude
			? 'Please either choose `select` or `include`.'
			: {})

	/**
	 * Subset + Intersection
	 * @desc From `T` pick properties that exist in `U` and intersect `K`
	 */
	export type SubsetIntersection<T, U, K> = {
		[key in keyof T]: key extends keyof U ? T[key] : never
	} &
		K

	type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

	/**
	 * XOR is needed to have a real mutually exclusive union type
	 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
	 */
	type XOR<T, U> =
		T extends object ?
			U extends object ?
				(Without<T, U> & U) | (Without<U, T> & T)
				: U : T


	/**
	 * Is T a Record?
	 */
	type IsObject<T extends any> = T extends Array<any>
		? False
		: T extends Date
			? False
			: T extends Buffer
				? False
				: T extends BigInt
					? False
					: T extends object
						? True
						: False


	/**
	 * If it's T[], return T
	 */
	export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

	/**
	 * From ts-toolbelt
	 */

	type __Either<O extends object, K extends Key> = Omit<O, K> &
		{
			// Merge all but K
			[P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
		}[K]

	type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

	type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

	type _Either<
		O extends object,
		K extends Key,
		strict extends Boolean
		> = {
		1: EitherStrict<O, K>
		0: EitherLoose<O, K>
	}[strict]

	type Either<
		O extends object,
		K extends Key,
		strict extends Boolean = 1
		> = O extends unknown ? _Either<O, K, strict> : never

	export type Union = any

	type PatchUndefined<O extends object, O1 extends object> = {
		[K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
	} & {}

	/** Helper Types for "Merge" **/
	export type IntersectOf<U extends Union> = (
		U extends unknown ? (k: U) => void : never
		) extends (k: infer I) => void
		? I
		: never

	export type Overwrite<O extends object, O1 extends object> = {
		[K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
	} & {};

	type _Merge<U extends object> = IntersectOf<Overwrite<U, {
		[K in keyof U]-?: At<U, K>;
	}>>;

	type Key = string | number | symbol;
	type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
	type AtStrict<O extends object, K extends Key> = O[K & keyof O];
	type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
	export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
		1: AtStrict<O, K>;
		0: AtLoose<O, K>;
	}[strict];

	export type ComputeRaw<A extends any> = A extends Function ? A : {
		[K in keyof A]: A[K];
	} & {};

	export type OptionalFlat<O> = {
		[K in keyof O]?: O[K];
	} & {};

	type _Record<K extends keyof any, T> = {
		[P in K]: T;
	};

	type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

	export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
	/** End Helper Types for "Merge" **/

	export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

	/**
  A [[Boolean]]
	 */
	export type Boolean = True | False

	// /**
	// 1
	// */
	export type True = 1

	/**
  0
	 */
	export type False = 0

	export type Not<B extends Boolean> = {
		0: 1
		1: 0
	}[B]

	export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
		? 0 // anything `never` is false
		: A1 extends A2
			? 1
			: 0

	export type Has<U extends Union, U1 extends Union> = Not<
		Extends<Exclude<U1, U>, U1>
		>

	export type Or<B1 extends Boolean, B2 extends Boolean> = {
		0: {
			0: 0
			1: 1
		}
		1: {
			0: 1
			1: 1
		}
	}[B1][B2]

	export type Keys<U extends Union> = U extends unknown ? keyof U : never

	type Exact<A, W = unknown> =
		W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
				{[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
				{[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
			: never;

	type Narrowable = string | number | boolean | bigint;

	type Cast<A, B> = A extends B ? A : B;

	export const type: unique symbol;

	export function validator<V>(): <S>(select: Exact<S, V>) => S;

	/**
	 * Used by group by
	 */

	export type GetScalarType<T, O> = O extends object ? {
		[P in keyof T]: P extends keyof O
			? O[P]
			: never
	} : never

	type FieldPaths<
		T,
		U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
		> = IsObject<T> extends True ? U : T

	type GetHavingFields<T> = {
		[K in keyof T]: Or<
			Or<Extends<'OR', K>, Extends<'AND', K>>,
			Extends<'NOT', K>
			> extends True
			? // infer is only needed to not hit TS limit
			// based on the brilliant idea of Pierre-Antoine Mills
			// https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
			T[K] extends infer TK
				? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
				: never
			: {} extends FieldPaths<T[K]>
				? never
				: K
	}[keyof T]

	/**
	 * Convert tuple to union
	 */
	type _TupleToUnion<T> = T extends (infer E)[] ? E : never
	type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
	type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

	/**
	 * Like `Pick`, but with an array
	 */
	type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

	/**
	 * Exclude all keys with underscores
	 */
	type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

	class PrismaClientFetcher {
		private readonly prisma;
		private readonly debug;
		private readonly hooks?;
		constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
		request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
		sanitizeMessage(message: string): string;
		protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
	}

	export const ModelName: {
		Account: 'Account',
		Workspace: 'Workspace',
		Project: 'Project',
		GitOrganization: 'GitOrganization',
		GitRepository: 'GitRepository',
		User: 'User',
		UserRole: 'UserRole',
		ApiToken: 'ApiToken',
		Resource: 'Resource',
		ResourceRole: 'ResourceRole',
		Commit: 'Commit',
		Entity: 'Entity',
		EntityVersion: 'EntityVersion',
		EntityPermission: 'EntityPermission',
		EntityPermissionRole: 'EntityPermissionRole',
		EntityPermissionField: 'EntityPermissionField',
		EntityField: 'EntityField',
		Block: 'Block',
		BlockVersion: 'BlockVersion',
		Action: 'Action',
		ActionStep: 'ActionStep',
		ActionLog: 'ActionLog',
		Build: 'Build',
		Release: 'Release',
		Environment: 'Environment',
		Deployment: 'Deployment',
		Invitation: 'Invitation',
		Subscription: 'Subscription'
	};

	export type ModelName = (typeof ModelName)[keyof typeof ModelName]


	export type Datasources = {
		db?: Datasource
	}

	export type RejectOnNotFound = boolean | ((error: Error) => Error)
	export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
	export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound }
	type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
	export type HasReject<
		GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
		LocalRejectSettings,
		Action extends PrismaAction,
		Model extends ModelName
		> = LocalRejectSettings extends RejectOnNotFound
		? IsReject<LocalRejectSettings>
		: GlobalRejectSettings extends RejectPerOperation
			? Action extends keyof GlobalRejectSettings
				? GlobalRejectSettings[Action] extends RejectOnNotFound
					? IsReject<GlobalRejectSettings[Action]>
					: GlobalRejectSettings[Action] extends RejectPerModel
						? Model extends keyof GlobalRejectSettings[Action]
							? IsReject<GlobalRejectSettings[Action][Model]>
							: False
						: False
				: False
			: IsReject<GlobalRejectSettings>
	export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

	export interface PrismaClientOptions {
		/**
		 * Configure findUnique/findFirst to throw an error if the query returns null.
		 *  * @example
		 * ```
		 * // Reject on both findUnique/findFirst
		 * rejectOnNotFound: true
		 * // Reject only on findFirst with a custom error
		 * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
		 * // Reject on user.findUnique with a custom error
		 * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
		 * ```
		 */
		rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
		/**
		 * Overwrites the datasource url from your prisma.schema file
		 */
		datasources?: Datasources

		/**
		 * @default "colorless"
		 */
		errorFormat?: ErrorFormat

		/**
		 * @example
		 * ```
		 * // Defaults to stdout
		 * log: ['query', 'info', 'warn', 'error']
		 *
		 * // Emit as events
		 * log: [
		 *  { emit: 'stdout', level: 'query' },
		 *  { emit: 'stdout', level: 'info' },
		 *  { emit: 'stdout', level: 'warn' }
		 *  { emit: 'stdout', level: 'error' }
		 * ]
		 * ```
		 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
		 */
		log?: Array<LogLevel | LogDefinition>
	}

	export type Hooks = {
		beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
	}

	/* Types for Logging */
	export type LogLevel = 'info' | 'query' | 'warn' | 'error'
	export type LogDefinition = {
		level: LogLevel
		emit: 'stdout' | 'event'
	}

	export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
	export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
		GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
		: never

	export type QueryEvent = {
		timestamp: Date
		query: string
		params: string
		duration: number
		target: string
	}

	export type LogEvent = {
		timestamp: Date
		message: string
		target: string
	}
	/* End Types for Logging */


	export type PrismaAction =
		| 'findUnique'
		| 'findMany'
		| 'findFirst'
		| 'create'
		| 'createMany'
		| 'update'
		| 'updateMany'
		| 'upsert'
		| 'delete'
		| 'deleteMany'
		| 'executeRaw'
		| 'queryRaw'
		| 'aggregate'
		| 'count'
		| 'runCommandRaw'
		| 'findRaw'

	/**
	 * These options are being passed in to the middleware as "params"
	 */
	export type MiddlewareParams = {
		model?: ModelName
		action: PrismaAction
		args: any
		dataPath: string[]
		runInTransaction: boolean
	}

	/**
	 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
	 */
	export type Middleware<T = any> = (
		params: MiddlewareParams,
		next: (params: MiddlewareParams) => Promise<T>,
	) => Promise<T>

	// tested in getLogLevel.test.ts
	export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

	export type Datasource = {
		url?: string
	}

	/**
	 * Count Types
	 */


	/**
	 * Count Type AccountCountOutputType
	 */


	export type AccountCountOutputType = {
		users: number
	}

	export type AccountCountOutputTypeSelect = {
		users?: boolean
	}

	export type AccountCountOutputTypeGetPayload<
		S extends boolean | null | undefined | AccountCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? AccountCountOutputType
		: S extends undefined
			? never
			: S extends AccountCountOutputTypeArgs
				?'include' extends U
					? AccountCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof AccountCountOutputType ? AccountCountOutputType[P] : never
						}
						: AccountCountOutputType
				: AccountCountOutputType




	// Custom InputTypes

	/**
	 * AccountCountOutputType without action
	 */
	export type AccountCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the AccountCountOutputType
		 *
		 **/
		select?: AccountCountOutputTypeSelect | null
	}



	/**
	 * Count Type WorkspaceCountOutputType
	 */


	export type WorkspaceCountOutputType = {
		users: number
		invitations: number
		subscriptions: number
		gitOrganizations: number
		projects: number
	}

	export type WorkspaceCountOutputTypeSelect = {
		users?: boolean
		invitations?: boolean
		subscriptions?: boolean
		gitOrganizations?: boolean
		projects?: boolean
	}

	export type WorkspaceCountOutputTypeGetPayload<
		S extends boolean | null | undefined | WorkspaceCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? WorkspaceCountOutputType
		: S extends undefined
			? never
			: S extends WorkspaceCountOutputTypeArgs
				?'include' extends U
					? WorkspaceCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof WorkspaceCountOutputType ? WorkspaceCountOutputType[P] : never
						}
						: WorkspaceCountOutputType
				: WorkspaceCountOutputType




	// Custom InputTypes

	/**
	 * WorkspaceCountOutputType without action
	 */
	export type WorkspaceCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the WorkspaceCountOutputType
		 *
		 **/
		select?: WorkspaceCountOutputTypeSelect | null
	}



	/**
	 * Count Type ProjectCountOutputType
	 */


	export type ProjectCountOutputType = {
		resources: number
		commits: number
	}

	export type ProjectCountOutputTypeSelect = {
		resources?: boolean
		commits?: boolean
	}

	export type ProjectCountOutputTypeGetPayload<
		S extends boolean | null | undefined | ProjectCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? ProjectCountOutputType
		: S extends undefined
			? never
			: S extends ProjectCountOutputTypeArgs
				?'include' extends U
					? ProjectCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof ProjectCountOutputType ? ProjectCountOutputType[P] : never
						}
						: ProjectCountOutputType
				: ProjectCountOutputType




	// Custom InputTypes

	/**
	 * ProjectCountOutputType without action
	 */
	export type ProjectCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the ProjectCountOutputType
		 *
		 **/
		select?: ProjectCountOutputTypeSelect | null
	}



	/**
	 * Count Type GitOrganizationCountOutputType
	 */


	export type GitOrganizationCountOutputType = {
		gitRepositories: number
	}

	export type GitOrganizationCountOutputTypeSelect = {
		gitRepositories?: boolean
	}

	export type GitOrganizationCountOutputTypeGetPayload<
		S extends boolean | null | undefined | GitOrganizationCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? GitOrganizationCountOutputType
		: S extends undefined
			? never
			: S extends GitOrganizationCountOutputTypeArgs
				?'include' extends U
					? GitOrganizationCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof GitOrganizationCountOutputType ? GitOrganizationCountOutputType[P] : never
						}
						: GitOrganizationCountOutputType
				: GitOrganizationCountOutputType




	// Custom InputTypes

	/**
	 * GitOrganizationCountOutputType without action
	 */
	export type GitOrganizationCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the GitOrganizationCountOutputType
		 *
		 **/
		select?: GitOrganizationCountOutputTypeSelect | null
	}



	/**
	 * Count Type GitRepositoryCountOutputType
	 */


	export type GitRepositoryCountOutputType = {
		resources: number
	}

	export type GitRepositoryCountOutputTypeSelect = {
		resources?: boolean
	}

	export type GitRepositoryCountOutputTypeGetPayload<
		S extends boolean | null | undefined | GitRepositoryCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? GitRepositoryCountOutputType
		: S extends undefined
			? never
			: S extends GitRepositoryCountOutputTypeArgs
				?'include' extends U
					? GitRepositoryCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof GitRepositoryCountOutputType ? GitRepositoryCountOutputType[P] : never
						}
						: GitRepositoryCountOutputType
				: GitRepositoryCountOutputType




	// Custom InputTypes

	/**
	 * GitRepositoryCountOutputType without action
	 */
	export type GitRepositoryCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the GitRepositoryCountOutputType
		 *
		 **/
		select?: GitRepositoryCountOutputTypeSelect | null
	}



	/**
	 * Count Type UserCountOutputType
	 */


	export type UserCountOutputType = {
		apiTokens: number
		lockedBlocks: number
		builds: number
		commits: number
		deployments: number
		lockedEntitis: number
		userRoles: number
		sentInvitations: number
	}

	export type UserCountOutputTypeSelect = {
		apiTokens?: boolean
		lockedBlocks?: boolean
		builds?: boolean
		commits?: boolean
		deployments?: boolean
		lockedEntitis?: boolean
		userRoles?: boolean
		sentInvitations?: boolean
	}

	export type UserCountOutputTypeGetPayload<
		S extends boolean | null | undefined | UserCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? UserCountOutputType
		: S extends undefined
			? never
			: S extends UserCountOutputTypeArgs
				?'include' extends U
					? UserCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
						}
						: UserCountOutputType
				: UserCountOutputType




	// Custom InputTypes

	/**
	 * UserCountOutputType without action
	 */
	export type UserCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the UserCountOutputType
		 *
		 **/
		select?: UserCountOutputTypeSelect | null
	}



	/**
	 * Count Type ResourceCountOutputType
	 */


	export type ResourceCountOutputType = {
		roles: number
		blocks: number
		builds: number
		entities: number
		environments: number
	}

	export type ResourceCountOutputTypeSelect = {
		roles?: boolean
		blocks?: boolean
		builds?: boolean
		entities?: boolean
		environments?: boolean
	}

	export type ResourceCountOutputTypeGetPayload<
		S extends boolean | null | undefined | ResourceCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? ResourceCountOutputType
		: S extends undefined
			? never
			: S extends ResourceCountOutputTypeArgs
				?'include' extends U
					? ResourceCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof ResourceCountOutputType ? ResourceCountOutputType[P] : never
						}
						: ResourceCountOutputType
				: ResourceCountOutputType




	// Custom InputTypes

	/**
	 * ResourceCountOutputType without action
	 */
	export type ResourceCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the ResourceCountOutputType
		 *
		 **/
		select?: ResourceCountOutputTypeSelect | null
	}



	/**
	 * Count Type ResourceRoleCountOutputType
	 */


	export type ResourceRoleCountOutputType = {
		entityPermissionRoles: number
	}

	export type ResourceRoleCountOutputTypeSelect = {
		entityPermissionRoles?: boolean
	}

	export type ResourceRoleCountOutputTypeGetPayload<
		S extends boolean | null | undefined | ResourceRoleCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? ResourceRoleCountOutputType
		: S extends undefined
			? never
			: S extends ResourceRoleCountOutputTypeArgs
				?'include' extends U
					? ResourceRoleCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof ResourceRoleCountOutputType ? ResourceRoleCountOutputType[P] : never
						}
						: ResourceRoleCountOutputType
				: ResourceRoleCountOutputType




	// Custom InputTypes

	/**
	 * ResourceRoleCountOutputType without action
	 */
	export type ResourceRoleCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the ResourceRoleCountOutputType
		 *
		 **/
		select?: ResourceRoleCountOutputTypeSelect | null
	}



	/**
	 * Count Type CommitCountOutputType
	 */


	export type CommitCountOutputType = {
		blockVersions: number
		builds: number
		entityVersions: number
		releases: number
	}

	export type CommitCountOutputTypeSelect = {
		blockVersions?: boolean
		builds?: boolean
		entityVersions?: boolean
		releases?: boolean
	}

	export type CommitCountOutputTypeGetPayload<
		S extends boolean | null | undefined | CommitCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? CommitCountOutputType
		: S extends undefined
			? never
			: S extends CommitCountOutputTypeArgs
				?'include' extends U
					? CommitCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof CommitCountOutputType ? CommitCountOutputType[P] : never
						}
						: CommitCountOutputType
				: CommitCountOutputType




	// Custom InputTypes

	/**
	 * CommitCountOutputType without action
	 */
	export type CommitCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the CommitCountOutputType
		 *
		 **/
		select?: CommitCountOutputTypeSelect | null
	}



	/**
	 * Count Type EntityCountOutputType
	 */


	export type EntityCountOutputType = {
		versions: number
	}

	export type EntityCountOutputTypeSelect = {
		versions?: boolean
	}

	export type EntityCountOutputTypeGetPayload<
		S extends boolean | null | undefined | EntityCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? EntityCountOutputType
		: S extends undefined
			? never
			: S extends EntityCountOutputTypeArgs
				?'include' extends U
					? EntityCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof EntityCountOutputType ? EntityCountOutputType[P] : never
						}
						: EntityCountOutputType
				: EntityCountOutputType




	// Custom InputTypes

	/**
	 * EntityCountOutputType without action
	 */
	export type EntityCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the EntityCountOutputType
		 *
		 **/
		select?: EntityCountOutputTypeSelect | null
	}



	/**
	 * Count Type EntityVersionCountOutputType
	 */


	export type EntityVersionCountOutputType = {
		fields: number
		permissions: number
		builds: number
	}

	export type EntityVersionCountOutputTypeSelect = {
		fields?: boolean
		permissions?: boolean
		builds?: boolean
	}

	export type EntityVersionCountOutputTypeGetPayload<
		S extends boolean | null | undefined | EntityVersionCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? EntityVersionCountOutputType
		: S extends undefined
			? never
			: S extends EntityVersionCountOutputTypeArgs
				?'include' extends U
					? EntityVersionCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof EntityVersionCountOutputType ? EntityVersionCountOutputType[P] : never
						}
						: EntityVersionCountOutputType
				: EntityVersionCountOutputType




	// Custom InputTypes

	/**
	 * EntityVersionCountOutputType without action
	 */
	export type EntityVersionCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the EntityVersionCountOutputType
		 *
		 **/
		select?: EntityVersionCountOutputTypeSelect | null
	}



	/**
	 * Count Type EntityPermissionCountOutputType
	 */


	export type EntityPermissionCountOutputType = {
		permissionFields: number
		permissionRoles: number
	}

	export type EntityPermissionCountOutputTypeSelect = {
		permissionFields?: boolean
		permissionRoles?: boolean
	}

	export type EntityPermissionCountOutputTypeGetPayload<
		S extends boolean | null | undefined | EntityPermissionCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? EntityPermissionCountOutputType
		: S extends undefined
			? never
			: S extends EntityPermissionCountOutputTypeArgs
				?'include' extends U
					? EntityPermissionCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof EntityPermissionCountOutputType ? EntityPermissionCountOutputType[P] : never
						}
						: EntityPermissionCountOutputType
				: EntityPermissionCountOutputType




	// Custom InputTypes

	/**
	 * EntityPermissionCountOutputType without action
	 */
	export type EntityPermissionCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionCountOutputType
		 *
		 **/
		select?: EntityPermissionCountOutputTypeSelect | null
	}



	/**
	 * Count Type EntityPermissionRoleCountOutputType
	 */


	export type EntityPermissionRoleCountOutputType = {
		permissionFields: number
	}

	export type EntityPermissionRoleCountOutputTypeSelect = {
		permissionFields?: boolean
	}

	export type EntityPermissionRoleCountOutputTypeGetPayload<
		S extends boolean | null | undefined | EntityPermissionRoleCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? EntityPermissionRoleCountOutputType
		: S extends undefined
			? never
			: S extends EntityPermissionRoleCountOutputTypeArgs
				?'include' extends U
					? EntityPermissionRoleCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof EntityPermissionRoleCountOutputType ? EntityPermissionRoleCountOutputType[P] : never
						}
						: EntityPermissionRoleCountOutputType
				: EntityPermissionRoleCountOutputType




	// Custom InputTypes

	/**
	 * EntityPermissionRoleCountOutputType without action
	 */
	export type EntityPermissionRoleCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionRoleCountOutputType
		 *
		 **/
		select?: EntityPermissionRoleCountOutputTypeSelect | null
	}



	/**
	 * Count Type EntityPermissionFieldCountOutputType
	 */


	export type EntityPermissionFieldCountOutputType = {
		permissionRoles: number
	}

	export type EntityPermissionFieldCountOutputTypeSelect = {
		permissionRoles?: boolean
	}

	export type EntityPermissionFieldCountOutputTypeGetPayload<
		S extends boolean | null | undefined | EntityPermissionFieldCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? EntityPermissionFieldCountOutputType
		: S extends undefined
			? never
			: S extends EntityPermissionFieldCountOutputTypeArgs
				?'include' extends U
					? EntityPermissionFieldCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof EntityPermissionFieldCountOutputType ? EntityPermissionFieldCountOutputType[P] : never
						}
						: EntityPermissionFieldCountOutputType
				: EntityPermissionFieldCountOutputType




	// Custom InputTypes

	/**
	 * EntityPermissionFieldCountOutputType without action
	 */
	export type EntityPermissionFieldCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionFieldCountOutputType
		 *
		 **/
		select?: EntityPermissionFieldCountOutputTypeSelect | null
	}



	/**
	 * Count Type EntityFieldCountOutputType
	 */


	export type EntityFieldCountOutputType = {
		permissionField: number
	}

	export type EntityFieldCountOutputTypeSelect = {
		permissionField?: boolean
	}

	export type EntityFieldCountOutputTypeGetPayload<
		S extends boolean | null | undefined | EntityFieldCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? EntityFieldCountOutputType
		: S extends undefined
			? never
			: S extends EntityFieldCountOutputTypeArgs
				?'include' extends U
					? EntityFieldCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof EntityFieldCountOutputType ? EntityFieldCountOutputType[P] : never
						}
						: EntityFieldCountOutputType
				: EntityFieldCountOutputType




	// Custom InputTypes

	/**
	 * EntityFieldCountOutputType without action
	 */
	export type EntityFieldCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the EntityFieldCountOutputType
		 *
		 **/
		select?: EntityFieldCountOutputTypeSelect | null
	}



	/**
	 * Count Type BlockCountOutputType
	 */


	export type BlockCountOutputType = {
		blocks: number
		versions: number
	}

	export type BlockCountOutputTypeSelect = {
		blocks?: boolean
		versions?: boolean
	}

	export type BlockCountOutputTypeGetPayload<
		S extends boolean | null | undefined | BlockCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? BlockCountOutputType
		: S extends undefined
			? never
			: S extends BlockCountOutputTypeArgs
				?'include' extends U
					? BlockCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof BlockCountOutputType ? BlockCountOutputType[P] : never
						}
						: BlockCountOutputType
				: BlockCountOutputType




	// Custom InputTypes

	/**
	 * BlockCountOutputType without action
	 */
	export type BlockCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the BlockCountOutputType
		 *
		 **/
		select?: BlockCountOutputTypeSelect | null
	}



	/**
	 * Count Type BlockVersionCountOutputType
	 */


	export type BlockVersionCountOutputType = {
		builds: number
	}

	export type BlockVersionCountOutputTypeSelect = {
		builds?: boolean
	}

	export type BlockVersionCountOutputTypeGetPayload<
		S extends boolean | null | undefined | BlockVersionCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? BlockVersionCountOutputType
		: S extends undefined
			? never
			: S extends BlockVersionCountOutputTypeArgs
				?'include' extends U
					? BlockVersionCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof BlockVersionCountOutputType ? BlockVersionCountOutputType[P] : never
						}
						: BlockVersionCountOutputType
				: BlockVersionCountOutputType




	// Custom InputTypes

	/**
	 * BlockVersionCountOutputType without action
	 */
	export type BlockVersionCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the BlockVersionCountOutputType
		 *
		 **/
		select?: BlockVersionCountOutputTypeSelect | null
	}



	/**
	 * Count Type ActionCountOutputType
	 */


	export type ActionCountOutputType = {
		steps: number
		builds: number
		deployments: number
	}

	export type ActionCountOutputTypeSelect = {
		steps?: boolean
		builds?: boolean
		deployments?: boolean
	}

	export type ActionCountOutputTypeGetPayload<
		S extends boolean | null | undefined | ActionCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? ActionCountOutputType
		: S extends undefined
			? never
			: S extends ActionCountOutputTypeArgs
				?'include' extends U
					? ActionCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof ActionCountOutputType ? ActionCountOutputType[P] : never
						}
						: ActionCountOutputType
				: ActionCountOutputType




	// Custom InputTypes

	/**
	 * ActionCountOutputType without action
	 */
	export type ActionCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the ActionCountOutputType
		 *
		 **/
		select?: ActionCountOutputTypeSelect | null
	}



	/**
	 * Count Type ActionStepCountOutputType
	 */


	export type ActionStepCountOutputType = {
		logs: number
	}

	export type ActionStepCountOutputTypeSelect = {
		logs?: boolean
	}

	export type ActionStepCountOutputTypeGetPayload<
		S extends boolean | null | undefined | ActionStepCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? ActionStepCountOutputType
		: S extends undefined
			? never
			: S extends ActionStepCountOutputTypeArgs
				?'include' extends U
					? ActionStepCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof ActionStepCountOutputType ? ActionStepCountOutputType[P] : never
						}
						: ActionStepCountOutputType
				: ActionStepCountOutputType




	// Custom InputTypes

	/**
	 * ActionStepCountOutputType without action
	 */
	export type ActionStepCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the ActionStepCountOutputType
		 *
		 **/
		select?: ActionStepCountOutputTypeSelect | null
	}



	/**
	 * Count Type BuildCountOutputType
	 */


	export type BuildCountOutputType = {
		deployments: number
		blockVersions: number
		entityVersions: number
	}

	export type BuildCountOutputTypeSelect = {
		deployments?: boolean
		blockVersions?: boolean
		entityVersions?: boolean
	}

	export type BuildCountOutputTypeGetPayload<
		S extends boolean | null | undefined | BuildCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? BuildCountOutputType
		: S extends undefined
			? never
			: S extends BuildCountOutputTypeArgs
				?'include' extends U
					? BuildCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof BuildCountOutputType ? BuildCountOutputType[P] : never
						}
						: BuildCountOutputType
				: BuildCountOutputType




	// Custom InputTypes

	/**
	 * BuildCountOutputType without action
	 */
	export type BuildCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the BuildCountOutputType
		 *
		 **/
		select?: BuildCountOutputTypeSelect | null
	}



	/**
	 * Count Type EnvironmentCountOutputType
	 */


	export type EnvironmentCountOutputType = {
		deployments: number
	}

	export type EnvironmentCountOutputTypeSelect = {
		deployments?: boolean
	}

	export type EnvironmentCountOutputTypeGetPayload<
		S extends boolean | null | undefined | EnvironmentCountOutputTypeArgs,
		U = keyof S
		> = S extends true
		? EnvironmentCountOutputType
		: S extends undefined
			? never
			: S extends EnvironmentCountOutputTypeArgs
				?'include' extends U
					? EnvironmentCountOutputType
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends keyof EnvironmentCountOutputType ? EnvironmentCountOutputType[P] : never
						}
						: EnvironmentCountOutputType
				: EnvironmentCountOutputType




	// Custom InputTypes

	/**
	 * EnvironmentCountOutputType without action
	 */
	export type EnvironmentCountOutputTypeArgs = {
		/**
		 * Select specific fields to fetch from the EnvironmentCountOutputType
		 *
		 **/
		select?: EnvironmentCountOutputTypeSelect | null
	}



	/**
	 * Models
	 */

	/**
	 * Model Account
	 */


	export type AggregateAccount = {
		_count: AccountCountAggregateOutputType | null
		_min: AccountMinAggregateOutputType | null
		_max: AccountMaxAggregateOutputType | null
	}

	export type AccountMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		email: string | null
		firstName: string | null
		lastName: string | null
		password: string | null
		currentUserId: string | null
		githubId: string | null
	}

	export type AccountMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		email: string | null
		firstName: string | null
		lastName: string | null
		password: string | null
		currentUserId: string | null
		githubId: string | null
	}

	export type AccountCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		email: number
		firstName: number
		lastName: number
		password: number
		currentUserId: number
		githubId: number
		_all: number
	}


	export type AccountMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		email?: true
		firstName?: true
		lastName?: true
		password?: true
		currentUserId?: true
		githubId?: true
	}

	export type AccountMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		email?: true
		firstName?: true
		lastName?: true
		password?: true
		currentUserId?: true
		githubId?: true
	}

	export type AccountCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		email?: true
		firstName?: true
		lastName?: true
		password?: true
		currentUserId?: true
		githubId?: true
		_all?: true
	}

	export type AccountAggregateArgs = {
		/**
		 * Filter which Account to aggregate.
		 *
		 **/
		where?: AccountWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Accounts to fetch.
		 *
		 **/
		orderBy?: Enumerable<AccountOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: AccountWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Accounts from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Accounts.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Accounts
		 **/
		_count?: true | AccountCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: AccountMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: AccountMaxAggregateInputType
	}

	export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
		[P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateAccount[P]>
			: GetScalarType<T[P], AggregateAccount[P]>
	}




	export type AccountGroupByArgs = {
		where?: AccountWhereInput
		orderBy?: Enumerable<AccountOrderByWithAggregationInput>
		by: Array<AccountScalarFieldEnum>
		having?: AccountScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: AccountCountAggregateInputType | true
		_min?: AccountMinAggregateInputType
		_max?: AccountMaxAggregateInputType
	}


	export type AccountGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		email: string
		firstName: string
		lastName: string
		password: string
		currentUserId: string | null
		githubId: string | null
		_count: AccountCountAggregateOutputType | null
		_min: AccountMinAggregateOutputType | null
		_max: AccountMaxAggregateOutputType | null
	}

	type GetAccountGroupByPayload<T extends AccountGroupByArgs> = PrismaPromise<
		Array<
			PickArray<AccountGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], AccountGroupByOutputType[P]>
				: GetScalarType<T[P], AccountGroupByOutputType[P]>
			}
			>
		>


	export type AccountSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		email?: boolean
		firstName?: boolean
		lastName?: boolean
		password?: boolean
		currentUserId?: boolean
		githubId?: boolean
		currentUser?: boolean | UserArgs
		users?: boolean | UserFindManyArgs
		_count?: boolean | AccountCountOutputTypeArgs
	}

	export type AccountInclude = {
		currentUser?: boolean | UserArgs
		users?: boolean | UserFindManyArgs
		_count?: boolean | AccountCountOutputTypeArgs
	}

	export type AccountGetPayload<
		S extends boolean | null | undefined | AccountArgs,
		U = keyof S
		> = S extends true
		? Account
		: S extends undefined
			? never
			: S extends AccountArgs | AccountFindManyArgs
				?'include' extends U
					? Account  & {
					[P in TrueKeys<S['include']>]:
					P extends 'currentUser' ? UserGetPayload<S['include'][P]> | null :
						P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
							P extends '_count' ? AccountCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'currentUser' ? UserGetPayload<S['select'][P]> | null :
								P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
									P extends '_count' ? AccountCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Account ? Account[P] : never
						}
						: Account
				: Account


	type AccountCountArgs = Merge<
		Omit<AccountFindManyArgs, 'select' | 'include'> & {
		select?: AccountCountAggregateInputType | true
	}
		>

	export interface AccountDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Account that matches the filter.
		 * @param {AccountFindUniqueArgs} args - Arguments to find a Account
		 * @example
		 * // Get one Account
		 * const account = await prisma.account.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, AccountFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null >, Prisma__AccountClient<AccountGetPayload<T> | null >>

		/**
		 * Find the first Account that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountFindFirstArgs} args - Arguments to find a Account
		 * @example
		 * // Get one Account
		 * const account = await prisma.account.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, AccountFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null >, Prisma__AccountClient<AccountGetPayload<T> | null >>

		/**
		 * Find zero or more Accounts that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Accounts
		 * const accounts = await prisma.account.findMany()
		 *
		 * // Get first 10 Accounts
		 * const accounts = await prisma.account.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends AccountFindManyArgs>(
			args?: SelectSubset<T, AccountFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>

		/**
		 * Create a Account.
		 * @param {AccountCreateArgs} args - Arguments to create a Account.
		 * @example
		 * // Create one Account
		 * const Account = await prisma.account.create({
		 *   data: {
		 *     // ... data to create a Account
		 *   }
		 * })
		 *
		 **/
		create<T extends AccountCreateArgs>(
			args: SelectSubset<T, AccountCreateArgs>
		): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

		/**
		 * Create many Accounts.
		 *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
		 *     @example
		 *     // Create many Accounts
		 *     const account = await prisma.account.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends AccountCreateManyArgs>(
			args?: SelectSubset<T, AccountCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Account.
		 * @param {AccountDeleteArgs} args - Arguments to delete one Account.
		 * @example
		 * // Delete one Account
		 * const Account = await prisma.account.delete({
		 *   where: {
		 *     // ... filter to delete one Account
		 *   }
		 * })
		 *
		 **/
		delete<T extends AccountDeleteArgs>(
			args: SelectSubset<T, AccountDeleteArgs>
		): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

		/**
		 * Update one Account.
		 * @param {AccountUpdateArgs} args - Arguments to update one Account.
		 * @example
		 * // Update one Account
		 * const account = await prisma.account.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends AccountUpdateArgs>(
			args: SelectSubset<T, AccountUpdateArgs>
		): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

		/**
		 * Delete zero or more Accounts.
		 * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
		 * @example
		 * // Delete a few Accounts
		 * const { count } = await prisma.account.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends AccountDeleteManyArgs>(
			args?: SelectSubset<T, AccountDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Accounts.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Accounts
		 * const account = await prisma.account.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends AccountUpdateManyArgs>(
			args: SelectSubset<T, AccountUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Account.
		 * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
		 * @example
		 * // Update or create a Account
		 * const account = await prisma.account.upsert({
		 *   create: {
		 *     // ... data to create a Account
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Account we want to update
		 *   }
		 * })
		 **/
		upsert<T extends AccountUpsertArgs>(
			args: SelectSubset<T, AccountUpsertArgs>
		): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

		/**
		 * Count the number of Accounts.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
		 * @example
		 * // Count the number of Accounts
		 * const count = await prisma.account.count({
		 *   where: {
		 *     // ... the filter for the Accounts we want to count
		 *   }
		 * })
		 **/
		count<T extends AccountCountArgs>(
			args?: Subset<T, AccountCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], AccountCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Account.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>

		/**
		 * Group by Account.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {AccountGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends AccountGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: AccountGroupByArgs['orderBy'] }
				: { orderBy?: AccountGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Account.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__AccountClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		currentUser<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Account findUnique
	 */
	export type AccountFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Account
		 *
		 **/
		select?: AccountSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: AccountInclude | null
		/**
		 * Throw an Error if a Account can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Account to fetch.
		 *
		 **/
		where: AccountWhereUniqueInput
	}


	/**
	 * Account findFirst
	 */
	export type AccountFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Account
		 *
		 **/
		select?: AccountSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: AccountInclude | null
		/**
		 * Throw an Error if a Account can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Account to fetch.
		 *
		 **/
		where?: AccountWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Accounts to fetch.
		 *
		 **/
		orderBy?: Enumerable<AccountOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Accounts.
		 *
		 **/
		cursor?: AccountWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Accounts from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Accounts.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Accounts.
		 *
		 **/
		distinct?: Enumerable<AccountScalarFieldEnum>
	}


	/**
	 * Account findMany
	 */
	export type AccountFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Account
		 *
		 **/
		select?: AccountSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: AccountInclude | null
		/**
		 * Filter, which Accounts to fetch.
		 *
		 **/
		where?: AccountWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Accounts to fetch.
		 *
		 **/
		orderBy?: Enumerable<AccountOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Accounts.
		 *
		 **/
		cursor?: AccountWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Accounts from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Accounts.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<AccountScalarFieldEnum>
	}


	/**
	 * Account create
	 */
	export type AccountCreateArgs = {
		/**
		 * Select specific fields to fetch from the Account
		 *
		 **/
		select?: AccountSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: AccountInclude | null
		/**
		 * The data needed to create a Account.
		 *
		 **/
		data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
	}


	/**
	 * Account createMany
	 */
	export type AccountCreateManyArgs = {
		/**
		 * The data used to create many Accounts.
		 *
		 **/
		data: Enumerable<AccountCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Account update
	 */
	export type AccountUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Account
		 *
		 **/
		select?: AccountSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: AccountInclude | null
		/**
		 * The data needed to update a Account.
		 *
		 **/
		data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
		/**
		 * Choose, which Account to update.
		 *
		 **/
		where: AccountWhereUniqueInput
	}


	/**
	 * Account updateMany
	 */
	export type AccountUpdateManyArgs = {
		/**
		 * The data used to update Accounts.
		 *
		 **/
		data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
		/**
		 * Filter which Accounts to update
		 *
		 **/
		where?: AccountWhereInput
	}


	/**
	 * Account upsert
	 */
	export type AccountUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Account
		 *
		 **/
		select?: AccountSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: AccountInclude | null
		/**
		 * The filter to search for the Account to update in case it exists.
		 *
		 **/
		where: AccountWhereUniqueInput
		/**
		 * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
		 *
		 **/
		create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
		/**
		 * In case the Account was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
	}


	/**
	 * Account delete
	 */
	export type AccountDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Account
		 *
		 **/
		select?: AccountSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: AccountInclude | null
		/**
		 * Filter which Account to delete.
		 *
		 **/
		where: AccountWhereUniqueInput
	}


	/**
	 * Account deleteMany
	 */
	export type AccountDeleteManyArgs = {
		/**
		 * Filter which Accounts to delete
		 *
		 **/
		where?: AccountWhereInput
	}


	/**
	 * Account without action
	 */
	export type AccountArgs = {
		/**
		 * Select specific fields to fetch from the Account
		 *
		 **/
		select?: AccountSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: AccountInclude | null
	}



	/**
	 * Model Workspace
	 */


	export type AggregateWorkspace = {
		_count: WorkspaceCountAggregateOutputType | null
		_min: WorkspaceMinAggregateOutputType | null
		_max: WorkspaceMaxAggregateOutputType | null
	}

	export type WorkspaceMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		name: string | null
	}

	export type WorkspaceMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		name: string | null
	}

	export type WorkspaceCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		name: number
		_all: number
	}


	export type WorkspaceMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		name?: true
	}

	export type WorkspaceMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		name?: true
	}

	export type WorkspaceCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		name?: true
		_all?: true
	}

	export type WorkspaceAggregateArgs = {
		/**
		 * Filter which Workspace to aggregate.
		 *
		 **/
		where?: WorkspaceWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Workspaces to fetch.
		 *
		 **/
		orderBy?: Enumerable<WorkspaceOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: WorkspaceWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Workspaces from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Workspaces.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Workspaces
		 **/
		_count?: true | WorkspaceCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: WorkspaceMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: WorkspaceMaxAggregateInputType
	}

	export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
		[P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateWorkspace[P]>
			: GetScalarType<T[P], AggregateWorkspace[P]>
	}




	export type WorkspaceGroupByArgs = {
		where?: WorkspaceWhereInput
		orderBy?: Enumerable<WorkspaceOrderByWithAggregationInput>
		by: Array<WorkspaceScalarFieldEnum>
		having?: WorkspaceScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: WorkspaceCountAggregateInputType | true
		_min?: WorkspaceMinAggregateInputType
		_max?: WorkspaceMaxAggregateInputType
	}


	export type WorkspaceGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		name: string
		_count: WorkspaceCountAggregateOutputType | null
		_min: WorkspaceMinAggregateOutputType | null
		_max: WorkspaceMaxAggregateOutputType | null
	}

	type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = PrismaPromise<
		Array<
			PickArray<WorkspaceGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
				: GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
			}
			>
		>


	export type WorkspaceSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		name?: boolean
		users?: boolean | UserFindManyArgs
		invitations?: boolean | InvitationFindManyArgs
		subscriptions?: boolean | SubscriptionFindManyArgs
		gitOrganizations?: boolean | GitOrganizationFindManyArgs
		projects?: boolean | ProjectFindManyArgs
		_count?: boolean | WorkspaceCountOutputTypeArgs
	}

	export type WorkspaceInclude = {
		users?: boolean | UserFindManyArgs
		invitations?: boolean | InvitationFindManyArgs
		subscriptions?: boolean | SubscriptionFindManyArgs
		gitOrganizations?: boolean | GitOrganizationFindManyArgs
		projects?: boolean | ProjectFindManyArgs
		_count?: boolean | WorkspaceCountOutputTypeArgs
	}

	export type WorkspaceGetPayload<
		S extends boolean | null | undefined | WorkspaceArgs,
		U = keyof S
		> = S extends true
		? Workspace
		: S extends undefined
			? never
			: S extends WorkspaceArgs | WorkspaceFindManyArgs
				?'include' extends U
					? Workspace  & {
					[P in TrueKeys<S['include']>]:
					P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
						P extends 'invitations' ? Array < InvitationGetPayload<S['include'][P]>>  :
							P extends 'subscriptions' ? Array < SubscriptionGetPayload<S['include'][P]>>  :
								P extends 'gitOrganizations' ? Array < GitOrganizationGetPayload<S['include'][P]>>  :
									P extends 'projects' ? Array < ProjectGetPayload<S['include'][P]>>  :
										P extends '_count' ? WorkspaceCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
								P extends 'invitations' ? Array < InvitationGetPayload<S['select'][P]>>  :
									P extends 'subscriptions' ? Array < SubscriptionGetPayload<S['select'][P]>>  :
										P extends 'gitOrganizations' ? Array < GitOrganizationGetPayload<S['select'][P]>>  :
											P extends 'projects' ? Array < ProjectGetPayload<S['select'][P]>>  :
												P extends '_count' ? WorkspaceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Workspace ? Workspace[P] : never
						}
						: Workspace
				: Workspace


	type WorkspaceCountArgs = Merge<
		Omit<WorkspaceFindManyArgs, 'select' | 'include'> & {
		select?: WorkspaceCountAggregateInputType | true
	}
		>

	export interface WorkspaceDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Workspace that matches the filter.
		 * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
		 * @example
		 * // Get one Workspace
		 * const workspace = await prisma.workspace.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends WorkspaceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, WorkspaceFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Workspace'> extends True ? CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>> : CheckSelect<T, Prisma__WorkspaceClient<Workspace | null >, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null >>

		/**
		 * Find the first Workspace that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
		 * @example
		 * // Get one Workspace
		 * const workspace = await prisma.workspace.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends WorkspaceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, WorkspaceFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Workspace'> extends True ? CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>> : CheckSelect<T, Prisma__WorkspaceClient<Workspace | null >, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null >>

		/**
		 * Find zero or more Workspaces that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {WorkspaceFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Workspaces
		 * const workspaces = await prisma.workspace.findMany()
		 *
		 * // Get first 10 Workspaces
		 * const workspaces = await prisma.workspace.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends WorkspaceFindManyArgs>(
			args?: SelectSubset<T, WorkspaceFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Workspace>>, PrismaPromise<Array<WorkspaceGetPayload<T>>>>

		/**
		 * Create a Workspace.
		 * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
		 * @example
		 * // Create one Workspace
		 * const Workspace = await prisma.workspace.create({
		 *   data: {
		 *     // ... data to create a Workspace
		 *   }
		 * })
		 *
		 **/
		create<T extends WorkspaceCreateArgs>(
			args: SelectSubset<T, WorkspaceCreateArgs>
		): CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>>

		/**
		 * Create many Workspaces.
		 *     @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
		 *     @example
		 *     // Create many Workspaces
		 *     const workspace = await prisma.workspace.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends WorkspaceCreateManyArgs>(
			args?: SelectSubset<T, WorkspaceCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Workspace.
		 * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
		 * @example
		 * // Delete one Workspace
		 * const Workspace = await prisma.workspace.delete({
		 *   where: {
		 *     // ... filter to delete one Workspace
		 *   }
		 * })
		 *
		 **/
		delete<T extends WorkspaceDeleteArgs>(
			args: SelectSubset<T, WorkspaceDeleteArgs>
		): CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>>

		/**
		 * Update one Workspace.
		 * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
		 * @example
		 * // Update one Workspace
		 * const workspace = await prisma.workspace.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends WorkspaceUpdateArgs>(
			args: SelectSubset<T, WorkspaceUpdateArgs>
		): CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>>

		/**
		 * Delete zero or more Workspaces.
		 * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
		 * @example
		 * // Delete a few Workspaces
		 * const { count } = await prisma.workspace.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends WorkspaceDeleteManyArgs>(
			args?: SelectSubset<T, WorkspaceDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Workspaces.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Workspaces
		 * const workspace = await prisma.workspace.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends WorkspaceUpdateManyArgs>(
			args: SelectSubset<T, WorkspaceUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Workspace.
		 * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
		 * @example
		 * // Update or create a Workspace
		 * const workspace = await prisma.workspace.upsert({
		 *   create: {
		 *     // ... data to create a Workspace
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Workspace we want to update
		 *   }
		 * })
		 **/
		upsert<T extends WorkspaceUpsertArgs>(
			args: SelectSubset<T, WorkspaceUpsertArgs>
		): CheckSelect<T, Prisma__WorkspaceClient<Workspace>, Prisma__WorkspaceClient<WorkspaceGetPayload<T>>>

		/**
		 * Count the number of Workspaces.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
		 * @example
		 * // Count the number of Workspaces
		 * const count = await prisma.workspace.count({
		 *   where: {
		 *     // ... the filter for the Workspaces we want to count
		 *   }
		 * })
		 **/
		count<T extends WorkspaceCountArgs>(
			args?: Subset<T, WorkspaceCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Workspace.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): PrismaPromise<GetWorkspaceAggregateType<T>>

		/**
		 * Group by Workspace.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {WorkspaceGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends WorkspaceGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: WorkspaceGroupByArgs['orderBy'] }
				: { orderBy?: WorkspaceGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Workspace.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__WorkspaceClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

		invitations<T extends InvitationFindManyArgs = {}>(args?: Subset<T, InvitationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Invitation>>, PrismaPromise<Array<InvitationGetPayload<T>>>>;

		subscriptions<T extends SubscriptionFindManyArgs = {}>(args?: Subset<T, SubscriptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscription>>, PrismaPromise<Array<SubscriptionGetPayload<T>>>>;

		gitOrganizations<T extends GitOrganizationFindManyArgs = {}>(args?: Subset<T, GitOrganizationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GitOrganization>>, PrismaPromise<Array<GitOrganizationGetPayload<T>>>>;

		projects<T extends ProjectFindManyArgs = {}>(args?: Subset<T, ProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Project>>, PrismaPromise<Array<ProjectGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Workspace findUnique
	 */
	export type WorkspaceFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Workspace
		 *
		 **/
		select?: WorkspaceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: WorkspaceInclude | null
		/**
		 * Throw an Error if a Workspace can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Workspace to fetch.
		 *
		 **/
		where: WorkspaceWhereUniqueInput
	}


	/**
	 * Workspace findFirst
	 */
	export type WorkspaceFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Workspace
		 *
		 **/
		select?: WorkspaceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: WorkspaceInclude | null
		/**
		 * Throw an Error if a Workspace can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Workspace to fetch.
		 *
		 **/
		where?: WorkspaceWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Workspaces to fetch.
		 *
		 **/
		orderBy?: Enumerable<WorkspaceOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Workspaces.
		 *
		 **/
		cursor?: WorkspaceWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Workspaces from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Workspaces.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Workspaces.
		 *
		 **/
		distinct?: Enumerable<WorkspaceScalarFieldEnum>
	}


	/**
	 * Workspace findMany
	 */
	export type WorkspaceFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Workspace
		 *
		 **/
		select?: WorkspaceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: WorkspaceInclude | null
		/**
		 * Filter, which Workspaces to fetch.
		 *
		 **/
		where?: WorkspaceWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Workspaces to fetch.
		 *
		 **/
		orderBy?: Enumerable<WorkspaceOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Workspaces.
		 *
		 **/
		cursor?: WorkspaceWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Workspaces from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Workspaces.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<WorkspaceScalarFieldEnum>
	}


	/**
	 * Workspace create
	 */
	export type WorkspaceCreateArgs = {
		/**
		 * Select specific fields to fetch from the Workspace
		 *
		 **/
		select?: WorkspaceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: WorkspaceInclude | null
		/**
		 * The data needed to create a Workspace.
		 *
		 **/
		data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
	}


	/**
	 * Workspace createMany
	 */
	export type WorkspaceCreateManyArgs = {
		/**
		 * The data used to create many Workspaces.
		 *
		 **/
		data: Enumerable<WorkspaceCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Workspace update
	 */
	export type WorkspaceUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Workspace
		 *
		 **/
		select?: WorkspaceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: WorkspaceInclude | null
		/**
		 * The data needed to update a Workspace.
		 *
		 **/
		data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
		/**
		 * Choose, which Workspace to update.
		 *
		 **/
		where: WorkspaceWhereUniqueInput
	}


	/**
	 * Workspace updateMany
	 */
	export type WorkspaceUpdateManyArgs = {
		/**
		 * The data used to update Workspaces.
		 *
		 **/
		data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
		/**
		 * Filter which Workspaces to update
		 *
		 **/
		where?: WorkspaceWhereInput
	}


	/**
	 * Workspace upsert
	 */
	export type WorkspaceUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Workspace
		 *
		 **/
		select?: WorkspaceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: WorkspaceInclude | null
		/**
		 * The filter to search for the Workspace to update in case it exists.
		 *
		 **/
		where: WorkspaceWhereUniqueInput
		/**
		 * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
		 *
		 **/
		create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
		/**
		 * In case the Workspace was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
	}


	/**
	 * Workspace delete
	 */
	export type WorkspaceDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Workspace
		 *
		 **/
		select?: WorkspaceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: WorkspaceInclude | null
		/**
		 * Filter which Workspace to delete.
		 *
		 **/
		where: WorkspaceWhereUniqueInput
	}


	/**
	 * Workspace deleteMany
	 */
	export type WorkspaceDeleteManyArgs = {
		/**
		 * Filter which Workspaces to delete
		 *
		 **/
		where?: WorkspaceWhereInput
	}


	/**
	 * Workspace without action
	 */
	export type WorkspaceArgs = {
		/**
		 * Select specific fields to fetch from the Workspace
		 *
		 **/
		select?: WorkspaceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: WorkspaceInclude | null
	}



	/**
	 * Model Project
	 */


	export type AggregateProject = {
		_count: ProjectCountAggregateOutputType | null
		_min: ProjectMinAggregateOutputType | null
		_max: ProjectMaxAggregateOutputType | null
	}

	export type ProjectMinAggregateOutputType = {
		id: string | null
		name: string | null
		workspaceId: string | null
		createdAt: Date | null
		updatedAt: Date | null
		deletedAt: Date | null
	}

	export type ProjectMaxAggregateOutputType = {
		id: string | null
		name: string | null
		workspaceId: string | null
		createdAt: Date | null
		updatedAt: Date | null
		deletedAt: Date | null
	}

	export type ProjectCountAggregateOutputType = {
		id: number
		name: number
		workspaceId: number
		createdAt: number
		updatedAt: number
		deletedAt: number
		_all: number
	}


	export type ProjectMinAggregateInputType = {
		id?: true
		name?: true
		workspaceId?: true
		createdAt?: true
		updatedAt?: true
		deletedAt?: true
	}

	export type ProjectMaxAggregateInputType = {
		id?: true
		name?: true
		workspaceId?: true
		createdAt?: true
		updatedAt?: true
		deletedAt?: true
	}

	export type ProjectCountAggregateInputType = {
		id?: true
		name?: true
		workspaceId?: true
		createdAt?: true
		updatedAt?: true
		deletedAt?: true
		_all?: true
	}

	export type ProjectAggregateArgs = {
		/**
		 * Filter which Project to aggregate.
		 *
		 **/
		where?: ProjectWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Projects to fetch.
		 *
		 **/
		orderBy?: Enumerable<ProjectOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: ProjectWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Projects from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Projects.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Projects
		 **/
		_count?: true | ProjectCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ProjectMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ProjectMaxAggregateInputType
	}

	export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
		[P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateProject[P]>
			: GetScalarType<T[P], AggregateProject[P]>
	}




	export type ProjectGroupByArgs = {
		where?: ProjectWhereInput
		orderBy?: Enumerable<ProjectOrderByWithAggregationInput>
		by: Array<ProjectScalarFieldEnum>
		having?: ProjectScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ProjectCountAggregateInputType | true
		_min?: ProjectMinAggregateInputType
		_max?: ProjectMaxAggregateInputType
	}


	export type ProjectGroupByOutputType = {
		id: string
		name: string
		workspaceId: string
		createdAt: Date
		updatedAt: Date
		deletedAt: Date | null
		_count: ProjectCountAggregateOutputType | null
		_min: ProjectMinAggregateOutputType | null
		_max: ProjectMaxAggregateOutputType | null
	}

	type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = PrismaPromise<
		Array<
			PickArray<ProjectGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], ProjectGroupByOutputType[P]>
				: GetScalarType<T[P], ProjectGroupByOutputType[P]>
			}
			>
		>


	export type ProjectSelect = {
		id?: boolean
		name?: boolean
		workspaceId?: boolean
		workspace?: boolean | WorkspaceArgs
		resources?: boolean | ResourceFindManyArgs
		createdAt?: boolean
		updatedAt?: boolean
		deletedAt?: boolean
		commits?: boolean | CommitFindManyArgs
		_count?: boolean | ProjectCountOutputTypeArgs
	}

	export type ProjectInclude = {
		workspace?: boolean | WorkspaceArgs
		resources?: boolean | ResourceFindManyArgs
		commits?: boolean | CommitFindManyArgs
		_count?: boolean | ProjectCountOutputTypeArgs
	}

	export type ProjectGetPayload<
		S extends boolean | null | undefined | ProjectArgs,
		U = keyof S
		> = S extends true
		? Project
		: S extends undefined
			? never
			: S extends ProjectArgs | ProjectFindManyArgs
				?'include' extends U
					? Project  & {
					[P in TrueKeys<S['include']>]:
					P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :
						P extends 'resources' ? Array < ResourceGetPayload<S['include'][P]>>  :
							P extends 'commits' ? Array < CommitGetPayload<S['include'][P]>>  :
								P extends '_count' ? ProjectCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :
								P extends 'resources' ? Array < ResourceGetPayload<S['select'][P]>>  :
									P extends 'commits' ? Array < CommitGetPayload<S['select'][P]>>  :
										P extends '_count' ? ProjectCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Project ? Project[P] : never
						}
						: Project
				: Project


	type ProjectCountArgs = Merge<
		Omit<ProjectFindManyArgs, 'select' | 'include'> & {
		select?: ProjectCountAggregateInputType | true
	}
		>

	export interface ProjectDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Project that matches the filter.
		 * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
		 * @example
		 * // Get one Project
		 * const project = await prisma.project.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends ProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, ProjectFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Project'> extends True ? CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>> : CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>

		/**
		 * Find the first Project that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProjectFindFirstArgs} args - Arguments to find a Project
		 * @example
		 * // Get one Project
		 * const project = await prisma.project.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends ProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, ProjectFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Project'> extends True ? CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>> : CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>

		/**
		 * Find zero or more Projects that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Projects
		 * const projects = await prisma.project.findMany()
		 *
		 * // Get first 10 Projects
		 * const projects = await prisma.project.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends ProjectFindManyArgs>(
			args?: SelectSubset<T, ProjectFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Project>>, PrismaPromise<Array<ProjectGetPayload<T>>>>

		/**
		 * Create a Project.
		 * @param {ProjectCreateArgs} args - Arguments to create a Project.
		 * @example
		 * // Create one Project
		 * const Project = await prisma.project.create({
		 *   data: {
		 *     // ... data to create a Project
		 *   }
		 * })
		 *
		 **/
		create<T extends ProjectCreateArgs>(
			args: SelectSubset<T, ProjectCreateArgs>
		): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

		/**
		 * Create many Projects.
		 *     @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
		 *     @example
		 *     // Create many Projects
		 *     const project = await prisma.project.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends ProjectCreateManyArgs>(
			args?: SelectSubset<T, ProjectCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Project.
		 * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
		 * @example
		 * // Delete one Project
		 * const Project = await prisma.project.delete({
		 *   where: {
		 *     // ... filter to delete one Project
		 *   }
		 * })
		 *
		 **/
		delete<T extends ProjectDeleteArgs>(
			args: SelectSubset<T, ProjectDeleteArgs>
		): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

		/**
		 * Update one Project.
		 * @param {ProjectUpdateArgs} args - Arguments to update one Project.
		 * @example
		 * // Update one Project
		 * const project = await prisma.project.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends ProjectUpdateArgs>(
			args: SelectSubset<T, ProjectUpdateArgs>
		): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

		/**
		 * Delete zero or more Projects.
		 * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
		 * @example
		 * // Delete a few Projects
		 * const { count } = await prisma.project.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends ProjectDeleteManyArgs>(
			args?: SelectSubset<T, ProjectDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Projects.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Projects
		 * const project = await prisma.project.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends ProjectUpdateManyArgs>(
			args: SelectSubset<T, ProjectUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Project.
		 * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
		 * @example
		 * // Update or create a Project
		 * const project = await prisma.project.upsert({
		 *   create: {
		 *     // ... data to create a Project
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Project we want to update
		 *   }
		 * })
		 **/
		upsert<T extends ProjectUpsertArgs>(
			args: SelectSubset<T, ProjectUpsertArgs>
		): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

		/**
		 * Count the number of Projects.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
		 * @example
		 * // Count the number of Projects
		 * const count = await prisma.project.count({
		 *   where: {
		 *     // ... the filter for the Projects we want to count
		 *   }
		 * })
		 **/
		count<T extends ProjectCountArgs>(
			args?: Subset<T, ProjectCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ProjectCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Project.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): PrismaPromise<GetProjectAggregateType<T>>

		/**
		 * Group by Project.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ProjectGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ProjectGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ProjectGroupByArgs['orderBy'] }
				: { orderBy?: ProjectGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Project.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__ProjectClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null >, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null >>;

		resources<T extends ResourceFindManyArgs = {}>(args?: Subset<T, ResourceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Resource>>, PrismaPromise<Array<ResourceGetPayload<T>>>>;

		commits<T extends CommitFindManyArgs = {}>(args?: Subset<T, CommitFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Commit>>, PrismaPromise<Array<CommitGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Project findUnique
	 */
	export type ProjectFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Project
		 *
		 **/
		select?: ProjectSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ProjectInclude | null
		/**
		 * Throw an Error if a Project can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Project to fetch.
		 *
		 **/
		where: ProjectWhereUniqueInput
	}


	/**
	 * Project findFirst
	 */
	export type ProjectFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Project
		 *
		 **/
		select?: ProjectSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ProjectInclude | null
		/**
		 * Throw an Error if a Project can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Project to fetch.
		 *
		 **/
		where?: ProjectWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Projects to fetch.
		 *
		 **/
		orderBy?: Enumerable<ProjectOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Projects.
		 *
		 **/
		cursor?: ProjectWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Projects from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Projects.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Projects.
		 *
		 **/
		distinct?: Enumerable<ProjectScalarFieldEnum>
	}


	/**
	 * Project findMany
	 */
	export type ProjectFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Project
		 *
		 **/
		select?: ProjectSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ProjectInclude | null
		/**
		 * Filter, which Projects to fetch.
		 *
		 **/
		where?: ProjectWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Projects to fetch.
		 *
		 **/
		orderBy?: Enumerable<ProjectOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Projects.
		 *
		 **/
		cursor?: ProjectWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Projects from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Projects.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<ProjectScalarFieldEnum>
	}


	/**
	 * Project create
	 */
	export type ProjectCreateArgs = {
		/**
		 * Select specific fields to fetch from the Project
		 *
		 **/
		select?: ProjectSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ProjectInclude | null
		/**
		 * The data needed to create a Project.
		 *
		 **/
		data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
	}


	/**
	 * Project createMany
	 */
	export type ProjectCreateManyArgs = {
		/**
		 * The data used to create many Projects.
		 *
		 **/
		data: Enumerable<ProjectCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Project update
	 */
	export type ProjectUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Project
		 *
		 **/
		select?: ProjectSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ProjectInclude | null
		/**
		 * The data needed to update a Project.
		 *
		 **/
		data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
		/**
		 * Choose, which Project to update.
		 *
		 **/
		where: ProjectWhereUniqueInput
	}


	/**
	 * Project updateMany
	 */
	export type ProjectUpdateManyArgs = {
		/**
		 * The data used to update Projects.
		 *
		 **/
		data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
		/**
		 * Filter which Projects to update
		 *
		 **/
		where?: ProjectWhereInput
	}


	/**
	 * Project upsert
	 */
	export type ProjectUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Project
		 *
		 **/
		select?: ProjectSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ProjectInclude | null
		/**
		 * The filter to search for the Project to update in case it exists.
		 *
		 **/
		where: ProjectWhereUniqueInput
		/**
		 * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
		 *
		 **/
		create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
		/**
		 * In case the Project was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
	}


	/**
	 * Project delete
	 */
	export type ProjectDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Project
		 *
		 **/
		select?: ProjectSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ProjectInclude | null
		/**
		 * Filter which Project to delete.
		 *
		 **/
		where: ProjectWhereUniqueInput
	}


	/**
	 * Project deleteMany
	 */
	export type ProjectDeleteManyArgs = {
		/**
		 * Filter which Projects to delete
		 *
		 **/
		where?: ProjectWhereInput
	}


	/**
	 * Project without action
	 */
	export type ProjectArgs = {
		/**
		 * Select specific fields to fetch from the Project
		 *
		 **/
		select?: ProjectSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ProjectInclude | null
	}



	/**
	 * Model GitOrganization
	 */


	export type AggregateGitOrganization = {
		_count: GitOrganizationCountAggregateOutputType | null
		_min: GitOrganizationMinAggregateOutputType | null
		_max: GitOrganizationMaxAggregateOutputType | null
	}

	export type GitOrganizationMinAggregateOutputType = {
		id: string | null
		provider: EnumGitProvider | null
		name: string | null
		installationId: string | null
		createdAt: Date | null
		updatedAt: Date | null
		workspaceId: string | null
		type: EnumGitOrganizationType | null
	}

	export type GitOrganizationMaxAggregateOutputType = {
		id: string | null
		provider: EnumGitProvider | null
		name: string | null
		installationId: string | null
		createdAt: Date | null
		updatedAt: Date | null
		workspaceId: string | null
		type: EnumGitOrganizationType | null
	}

	export type GitOrganizationCountAggregateOutputType = {
		id: number
		provider: number
		name: number
		installationId: number
		createdAt: number
		updatedAt: number
		workspaceId: number
		type: number
		_all: number
	}


	export type GitOrganizationMinAggregateInputType = {
		id?: true
		provider?: true
		name?: true
		installationId?: true
		createdAt?: true
		updatedAt?: true
		workspaceId?: true
		type?: true
	}

	export type GitOrganizationMaxAggregateInputType = {
		id?: true
		provider?: true
		name?: true
		installationId?: true
		createdAt?: true
		updatedAt?: true
		workspaceId?: true
		type?: true
	}

	export type GitOrganizationCountAggregateInputType = {
		id?: true
		provider?: true
		name?: true
		installationId?: true
		createdAt?: true
		updatedAt?: true
		workspaceId?: true
		type?: true
		_all?: true
	}

	export type GitOrganizationAggregateArgs = {
		/**
		 * Filter which GitOrganization to aggregate.
		 *
		 **/
		where?: GitOrganizationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of GitOrganizations to fetch.
		 *
		 **/
		orderBy?: Enumerable<GitOrganizationOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: GitOrganizationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` GitOrganizations from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` GitOrganizations.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned GitOrganizations
		 **/
		_count?: true | GitOrganizationCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: GitOrganizationMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: GitOrganizationMaxAggregateInputType
	}

	export type GetGitOrganizationAggregateType<T extends GitOrganizationAggregateArgs> = {
		[P in keyof T & keyof AggregateGitOrganization]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateGitOrganization[P]>
			: GetScalarType<T[P], AggregateGitOrganization[P]>
	}




	export type GitOrganizationGroupByArgs = {
		where?: GitOrganizationWhereInput
		orderBy?: Enumerable<GitOrganizationOrderByWithAggregationInput>
		by: Array<GitOrganizationScalarFieldEnum>
		having?: GitOrganizationScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: GitOrganizationCountAggregateInputType | true
		_min?: GitOrganizationMinAggregateInputType
		_max?: GitOrganizationMaxAggregateInputType
	}


	export type GitOrganizationGroupByOutputType = {
		id: string
		provider: EnumGitProvider
		name: string
		installationId: string
		createdAt: Date
		updatedAt: Date
		workspaceId: string
		type: EnumGitOrganizationType | null
		_count: GitOrganizationCountAggregateOutputType | null
		_min: GitOrganizationMinAggregateOutputType | null
		_max: GitOrganizationMaxAggregateOutputType | null
	}

	type GetGitOrganizationGroupByPayload<T extends GitOrganizationGroupByArgs> = PrismaPromise<
		Array<
			PickArray<GitOrganizationGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof GitOrganizationGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], GitOrganizationGroupByOutputType[P]>
				: GetScalarType<T[P], GitOrganizationGroupByOutputType[P]>
			}
			>
		>


	export type GitOrganizationSelect = {
		id?: boolean
		provider?: boolean
		name?: boolean
		installationId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		workspaceId?: boolean
		type?: boolean
		workspace?: boolean | WorkspaceArgs
		gitRepositories?: boolean | GitRepositoryFindManyArgs
		_count?: boolean | GitOrganizationCountOutputTypeArgs
	}

	export type GitOrganizationInclude = {
		workspace?: boolean | WorkspaceArgs
		gitRepositories?: boolean | GitRepositoryFindManyArgs
		_count?: boolean | GitOrganizationCountOutputTypeArgs
	}

	export type GitOrganizationGetPayload<
		S extends boolean | null | undefined | GitOrganizationArgs,
		U = keyof S
		> = S extends true
		? GitOrganization
		: S extends undefined
			? never
			: S extends GitOrganizationArgs | GitOrganizationFindManyArgs
				?'include' extends U
					? GitOrganization  & {
					[P in TrueKeys<S['include']>]:
					P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :
						P extends 'gitRepositories' ? Array < GitRepositoryGetPayload<S['include'][P]>>  :
							P extends '_count' ? GitOrganizationCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :
								P extends 'gitRepositories' ? Array < GitRepositoryGetPayload<S['select'][P]>>  :
									P extends '_count' ? GitOrganizationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof GitOrganization ? GitOrganization[P] : never
						}
						: GitOrganization
				: GitOrganization


	type GitOrganizationCountArgs = Merge<
		Omit<GitOrganizationFindManyArgs, 'select' | 'include'> & {
		select?: GitOrganizationCountAggregateInputType | true
	}
		>

	export interface GitOrganizationDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one GitOrganization that matches the filter.
		 * @param {GitOrganizationFindUniqueArgs} args - Arguments to find a GitOrganization
		 * @example
		 * // Get one GitOrganization
		 * const gitOrganization = await prisma.gitOrganization.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends GitOrganizationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, GitOrganizationFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GitOrganization'> extends True ? CheckSelect<T, Prisma__GitOrganizationClient<GitOrganization>, Prisma__GitOrganizationClient<GitOrganizationGetPayload<T>>> : CheckSelect<T, Prisma__GitOrganizationClient<GitOrganization | null >, Prisma__GitOrganizationClient<GitOrganizationGetPayload<T> | null >>

		/**
		 * Find the first GitOrganization that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitOrganizationFindFirstArgs} args - Arguments to find a GitOrganization
		 * @example
		 * // Get one GitOrganization
		 * const gitOrganization = await prisma.gitOrganization.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends GitOrganizationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, GitOrganizationFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GitOrganization'> extends True ? CheckSelect<T, Prisma__GitOrganizationClient<GitOrganization>, Prisma__GitOrganizationClient<GitOrganizationGetPayload<T>>> : CheckSelect<T, Prisma__GitOrganizationClient<GitOrganization | null >, Prisma__GitOrganizationClient<GitOrganizationGetPayload<T> | null >>

		/**
		 * Find zero or more GitOrganizations that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitOrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all GitOrganizations
		 * const gitOrganizations = await prisma.gitOrganization.findMany()
		 *
		 * // Get first 10 GitOrganizations
		 * const gitOrganizations = await prisma.gitOrganization.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const gitOrganizationWithIdOnly = await prisma.gitOrganization.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends GitOrganizationFindManyArgs>(
			args?: SelectSubset<T, GitOrganizationFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<GitOrganization>>, PrismaPromise<Array<GitOrganizationGetPayload<T>>>>

		/**
		 * Create a GitOrganization.
		 * @param {GitOrganizationCreateArgs} args - Arguments to create a GitOrganization.
		 * @example
		 * // Create one GitOrganization
		 * const GitOrganization = await prisma.gitOrganization.create({
		 *   data: {
		 *     // ... data to create a GitOrganization
		 *   }
		 * })
		 *
		 **/
		create<T extends GitOrganizationCreateArgs>(
			args: SelectSubset<T, GitOrganizationCreateArgs>
		): CheckSelect<T, Prisma__GitOrganizationClient<GitOrganization>, Prisma__GitOrganizationClient<GitOrganizationGetPayload<T>>>

		/**
		 * Create many GitOrganizations.
		 *     @param {GitOrganizationCreateManyArgs} args - Arguments to create many GitOrganizations.
		 *     @example
		 *     // Create many GitOrganizations
		 *     const gitOrganization = await prisma.gitOrganization.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends GitOrganizationCreateManyArgs>(
			args?: SelectSubset<T, GitOrganizationCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a GitOrganization.
		 * @param {GitOrganizationDeleteArgs} args - Arguments to delete one GitOrganization.
		 * @example
		 * // Delete one GitOrganization
		 * const GitOrganization = await prisma.gitOrganization.delete({
		 *   where: {
		 *     // ... filter to delete one GitOrganization
		 *   }
		 * })
		 *
		 **/
		delete<T extends GitOrganizationDeleteArgs>(
			args: SelectSubset<T, GitOrganizationDeleteArgs>
		): CheckSelect<T, Prisma__GitOrganizationClient<GitOrganization>, Prisma__GitOrganizationClient<GitOrganizationGetPayload<T>>>

		/**
		 * Update one GitOrganization.
		 * @param {GitOrganizationUpdateArgs} args - Arguments to update one GitOrganization.
		 * @example
		 * // Update one GitOrganization
		 * const gitOrganization = await prisma.gitOrganization.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends GitOrganizationUpdateArgs>(
			args: SelectSubset<T, GitOrganizationUpdateArgs>
		): CheckSelect<T, Prisma__GitOrganizationClient<GitOrganization>, Prisma__GitOrganizationClient<GitOrganizationGetPayload<T>>>

		/**
		 * Delete zero or more GitOrganizations.
		 * @param {GitOrganizationDeleteManyArgs} args - Arguments to filter GitOrganizations to delete.
		 * @example
		 * // Delete a few GitOrganizations
		 * const { count } = await prisma.gitOrganization.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends GitOrganizationDeleteManyArgs>(
			args?: SelectSubset<T, GitOrganizationDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more GitOrganizations.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitOrganizationUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many GitOrganizations
		 * const gitOrganization = await prisma.gitOrganization.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends GitOrganizationUpdateManyArgs>(
			args: SelectSubset<T, GitOrganizationUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one GitOrganization.
		 * @param {GitOrganizationUpsertArgs} args - Arguments to update or create a GitOrganization.
		 * @example
		 * // Update or create a GitOrganization
		 * const gitOrganization = await prisma.gitOrganization.upsert({
		 *   create: {
		 *     // ... data to create a GitOrganization
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the GitOrganization we want to update
		 *   }
		 * })
		 **/
		upsert<T extends GitOrganizationUpsertArgs>(
			args: SelectSubset<T, GitOrganizationUpsertArgs>
		): CheckSelect<T, Prisma__GitOrganizationClient<GitOrganization>, Prisma__GitOrganizationClient<GitOrganizationGetPayload<T>>>

		/**
		 * Count the number of GitOrganizations.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitOrganizationCountArgs} args - Arguments to filter GitOrganizations to count.
		 * @example
		 * // Count the number of GitOrganizations
		 * const count = await prisma.gitOrganization.count({
		 *   where: {
		 *     // ... the filter for the GitOrganizations we want to count
		 *   }
		 * })
		 **/
		count<T extends GitOrganizationCountArgs>(
			args?: Subset<T, GitOrganizationCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], GitOrganizationCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a GitOrganization.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitOrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends GitOrganizationAggregateArgs>(args: Subset<T, GitOrganizationAggregateArgs>): PrismaPromise<GetGitOrganizationAggregateType<T>>

		/**
		 * Group by GitOrganization.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitOrganizationGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends GitOrganizationGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: GitOrganizationGroupByArgs['orderBy'] }
				: { orderBy?: GitOrganizationGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, GitOrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGitOrganizationGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for GitOrganization.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__GitOrganizationClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null >, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null >>;

		gitRepositories<T extends GitRepositoryFindManyArgs = {}>(args?: Subset<T, GitRepositoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GitRepository>>, PrismaPromise<Array<GitRepositoryGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * GitOrganization findUnique
	 */
	export type GitOrganizationFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the GitOrganization
		 *
		 **/
		select?: GitOrganizationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitOrganizationInclude | null
		/**
		 * Throw an Error if a GitOrganization can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which GitOrganization to fetch.
		 *
		 **/
		where: GitOrganizationWhereUniqueInput
	}


	/**
	 * GitOrganization findFirst
	 */
	export type GitOrganizationFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the GitOrganization
		 *
		 **/
		select?: GitOrganizationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitOrganizationInclude | null
		/**
		 * Throw an Error if a GitOrganization can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which GitOrganization to fetch.
		 *
		 **/
		where?: GitOrganizationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of GitOrganizations to fetch.
		 *
		 **/
		orderBy?: Enumerable<GitOrganizationOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for GitOrganizations.
		 *
		 **/
		cursor?: GitOrganizationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` GitOrganizations from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` GitOrganizations.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of GitOrganizations.
		 *
		 **/
		distinct?: Enumerable<GitOrganizationScalarFieldEnum>
	}


	/**
	 * GitOrganization findMany
	 */
	export type GitOrganizationFindManyArgs = {
		/**
		 * Select specific fields to fetch from the GitOrganization
		 *
		 **/
		select?: GitOrganizationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitOrganizationInclude | null
		/**
		 * Filter, which GitOrganizations to fetch.
		 *
		 **/
		where?: GitOrganizationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of GitOrganizations to fetch.
		 *
		 **/
		orderBy?: Enumerable<GitOrganizationOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing GitOrganizations.
		 *
		 **/
		cursor?: GitOrganizationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` GitOrganizations from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` GitOrganizations.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<GitOrganizationScalarFieldEnum>
	}


	/**
	 * GitOrganization create
	 */
	export type GitOrganizationCreateArgs = {
		/**
		 * Select specific fields to fetch from the GitOrganization
		 *
		 **/
		select?: GitOrganizationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitOrganizationInclude | null
		/**
		 * The data needed to create a GitOrganization.
		 *
		 **/
		data: XOR<GitOrganizationCreateInput, GitOrganizationUncheckedCreateInput>
	}


	/**
	 * GitOrganization createMany
	 */
	export type GitOrganizationCreateManyArgs = {
		/**
		 * The data used to create many GitOrganizations.
		 *
		 **/
		data: Enumerable<GitOrganizationCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * GitOrganization update
	 */
	export type GitOrganizationUpdateArgs = {
		/**
		 * Select specific fields to fetch from the GitOrganization
		 *
		 **/
		select?: GitOrganizationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitOrganizationInclude | null
		/**
		 * The data needed to update a GitOrganization.
		 *
		 **/
		data: XOR<GitOrganizationUpdateInput, GitOrganizationUncheckedUpdateInput>
		/**
		 * Choose, which GitOrganization to update.
		 *
		 **/
		where: GitOrganizationWhereUniqueInput
	}


	/**
	 * GitOrganization updateMany
	 */
	export type GitOrganizationUpdateManyArgs = {
		/**
		 * The data used to update GitOrganizations.
		 *
		 **/
		data: XOR<GitOrganizationUpdateManyMutationInput, GitOrganizationUncheckedUpdateManyInput>
		/**
		 * Filter which GitOrganizations to update
		 *
		 **/
		where?: GitOrganizationWhereInput
	}


	/**
	 * GitOrganization upsert
	 */
	export type GitOrganizationUpsertArgs = {
		/**
		 * Select specific fields to fetch from the GitOrganization
		 *
		 **/
		select?: GitOrganizationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitOrganizationInclude | null
		/**
		 * The filter to search for the GitOrganization to update in case it exists.
		 *
		 **/
		where: GitOrganizationWhereUniqueInput
		/**
		 * In case the GitOrganization found by the `where` argument doesn't exist, create a new GitOrganization with this data.
		 *
		 **/
		create: XOR<GitOrganizationCreateInput, GitOrganizationUncheckedCreateInput>
		/**
		 * In case the GitOrganization was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<GitOrganizationUpdateInput, GitOrganizationUncheckedUpdateInput>
	}


	/**
	 * GitOrganization delete
	 */
	export type GitOrganizationDeleteArgs = {
		/**
		 * Select specific fields to fetch from the GitOrganization
		 *
		 **/
		select?: GitOrganizationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitOrganizationInclude | null
		/**
		 * Filter which GitOrganization to delete.
		 *
		 **/
		where: GitOrganizationWhereUniqueInput
	}


	/**
	 * GitOrganization deleteMany
	 */
	export type GitOrganizationDeleteManyArgs = {
		/**
		 * Filter which GitOrganizations to delete
		 *
		 **/
		where?: GitOrganizationWhereInput
	}


	/**
	 * GitOrganization without action
	 */
	export type GitOrganizationArgs = {
		/**
		 * Select specific fields to fetch from the GitOrganization
		 *
		 **/
		select?: GitOrganizationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitOrganizationInclude | null
	}



	/**
	 * Model GitRepository
	 */


	export type AggregateGitRepository = {
		_count: GitRepositoryCountAggregateOutputType | null
		_min: GitRepositoryMinAggregateOutputType | null
		_max: GitRepositoryMaxAggregateOutputType | null
	}

	export type GitRepositoryMinAggregateOutputType = {
		id: string | null
		name: string | null
		createdAt: Date | null
		updatedAt: Date | null
		gitOrganizationId: string | null
	}

	export type GitRepositoryMaxAggregateOutputType = {
		id: string | null
		name: string | null
		createdAt: Date | null
		updatedAt: Date | null
		gitOrganizationId: string | null
	}

	export type GitRepositoryCountAggregateOutputType = {
		id: number
		name: number
		createdAt: number
		updatedAt: number
		gitOrganizationId: number
		_all: number
	}


	export type GitRepositoryMinAggregateInputType = {
		id?: true
		name?: true
		createdAt?: true
		updatedAt?: true
		gitOrganizationId?: true
	}

	export type GitRepositoryMaxAggregateInputType = {
		id?: true
		name?: true
		createdAt?: true
		updatedAt?: true
		gitOrganizationId?: true
	}

	export type GitRepositoryCountAggregateInputType = {
		id?: true
		name?: true
		createdAt?: true
		updatedAt?: true
		gitOrganizationId?: true
		_all?: true
	}

	export type GitRepositoryAggregateArgs = {
		/**
		 * Filter which GitRepository to aggregate.
		 *
		 **/
		where?: GitRepositoryWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of GitRepositories to fetch.
		 *
		 **/
		orderBy?: Enumerable<GitRepositoryOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: GitRepositoryWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` GitRepositories from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` GitRepositories.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned GitRepositories
		 **/
		_count?: true | GitRepositoryCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: GitRepositoryMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: GitRepositoryMaxAggregateInputType
	}

	export type GetGitRepositoryAggregateType<T extends GitRepositoryAggregateArgs> = {
		[P in keyof T & keyof AggregateGitRepository]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateGitRepository[P]>
			: GetScalarType<T[P], AggregateGitRepository[P]>
	}




	export type GitRepositoryGroupByArgs = {
		where?: GitRepositoryWhereInput
		orderBy?: Enumerable<GitRepositoryOrderByWithAggregationInput>
		by: Array<GitRepositoryScalarFieldEnum>
		having?: GitRepositoryScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: GitRepositoryCountAggregateInputType | true
		_min?: GitRepositoryMinAggregateInputType
		_max?: GitRepositoryMaxAggregateInputType
	}


	export type GitRepositoryGroupByOutputType = {
		id: string
		name: string
		createdAt: Date
		updatedAt: Date
		gitOrganizationId: string
		_count: GitRepositoryCountAggregateOutputType | null
		_min: GitRepositoryMinAggregateOutputType | null
		_max: GitRepositoryMaxAggregateOutputType | null
	}

	type GetGitRepositoryGroupByPayload<T extends GitRepositoryGroupByArgs> = PrismaPromise<
		Array<
			PickArray<GitRepositoryGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof GitRepositoryGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], GitRepositoryGroupByOutputType[P]>
				: GetScalarType<T[P], GitRepositoryGroupByOutputType[P]>
			}
			>
		>


	export type GitRepositorySelect = {
		id?: boolean
		name?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		gitOrganizationId?: boolean
		resources?: boolean | ResourceFindManyArgs
		gitOrganization?: boolean | GitOrganizationArgs
		_count?: boolean | GitRepositoryCountOutputTypeArgs
	}

	export type GitRepositoryInclude = {
		resources?: boolean | ResourceFindManyArgs
		gitOrganization?: boolean | GitOrganizationArgs
		_count?: boolean | GitRepositoryCountOutputTypeArgs
	}

	export type GitRepositoryGetPayload<
		S extends boolean | null | undefined | GitRepositoryArgs,
		U = keyof S
		> = S extends true
		? GitRepository
		: S extends undefined
			? never
			: S extends GitRepositoryArgs | GitRepositoryFindManyArgs
				?'include' extends U
					? GitRepository  & {
					[P in TrueKeys<S['include']>]:
					P extends 'resources' ? Array < ResourceGetPayload<S['include'][P]>>  :
						P extends 'gitOrganization' ? GitOrganizationGetPayload<S['include'][P]> :
							P extends '_count' ? GitRepositoryCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'resources' ? Array < ResourceGetPayload<S['select'][P]>>  :
								P extends 'gitOrganization' ? GitOrganizationGetPayload<S['select'][P]> :
									P extends '_count' ? GitRepositoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof GitRepository ? GitRepository[P] : never
						}
						: GitRepository
				: GitRepository


	type GitRepositoryCountArgs = Merge<
		Omit<GitRepositoryFindManyArgs, 'select' | 'include'> & {
		select?: GitRepositoryCountAggregateInputType | true
	}
		>

	export interface GitRepositoryDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one GitRepository that matches the filter.
		 * @param {GitRepositoryFindUniqueArgs} args - Arguments to find a GitRepository
		 * @example
		 * // Get one GitRepository
		 * const gitRepository = await prisma.gitRepository.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends GitRepositoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, GitRepositoryFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GitRepository'> extends True ? CheckSelect<T, Prisma__GitRepositoryClient<GitRepository>, Prisma__GitRepositoryClient<GitRepositoryGetPayload<T>>> : CheckSelect<T, Prisma__GitRepositoryClient<GitRepository | null >, Prisma__GitRepositoryClient<GitRepositoryGetPayload<T> | null >>

		/**
		 * Find the first GitRepository that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitRepositoryFindFirstArgs} args - Arguments to find a GitRepository
		 * @example
		 * // Get one GitRepository
		 * const gitRepository = await prisma.gitRepository.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends GitRepositoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, GitRepositoryFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GitRepository'> extends True ? CheckSelect<T, Prisma__GitRepositoryClient<GitRepository>, Prisma__GitRepositoryClient<GitRepositoryGetPayload<T>>> : CheckSelect<T, Prisma__GitRepositoryClient<GitRepository | null >, Prisma__GitRepositoryClient<GitRepositoryGetPayload<T> | null >>

		/**
		 * Find zero or more GitRepositories that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitRepositoryFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all GitRepositories
		 * const gitRepositories = await prisma.gitRepository.findMany()
		 *
		 * // Get first 10 GitRepositories
		 * const gitRepositories = await prisma.gitRepository.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const gitRepositoryWithIdOnly = await prisma.gitRepository.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends GitRepositoryFindManyArgs>(
			args?: SelectSubset<T, GitRepositoryFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<GitRepository>>, PrismaPromise<Array<GitRepositoryGetPayload<T>>>>

		/**
		 * Create a GitRepository.
		 * @param {GitRepositoryCreateArgs} args - Arguments to create a GitRepository.
		 * @example
		 * // Create one GitRepository
		 * const GitRepository = await prisma.gitRepository.create({
		 *   data: {
		 *     // ... data to create a GitRepository
		 *   }
		 * })
		 *
		 **/
		create<T extends GitRepositoryCreateArgs>(
			args: SelectSubset<T, GitRepositoryCreateArgs>
		): CheckSelect<T, Prisma__GitRepositoryClient<GitRepository>, Prisma__GitRepositoryClient<GitRepositoryGetPayload<T>>>

		/**
		 * Create many GitRepositories.
		 *     @param {GitRepositoryCreateManyArgs} args - Arguments to create many GitRepositories.
		 *     @example
		 *     // Create many GitRepositories
		 *     const gitRepository = await prisma.gitRepository.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends GitRepositoryCreateManyArgs>(
			args?: SelectSubset<T, GitRepositoryCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a GitRepository.
		 * @param {GitRepositoryDeleteArgs} args - Arguments to delete one GitRepository.
		 * @example
		 * // Delete one GitRepository
		 * const GitRepository = await prisma.gitRepository.delete({
		 *   where: {
		 *     // ... filter to delete one GitRepository
		 *   }
		 * })
		 *
		 **/
		delete<T extends GitRepositoryDeleteArgs>(
			args: SelectSubset<T, GitRepositoryDeleteArgs>
		): CheckSelect<T, Prisma__GitRepositoryClient<GitRepository>, Prisma__GitRepositoryClient<GitRepositoryGetPayload<T>>>

		/**
		 * Update one GitRepository.
		 * @param {GitRepositoryUpdateArgs} args - Arguments to update one GitRepository.
		 * @example
		 * // Update one GitRepository
		 * const gitRepository = await prisma.gitRepository.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends GitRepositoryUpdateArgs>(
			args: SelectSubset<T, GitRepositoryUpdateArgs>
		): CheckSelect<T, Prisma__GitRepositoryClient<GitRepository>, Prisma__GitRepositoryClient<GitRepositoryGetPayload<T>>>

		/**
		 * Delete zero or more GitRepositories.
		 * @param {GitRepositoryDeleteManyArgs} args - Arguments to filter GitRepositories to delete.
		 * @example
		 * // Delete a few GitRepositories
		 * const { count } = await prisma.gitRepository.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends GitRepositoryDeleteManyArgs>(
			args?: SelectSubset<T, GitRepositoryDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more GitRepositories.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitRepositoryUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many GitRepositories
		 * const gitRepository = await prisma.gitRepository.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends GitRepositoryUpdateManyArgs>(
			args: SelectSubset<T, GitRepositoryUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one GitRepository.
		 * @param {GitRepositoryUpsertArgs} args - Arguments to update or create a GitRepository.
		 * @example
		 * // Update or create a GitRepository
		 * const gitRepository = await prisma.gitRepository.upsert({
		 *   create: {
		 *     // ... data to create a GitRepository
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the GitRepository we want to update
		 *   }
		 * })
		 **/
		upsert<T extends GitRepositoryUpsertArgs>(
			args: SelectSubset<T, GitRepositoryUpsertArgs>
		): CheckSelect<T, Prisma__GitRepositoryClient<GitRepository>, Prisma__GitRepositoryClient<GitRepositoryGetPayload<T>>>

		/**
		 * Count the number of GitRepositories.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitRepositoryCountArgs} args - Arguments to filter GitRepositories to count.
		 * @example
		 * // Count the number of GitRepositories
		 * const count = await prisma.gitRepository.count({
		 *   where: {
		 *     // ... the filter for the GitRepositories we want to count
		 *   }
		 * })
		 **/
		count<T extends GitRepositoryCountArgs>(
			args?: Subset<T, GitRepositoryCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], GitRepositoryCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a GitRepository.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitRepositoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends GitRepositoryAggregateArgs>(args: Subset<T, GitRepositoryAggregateArgs>): PrismaPromise<GetGitRepositoryAggregateType<T>>

		/**
		 * Group by GitRepository.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {GitRepositoryGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends GitRepositoryGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: GitRepositoryGroupByArgs['orderBy'] }
				: { orderBy?: GitRepositoryGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, GitRepositoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGitRepositoryGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for GitRepository.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__GitRepositoryClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		resources<T extends ResourceFindManyArgs = {}>(args?: Subset<T, ResourceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Resource>>, PrismaPromise<Array<ResourceGetPayload<T>>>>;

		gitOrganization<T extends GitOrganizationArgs = {}>(args?: Subset<T, GitOrganizationArgs>): CheckSelect<T, Prisma__GitOrganizationClient<GitOrganization | null >, Prisma__GitOrganizationClient<GitOrganizationGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * GitRepository findUnique
	 */
	export type GitRepositoryFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the GitRepository
		 *
		 **/
		select?: GitRepositorySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitRepositoryInclude | null
		/**
		 * Throw an Error if a GitRepository can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which GitRepository to fetch.
		 *
		 **/
		where: GitRepositoryWhereUniqueInput
	}


	/**
	 * GitRepository findFirst
	 */
	export type GitRepositoryFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the GitRepository
		 *
		 **/
		select?: GitRepositorySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitRepositoryInclude | null
		/**
		 * Throw an Error if a GitRepository can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which GitRepository to fetch.
		 *
		 **/
		where?: GitRepositoryWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of GitRepositories to fetch.
		 *
		 **/
		orderBy?: Enumerable<GitRepositoryOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for GitRepositories.
		 *
		 **/
		cursor?: GitRepositoryWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` GitRepositories from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` GitRepositories.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of GitRepositories.
		 *
		 **/
		distinct?: Enumerable<GitRepositoryScalarFieldEnum>
	}


	/**
	 * GitRepository findMany
	 */
	export type GitRepositoryFindManyArgs = {
		/**
		 * Select specific fields to fetch from the GitRepository
		 *
		 **/
		select?: GitRepositorySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitRepositoryInclude | null
		/**
		 * Filter, which GitRepositories to fetch.
		 *
		 **/
		where?: GitRepositoryWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of GitRepositories to fetch.
		 *
		 **/
		orderBy?: Enumerable<GitRepositoryOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing GitRepositories.
		 *
		 **/
		cursor?: GitRepositoryWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` GitRepositories from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` GitRepositories.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<GitRepositoryScalarFieldEnum>
	}


	/**
	 * GitRepository create
	 */
	export type GitRepositoryCreateArgs = {
		/**
		 * Select specific fields to fetch from the GitRepository
		 *
		 **/
		select?: GitRepositorySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitRepositoryInclude | null
		/**
		 * The data needed to create a GitRepository.
		 *
		 **/
		data: XOR<GitRepositoryCreateInput, GitRepositoryUncheckedCreateInput>
	}


	/**
	 * GitRepository createMany
	 */
	export type GitRepositoryCreateManyArgs = {
		/**
		 * The data used to create many GitRepositories.
		 *
		 **/
		data: Enumerable<GitRepositoryCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * GitRepository update
	 */
	export type GitRepositoryUpdateArgs = {
		/**
		 * Select specific fields to fetch from the GitRepository
		 *
		 **/
		select?: GitRepositorySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitRepositoryInclude | null
		/**
		 * The data needed to update a GitRepository.
		 *
		 **/
		data: XOR<GitRepositoryUpdateInput, GitRepositoryUncheckedUpdateInput>
		/**
		 * Choose, which GitRepository to update.
		 *
		 **/
		where: GitRepositoryWhereUniqueInput
	}


	/**
	 * GitRepository updateMany
	 */
	export type GitRepositoryUpdateManyArgs = {
		/**
		 * The data used to update GitRepositories.
		 *
		 **/
		data: XOR<GitRepositoryUpdateManyMutationInput, GitRepositoryUncheckedUpdateManyInput>
		/**
		 * Filter which GitRepositories to update
		 *
		 **/
		where?: GitRepositoryWhereInput
	}


	/**
	 * GitRepository upsert
	 */
	export type GitRepositoryUpsertArgs = {
		/**
		 * Select specific fields to fetch from the GitRepository
		 *
		 **/
		select?: GitRepositorySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitRepositoryInclude | null
		/**
		 * The filter to search for the GitRepository to update in case it exists.
		 *
		 **/
		where: GitRepositoryWhereUniqueInput
		/**
		 * In case the GitRepository found by the `where` argument doesn't exist, create a new GitRepository with this data.
		 *
		 **/
		create: XOR<GitRepositoryCreateInput, GitRepositoryUncheckedCreateInput>
		/**
		 * In case the GitRepository was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<GitRepositoryUpdateInput, GitRepositoryUncheckedUpdateInput>
	}


	/**
	 * GitRepository delete
	 */
	export type GitRepositoryDeleteArgs = {
		/**
		 * Select specific fields to fetch from the GitRepository
		 *
		 **/
		select?: GitRepositorySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitRepositoryInclude | null
		/**
		 * Filter which GitRepository to delete.
		 *
		 **/
		where: GitRepositoryWhereUniqueInput
	}


	/**
	 * GitRepository deleteMany
	 */
	export type GitRepositoryDeleteManyArgs = {
		/**
		 * Filter which GitRepositories to delete
		 *
		 **/
		where?: GitRepositoryWhereInput
	}


	/**
	 * GitRepository without action
	 */
	export type GitRepositoryArgs = {
		/**
		 * Select specific fields to fetch from the GitRepository
		 *
		 **/
		select?: GitRepositorySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: GitRepositoryInclude | null
	}



	/**
	 * Model User
	 */


	export type AggregateUser = {
		_count: UserCountAggregateOutputType | null
		_min: UserMinAggregateOutputType | null
		_max: UserMaxAggregateOutputType | null
	}

	export type UserMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		accountId: string | null
		workspaceId: string | null
		isOwner: boolean | null
		deletedAt: Date | null
	}

	export type UserMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		accountId: string | null
		workspaceId: string | null
		isOwner: boolean | null
		deletedAt: Date | null
	}

	export type UserCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		accountId: number
		workspaceId: number
		isOwner: number
		deletedAt: number
		_all: number
	}


	export type UserMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		accountId?: true
		workspaceId?: true
		isOwner?: true
		deletedAt?: true
	}

	export type UserMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		accountId?: true
		workspaceId?: true
		isOwner?: true
		deletedAt?: true
	}

	export type UserCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		accountId?: true
		workspaceId?: true
		isOwner?: true
		deletedAt?: true
		_all?: true
	}

	export type UserAggregateArgs = {
		/**
		 * Filter which User to aggregate.
		 *
		 **/
		where?: UserWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Users to fetch.
		 *
		 **/
		orderBy?: Enumerable<UserOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: UserWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Users from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Users.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Users
		 **/
		_count?: true | UserCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: UserMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: UserMaxAggregateInputType
	}

	export type GetUserAggregateType<T extends UserAggregateArgs> = {
		[P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateUser[P]>
			: GetScalarType<T[P], AggregateUser[P]>
	}




	export type UserGroupByArgs = {
		where?: UserWhereInput
		orderBy?: Enumerable<UserOrderByWithAggregationInput>
		by: Array<UserScalarFieldEnum>
		having?: UserScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: UserCountAggregateInputType | true
		_min?: UserMinAggregateInputType
		_max?: UserMaxAggregateInputType
	}


	export type UserGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		accountId: string
		workspaceId: string
		isOwner: boolean
		deletedAt: Date | null
		_count: UserCountAggregateOutputType | null
		_min: UserMinAggregateOutputType | null
		_max: UserMaxAggregateOutputType | null
	}

	type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
		Array<
			PickArray<UserGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], UserGroupByOutputType[P]>
				: GetScalarType<T[P], UserGroupByOutputType[P]>
			}
			>
		>


	export type UserSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		accountId?: boolean
		workspaceId?: boolean
		isOwner?: boolean
		account?: boolean | AccountArgs
		workspace?: boolean | WorkspaceArgs
		assignedCurrentTo?: boolean | AccountArgs
		apiTokens?: boolean | ApiTokenFindManyArgs
		lockedBlocks?: boolean | BlockFindManyArgs
		builds?: boolean | BuildFindManyArgs
		commits?: boolean | CommitFindManyArgs
		deployments?: boolean | DeploymentFindManyArgs
		lockedEntitis?: boolean | EntityFindManyArgs
		userRoles?: boolean | UserRoleFindManyArgs
		sentInvitations?: boolean | InvitationFindManyArgs
		createdFromInvitation?: boolean | InvitationArgs
		deletedAt?: boolean
		_count?: boolean | UserCountOutputTypeArgs
	}

	export type UserInclude = {
		account?: boolean | AccountArgs
		workspace?: boolean | WorkspaceArgs
		assignedCurrentTo?: boolean | AccountArgs
		apiTokens?: boolean | ApiTokenFindManyArgs
		lockedBlocks?: boolean | BlockFindManyArgs
		builds?: boolean | BuildFindManyArgs
		commits?: boolean | CommitFindManyArgs
		deployments?: boolean | DeploymentFindManyArgs
		lockedEntitis?: boolean | EntityFindManyArgs
		userRoles?: boolean | UserRoleFindManyArgs
		sentInvitations?: boolean | InvitationFindManyArgs
		createdFromInvitation?: boolean | InvitationArgs
		_count?: boolean | UserCountOutputTypeArgs
	}

	export type UserGetPayload<
		S extends boolean | null | undefined | UserArgs,
		U = keyof S
		> = S extends true
		? User
		: S extends undefined
			? never
			: S extends UserArgs | UserFindManyArgs
				?'include' extends U
					? User  & {
					[P in TrueKeys<S['include']>]:
					P extends 'account' ? AccountGetPayload<S['include'][P]> :
						P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :
							P extends 'assignedCurrentTo' ? AccountGetPayload<S['include'][P]> | null :
								P extends 'apiTokens' ? Array < ApiTokenGetPayload<S['include'][P]>>  :
									P extends 'lockedBlocks' ? Array < BlockGetPayload<S['include'][P]>>  :
										P extends 'builds' ? Array < BuildGetPayload<S['include'][P]>>  :
											P extends 'commits' ? Array < CommitGetPayload<S['include'][P]>>  :
												P extends 'deployments' ? Array < DeploymentGetPayload<S['include'][P]>>  :
													P extends 'lockedEntitis' ? Array < EntityGetPayload<S['include'][P]>>  :
														P extends 'userRoles' ? Array < UserRoleGetPayload<S['include'][P]>>  :
															P extends 'sentInvitations' ? Array < InvitationGetPayload<S['include'][P]>>  :
																P extends 'createdFromInvitation' ? InvitationGetPayload<S['include'][P]> | null :
																	P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'account' ? AccountGetPayload<S['select'][P]> :
								P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :
									P extends 'assignedCurrentTo' ? AccountGetPayload<S['select'][P]> | null :
										P extends 'apiTokens' ? Array < ApiTokenGetPayload<S['select'][P]>>  :
											P extends 'lockedBlocks' ? Array < BlockGetPayload<S['select'][P]>>  :
												P extends 'builds' ? Array < BuildGetPayload<S['select'][P]>>  :
													P extends 'commits' ? Array < CommitGetPayload<S['select'][P]>>  :
														P extends 'deployments' ? Array < DeploymentGetPayload<S['select'][P]>>  :
															P extends 'lockedEntitis' ? Array < EntityGetPayload<S['select'][P]>>  :
																P extends 'userRoles' ? Array < UserRoleGetPayload<S['select'][P]>>  :
																	P extends 'sentInvitations' ? Array < InvitationGetPayload<S['select'][P]>>  :
																		P extends 'createdFromInvitation' ? InvitationGetPayload<S['select'][P]> | null :
																			P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
						}
						: User
				: User


	type UserCountArgs = Merge<
		Omit<UserFindManyArgs, 'select' | 'include'> & {
		select?: UserCountAggregateInputType | true
	}
		>

	export interface UserDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one User that matches the filter.
		 * @param {UserFindUniqueArgs} args - Arguments to find a User
		 * @example
		 * // Get one User
		 * const user = await prisma.user.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, UserFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

		/**
		 * Find the first User that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserFindFirstArgs} args - Arguments to find a User
		 * @example
		 * // Get one User
		 * const user = await prisma.user.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, UserFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

		/**
		 * Find zero or more Users that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Users
		 * const users = await prisma.user.findMany()
		 *
		 * // Get first 10 Users
		 * const users = await prisma.user.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends UserFindManyArgs>(
			args?: SelectSubset<T, UserFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

		/**
		 * Create a User.
		 * @param {UserCreateArgs} args - Arguments to create a User.
		 * @example
		 * // Create one User
		 * const User = await prisma.user.create({
		 *   data: {
		 *     // ... data to create a User
		 *   }
		 * })
		 *
		 **/
		create<T extends UserCreateArgs>(
			args: SelectSubset<T, UserCreateArgs>
		): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

		/**
		 * Create many Users.
		 *     @param {UserCreateManyArgs} args - Arguments to create many Users.
		 *     @example
		 *     // Create many Users
		 *     const user = await prisma.user.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends UserCreateManyArgs>(
			args?: SelectSubset<T, UserCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a User.
		 * @param {UserDeleteArgs} args - Arguments to delete one User.
		 * @example
		 * // Delete one User
		 * const User = await prisma.user.delete({
		 *   where: {
		 *     // ... filter to delete one User
		 *   }
		 * })
		 *
		 **/
		delete<T extends UserDeleteArgs>(
			args: SelectSubset<T, UserDeleteArgs>
		): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

		/**
		 * Update one User.
		 * @param {UserUpdateArgs} args - Arguments to update one User.
		 * @example
		 * // Update one User
		 * const user = await prisma.user.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends UserUpdateArgs>(
			args: SelectSubset<T, UserUpdateArgs>
		): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

		/**
		 * Delete zero or more Users.
		 * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
		 * @example
		 * // Delete a few Users
		 * const { count } = await prisma.user.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends UserDeleteManyArgs>(
			args?: SelectSubset<T, UserDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Users.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Users
		 * const user = await prisma.user.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends UserUpdateManyArgs>(
			args: SelectSubset<T, UserUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one User.
		 * @param {UserUpsertArgs} args - Arguments to update or create a User.
		 * @example
		 * // Update or create a User
		 * const user = await prisma.user.upsert({
		 *   create: {
		 *     // ... data to create a User
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the User we want to update
		 *   }
		 * })
		 **/
		upsert<T extends UserUpsertArgs>(
			args: SelectSubset<T, UserUpsertArgs>
		): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

		/**
		 * Count the number of Users.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserCountArgs} args - Arguments to filter Users to count.
		 * @example
		 * // Count the number of Users
		 * const count = await prisma.user.count({
		 *   where: {
		 *     // ... the filter for the Users we want to count
		 *   }
		 * })
		 **/
		count<T extends UserCountArgs>(
			args?: Subset<T, UserCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], UserCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a User.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

		/**
		 * Group by User.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends UserGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: UserGroupByArgs['orderBy'] }
				: { orderBy?: UserGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for User.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__UserClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | null >, Prisma__AccountClient<AccountGetPayload<T> | null >>;

		workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null >, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null >>;

		assignedCurrentTo<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | null >, Prisma__AccountClient<AccountGetPayload<T> | null >>;

		apiTokens<T extends ApiTokenFindManyArgs = {}>(args?: Subset<T, ApiTokenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ApiToken>>, PrismaPromise<Array<ApiTokenGetPayload<T>>>>;

		lockedBlocks<T extends BlockFindManyArgs = {}>(args?: Subset<T, BlockFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Block>>, PrismaPromise<Array<BlockGetPayload<T>>>>;

		builds<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

		commits<T extends CommitFindManyArgs = {}>(args?: Subset<T, CommitFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Commit>>, PrismaPromise<Array<CommitGetPayload<T>>>>;

		deployments<T extends DeploymentFindManyArgs = {}>(args?: Subset<T, DeploymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Deployment>>, PrismaPromise<Array<DeploymentGetPayload<T>>>>;

		lockedEntitis<T extends EntityFindManyArgs = {}>(args?: Subset<T, EntityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Entity>>, PrismaPromise<Array<EntityGetPayload<T>>>>;

		userRoles<T extends UserRoleFindManyArgs = {}>(args?: Subset<T, UserRoleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserRole>>, PrismaPromise<Array<UserRoleGetPayload<T>>>>;

		sentInvitations<T extends InvitationFindManyArgs = {}>(args?: Subset<T, InvitationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Invitation>>, PrismaPromise<Array<InvitationGetPayload<T>>>>;

		createdFromInvitation<T extends InvitationArgs = {}>(args?: Subset<T, InvitationArgs>): CheckSelect<T, Prisma__InvitationClient<Invitation | null >, Prisma__InvitationClient<InvitationGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * User findUnique
	 */
	export type UserFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the User
		 *
		 **/
		select?: UserSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserInclude | null
		/**
		 * Throw an Error if a User can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which User to fetch.
		 *
		 **/
		where: UserWhereUniqueInput
	}


	/**
	 * User findFirst
	 */
	export type UserFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the User
		 *
		 **/
		select?: UserSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserInclude | null
		/**
		 * Throw an Error if a User can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which User to fetch.
		 *
		 **/
		where?: UserWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Users to fetch.
		 *
		 **/
		orderBy?: Enumerable<UserOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Users.
		 *
		 **/
		cursor?: UserWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Users from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Users.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Users.
		 *
		 **/
		distinct?: Enumerable<UserScalarFieldEnum>
	}


	/**
	 * User findMany
	 */
	export type UserFindManyArgs = {
		/**
		 * Select specific fields to fetch from the User
		 *
		 **/
		select?: UserSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserInclude | null
		/**
		 * Filter, which Users to fetch.
		 *
		 **/
		where?: UserWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Users to fetch.
		 *
		 **/
		orderBy?: Enumerable<UserOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Users.
		 *
		 **/
		cursor?: UserWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Users from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Users.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<UserScalarFieldEnum>
	}


	/**
	 * User create
	 */
	export type UserCreateArgs = {
		/**
		 * Select specific fields to fetch from the User
		 *
		 **/
		select?: UserSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserInclude | null
		/**
		 * The data needed to create a User.
		 *
		 **/
		data: XOR<UserCreateInput, UserUncheckedCreateInput>
	}


	/**
	 * User createMany
	 */
	export type UserCreateManyArgs = {
		/**
		 * The data used to create many Users.
		 *
		 **/
		data: Enumerable<UserCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * User update
	 */
	export type UserUpdateArgs = {
		/**
		 * Select specific fields to fetch from the User
		 *
		 **/
		select?: UserSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserInclude | null
		/**
		 * The data needed to update a User.
		 *
		 **/
		data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
		/**
		 * Choose, which User to update.
		 *
		 **/
		where: UserWhereUniqueInput
	}


	/**
	 * User updateMany
	 */
	export type UserUpdateManyArgs = {
		/**
		 * The data used to update Users.
		 *
		 **/
		data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
		/**
		 * Filter which Users to update
		 *
		 **/
		where?: UserWhereInput
	}


	/**
	 * User upsert
	 */
	export type UserUpsertArgs = {
		/**
		 * Select specific fields to fetch from the User
		 *
		 **/
		select?: UserSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserInclude | null
		/**
		 * The filter to search for the User to update in case it exists.
		 *
		 **/
		where: UserWhereUniqueInput
		/**
		 * In case the User found by the `where` argument doesn't exist, create a new User with this data.
		 *
		 **/
		create: XOR<UserCreateInput, UserUncheckedCreateInput>
		/**
		 * In case the User was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
	}


	/**
	 * User delete
	 */
	export type UserDeleteArgs = {
		/**
		 * Select specific fields to fetch from the User
		 *
		 **/
		select?: UserSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserInclude | null
		/**
		 * Filter which User to delete.
		 *
		 **/
		where: UserWhereUniqueInput
	}


	/**
	 * User deleteMany
	 */
	export type UserDeleteManyArgs = {
		/**
		 * Filter which Users to delete
		 *
		 **/
		where?: UserWhereInput
	}


	/**
	 * User without action
	 */
	export type UserArgs = {
		/**
		 * Select specific fields to fetch from the User
		 *
		 **/
		select?: UserSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserInclude | null
	}



	/**
	 * Model UserRole
	 */


	export type AggregateUserRole = {
		_count: UserRoleCountAggregateOutputType | null
		_min: UserRoleMinAggregateOutputType | null
		_max: UserRoleMaxAggregateOutputType | null
	}

	export type UserRoleMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		userId: string | null
		role: string | null
	}

	export type UserRoleMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		userId: string | null
		role: string | null
	}

	export type UserRoleCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		userId: number
		role: number
		_all: number
	}


	export type UserRoleMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		userId?: true
		role?: true
	}

	export type UserRoleMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		userId?: true
		role?: true
	}

	export type UserRoleCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		userId?: true
		role?: true
		_all?: true
	}

	export type UserRoleAggregateArgs = {
		/**
		 * Filter which UserRole to aggregate.
		 *
		 **/
		where?: UserRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of UserRoles to fetch.
		 *
		 **/
		orderBy?: Enumerable<UserRoleOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: UserRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` UserRoles from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` UserRoles.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned UserRoles
		 **/
		_count?: true | UserRoleCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: UserRoleMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: UserRoleMaxAggregateInputType
	}

	export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
		[P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateUserRole[P]>
			: GetScalarType<T[P], AggregateUserRole[P]>
	}




	export type UserRoleGroupByArgs = {
		where?: UserRoleWhereInput
		orderBy?: Enumerable<UserRoleOrderByWithAggregationInput>
		by: Array<UserRoleScalarFieldEnum>
		having?: UserRoleScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: UserRoleCountAggregateInputType | true
		_min?: UserRoleMinAggregateInputType
		_max?: UserRoleMaxAggregateInputType
	}


	export type UserRoleGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		userId: string
		role: string
		_count: UserRoleCountAggregateOutputType | null
		_min: UserRoleMinAggregateOutputType | null
		_max: UserRoleMaxAggregateOutputType | null
	}

	type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = PrismaPromise<
		Array<
			PickArray<UserRoleGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], UserRoleGroupByOutputType[P]>
				: GetScalarType<T[P], UserRoleGroupByOutputType[P]>
			}
			>
		>


	export type UserRoleSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		userId?: boolean
		role?: boolean
		user?: boolean | UserArgs
	}

	export type UserRoleInclude = {
		user?: boolean | UserArgs
	}

	export type UserRoleGetPayload<
		S extends boolean | null | undefined | UserRoleArgs,
		U = keyof S
		> = S extends true
		? UserRole
		: S extends undefined
			? never
			: S extends UserRoleArgs | UserRoleFindManyArgs
				?'include' extends U
					? UserRole  & {
					[P in TrueKeys<S['include']>]:
					P extends 'user' ? UserGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserRole ? UserRole[P] : never
						}
						: UserRole
				: UserRole


	type UserRoleCountArgs = Merge<
		Omit<UserRoleFindManyArgs, 'select' | 'include'> & {
		select?: UserRoleCountAggregateInputType | true
	}
		>

	export interface UserRoleDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one UserRole that matches the filter.
		 * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
		 * @example
		 * // Get one UserRole
		 * const userRole = await prisma.userRole.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends UserRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, UserRoleFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserRole'> extends True ? CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>> : CheckSelect<T, Prisma__UserRoleClient<UserRole | null >, Prisma__UserRoleClient<UserRoleGetPayload<T> | null >>

		/**
		 * Find the first UserRole that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
		 * @example
		 * // Get one UserRole
		 * const userRole = await prisma.userRole.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends UserRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, UserRoleFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserRole'> extends True ? CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>> : CheckSelect<T, Prisma__UserRoleClient<UserRole | null >, Prisma__UserRoleClient<UserRoleGetPayload<T> | null >>

		/**
		 * Find zero or more UserRoles that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all UserRoles
		 * const userRoles = await prisma.userRole.findMany()
		 *
		 * // Get first 10 UserRoles
		 * const userRoles = await prisma.userRole.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends UserRoleFindManyArgs>(
			args?: SelectSubset<T, UserRoleFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<UserRole>>, PrismaPromise<Array<UserRoleGetPayload<T>>>>

		/**
		 * Create a UserRole.
		 * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
		 * @example
		 * // Create one UserRole
		 * const UserRole = await prisma.userRole.create({
		 *   data: {
		 *     // ... data to create a UserRole
		 *   }
		 * })
		 *
		 **/
		create<T extends UserRoleCreateArgs>(
			args: SelectSubset<T, UserRoleCreateArgs>
		): CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>>

		/**
		 * Create many UserRoles.
		 *     @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
		 *     @example
		 *     // Create many UserRoles
		 *     const userRole = await prisma.userRole.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends UserRoleCreateManyArgs>(
			args?: SelectSubset<T, UserRoleCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a UserRole.
		 * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
		 * @example
		 * // Delete one UserRole
		 * const UserRole = await prisma.userRole.delete({
		 *   where: {
		 *     // ... filter to delete one UserRole
		 *   }
		 * })
		 *
		 **/
		delete<T extends UserRoleDeleteArgs>(
			args: SelectSubset<T, UserRoleDeleteArgs>
		): CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>>

		/**
		 * Update one UserRole.
		 * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
		 * @example
		 * // Update one UserRole
		 * const userRole = await prisma.userRole.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends UserRoleUpdateArgs>(
			args: SelectSubset<T, UserRoleUpdateArgs>
		): CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>>

		/**
		 * Delete zero or more UserRoles.
		 * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
		 * @example
		 * // Delete a few UserRoles
		 * const { count } = await prisma.userRole.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends UserRoleDeleteManyArgs>(
			args?: SelectSubset<T, UserRoleDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more UserRoles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many UserRoles
		 * const userRole = await prisma.userRole.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends UserRoleUpdateManyArgs>(
			args: SelectSubset<T, UserRoleUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one UserRole.
		 * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
		 * @example
		 * // Update or create a UserRole
		 * const userRole = await prisma.userRole.upsert({
		 *   create: {
		 *     // ... data to create a UserRole
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the UserRole we want to update
		 *   }
		 * })
		 **/
		upsert<T extends UserRoleUpsertArgs>(
			args: SelectSubset<T, UserRoleUpsertArgs>
		): CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>>

		/**
		 * Count the number of UserRoles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
		 * @example
		 * // Count the number of UserRoles
		 * const count = await prisma.userRole.count({
		 *   where: {
		 *     // ... the filter for the UserRoles we want to count
		 *   }
		 * })
		 **/
		count<T extends UserRoleCountArgs>(
			args?: Subset<T, UserRoleCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], UserRoleCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a UserRole.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): PrismaPromise<GetUserRoleAggregateType<T>>

		/**
		 * Group by UserRole.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {UserRoleGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends UserRoleGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: UserRoleGroupByArgs['orderBy'] }
				: { orderBy?: UserRoleGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for UserRole.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__UserRoleClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * UserRole findUnique
	 */
	export type UserRoleFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the UserRole
		 *
		 **/
		select?: UserRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserRoleInclude | null
		/**
		 * Throw an Error if a UserRole can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which UserRole to fetch.
		 *
		 **/
		where: UserRoleWhereUniqueInput
	}


	/**
	 * UserRole findFirst
	 */
	export type UserRoleFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the UserRole
		 *
		 **/
		select?: UserRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserRoleInclude | null
		/**
		 * Throw an Error if a UserRole can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which UserRole to fetch.
		 *
		 **/
		where?: UserRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of UserRoles to fetch.
		 *
		 **/
		orderBy?: Enumerable<UserRoleOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for UserRoles.
		 *
		 **/
		cursor?: UserRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` UserRoles from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` UserRoles.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of UserRoles.
		 *
		 **/
		distinct?: Enumerable<UserRoleScalarFieldEnum>
	}


	/**
	 * UserRole findMany
	 */
	export type UserRoleFindManyArgs = {
		/**
		 * Select specific fields to fetch from the UserRole
		 *
		 **/
		select?: UserRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserRoleInclude | null
		/**
		 * Filter, which UserRoles to fetch.
		 *
		 **/
		where?: UserRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of UserRoles to fetch.
		 *
		 **/
		orderBy?: Enumerable<UserRoleOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing UserRoles.
		 *
		 **/
		cursor?: UserRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` UserRoles from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` UserRoles.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<UserRoleScalarFieldEnum>
	}


	/**
	 * UserRole create
	 */
	export type UserRoleCreateArgs = {
		/**
		 * Select specific fields to fetch from the UserRole
		 *
		 **/
		select?: UserRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserRoleInclude | null
		/**
		 * The data needed to create a UserRole.
		 *
		 **/
		data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
	}


	/**
	 * UserRole createMany
	 */
	export type UserRoleCreateManyArgs = {
		/**
		 * The data used to create many UserRoles.
		 *
		 **/
		data: Enumerable<UserRoleCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * UserRole update
	 */
	export type UserRoleUpdateArgs = {
		/**
		 * Select specific fields to fetch from the UserRole
		 *
		 **/
		select?: UserRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserRoleInclude | null
		/**
		 * The data needed to update a UserRole.
		 *
		 **/
		data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
		/**
		 * Choose, which UserRole to update.
		 *
		 **/
		where: UserRoleWhereUniqueInput
	}


	/**
	 * UserRole updateMany
	 */
	export type UserRoleUpdateManyArgs = {
		/**
		 * The data used to update UserRoles.
		 *
		 **/
		data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
		/**
		 * Filter which UserRoles to update
		 *
		 **/
		where?: UserRoleWhereInput
	}


	/**
	 * UserRole upsert
	 */
	export type UserRoleUpsertArgs = {
		/**
		 * Select specific fields to fetch from the UserRole
		 *
		 **/
		select?: UserRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserRoleInclude | null
		/**
		 * The filter to search for the UserRole to update in case it exists.
		 *
		 **/
		where: UserRoleWhereUniqueInput
		/**
		 * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
		 *
		 **/
		create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
		/**
		 * In case the UserRole was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
	}


	/**
	 * UserRole delete
	 */
	export type UserRoleDeleteArgs = {
		/**
		 * Select specific fields to fetch from the UserRole
		 *
		 **/
		select?: UserRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserRoleInclude | null
		/**
		 * Filter which UserRole to delete.
		 *
		 **/
		where: UserRoleWhereUniqueInput
	}


	/**
	 * UserRole deleteMany
	 */
	export type UserRoleDeleteManyArgs = {
		/**
		 * Filter which UserRoles to delete
		 *
		 **/
		where?: UserRoleWhereInput
	}


	/**
	 * UserRole without action
	 */
	export type UserRoleArgs = {
		/**
		 * Select specific fields to fetch from the UserRole
		 *
		 **/
		select?: UserRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: UserRoleInclude | null
	}



	/**
	 * Model ApiToken
	 */


	export type AggregateApiToken = {
		_count: ApiTokenCountAggregateOutputType | null
		_min: ApiTokenMinAggregateOutputType | null
		_max: ApiTokenMaxAggregateOutputType | null
	}

	export type ApiTokenMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		name: string | null
		userId: string | null
		token: string | null
		previewChars: string | null
		lastAccessAt: Date | null
	}

	export type ApiTokenMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		name: string | null
		userId: string | null
		token: string | null
		previewChars: string | null
		lastAccessAt: Date | null
	}

	export type ApiTokenCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		name: number
		userId: number
		token: number
		previewChars: number
		lastAccessAt: number
		_all: number
	}


	export type ApiTokenMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		name?: true
		userId?: true
		token?: true
		previewChars?: true
		lastAccessAt?: true
	}

	export type ApiTokenMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		name?: true
		userId?: true
		token?: true
		previewChars?: true
		lastAccessAt?: true
	}

	export type ApiTokenCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		name?: true
		userId?: true
		token?: true
		previewChars?: true
		lastAccessAt?: true
		_all?: true
	}

	export type ApiTokenAggregateArgs = {
		/**
		 * Filter which ApiToken to aggregate.
		 *
		 **/
		where?: ApiTokenWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ApiTokens to fetch.
		 *
		 **/
		orderBy?: Enumerable<ApiTokenOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: ApiTokenWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ApiTokens from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ApiTokens.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned ApiTokens
		 **/
		_count?: true | ApiTokenCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ApiTokenMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ApiTokenMaxAggregateInputType
	}

	export type GetApiTokenAggregateType<T extends ApiTokenAggregateArgs> = {
		[P in keyof T & keyof AggregateApiToken]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateApiToken[P]>
			: GetScalarType<T[P], AggregateApiToken[P]>
	}




	export type ApiTokenGroupByArgs = {
		where?: ApiTokenWhereInput
		orderBy?: Enumerable<ApiTokenOrderByWithAggregationInput>
		by: Array<ApiTokenScalarFieldEnum>
		having?: ApiTokenScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ApiTokenCountAggregateInputType | true
		_min?: ApiTokenMinAggregateInputType
		_max?: ApiTokenMaxAggregateInputType
	}


	export type ApiTokenGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		name: string
		userId: string
		token: string
		previewChars: string
		lastAccessAt: Date
		_count: ApiTokenCountAggregateOutputType | null
		_min: ApiTokenMinAggregateOutputType | null
		_max: ApiTokenMaxAggregateOutputType | null
	}

	type GetApiTokenGroupByPayload<T extends ApiTokenGroupByArgs> = PrismaPromise<
		Array<
			PickArray<ApiTokenGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof ApiTokenGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], ApiTokenGroupByOutputType[P]>
				: GetScalarType<T[P], ApiTokenGroupByOutputType[P]>
			}
			>
		>


	export type ApiTokenSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		name?: boolean
		userId?: boolean
		token?: boolean
		previewChars?: boolean
		lastAccessAt?: boolean
		user?: boolean | UserArgs
	}

	export type ApiTokenInclude = {
		user?: boolean | UserArgs
	}

	export type ApiTokenGetPayload<
		S extends boolean | null | undefined | ApiTokenArgs,
		U = keyof S
		> = S extends true
		? ApiToken
		: S extends undefined
			? never
			: S extends ApiTokenArgs | ApiTokenFindManyArgs
				?'include' extends U
					? ApiToken  & {
					[P in TrueKeys<S['include']>]:
					P extends 'user' ? UserGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof ApiToken ? ApiToken[P] : never
						}
						: ApiToken
				: ApiToken


	type ApiTokenCountArgs = Merge<
		Omit<ApiTokenFindManyArgs, 'select' | 'include'> & {
		select?: ApiTokenCountAggregateInputType | true
	}
		>

	export interface ApiTokenDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one ApiToken that matches the filter.
		 * @param {ApiTokenFindUniqueArgs} args - Arguments to find a ApiToken
		 * @example
		 * // Get one ApiToken
		 * const apiToken = await prisma.apiToken.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends ApiTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, ApiTokenFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ApiToken'> extends True ? CheckSelect<T, Prisma__ApiTokenClient<ApiToken>, Prisma__ApiTokenClient<ApiTokenGetPayload<T>>> : CheckSelect<T, Prisma__ApiTokenClient<ApiToken | null >, Prisma__ApiTokenClient<ApiTokenGetPayload<T> | null >>

		/**
		 * Find the first ApiToken that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ApiTokenFindFirstArgs} args - Arguments to find a ApiToken
		 * @example
		 * // Get one ApiToken
		 * const apiToken = await prisma.apiToken.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends ApiTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, ApiTokenFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ApiToken'> extends True ? CheckSelect<T, Prisma__ApiTokenClient<ApiToken>, Prisma__ApiTokenClient<ApiTokenGetPayload<T>>> : CheckSelect<T, Prisma__ApiTokenClient<ApiToken | null >, Prisma__ApiTokenClient<ApiTokenGetPayload<T> | null >>

		/**
		 * Find zero or more ApiTokens that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ApiTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all ApiTokens
		 * const apiTokens = await prisma.apiToken.findMany()
		 *
		 * // Get first 10 ApiTokens
		 * const apiTokens = await prisma.apiToken.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const apiTokenWithIdOnly = await prisma.apiToken.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends ApiTokenFindManyArgs>(
			args?: SelectSubset<T, ApiTokenFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<ApiToken>>, PrismaPromise<Array<ApiTokenGetPayload<T>>>>

		/**
		 * Create a ApiToken.
		 * @param {ApiTokenCreateArgs} args - Arguments to create a ApiToken.
		 * @example
		 * // Create one ApiToken
		 * const ApiToken = await prisma.apiToken.create({
		 *   data: {
		 *     // ... data to create a ApiToken
		 *   }
		 * })
		 *
		 **/
		create<T extends ApiTokenCreateArgs>(
			args: SelectSubset<T, ApiTokenCreateArgs>
		): CheckSelect<T, Prisma__ApiTokenClient<ApiToken>, Prisma__ApiTokenClient<ApiTokenGetPayload<T>>>

		/**
		 * Create many ApiTokens.
		 *     @param {ApiTokenCreateManyArgs} args - Arguments to create many ApiTokens.
		 *     @example
		 *     // Create many ApiTokens
		 *     const apiToken = await prisma.apiToken.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends ApiTokenCreateManyArgs>(
			args?: SelectSubset<T, ApiTokenCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a ApiToken.
		 * @param {ApiTokenDeleteArgs} args - Arguments to delete one ApiToken.
		 * @example
		 * // Delete one ApiToken
		 * const ApiToken = await prisma.apiToken.delete({
		 *   where: {
		 *     // ... filter to delete one ApiToken
		 *   }
		 * })
		 *
		 **/
		delete<T extends ApiTokenDeleteArgs>(
			args: SelectSubset<T, ApiTokenDeleteArgs>
		): CheckSelect<T, Prisma__ApiTokenClient<ApiToken>, Prisma__ApiTokenClient<ApiTokenGetPayload<T>>>

		/**
		 * Update one ApiToken.
		 * @param {ApiTokenUpdateArgs} args - Arguments to update one ApiToken.
		 * @example
		 * // Update one ApiToken
		 * const apiToken = await prisma.apiToken.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends ApiTokenUpdateArgs>(
			args: SelectSubset<T, ApiTokenUpdateArgs>
		): CheckSelect<T, Prisma__ApiTokenClient<ApiToken>, Prisma__ApiTokenClient<ApiTokenGetPayload<T>>>

		/**
		 * Delete zero or more ApiTokens.
		 * @param {ApiTokenDeleteManyArgs} args - Arguments to filter ApiTokens to delete.
		 * @example
		 * // Delete a few ApiTokens
		 * const { count } = await prisma.apiToken.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends ApiTokenDeleteManyArgs>(
			args?: SelectSubset<T, ApiTokenDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more ApiTokens.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ApiTokenUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many ApiTokens
		 * const apiToken = await prisma.apiToken.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends ApiTokenUpdateManyArgs>(
			args: SelectSubset<T, ApiTokenUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one ApiToken.
		 * @param {ApiTokenUpsertArgs} args - Arguments to update or create a ApiToken.
		 * @example
		 * // Update or create a ApiToken
		 * const apiToken = await prisma.apiToken.upsert({
		 *   create: {
		 *     // ... data to create a ApiToken
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the ApiToken we want to update
		 *   }
		 * })
		 **/
		upsert<T extends ApiTokenUpsertArgs>(
			args: SelectSubset<T, ApiTokenUpsertArgs>
		): CheckSelect<T, Prisma__ApiTokenClient<ApiToken>, Prisma__ApiTokenClient<ApiTokenGetPayload<T>>>

		/**
		 * Count the number of ApiTokens.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ApiTokenCountArgs} args - Arguments to filter ApiTokens to count.
		 * @example
		 * // Count the number of ApiTokens
		 * const count = await prisma.apiToken.count({
		 *   where: {
		 *     // ... the filter for the ApiTokens we want to count
		 *   }
		 * })
		 **/
		count<T extends ApiTokenCountArgs>(
			args?: Subset<T, ApiTokenCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ApiTokenCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a ApiToken.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ApiTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ApiTokenAggregateArgs>(args: Subset<T, ApiTokenAggregateArgs>): PrismaPromise<GetApiTokenAggregateType<T>>

		/**
		 * Group by ApiToken.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ApiTokenGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ApiTokenGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ApiTokenGroupByArgs['orderBy'] }
				: { orderBy?: ApiTokenGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, ApiTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiTokenGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for ApiToken.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__ApiTokenClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * ApiToken findUnique
	 */
	export type ApiTokenFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the ApiToken
		 *
		 **/
		select?: ApiTokenSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ApiTokenInclude | null
		/**
		 * Throw an Error if a ApiToken can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which ApiToken to fetch.
		 *
		 **/
		where: ApiTokenWhereUniqueInput
	}


	/**
	 * ApiToken findFirst
	 */
	export type ApiTokenFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the ApiToken
		 *
		 **/
		select?: ApiTokenSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ApiTokenInclude | null
		/**
		 * Throw an Error if a ApiToken can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which ApiToken to fetch.
		 *
		 **/
		where?: ApiTokenWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ApiTokens to fetch.
		 *
		 **/
		orderBy?: Enumerable<ApiTokenOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for ApiTokens.
		 *
		 **/
		cursor?: ApiTokenWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ApiTokens from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ApiTokens.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of ApiTokens.
		 *
		 **/
		distinct?: Enumerable<ApiTokenScalarFieldEnum>
	}


	/**
	 * ApiToken findMany
	 */
	export type ApiTokenFindManyArgs = {
		/**
		 * Select specific fields to fetch from the ApiToken
		 *
		 **/
		select?: ApiTokenSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ApiTokenInclude | null
		/**
		 * Filter, which ApiTokens to fetch.
		 *
		 **/
		where?: ApiTokenWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ApiTokens to fetch.
		 *
		 **/
		orderBy?: Enumerable<ApiTokenOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing ApiTokens.
		 *
		 **/
		cursor?: ApiTokenWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ApiTokens from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ApiTokens.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<ApiTokenScalarFieldEnum>
	}


	/**
	 * ApiToken create
	 */
	export type ApiTokenCreateArgs = {
		/**
		 * Select specific fields to fetch from the ApiToken
		 *
		 **/
		select?: ApiTokenSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ApiTokenInclude | null
		/**
		 * The data needed to create a ApiToken.
		 *
		 **/
		data: XOR<ApiTokenCreateInput, ApiTokenUncheckedCreateInput>
	}


	/**
	 * ApiToken createMany
	 */
	export type ApiTokenCreateManyArgs = {
		/**
		 * The data used to create many ApiTokens.
		 *
		 **/
		data: Enumerable<ApiTokenCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * ApiToken update
	 */
	export type ApiTokenUpdateArgs = {
		/**
		 * Select specific fields to fetch from the ApiToken
		 *
		 **/
		select?: ApiTokenSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ApiTokenInclude | null
		/**
		 * The data needed to update a ApiToken.
		 *
		 **/
		data: XOR<ApiTokenUpdateInput, ApiTokenUncheckedUpdateInput>
		/**
		 * Choose, which ApiToken to update.
		 *
		 **/
		where: ApiTokenWhereUniqueInput
	}


	/**
	 * ApiToken updateMany
	 */
	export type ApiTokenUpdateManyArgs = {
		/**
		 * The data used to update ApiTokens.
		 *
		 **/
		data: XOR<ApiTokenUpdateManyMutationInput, ApiTokenUncheckedUpdateManyInput>
		/**
		 * Filter which ApiTokens to update
		 *
		 **/
		where?: ApiTokenWhereInput
	}


	/**
	 * ApiToken upsert
	 */
	export type ApiTokenUpsertArgs = {
		/**
		 * Select specific fields to fetch from the ApiToken
		 *
		 **/
		select?: ApiTokenSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ApiTokenInclude | null
		/**
		 * The filter to search for the ApiToken to update in case it exists.
		 *
		 **/
		where: ApiTokenWhereUniqueInput
		/**
		 * In case the ApiToken found by the `where` argument doesn't exist, create a new ApiToken with this data.
		 *
		 **/
		create: XOR<ApiTokenCreateInput, ApiTokenUncheckedCreateInput>
		/**
		 * In case the ApiToken was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<ApiTokenUpdateInput, ApiTokenUncheckedUpdateInput>
	}


	/**
	 * ApiToken delete
	 */
	export type ApiTokenDeleteArgs = {
		/**
		 * Select specific fields to fetch from the ApiToken
		 *
		 **/
		select?: ApiTokenSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ApiTokenInclude | null
		/**
		 * Filter which ApiToken to delete.
		 *
		 **/
		where: ApiTokenWhereUniqueInput
	}


	/**
	 * ApiToken deleteMany
	 */
	export type ApiTokenDeleteManyArgs = {
		/**
		 * Filter which ApiTokens to delete
		 *
		 **/
		where?: ApiTokenWhereInput
	}


	/**
	 * ApiToken without action
	 */
	export type ApiTokenArgs = {
		/**
		 * Select specific fields to fetch from the ApiToken
		 *
		 **/
		select?: ApiTokenSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ApiTokenInclude | null
	}



	/**
	 * Model Resource
	 */


	export type AggregateResource = {
		_count: ResourceCountAggregateOutputType | null
		_min: ResourceMinAggregateOutputType | null
		_max: ResourceMaxAggregateOutputType | null
	}

	export type ResourceMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		name: string | null
		description: string | null
		gitRepositoryOverride: boolean | null
		githubLastSync: Date | null
		githubLastMessage: string | null
		deletedAt: Date | null
		gitRepositoryId: string | null
		projectId: string | null
		resourceType: EnumResourceType | null
	}

	export type ResourceMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		name: string | null
		description: string | null
		gitRepositoryOverride: boolean | null
		githubLastSync: Date | null
		githubLastMessage: string | null
		deletedAt: Date | null
		gitRepositoryId: string | null
		projectId: string | null
		resourceType: EnumResourceType | null
	}

	export type ResourceCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		name: number
		description: number
		gitRepositoryOverride: number
		githubLastSync: number
		githubLastMessage: number
		deletedAt: number
		gitRepositoryId: number
		projectId: number
		resourceType: number
		_all: number
	}


	export type ResourceMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		name?: true
		description?: true
		gitRepositoryOverride?: true
		githubLastSync?: true
		githubLastMessage?: true
		deletedAt?: true
		gitRepositoryId?: true
		projectId?: true
		resourceType?: true
	}

	export type ResourceMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		name?: true
		description?: true
		gitRepositoryOverride?: true
		githubLastSync?: true
		githubLastMessage?: true
		deletedAt?: true
		gitRepositoryId?: true
		projectId?: true
		resourceType?: true
	}

	export type ResourceCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		name?: true
		description?: true
		gitRepositoryOverride?: true
		githubLastSync?: true
		githubLastMessage?: true
		deletedAt?: true
		gitRepositoryId?: true
		projectId?: true
		resourceType?: true
		_all?: true
	}

	export type ResourceAggregateArgs = {
		/**
		 * Filter which Resource to aggregate.
		 *
		 **/
		where?: ResourceWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Resources to fetch.
		 *
		 **/
		orderBy?: Enumerable<ResourceOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: ResourceWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Resources from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Resources.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Resources
		 **/
		_count?: true | ResourceCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ResourceMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ResourceMaxAggregateInputType
	}

	export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
		[P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateResource[P]>
			: GetScalarType<T[P], AggregateResource[P]>
	}




	export type ResourceGroupByArgs = {
		where?: ResourceWhereInput
		orderBy?: Enumerable<ResourceOrderByWithAggregationInput>
		by: Array<ResourceScalarFieldEnum>
		having?: ResourceScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ResourceCountAggregateInputType | true
		_min?: ResourceMinAggregateInputType
		_max?: ResourceMaxAggregateInputType
	}


	export type ResourceGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		name: string
		description: string
		gitRepositoryOverride: boolean
		githubLastSync: Date | null
		githubLastMessage: string | null
		deletedAt: Date | null
		gitRepositoryId: string | null
		projectId: string
		resourceType: EnumResourceType
		_count: ResourceCountAggregateOutputType | null
		_min: ResourceMinAggregateOutputType | null
		_max: ResourceMaxAggregateOutputType | null
	}

	type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = PrismaPromise<
		Array<
			PickArray<ResourceGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], ResourceGroupByOutputType[P]>
				: GetScalarType<T[P], ResourceGroupByOutputType[P]>
			}
			>
		>


	export type ResourceSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		name?: boolean
		description?: boolean
		gitRepositoryOverride?: boolean
		githubLastSync?: boolean
		githubLastMessage?: boolean
		deletedAt?: boolean
		gitRepositoryId?: boolean
		roles?: boolean | ResourceRoleFindManyArgs
		blocks?: boolean | BlockFindManyArgs
		builds?: boolean | BuildFindManyArgs
		entities?: boolean | EntityFindManyArgs
		environments?: boolean | EnvironmentFindManyArgs
		gitRepository?: boolean | GitRepositoryArgs
		projectId?: boolean
		project?: boolean | ProjectArgs
		resourceType?: boolean
		_count?: boolean | ResourceCountOutputTypeArgs
	}

	export type ResourceInclude = {
		roles?: boolean | ResourceRoleFindManyArgs
		blocks?: boolean | BlockFindManyArgs
		builds?: boolean | BuildFindManyArgs
		entities?: boolean | EntityFindManyArgs
		environments?: boolean | EnvironmentFindManyArgs
		gitRepository?: boolean | GitRepositoryArgs
		project?: boolean | ProjectArgs
		_count?: boolean | ResourceCountOutputTypeArgs
	}

	export type ResourceGetPayload<
		S extends boolean | null | undefined | ResourceArgs,
		U = keyof S
		> = S extends true
		? Resource
		: S extends undefined
			? never
			: S extends ResourceArgs | ResourceFindManyArgs
				?'include' extends U
					? Resource  & {
					[P in TrueKeys<S['include']>]:
					P extends 'roles' ? Array < ResourceRoleGetPayload<S['include'][P]>>  :
						P extends 'blocks' ? Array < BlockGetPayload<S['include'][P]>>  :
							P extends 'builds' ? Array < BuildGetPayload<S['include'][P]>>  :
								P extends 'entities' ? Array < EntityGetPayload<S['include'][P]>>  :
									P extends 'environments' ? Array < EnvironmentGetPayload<S['include'][P]>>  :
										P extends 'gitRepository' ? GitRepositoryGetPayload<S['include'][P]> | null :
											P extends 'project' ? ProjectGetPayload<S['include'][P]> :
												P extends '_count' ? ResourceCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'roles' ? Array < ResourceRoleGetPayload<S['select'][P]>>  :
								P extends 'blocks' ? Array < BlockGetPayload<S['select'][P]>>  :
									P extends 'builds' ? Array < BuildGetPayload<S['select'][P]>>  :
										P extends 'entities' ? Array < EntityGetPayload<S['select'][P]>>  :
											P extends 'environments' ? Array < EnvironmentGetPayload<S['select'][P]>>  :
												P extends 'gitRepository' ? GitRepositoryGetPayload<S['select'][P]> | null :
													P extends 'project' ? ProjectGetPayload<S['select'][P]> :
														P extends '_count' ? ResourceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Resource ? Resource[P] : never
						}
						: Resource
				: Resource


	type ResourceCountArgs = Merge<
		Omit<ResourceFindManyArgs, 'select' | 'include'> & {
		select?: ResourceCountAggregateInputType | true
	}
		>

	export interface ResourceDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Resource that matches the filter.
		 * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
		 * @example
		 * // Get one Resource
		 * const resource = await prisma.resource.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends ResourceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, ResourceFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Resource'> extends True ? CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>> : CheckSelect<T, Prisma__ResourceClient<Resource | null >, Prisma__ResourceClient<ResourceGetPayload<T> | null >>

		/**
		 * Find the first Resource that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
		 * @example
		 * // Get one Resource
		 * const resource = await prisma.resource.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends ResourceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, ResourceFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Resource'> extends True ? CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>> : CheckSelect<T, Prisma__ResourceClient<Resource | null >, Prisma__ResourceClient<ResourceGetPayload<T> | null >>

		/**
		 * Find zero or more Resources that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Resources
		 * const resources = await prisma.resource.findMany()
		 *
		 * // Get first 10 Resources
		 * const resources = await prisma.resource.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends ResourceFindManyArgs>(
			args?: SelectSubset<T, ResourceFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Resource>>, PrismaPromise<Array<ResourceGetPayload<T>>>>

		/**
		 * Create a Resource.
		 * @param {ResourceCreateArgs} args - Arguments to create a Resource.
		 * @example
		 * // Create one Resource
		 * const Resource = await prisma.resource.create({
		 *   data: {
		 *     // ... data to create a Resource
		 *   }
		 * })
		 *
		 **/
		create<T extends ResourceCreateArgs>(
			args: SelectSubset<T, ResourceCreateArgs>
		): CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>>

		/**
		 * Create many Resources.
		 *     @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
		 *     @example
		 *     // Create many Resources
		 *     const resource = await prisma.resource.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends ResourceCreateManyArgs>(
			args?: SelectSubset<T, ResourceCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Resource.
		 * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
		 * @example
		 * // Delete one Resource
		 * const Resource = await prisma.resource.delete({
		 *   where: {
		 *     // ... filter to delete one Resource
		 *   }
		 * })
		 *
		 **/
		delete<T extends ResourceDeleteArgs>(
			args: SelectSubset<T, ResourceDeleteArgs>
		): CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>>

		/**
		 * Update one Resource.
		 * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
		 * @example
		 * // Update one Resource
		 * const resource = await prisma.resource.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends ResourceUpdateArgs>(
			args: SelectSubset<T, ResourceUpdateArgs>
		): CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>>

		/**
		 * Delete zero or more Resources.
		 * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
		 * @example
		 * // Delete a few Resources
		 * const { count } = await prisma.resource.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends ResourceDeleteManyArgs>(
			args?: SelectSubset<T, ResourceDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Resources.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Resources
		 * const resource = await prisma.resource.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends ResourceUpdateManyArgs>(
			args: SelectSubset<T, ResourceUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Resource.
		 * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
		 * @example
		 * // Update or create a Resource
		 * const resource = await prisma.resource.upsert({
		 *   create: {
		 *     // ... data to create a Resource
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Resource we want to update
		 *   }
		 * })
		 **/
		upsert<T extends ResourceUpsertArgs>(
			args: SelectSubset<T, ResourceUpsertArgs>
		): CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>>

		/**
		 * Count the number of Resources.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
		 * @example
		 * // Count the number of Resources
		 * const count = await prisma.resource.count({
		 *   where: {
		 *     // ... the filter for the Resources we want to count
		 *   }
		 * })
		 **/
		count<T extends ResourceCountArgs>(
			args?: Subset<T, ResourceCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ResourceCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Resource.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): PrismaPromise<GetResourceAggregateType<T>>

		/**
		 * Group by Resource.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ResourceGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ResourceGroupByArgs['orderBy'] }
				: { orderBy?: ResourceGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Resource.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__ResourceClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		roles<T extends ResourceRoleFindManyArgs = {}>(args?: Subset<T, ResourceRoleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ResourceRole>>, PrismaPromise<Array<ResourceRoleGetPayload<T>>>>;

		blocks<T extends BlockFindManyArgs = {}>(args?: Subset<T, BlockFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Block>>, PrismaPromise<Array<BlockGetPayload<T>>>>;

		builds<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

		entities<T extends EntityFindManyArgs = {}>(args?: Subset<T, EntityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Entity>>, PrismaPromise<Array<EntityGetPayload<T>>>>;

		environments<T extends EnvironmentFindManyArgs = {}>(args?: Subset<T, EnvironmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Environment>>, PrismaPromise<Array<EnvironmentGetPayload<T>>>>;

		gitRepository<T extends GitRepositoryArgs = {}>(args?: Subset<T, GitRepositoryArgs>): CheckSelect<T, Prisma__GitRepositoryClient<GitRepository | null >, Prisma__GitRepositoryClient<GitRepositoryGetPayload<T> | null >>;

		project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Resource findUnique
	 */
	export type ResourceFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Resource
		 *
		 **/
		select?: ResourceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceInclude | null
		/**
		 * Throw an Error if a Resource can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Resource to fetch.
		 *
		 **/
		where: ResourceWhereUniqueInput
	}


	/**
	 * Resource findFirst
	 */
	export type ResourceFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Resource
		 *
		 **/
		select?: ResourceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceInclude | null
		/**
		 * Throw an Error if a Resource can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Resource to fetch.
		 *
		 **/
		where?: ResourceWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Resources to fetch.
		 *
		 **/
		orderBy?: Enumerable<ResourceOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Resources.
		 *
		 **/
		cursor?: ResourceWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Resources from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Resources.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Resources.
		 *
		 **/
		distinct?: Enumerable<ResourceScalarFieldEnum>
	}


	/**
	 * Resource findMany
	 */
	export type ResourceFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Resource
		 *
		 **/
		select?: ResourceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceInclude | null
		/**
		 * Filter, which Resources to fetch.
		 *
		 **/
		where?: ResourceWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Resources to fetch.
		 *
		 **/
		orderBy?: Enumerable<ResourceOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Resources.
		 *
		 **/
		cursor?: ResourceWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Resources from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Resources.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<ResourceScalarFieldEnum>
	}


	/**
	 * Resource create
	 */
	export type ResourceCreateArgs = {
		/**
		 * Select specific fields to fetch from the Resource
		 *
		 **/
		select?: ResourceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceInclude | null
		/**
		 * The data needed to create a Resource.
		 *
		 **/
		data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
	}


	/**
	 * Resource createMany
	 */
	export type ResourceCreateManyArgs = {
		/**
		 * The data used to create many Resources.
		 *
		 **/
		data: Enumerable<ResourceCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Resource update
	 */
	export type ResourceUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Resource
		 *
		 **/
		select?: ResourceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceInclude | null
		/**
		 * The data needed to update a Resource.
		 *
		 **/
		data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
		/**
		 * Choose, which Resource to update.
		 *
		 **/
		where: ResourceWhereUniqueInput
	}


	/**
	 * Resource updateMany
	 */
	export type ResourceUpdateManyArgs = {
		/**
		 * The data used to update Resources.
		 *
		 **/
		data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
		/**
		 * Filter which Resources to update
		 *
		 **/
		where?: ResourceWhereInput
	}


	/**
	 * Resource upsert
	 */
	export type ResourceUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Resource
		 *
		 **/
		select?: ResourceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceInclude | null
		/**
		 * The filter to search for the Resource to update in case it exists.
		 *
		 **/
		where: ResourceWhereUniqueInput
		/**
		 * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
		 *
		 **/
		create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
		/**
		 * In case the Resource was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
	}


	/**
	 * Resource delete
	 */
	export type ResourceDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Resource
		 *
		 **/
		select?: ResourceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceInclude | null
		/**
		 * Filter which Resource to delete.
		 *
		 **/
		where: ResourceWhereUniqueInput
	}


	/**
	 * Resource deleteMany
	 */
	export type ResourceDeleteManyArgs = {
		/**
		 * Filter which Resources to delete
		 *
		 **/
		where?: ResourceWhereInput
	}


	/**
	 * Resource without action
	 */
	export type ResourceArgs = {
		/**
		 * Select specific fields to fetch from the Resource
		 *
		 **/
		select?: ResourceSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceInclude | null
	}



	/**
	 * Model ResourceRole
	 */


	export type AggregateResourceRole = {
		_count: ResourceRoleCountAggregateOutputType | null
		_min: ResourceRoleMinAggregateOutputType | null
		_max: ResourceRoleMaxAggregateOutputType | null
	}

	export type ResourceRoleMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		resourceId: string | null
		name: string | null
		displayName: string | null
		description: string | null
	}

	export type ResourceRoleMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		resourceId: string | null
		name: string | null
		displayName: string | null
		description: string | null
	}

	export type ResourceRoleCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		resourceId: number
		name: number
		displayName: number
		description: number
		_all: number
	}


	export type ResourceRoleMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		name?: true
		displayName?: true
		description?: true
	}

	export type ResourceRoleMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		name?: true
		displayName?: true
		description?: true
	}

	export type ResourceRoleCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		name?: true
		displayName?: true
		description?: true
		_all?: true
	}

	export type ResourceRoleAggregateArgs = {
		/**
		 * Filter which ResourceRole to aggregate.
		 *
		 **/
		where?: ResourceRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ResourceRoles to fetch.
		 *
		 **/
		orderBy?: Enumerable<ResourceRoleOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: ResourceRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ResourceRoles from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ResourceRoles.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned ResourceRoles
		 **/
		_count?: true | ResourceRoleCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ResourceRoleMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ResourceRoleMaxAggregateInputType
	}

	export type GetResourceRoleAggregateType<T extends ResourceRoleAggregateArgs> = {
		[P in keyof T & keyof AggregateResourceRole]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateResourceRole[P]>
			: GetScalarType<T[P], AggregateResourceRole[P]>
	}




	export type ResourceRoleGroupByArgs = {
		where?: ResourceRoleWhereInput
		orderBy?: Enumerable<ResourceRoleOrderByWithAggregationInput>
		by: Array<ResourceRoleScalarFieldEnum>
		having?: ResourceRoleScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ResourceRoleCountAggregateInputType | true
		_min?: ResourceRoleMinAggregateInputType
		_max?: ResourceRoleMaxAggregateInputType
	}


	export type ResourceRoleGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		resourceId: string
		name: string
		displayName: string
		description: string | null
		_count: ResourceRoleCountAggregateOutputType | null
		_min: ResourceRoleMinAggregateOutputType | null
		_max: ResourceRoleMaxAggregateOutputType | null
	}

	type GetResourceRoleGroupByPayload<T extends ResourceRoleGroupByArgs> = PrismaPromise<
		Array<
			PickArray<ResourceRoleGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof ResourceRoleGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], ResourceRoleGroupByOutputType[P]>
				: GetScalarType<T[P], ResourceRoleGroupByOutputType[P]>
			}
			>
		>


	export type ResourceRoleSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		resourceId?: boolean
		name?: boolean
		displayName?: boolean
		description?: boolean
		resource?: boolean | ResourceArgs
		entityPermissionRoles?: boolean | EntityPermissionRoleFindManyArgs
		_count?: boolean | ResourceRoleCountOutputTypeArgs
	}

	export type ResourceRoleInclude = {
		resource?: boolean | ResourceArgs
		entityPermissionRoles?: boolean | EntityPermissionRoleFindManyArgs
		_count?: boolean | ResourceRoleCountOutputTypeArgs
	}

	export type ResourceRoleGetPayload<
		S extends boolean | null | undefined | ResourceRoleArgs,
		U = keyof S
		> = S extends true
		? ResourceRole
		: S extends undefined
			? never
			: S extends ResourceRoleArgs | ResourceRoleFindManyArgs
				?'include' extends U
					? ResourceRole  & {
					[P in TrueKeys<S['include']>]:
					P extends 'resource' ? ResourceGetPayload<S['include'][P]> :
						P extends 'entityPermissionRoles' ? Array < EntityPermissionRoleGetPayload<S['include'][P]>>  :
							P extends '_count' ? ResourceRoleCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'resource' ? ResourceGetPayload<S['select'][P]> :
								P extends 'entityPermissionRoles' ? Array < EntityPermissionRoleGetPayload<S['select'][P]>>  :
									P extends '_count' ? ResourceRoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ResourceRole ? ResourceRole[P] : never
						}
						: ResourceRole
				: ResourceRole


	type ResourceRoleCountArgs = Merge<
		Omit<ResourceRoleFindManyArgs, 'select' | 'include'> & {
		select?: ResourceRoleCountAggregateInputType | true
	}
		>

	export interface ResourceRoleDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one ResourceRole that matches the filter.
		 * @param {ResourceRoleFindUniqueArgs} args - Arguments to find a ResourceRole
		 * @example
		 * // Get one ResourceRole
		 * const resourceRole = await prisma.resourceRole.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends ResourceRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, ResourceRoleFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ResourceRole'> extends True ? CheckSelect<T, Prisma__ResourceRoleClient<ResourceRole>, Prisma__ResourceRoleClient<ResourceRoleGetPayload<T>>> : CheckSelect<T, Prisma__ResourceRoleClient<ResourceRole | null >, Prisma__ResourceRoleClient<ResourceRoleGetPayload<T> | null >>

		/**
		 * Find the first ResourceRole that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceRoleFindFirstArgs} args - Arguments to find a ResourceRole
		 * @example
		 * // Get one ResourceRole
		 * const resourceRole = await prisma.resourceRole.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends ResourceRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, ResourceRoleFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ResourceRole'> extends True ? CheckSelect<T, Prisma__ResourceRoleClient<ResourceRole>, Prisma__ResourceRoleClient<ResourceRoleGetPayload<T>>> : CheckSelect<T, Prisma__ResourceRoleClient<ResourceRole | null >, Prisma__ResourceRoleClient<ResourceRoleGetPayload<T> | null >>

		/**
		 * Find zero or more ResourceRoles that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all ResourceRoles
		 * const resourceRoles = await prisma.resourceRole.findMany()
		 *
		 * // Get first 10 ResourceRoles
		 * const resourceRoles = await prisma.resourceRole.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const resourceRoleWithIdOnly = await prisma.resourceRole.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends ResourceRoleFindManyArgs>(
			args?: SelectSubset<T, ResourceRoleFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<ResourceRole>>, PrismaPromise<Array<ResourceRoleGetPayload<T>>>>

		/**
		 * Create a ResourceRole.
		 * @param {ResourceRoleCreateArgs} args - Arguments to create a ResourceRole.
		 * @example
		 * // Create one ResourceRole
		 * const ResourceRole = await prisma.resourceRole.create({
		 *   data: {
		 *     // ... data to create a ResourceRole
		 *   }
		 * })
		 *
		 **/
		create<T extends ResourceRoleCreateArgs>(
			args: SelectSubset<T, ResourceRoleCreateArgs>
		): CheckSelect<T, Prisma__ResourceRoleClient<ResourceRole>, Prisma__ResourceRoleClient<ResourceRoleGetPayload<T>>>

		/**
		 * Create many ResourceRoles.
		 *     @param {ResourceRoleCreateManyArgs} args - Arguments to create many ResourceRoles.
		 *     @example
		 *     // Create many ResourceRoles
		 *     const resourceRole = await prisma.resourceRole.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends ResourceRoleCreateManyArgs>(
			args?: SelectSubset<T, ResourceRoleCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a ResourceRole.
		 * @param {ResourceRoleDeleteArgs} args - Arguments to delete one ResourceRole.
		 * @example
		 * // Delete one ResourceRole
		 * const ResourceRole = await prisma.resourceRole.delete({
		 *   where: {
		 *     // ... filter to delete one ResourceRole
		 *   }
		 * })
		 *
		 **/
		delete<T extends ResourceRoleDeleteArgs>(
			args: SelectSubset<T, ResourceRoleDeleteArgs>
		): CheckSelect<T, Prisma__ResourceRoleClient<ResourceRole>, Prisma__ResourceRoleClient<ResourceRoleGetPayload<T>>>

		/**
		 * Update one ResourceRole.
		 * @param {ResourceRoleUpdateArgs} args - Arguments to update one ResourceRole.
		 * @example
		 * // Update one ResourceRole
		 * const resourceRole = await prisma.resourceRole.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends ResourceRoleUpdateArgs>(
			args: SelectSubset<T, ResourceRoleUpdateArgs>
		): CheckSelect<T, Prisma__ResourceRoleClient<ResourceRole>, Prisma__ResourceRoleClient<ResourceRoleGetPayload<T>>>

		/**
		 * Delete zero or more ResourceRoles.
		 * @param {ResourceRoleDeleteManyArgs} args - Arguments to filter ResourceRoles to delete.
		 * @example
		 * // Delete a few ResourceRoles
		 * const { count } = await prisma.resourceRole.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends ResourceRoleDeleteManyArgs>(
			args?: SelectSubset<T, ResourceRoleDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more ResourceRoles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceRoleUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many ResourceRoles
		 * const resourceRole = await prisma.resourceRole.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends ResourceRoleUpdateManyArgs>(
			args: SelectSubset<T, ResourceRoleUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one ResourceRole.
		 * @param {ResourceRoleUpsertArgs} args - Arguments to update or create a ResourceRole.
		 * @example
		 * // Update or create a ResourceRole
		 * const resourceRole = await prisma.resourceRole.upsert({
		 *   create: {
		 *     // ... data to create a ResourceRole
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the ResourceRole we want to update
		 *   }
		 * })
		 **/
		upsert<T extends ResourceRoleUpsertArgs>(
			args: SelectSubset<T, ResourceRoleUpsertArgs>
		): CheckSelect<T, Prisma__ResourceRoleClient<ResourceRole>, Prisma__ResourceRoleClient<ResourceRoleGetPayload<T>>>

		/**
		 * Count the number of ResourceRoles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceRoleCountArgs} args - Arguments to filter ResourceRoles to count.
		 * @example
		 * // Count the number of ResourceRoles
		 * const count = await prisma.resourceRole.count({
		 *   where: {
		 *     // ... the filter for the ResourceRoles we want to count
		 *   }
		 * })
		 **/
		count<T extends ResourceRoleCountArgs>(
			args?: Subset<T, ResourceRoleCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ResourceRoleCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a ResourceRole.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ResourceRoleAggregateArgs>(args: Subset<T, ResourceRoleAggregateArgs>): PrismaPromise<GetResourceRoleAggregateType<T>>

		/**
		 * Group by ResourceRole.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ResourceRoleGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ResourceRoleGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ResourceRoleGroupByArgs['orderBy'] }
				: { orderBy?: ResourceRoleGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, ResourceRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceRoleGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for ResourceRole.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__ResourceRoleClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		resource<T extends ResourceArgs = {}>(args?: Subset<T, ResourceArgs>): CheckSelect<T, Prisma__ResourceClient<Resource | null >, Prisma__ResourceClient<ResourceGetPayload<T> | null >>;

		entityPermissionRoles<T extends EntityPermissionRoleFindManyArgs = {}>(args?: Subset<T, EntityPermissionRoleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityPermissionRole>>, PrismaPromise<Array<EntityPermissionRoleGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * ResourceRole findUnique
	 */
	export type ResourceRoleFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the ResourceRole
		 *
		 **/
		select?: ResourceRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceRoleInclude | null
		/**
		 * Throw an Error if a ResourceRole can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which ResourceRole to fetch.
		 *
		 **/
		where: ResourceRoleWhereUniqueInput
	}


	/**
	 * ResourceRole findFirst
	 */
	export type ResourceRoleFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the ResourceRole
		 *
		 **/
		select?: ResourceRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceRoleInclude | null
		/**
		 * Throw an Error if a ResourceRole can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which ResourceRole to fetch.
		 *
		 **/
		where?: ResourceRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ResourceRoles to fetch.
		 *
		 **/
		orderBy?: Enumerable<ResourceRoleOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for ResourceRoles.
		 *
		 **/
		cursor?: ResourceRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ResourceRoles from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ResourceRoles.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of ResourceRoles.
		 *
		 **/
		distinct?: Enumerable<ResourceRoleScalarFieldEnum>
	}


	/**
	 * ResourceRole findMany
	 */
	export type ResourceRoleFindManyArgs = {
		/**
		 * Select specific fields to fetch from the ResourceRole
		 *
		 **/
		select?: ResourceRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceRoleInclude | null
		/**
		 * Filter, which ResourceRoles to fetch.
		 *
		 **/
		where?: ResourceRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ResourceRoles to fetch.
		 *
		 **/
		orderBy?: Enumerable<ResourceRoleOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing ResourceRoles.
		 *
		 **/
		cursor?: ResourceRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ResourceRoles from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ResourceRoles.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<ResourceRoleScalarFieldEnum>
	}


	/**
	 * ResourceRole create
	 */
	export type ResourceRoleCreateArgs = {
		/**
		 * Select specific fields to fetch from the ResourceRole
		 *
		 **/
		select?: ResourceRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceRoleInclude | null
		/**
		 * The data needed to create a ResourceRole.
		 *
		 **/
		data: XOR<ResourceRoleCreateInput, ResourceRoleUncheckedCreateInput>
	}


	/**
	 * ResourceRole createMany
	 */
	export type ResourceRoleCreateManyArgs = {
		/**
		 * The data used to create many ResourceRoles.
		 *
		 **/
		data: Enumerable<ResourceRoleCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * ResourceRole update
	 */
	export type ResourceRoleUpdateArgs = {
		/**
		 * Select specific fields to fetch from the ResourceRole
		 *
		 **/
		select?: ResourceRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceRoleInclude | null
		/**
		 * The data needed to update a ResourceRole.
		 *
		 **/
		data: XOR<ResourceRoleUpdateInput, ResourceRoleUncheckedUpdateInput>
		/**
		 * Choose, which ResourceRole to update.
		 *
		 **/
		where: ResourceRoleWhereUniqueInput
	}


	/**
	 * ResourceRole updateMany
	 */
	export type ResourceRoleUpdateManyArgs = {
		/**
		 * The data used to update ResourceRoles.
		 *
		 **/
		data: XOR<ResourceRoleUpdateManyMutationInput, ResourceRoleUncheckedUpdateManyInput>
		/**
		 * Filter which ResourceRoles to update
		 *
		 **/
		where?: ResourceRoleWhereInput
	}


	/**
	 * ResourceRole upsert
	 */
	export type ResourceRoleUpsertArgs = {
		/**
		 * Select specific fields to fetch from the ResourceRole
		 *
		 **/
		select?: ResourceRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceRoleInclude | null
		/**
		 * The filter to search for the ResourceRole to update in case it exists.
		 *
		 **/
		where: ResourceRoleWhereUniqueInput
		/**
		 * In case the ResourceRole found by the `where` argument doesn't exist, create a new ResourceRole with this data.
		 *
		 **/
		create: XOR<ResourceRoleCreateInput, ResourceRoleUncheckedCreateInput>
		/**
		 * In case the ResourceRole was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<ResourceRoleUpdateInput, ResourceRoleUncheckedUpdateInput>
	}


	/**
	 * ResourceRole delete
	 */
	export type ResourceRoleDeleteArgs = {
		/**
		 * Select specific fields to fetch from the ResourceRole
		 *
		 **/
		select?: ResourceRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceRoleInclude | null
		/**
		 * Filter which ResourceRole to delete.
		 *
		 **/
		where: ResourceRoleWhereUniqueInput
	}


	/**
	 * ResourceRole deleteMany
	 */
	export type ResourceRoleDeleteManyArgs = {
		/**
		 * Filter which ResourceRoles to delete
		 *
		 **/
		where?: ResourceRoleWhereInput
	}


	/**
	 * ResourceRole without action
	 */
	export type ResourceRoleArgs = {
		/**
		 * Select specific fields to fetch from the ResourceRole
		 *
		 **/
		select?: ResourceRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ResourceRoleInclude | null
	}



	/**
	 * Model Commit
	 */


	export type AggregateCommit = {
		_count: CommitCountAggregateOutputType | null
		_min: CommitMinAggregateOutputType | null
		_max: CommitMaxAggregateOutputType | null
	}

	export type CommitMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		userId: string | null
		message: string | null
		projectId: string | null
	}

	export type CommitMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		userId: string | null
		message: string | null
		projectId: string | null
	}

	export type CommitCountAggregateOutputType = {
		id: number
		createdAt: number
		userId: number
		message: number
		projectId: number
		_all: number
	}


	export type CommitMinAggregateInputType = {
		id?: true
		createdAt?: true
		userId?: true
		message?: true
		projectId?: true
	}

	export type CommitMaxAggregateInputType = {
		id?: true
		createdAt?: true
		userId?: true
		message?: true
		projectId?: true
	}

	export type CommitCountAggregateInputType = {
		id?: true
		createdAt?: true
		userId?: true
		message?: true
		projectId?: true
		_all?: true
	}

	export type CommitAggregateArgs = {
		/**
		 * Filter which Commit to aggregate.
		 *
		 **/
		where?: CommitWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Commits to fetch.
		 *
		 **/
		orderBy?: Enumerable<CommitOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: CommitWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Commits from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Commits.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Commits
		 **/
		_count?: true | CommitCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: CommitMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: CommitMaxAggregateInputType
	}

	export type GetCommitAggregateType<T extends CommitAggregateArgs> = {
		[P in keyof T & keyof AggregateCommit]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateCommit[P]>
			: GetScalarType<T[P], AggregateCommit[P]>
	}




	export type CommitGroupByArgs = {
		where?: CommitWhereInput
		orderBy?: Enumerable<CommitOrderByWithAggregationInput>
		by: Array<CommitScalarFieldEnum>
		having?: CommitScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: CommitCountAggregateInputType | true
		_min?: CommitMinAggregateInputType
		_max?: CommitMaxAggregateInputType
	}


	export type CommitGroupByOutputType = {
		id: string
		createdAt: Date
		userId: string
		message: string
		projectId: string
		_count: CommitCountAggregateOutputType | null
		_min: CommitMinAggregateOutputType | null
		_max: CommitMaxAggregateOutputType | null
	}

	type GetCommitGroupByPayload<T extends CommitGroupByArgs> = PrismaPromise<
		Array<
			PickArray<CommitGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof CommitGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], CommitGroupByOutputType[P]>
				: GetScalarType<T[P], CommitGroupByOutputType[P]>
			}
			>
		>


	export type CommitSelect = {
		id?: boolean
		createdAt?: boolean
		userId?: boolean
		message?: boolean
		user?: boolean | UserArgs
		blockVersions?: boolean | BlockVersionFindManyArgs
		builds?: boolean | BuildFindManyArgs
		entityVersions?: boolean | EntityVersionFindManyArgs
		releases?: boolean | ReleaseFindManyArgs
		project?: boolean | ProjectArgs
		projectId?: boolean
		_count?: boolean | CommitCountOutputTypeArgs
	}

	export type CommitInclude = {
		user?: boolean | UserArgs
		blockVersions?: boolean | BlockVersionFindManyArgs
		builds?: boolean | BuildFindManyArgs
		entityVersions?: boolean | EntityVersionFindManyArgs
		releases?: boolean | ReleaseFindManyArgs
		project?: boolean | ProjectArgs
		_count?: boolean | CommitCountOutputTypeArgs
	}

	export type CommitGetPayload<
		S extends boolean | null | undefined | CommitArgs,
		U = keyof S
		> = S extends true
		? Commit
		: S extends undefined
			? never
			: S extends CommitArgs | CommitFindManyArgs
				?'include' extends U
					? Commit  & {
					[P in TrueKeys<S['include']>]:
					P extends 'user' ? UserGetPayload<S['include'][P]> :
						P extends 'blockVersions' ? Array < BlockVersionGetPayload<S['include'][P]>>  :
							P extends 'builds' ? Array < BuildGetPayload<S['include'][P]>>  :
								P extends 'entityVersions' ? Array < EntityVersionGetPayload<S['include'][P]>>  :
									P extends 'releases' ? Array < ReleaseGetPayload<S['include'][P]>>  :
										P extends 'project' ? ProjectGetPayload<S['include'][P]> :
											P extends '_count' ? CommitCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'user' ? UserGetPayload<S['select'][P]> :
								P extends 'blockVersions' ? Array < BlockVersionGetPayload<S['select'][P]>>  :
									P extends 'builds' ? Array < BuildGetPayload<S['select'][P]>>  :
										P extends 'entityVersions' ? Array < EntityVersionGetPayload<S['select'][P]>>  :
											P extends 'releases' ? Array < ReleaseGetPayload<S['select'][P]>>  :
												P extends 'project' ? ProjectGetPayload<S['select'][P]> :
													P extends '_count' ? CommitCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Commit ? Commit[P] : never
						}
						: Commit
				: Commit


	type CommitCountArgs = Merge<
		Omit<CommitFindManyArgs, 'select' | 'include'> & {
		select?: CommitCountAggregateInputType | true
	}
		>

	export interface CommitDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Commit that matches the filter.
		 * @param {CommitFindUniqueArgs} args - Arguments to find a Commit
		 * @example
		 * // Get one Commit
		 * const commit = await prisma.commit.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends CommitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, CommitFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Commit'> extends True ? CheckSelect<T, Prisma__CommitClient<Commit>, Prisma__CommitClient<CommitGetPayload<T>>> : CheckSelect<T, Prisma__CommitClient<Commit | null >, Prisma__CommitClient<CommitGetPayload<T> | null >>

		/**
		 * Find the first Commit that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CommitFindFirstArgs} args - Arguments to find a Commit
		 * @example
		 * // Get one Commit
		 * const commit = await prisma.commit.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends CommitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, CommitFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Commit'> extends True ? CheckSelect<T, Prisma__CommitClient<Commit>, Prisma__CommitClient<CommitGetPayload<T>>> : CheckSelect<T, Prisma__CommitClient<Commit | null >, Prisma__CommitClient<CommitGetPayload<T> | null >>

		/**
		 * Find zero or more Commits that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CommitFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Commits
		 * const commits = await prisma.commit.findMany()
		 *
		 * // Get first 10 Commits
		 * const commits = await prisma.commit.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const commitWithIdOnly = await prisma.commit.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends CommitFindManyArgs>(
			args?: SelectSubset<T, CommitFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Commit>>, PrismaPromise<Array<CommitGetPayload<T>>>>

		/**
		 * Create a Commit.
		 * @param {CommitCreateArgs} args - Arguments to create a Commit.
		 * @example
		 * // Create one Commit
		 * const Commit = await prisma.commit.create({
		 *   data: {
		 *     // ... data to create a Commit
		 *   }
		 * })
		 *
		 **/
		create<T extends CommitCreateArgs>(
			args: SelectSubset<T, CommitCreateArgs>
		): CheckSelect<T, Prisma__CommitClient<Commit>, Prisma__CommitClient<CommitGetPayload<T>>>

		/**
		 * Create many Commits.
		 *     @param {CommitCreateManyArgs} args - Arguments to create many Commits.
		 *     @example
		 *     // Create many Commits
		 *     const commit = await prisma.commit.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends CommitCreateManyArgs>(
			args?: SelectSubset<T, CommitCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Commit.
		 * @param {CommitDeleteArgs} args - Arguments to delete one Commit.
		 * @example
		 * // Delete one Commit
		 * const Commit = await prisma.commit.delete({
		 *   where: {
		 *     // ... filter to delete one Commit
		 *   }
		 * })
		 *
		 **/
		delete<T extends CommitDeleteArgs>(
			args: SelectSubset<T, CommitDeleteArgs>
		): CheckSelect<T, Prisma__CommitClient<Commit>, Prisma__CommitClient<CommitGetPayload<T>>>

		/**
		 * Update one Commit.
		 * @param {CommitUpdateArgs} args - Arguments to update one Commit.
		 * @example
		 * // Update one Commit
		 * const commit = await prisma.commit.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends CommitUpdateArgs>(
			args: SelectSubset<T, CommitUpdateArgs>
		): CheckSelect<T, Prisma__CommitClient<Commit>, Prisma__CommitClient<CommitGetPayload<T>>>

		/**
		 * Delete zero or more Commits.
		 * @param {CommitDeleteManyArgs} args - Arguments to filter Commits to delete.
		 * @example
		 * // Delete a few Commits
		 * const { count } = await prisma.commit.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends CommitDeleteManyArgs>(
			args?: SelectSubset<T, CommitDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Commits.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CommitUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Commits
		 * const commit = await prisma.commit.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends CommitUpdateManyArgs>(
			args: SelectSubset<T, CommitUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Commit.
		 * @param {CommitUpsertArgs} args - Arguments to update or create a Commit.
		 * @example
		 * // Update or create a Commit
		 * const commit = await prisma.commit.upsert({
		 *   create: {
		 *     // ... data to create a Commit
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Commit we want to update
		 *   }
		 * })
		 **/
		upsert<T extends CommitUpsertArgs>(
			args: SelectSubset<T, CommitUpsertArgs>
		): CheckSelect<T, Prisma__CommitClient<Commit>, Prisma__CommitClient<CommitGetPayload<T>>>

		/**
		 * Count the number of Commits.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CommitCountArgs} args - Arguments to filter Commits to count.
		 * @example
		 * // Count the number of Commits
		 * const count = await prisma.commit.count({
		 *   where: {
		 *     // ... the filter for the Commits we want to count
		 *   }
		 * })
		 **/
		count<T extends CommitCountArgs>(
			args?: Subset<T, CommitCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], CommitCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Commit.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CommitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends CommitAggregateArgs>(args: Subset<T, CommitAggregateArgs>): PrismaPromise<GetCommitAggregateType<T>>

		/**
		 * Group by Commit.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {CommitGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends CommitGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: CommitGroupByArgs['orderBy'] }
				: { orderBy?: CommitGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, CommitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommitGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Commit.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__CommitClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		blockVersions<T extends BlockVersionFindManyArgs = {}>(args?: Subset<T, BlockVersionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<BlockVersion>>, PrismaPromise<Array<BlockVersionGetPayload<T>>>>;

		builds<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

		entityVersions<T extends EntityVersionFindManyArgs = {}>(args?: Subset<T, EntityVersionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityVersion>>, PrismaPromise<Array<EntityVersionGetPayload<T>>>>;

		releases<T extends ReleaseFindManyArgs = {}>(args?: Subset<T, ReleaseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Release>>, PrismaPromise<Array<ReleaseGetPayload<T>>>>;

		project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Commit findUnique
	 */
	export type CommitFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Commit
		 *
		 **/
		select?: CommitSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: CommitInclude | null
		/**
		 * Throw an Error if a Commit can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Commit to fetch.
		 *
		 **/
		where: CommitWhereUniqueInput
	}


	/**
	 * Commit findFirst
	 */
	export type CommitFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Commit
		 *
		 **/
		select?: CommitSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: CommitInclude | null
		/**
		 * Throw an Error if a Commit can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Commit to fetch.
		 *
		 **/
		where?: CommitWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Commits to fetch.
		 *
		 **/
		orderBy?: Enumerable<CommitOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Commits.
		 *
		 **/
		cursor?: CommitWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Commits from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Commits.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Commits.
		 *
		 **/
		distinct?: Enumerable<CommitScalarFieldEnum>
	}


	/**
	 * Commit findMany
	 */
	export type CommitFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Commit
		 *
		 **/
		select?: CommitSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: CommitInclude | null
		/**
		 * Filter, which Commits to fetch.
		 *
		 **/
		where?: CommitWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Commits to fetch.
		 *
		 **/
		orderBy?: Enumerable<CommitOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Commits.
		 *
		 **/
		cursor?: CommitWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Commits from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Commits.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<CommitScalarFieldEnum>
	}


	/**
	 * Commit create
	 */
	export type CommitCreateArgs = {
		/**
		 * Select specific fields to fetch from the Commit
		 *
		 **/
		select?: CommitSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: CommitInclude | null
		/**
		 * The data needed to create a Commit.
		 *
		 **/
		data: XOR<CommitCreateInput, CommitUncheckedCreateInput>
	}


	/**
	 * Commit createMany
	 */
	export type CommitCreateManyArgs = {
		/**
		 * The data used to create many Commits.
		 *
		 **/
		data: Enumerable<CommitCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Commit update
	 */
	export type CommitUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Commit
		 *
		 **/
		select?: CommitSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: CommitInclude | null
		/**
		 * The data needed to update a Commit.
		 *
		 **/
		data: XOR<CommitUpdateInput, CommitUncheckedUpdateInput>
		/**
		 * Choose, which Commit to update.
		 *
		 **/
		where: CommitWhereUniqueInput
	}


	/**
	 * Commit updateMany
	 */
	export type CommitUpdateManyArgs = {
		/**
		 * The data used to update Commits.
		 *
		 **/
		data: XOR<CommitUpdateManyMutationInput, CommitUncheckedUpdateManyInput>
		/**
		 * Filter which Commits to update
		 *
		 **/
		where?: CommitWhereInput
	}


	/**
	 * Commit upsert
	 */
	export type CommitUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Commit
		 *
		 **/
		select?: CommitSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: CommitInclude | null
		/**
		 * The filter to search for the Commit to update in case it exists.
		 *
		 **/
		where: CommitWhereUniqueInput
		/**
		 * In case the Commit found by the `where` argument doesn't exist, create a new Commit with this data.
		 *
		 **/
		create: XOR<CommitCreateInput, CommitUncheckedCreateInput>
		/**
		 * In case the Commit was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<CommitUpdateInput, CommitUncheckedUpdateInput>
	}


	/**
	 * Commit delete
	 */
	export type CommitDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Commit
		 *
		 **/
		select?: CommitSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: CommitInclude | null
		/**
		 * Filter which Commit to delete.
		 *
		 **/
		where: CommitWhereUniqueInput
	}


	/**
	 * Commit deleteMany
	 */
	export type CommitDeleteManyArgs = {
		/**
		 * Filter which Commits to delete
		 *
		 **/
		where?: CommitWhereInput
	}


	/**
	 * Commit without action
	 */
	export type CommitArgs = {
		/**
		 * Select specific fields to fetch from the Commit
		 *
		 **/
		select?: CommitSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: CommitInclude | null
	}



	/**
	 * Model Entity
	 */


	export type AggregateEntity = {
		_count: EntityCountAggregateOutputType | null
		_min: EntityMinAggregateOutputType | null
		_max: EntityMaxAggregateOutputType | null
	}

	export type EntityMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		resourceId: string | null
		name: string | null
		displayName: string | null
		pluralDisplayName: string | null
		description: string | null
		lockedByUserId: string | null
		lockedAt: Date | null
		deletedAt: Date | null
	}

	export type EntityMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		resourceId: string | null
		name: string | null
		displayName: string | null
		pluralDisplayName: string | null
		description: string | null
		lockedByUserId: string | null
		lockedAt: Date | null
		deletedAt: Date | null
	}

	export type EntityCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		resourceId: number
		name: number
		displayName: number
		pluralDisplayName: number
		description: number
		lockedByUserId: number
		lockedAt: number
		deletedAt: number
		_all: number
	}


	export type EntityMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		name?: true
		displayName?: true
		pluralDisplayName?: true
		description?: true
		lockedByUserId?: true
		lockedAt?: true
		deletedAt?: true
	}

	export type EntityMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		name?: true
		displayName?: true
		pluralDisplayName?: true
		description?: true
		lockedByUserId?: true
		lockedAt?: true
		deletedAt?: true
	}

	export type EntityCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		name?: true
		displayName?: true
		pluralDisplayName?: true
		description?: true
		lockedByUserId?: true
		lockedAt?: true
		deletedAt?: true
		_all?: true
	}

	export type EntityAggregateArgs = {
		/**
		 * Filter which Entity to aggregate.
		 *
		 **/
		where?: EntityWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Entities to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: EntityWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Entities from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Entities.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Entities
		 **/
		_count?: true | EntityCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: EntityMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: EntityMaxAggregateInputType
	}

	export type GetEntityAggregateType<T extends EntityAggregateArgs> = {
		[P in keyof T & keyof AggregateEntity]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateEntity[P]>
			: GetScalarType<T[P], AggregateEntity[P]>
	}




	export type EntityGroupByArgs = {
		where?: EntityWhereInput
		orderBy?: Enumerable<EntityOrderByWithAggregationInput>
		by: Array<EntityScalarFieldEnum>
		having?: EntityScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: EntityCountAggregateInputType | true
		_min?: EntityMinAggregateInputType
		_max?: EntityMaxAggregateInputType
	}


	export type EntityGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		resourceId: string
		name: string
		displayName: string
		pluralDisplayName: string
		description: string | null
		lockedByUserId: string | null
		lockedAt: Date | null
		deletedAt: Date | null
		_count: EntityCountAggregateOutputType | null
		_min: EntityMinAggregateOutputType | null
		_max: EntityMaxAggregateOutputType | null
	}

	type GetEntityGroupByPayload<T extends EntityGroupByArgs> = PrismaPromise<
		Array<
			PickArray<EntityGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof EntityGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], EntityGroupByOutputType[P]>
				: GetScalarType<T[P], EntityGroupByOutputType[P]>
			}
			>
		>


	export type EntitySelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		resourceId?: boolean
		name?: boolean
		displayName?: boolean
		pluralDisplayName?: boolean
		description?: boolean
		lockedByUserId?: boolean
		lockedAt?: boolean
		deletedAt?: boolean
		resource?: boolean | ResourceArgs
		lockedByUser?: boolean | UserArgs
		versions?: boolean | EntityVersionFindManyArgs
		_count?: boolean | EntityCountOutputTypeArgs
	}

	export type EntityInclude = {
		resource?: boolean | ResourceArgs
		lockedByUser?: boolean | UserArgs
		versions?: boolean | EntityVersionFindManyArgs
		_count?: boolean | EntityCountOutputTypeArgs
	}

	export type EntityGetPayload<
		S extends boolean | null | undefined | EntityArgs,
		U = keyof S
		> = S extends true
		? Entity
		: S extends undefined
			? never
			: S extends EntityArgs | EntityFindManyArgs
				?'include' extends U
					? Entity  & {
					[P in TrueKeys<S['include']>]:
					P extends 'resource' ? ResourceGetPayload<S['include'][P]> :
						P extends 'lockedByUser' ? UserGetPayload<S['include'][P]> | null :
							P extends 'versions' ? Array < EntityVersionGetPayload<S['include'][P]>>  :
								P extends '_count' ? EntityCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'resource' ? ResourceGetPayload<S['select'][P]> :
								P extends 'lockedByUser' ? UserGetPayload<S['select'][P]> | null :
									P extends 'versions' ? Array < EntityVersionGetPayload<S['select'][P]>>  :
										P extends '_count' ? EntityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Entity ? Entity[P] : never
						}
						: Entity
				: Entity


	type EntityCountArgs = Merge<
		Omit<EntityFindManyArgs, 'select' | 'include'> & {
		select?: EntityCountAggregateInputType | true
	}
		>

	export interface EntityDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Entity that matches the filter.
		 * @param {EntityFindUniqueArgs} args - Arguments to find a Entity
		 * @example
		 * // Get one Entity
		 * const entity = await prisma.entity.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends EntityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, EntityFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Entity'> extends True ? CheckSelect<T, Prisma__EntityClient<Entity>, Prisma__EntityClient<EntityGetPayload<T>>> : CheckSelect<T, Prisma__EntityClient<Entity | null >, Prisma__EntityClient<EntityGetPayload<T> | null >>

		/**
		 * Find the first Entity that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityFindFirstArgs} args - Arguments to find a Entity
		 * @example
		 * // Get one Entity
		 * const entity = await prisma.entity.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends EntityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, EntityFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Entity'> extends True ? CheckSelect<T, Prisma__EntityClient<Entity>, Prisma__EntityClient<EntityGetPayload<T>>> : CheckSelect<T, Prisma__EntityClient<Entity | null >, Prisma__EntityClient<EntityGetPayload<T> | null >>

		/**
		 * Find zero or more Entities that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Entities
		 * const entities = await prisma.entity.findMany()
		 *
		 * // Get first 10 Entities
		 * const entities = await prisma.entity.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const entityWithIdOnly = await prisma.entity.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends EntityFindManyArgs>(
			args?: SelectSubset<T, EntityFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Entity>>, PrismaPromise<Array<EntityGetPayload<T>>>>

		/**
		 * Create a Entity.
		 * @param {EntityCreateArgs} args - Arguments to create a Entity.
		 * @example
		 * // Create one Entity
		 * const Entity = await prisma.entity.create({
		 *   data: {
		 *     // ... data to create a Entity
		 *   }
		 * })
		 *
		 **/
		create<T extends EntityCreateArgs>(
			args: SelectSubset<T, EntityCreateArgs>
		): CheckSelect<T, Prisma__EntityClient<Entity>, Prisma__EntityClient<EntityGetPayload<T>>>

		/**
		 * Create many Entities.
		 *     @param {EntityCreateManyArgs} args - Arguments to create many Entities.
		 *     @example
		 *     // Create many Entities
		 *     const entity = await prisma.entity.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends EntityCreateManyArgs>(
			args?: SelectSubset<T, EntityCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Entity.
		 * @param {EntityDeleteArgs} args - Arguments to delete one Entity.
		 * @example
		 * // Delete one Entity
		 * const Entity = await prisma.entity.delete({
		 *   where: {
		 *     // ... filter to delete one Entity
		 *   }
		 * })
		 *
		 **/
		delete<T extends EntityDeleteArgs>(
			args: SelectSubset<T, EntityDeleteArgs>
		): CheckSelect<T, Prisma__EntityClient<Entity>, Prisma__EntityClient<EntityGetPayload<T>>>

		/**
		 * Update one Entity.
		 * @param {EntityUpdateArgs} args - Arguments to update one Entity.
		 * @example
		 * // Update one Entity
		 * const entity = await prisma.entity.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends EntityUpdateArgs>(
			args: SelectSubset<T, EntityUpdateArgs>
		): CheckSelect<T, Prisma__EntityClient<Entity>, Prisma__EntityClient<EntityGetPayload<T>>>

		/**
		 * Delete zero or more Entities.
		 * @param {EntityDeleteManyArgs} args - Arguments to filter Entities to delete.
		 * @example
		 * // Delete a few Entities
		 * const { count } = await prisma.entity.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends EntityDeleteManyArgs>(
			args?: SelectSubset<T, EntityDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Entities.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Entities
		 * const entity = await prisma.entity.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends EntityUpdateManyArgs>(
			args: SelectSubset<T, EntityUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Entity.
		 * @param {EntityUpsertArgs} args - Arguments to update or create a Entity.
		 * @example
		 * // Update or create a Entity
		 * const entity = await prisma.entity.upsert({
		 *   create: {
		 *     // ... data to create a Entity
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Entity we want to update
		 *   }
		 * })
		 **/
		upsert<T extends EntityUpsertArgs>(
			args: SelectSubset<T, EntityUpsertArgs>
		): CheckSelect<T, Prisma__EntityClient<Entity>, Prisma__EntityClient<EntityGetPayload<T>>>

		/**
		 * Count the number of Entities.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityCountArgs} args - Arguments to filter Entities to count.
		 * @example
		 * // Count the number of Entities
		 * const count = await prisma.entity.count({
		 *   where: {
		 *     // ... the filter for the Entities we want to count
		 *   }
		 * })
		 **/
		count<T extends EntityCountArgs>(
			args?: Subset<T, EntityCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], EntityCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Entity.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends EntityAggregateArgs>(args: Subset<T, EntityAggregateArgs>): PrismaPromise<GetEntityAggregateType<T>>

		/**
		 * Group by Entity.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends EntityGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: EntityGroupByArgs['orderBy'] }
				: { orderBy?: EntityGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, EntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Entity.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__EntityClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		resource<T extends ResourceArgs = {}>(args?: Subset<T, ResourceArgs>): CheckSelect<T, Prisma__ResourceClient<Resource | null >, Prisma__ResourceClient<ResourceGetPayload<T> | null >>;

		lockedByUser<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		versions<T extends EntityVersionFindManyArgs = {}>(args?: Subset<T, EntityVersionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityVersion>>, PrismaPromise<Array<EntityVersionGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Entity findUnique
	 */
	export type EntityFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Entity
		 *
		 **/
		select?: EntitySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityInclude | null
		/**
		 * Throw an Error if a Entity can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Entity to fetch.
		 *
		 **/
		where: EntityWhereUniqueInput
	}


	/**
	 * Entity findFirst
	 */
	export type EntityFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Entity
		 *
		 **/
		select?: EntitySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityInclude | null
		/**
		 * Throw an Error if a Entity can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Entity to fetch.
		 *
		 **/
		where?: EntityWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Entities to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Entities.
		 *
		 **/
		cursor?: EntityWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Entities from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Entities.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Entities.
		 *
		 **/
		distinct?: Enumerable<EntityScalarFieldEnum>
	}


	/**
	 * Entity findMany
	 */
	export type EntityFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Entity
		 *
		 **/
		select?: EntitySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityInclude | null
		/**
		 * Filter, which Entities to fetch.
		 *
		 **/
		where?: EntityWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Entities to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Entities.
		 *
		 **/
		cursor?: EntityWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Entities from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Entities.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<EntityScalarFieldEnum>
	}


	/**
	 * Entity create
	 */
	export type EntityCreateArgs = {
		/**
		 * Select specific fields to fetch from the Entity
		 *
		 **/
		select?: EntitySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityInclude | null
		/**
		 * The data needed to create a Entity.
		 *
		 **/
		data: XOR<EntityCreateInput, EntityUncheckedCreateInput>
	}


	/**
	 * Entity createMany
	 */
	export type EntityCreateManyArgs = {
		/**
		 * The data used to create many Entities.
		 *
		 **/
		data: Enumerable<EntityCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Entity update
	 */
	export type EntityUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Entity
		 *
		 **/
		select?: EntitySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityInclude | null
		/**
		 * The data needed to update a Entity.
		 *
		 **/
		data: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
		/**
		 * Choose, which Entity to update.
		 *
		 **/
		where: EntityWhereUniqueInput
	}


	/**
	 * Entity updateMany
	 */
	export type EntityUpdateManyArgs = {
		/**
		 * The data used to update Entities.
		 *
		 **/
		data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyInput>
		/**
		 * Filter which Entities to update
		 *
		 **/
		where?: EntityWhereInput
	}


	/**
	 * Entity upsert
	 */
	export type EntityUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Entity
		 *
		 **/
		select?: EntitySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityInclude | null
		/**
		 * The filter to search for the Entity to update in case it exists.
		 *
		 **/
		where: EntityWhereUniqueInput
		/**
		 * In case the Entity found by the `where` argument doesn't exist, create a new Entity with this data.
		 *
		 **/
		create: XOR<EntityCreateInput, EntityUncheckedCreateInput>
		/**
		 * In case the Entity was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<EntityUpdateInput, EntityUncheckedUpdateInput>
	}


	/**
	 * Entity delete
	 */
	export type EntityDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Entity
		 *
		 **/
		select?: EntitySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityInclude | null
		/**
		 * Filter which Entity to delete.
		 *
		 **/
		where: EntityWhereUniqueInput
	}


	/**
	 * Entity deleteMany
	 */
	export type EntityDeleteManyArgs = {
		/**
		 * Filter which Entities to delete
		 *
		 **/
		where?: EntityWhereInput
	}


	/**
	 * Entity without action
	 */
	export type EntityArgs = {
		/**
		 * Select specific fields to fetch from the Entity
		 *
		 **/
		select?: EntitySelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityInclude | null
	}



	/**
	 * Model EntityVersion
	 */


	export type AggregateEntityVersion = {
		_count: EntityVersionCountAggregateOutputType | null
		_avg: EntityVersionAvgAggregateOutputType | null
		_sum: EntityVersionSumAggregateOutputType | null
		_min: EntityVersionMinAggregateOutputType | null
		_max: EntityVersionMaxAggregateOutputType | null
	}

	export type EntityVersionAvgAggregateOutputType = {
		versionNumber: number | null
	}

	export type EntityVersionSumAggregateOutputType = {
		versionNumber: number | null
	}

	export type EntityVersionMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		entityId: string | null
		versionNumber: number | null
		name: string | null
		displayName: string | null
		pluralDisplayName: string | null
		description: string | null
		commitId: string | null
		deleted: boolean | null
	}

	export type EntityVersionMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		entityId: string | null
		versionNumber: number | null
		name: string | null
		displayName: string | null
		pluralDisplayName: string | null
		description: string | null
		commitId: string | null
		deleted: boolean | null
	}

	export type EntityVersionCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		entityId: number
		versionNumber: number
		name: number
		displayName: number
		pluralDisplayName: number
		description: number
		commitId: number
		deleted: number
		_all: number
	}


	export type EntityVersionAvgAggregateInputType = {
		versionNumber?: true
	}

	export type EntityVersionSumAggregateInputType = {
		versionNumber?: true
	}

	export type EntityVersionMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		entityId?: true
		versionNumber?: true
		name?: true
		displayName?: true
		pluralDisplayName?: true
		description?: true
		commitId?: true
		deleted?: true
	}

	export type EntityVersionMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		entityId?: true
		versionNumber?: true
		name?: true
		displayName?: true
		pluralDisplayName?: true
		description?: true
		commitId?: true
		deleted?: true
	}

	export type EntityVersionCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		entityId?: true
		versionNumber?: true
		name?: true
		displayName?: true
		pluralDisplayName?: true
		description?: true
		commitId?: true
		deleted?: true
		_all?: true
	}

	export type EntityVersionAggregateArgs = {
		/**
		 * Filter which EntityVersion to aggregate.
		 *
		 **/
		where?: EntityVersionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityVersions to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityVersionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: EntityVersionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityVersions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityVersions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned EntityVersions
		 **/
		_count?: true | EntityVersionCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: EntityVersionAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: EntityVersionSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: EntityVersionMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: EntityVersionMaxAggregateInputType
	}

	export type GetEntityVersionAggregateType<T extends EntityVersionAggregateArgs> = {
		[P in keyof T & keyof AggregateEntityVersion]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateEntityVersion[P]>
			: GetScalarType<T[P], AggregateEntityVersion[P]>
	}




	export type EntityVersionGroupByArgs = {
		where?: EntityVersionWhereInput
		orderBy?: Enumerable<EntityVersionOrderByWithAggregationInput>
		by: Array<EntityVersionScalarFieldEnum>
		having?: EntityVersionScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: EntityVersionCountAggregateInputType | true
		_avg?: EntityVersionAvgAggregateInputType
		_sum?: EntityVersionSumAggregateInputType
		_min?: EntityVersionMinAggregateInputType
		_max?: EntityVersionMaxAggregateInputType
	}


	export type EntityVersionGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		entityId: string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description: string | null
		commitId: string | null
		deleted: boolean | null
		_count: EntityVersionCountAggregateOutputType | null
		_avg: EntityVersionAvgAggregateOutputType | null
		_sum: EntityVersionSumAggregateOutputType | null
		_min: EntityVersionMinAggregateOutputType | null
		_max: EntityVersionMaxAggregateOutputType | null
	}

	type GetEntityVersionGroupByPayload<T extends EntityVersionGroupByArgs> = PrismaPromise<
		Array<
			PickArray<EntityVersionGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof EntityVersionGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], EntityVersionGroupByOutputType[P]>
				: GetScalarType<T[P], EntityVersionGroupByOutputType[P]>
			}
			>
		>


	export type EntityVersionSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		entityId?: boolean
		versionNumber?: boolean
		name?: boolean
		displayName?: boolean
		pluralDisplayName?: boolean
		description?: boolean
		commitId?: boolean
		deleted?: boolean
		commit?: boolean | CommitArgs
		entity?: boolean | EntityArgs
		fields?: boolean | EntityFieldFindManyArgs
		permissions?: boolean | EntityPermissionFindManyArgs
		builds?: boolean | BuildFindManyArgs
		_count?: boolean | EntityVersionCountOutputTypeArgs
	}

	export type EntityVersionInclude = {
		commit?: boolean | CommitArgs
		entity?: boolean | EntityArgs
		fields?: boolean | EntityFieldFindManyArgs
		permissions?: boolean | EntityPermissionFindManyArgs
		builds?: boolean | BuildFindManyArgs
		_count?: boolean | EntityVersionCountOutputTypeArgs
	}

	export type EntityVersionGetPayload<
		S extends boolean | null | undefined | EntityVersionArgs,
		U = keyof S
		> = S extends true
		? EntityVersion
		: S extends undefined
			? never
			: S extends EntityVersionArgs | EntityVersionFindManyArgs
				?'include' extends U
					? EntityVersion  & {
					[P in TrueKeys<S['include']>]:
					P extends 'commit' ? CommitGetPayload<S['include'][P]> | null :
						P extends 'entity' ? EntityGetPayload<S['include'][P]> :
							P extends 'fields' ? Array < EntityFieldGetPayload<S['include'][P]>>  :
								P extends 'permissions' ? Array < EntityPermissionGetPayload<S['include'][P]>>  :
									P extends 'builds' ? Array < BuildGetPayload<S['include'][P]>>  :
										P extends '_count' ? EntityVersionCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'commit' ? CommitGetPayload<S['select'][P]> | null :
								P extends 'entity' ? EntityGetPayload<S['select'][P]> :
									P extends 'fields' ? Array < EntityFieldGetPayload<S['select'][P]>>  :
										P extends 'permissions' ? Array < EntityPermissionGetPayload<S['select'][P]>>  :
											P extends 'builds' ? Array < BuildGetPayload<S['select'][P]>>  :
												P extends '_count' ? EntityVersionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof EntityVersion ? EntityVersion[P] : never
						}
						: EntityVersion
				: EntityVersion


	type EntityVersionCountArgs = Merge<
		Omit<EntityVersionFindManyArgs, 'select' | 'include'> & {
		select?: EntityVersionCountAggregateInputType | true
	}
		>

	export interface EntityVersionDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one EntityVersion that matches the filter.
		 * @param {EntityVersionFindUniqueArgs} args - Arguments to find a EntityVersion
		 * @example
		 * // Get one EntityVersion
		 * const entityVersion = await prisma.entityVersion.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends EntityVersionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, EntityVersionFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EntityVersion'> extends True ? CheckSelect<T, Prisma__EntityVersionClient<EntityVersion>, Prisma__EntityVersionClient<EntityVersionGetPayload<T>>> : CheckSelect<T, Prisma__EntityVersionClient<EntityVersion | null >, Prisma__EntityVersionClient<EntityVersionGetPayload<T> | null >>

		/**
		 * Find the first EntityVersion that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityVersionFindFirstArgs} args - Arguments to find a EntityVersion
		 * @example
		 * // Get one EntityVersion
		 * const entityVersion = await prisma.entityVersion.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends EntityVersionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, EntityVersionFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EntityVersion'> extends True ? CheckSelect<T, Prisma__EntityVersionClient<EntityVersion>, Prisma__EntityVersionClient<EntityVersionGetPayload<T>>> : CheckSelect<T, Prisma__EntityVersionClient<EntityVersion | null >, Prisma__EntityVersionClient<EntityVersionGetPayload<T> | null >>

		/**
		 * Find zero or more EntityVersions that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityVersionFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all EntityVersions
		 * const entityVersions = await prisma.entityVersion.findMany()
		 *
		 * // Get first 10 EntityVersions
		 * const entityVersions = await prisma.entityVersion.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const entityVersionWithIdOnly = await prisma.entityVersion.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends EntityVersionFindManyArgs>(
			args?: SelectSubset<T, EntityVersionFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<EntityVersion>>, PrismaPromise<Array<EntityVersionGetPayload<T>>>>

		/**
		 * Create a EntityVersion.
		 * @param {EntityVersionCreateArgs} args - Arguments to create a EntityVersion.
		 * @example
		 * // Create one EntityVersion
		 * const EntityVersion = await prisma.entityVersion.create({
		 *   data: {
		 *     // ... data to create a EntityVersion
		 *   }
		 * })
		 *
		 **/
		create<T extends EntityVersionCreateArgs>(
			args: SelectSubset<T, EntityVersionCreateArgs>
		): CheckSelect<T, Prisma__EntityVersionClient<EntityVersion>, Prisma__EntityVersionClient<EntityVersionGetPayload<T>>>

		/**
		 * Create many EntityVersions.
		 *     @param {EntityVersionCreateManyArgs} args - Arguments to create many EntityVersions.
		 *     @example
		 *     // Create many EntityVersions
		 *     const entityVersion = await prisma.entityVersion.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends EntityVersionCreateManyArgs>(
			args?: SelectSubset<T, EntityVersionCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a EntityVersion.
		 * @param {EntityVersionDeleteArgs} args - Arguments to delete one EntityVersion.
		 * @example
		 * // Delete one EntityVersion
		 * const EntityVersion = await prisma.entityVersion.delete({
		 *   where: {
		 *     // ... filter to delete one EntityVersion
		 *   }
		 * })
		 *
		 **/
		delete<T extends EntityVersionDeleteArgs>(
			args: SelectSubset<T, EntityVersionDeleteArgs>
		): CheckSelect<T, Prisma__EntityVersionClient<EntityVersion>, Prisma__EntityVersionClient<EntityVersionGetPayload<T>>>

		/**
		 * Update one EntityVersion.
		 * @param {EntityVersionUpdateArgs} args - Arguments to update one EntityVersion.
		 * @example
		 * // Update one EntityVersion
		 * const entityVersion = await prisma.entityVersion.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends EntityVersionUpdateArgs>(
			args: SelectSubset<T, EntityVersionUpdateArgs>
		): CheckSelect<T, Prisma__EntityVersionClient<EntityVersion>, Prisma__EntityVersionClient<EntityVersionGetPayload<T>>>

		/**
		 * Delete zero or more EntityVersions.
		 * @param {EntityVersionDeleteManyArgs} args - Arguments to filter EntityVersions to delete.
		 * @example
		 * // Delete a few EntityVersions
		 * const { count } = await prisma.entityVersion.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends EntityVersionDeleteManyArgs>(
			args?: SelectSubset<T, EntityVersionDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more EntityVersions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityVersionUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many EntityVersions
		 * const entityVersion = await prisma.entityVersion.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends EntityVersionUpdateManyArgs>(
			args: SelectSubset<T, EntityVersionUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one EntityVersion.
		 * @param {EntityVersionUpsertArgs} args - Arguments to update or create a EntityVersion.
		 * @example
		 * // Update or create a EntityVersion
		 * const entityVersion = await prisma.entityVersion.upsert({
		 *   create: {
		 *     // ... data to create a EntityVersion
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the EntityVersion we want to update
		 *   }
		 * })
		 **/
		upsert<T extends EntityVersionUpsertArgs>(
			args: SelectSubset<T, EntityVersionUpsertArgs>
		): CheckSelect<T, Prisma__EntityVersionClient<EntityVersion>, Prisma__EntityVersionClient<EntityVersionGetPayload<T>>>

		/**
		 * Count the number of EntityVersions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityVersionCountArgs} args - Arguments to filter EntityVersions to count.
		 * @example
		 * // Count the number of EntityVersions
		 * const count = await prisma.entityVersion.count({
		 *   where: {
		 *     // ... the filter for the EntityVersions we want to count
		 *   }
		 * })
		 **/
		count<T extends EntityVersionCountArgs>(
			args?: Subset<T, EntityVersionCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], EntityVersionCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a EntityVersion.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends EntityVersionAggregateArgs>(args: Subset<T, EntityVersionAggregateArgs>): PrismaPromise<GetEntityVersionAggregateType<T>>

		/**
		 * Group by EntityVersion.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityVersionGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends EntityVersionGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: EntityVersionGroupByArgs['orderBy'] }
				: { orderBy?: EntityVersionGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, EntityVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityVersionGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for EntityVersion.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__EntityVersionClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		commit<T extends CommitArgs = {}>(args?: Subset<T, CommitArgs>): CheckSelect<T, Prisma__CommitClient<Commit | null >, Prisma__CommitClient<CommitGetPayload<T> | null >>;

		entity<T extends EntityArgs = {}>(args?: Subset<T, EntityArgs>): CheckSelect<T, Prisma__EntityClient<Entity | null >, Prisma__EntityClient<EntityGetPayload<T> | null >>;

		fields<T extends EntityFieldFindManyArgs = {}>(args?: Subset<T, EntityFieldFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityField>>, PrismaPromise<Array<EntityFieldGetPayload<T>>>>;

		permissions<T extends EntityPermissionFindManyArgs = {}>(args?: Subset<T, EntityPermissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityPermission>>, PrismaPromise<Array<EntityPermissionGetPayload<T>>>>;

		builds<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * EntityVersion findUnique
	 */
	export type EntityVersionFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the EntityVersion
		 *
		 **/
		select?: EntityVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityVersionInclude | null
		/**
		 * Throw an Error if a EntityVersion can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityVersion to fetch.
		 *
		 **/
		where: EntityVersionWhereUniqueInput
	}


	/**
	 * EntityVersion findFirst
	 */
	export type EntityVersionFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the EntityVersion
		 *
		 **/
		select?: EntityVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityVersionInclude | null
		/**
		 * Throw an Error if a EntityVersion can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityVersion to fetch.
		 *
		 **/
		where?: EntityVersionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityVersions to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityVersionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for EntityVersions.
		 *
		 **/
		cursor?: EntityVersionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityVersions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityVersions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of EntityVersions.
		 *
		 **/
		distinct?: Enumerable<EntityVersionScalarFieldEnum>
	}


	/**
	 * EntityVersion findMany
	 */
	export type EntityVersionFindManyArgs = {
		/**
		 * Select specific fields to fetch from the EntityVersion
		 *
		 **/
		select?: EntityVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityVersionInclude | null
		/**
		 * Filter, which EntityVersions to fetch.
		 *
		 **/
		where?: EntityVersionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityVersions to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityVersionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing EntityVersions.
		 *
		 **/
		cursor?: EntityVersionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityVersions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityVersions.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<EntityVersionScalarFieldEnum>
	}


	/**
	 * EntityVersion create
	 */
	export type EntityVersionCreateArgs = {
		/**
		 * Select specific fields to fetch from the EntityVersion
		 *
		 **/
		select?: EntityVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityVersionInclude | null
		/**
		 * The data needed to create a EntityVersion.
		 *
		 **/
		data: XOR<EntityVersionCreateInput, EntityVersionUncheckedCreateInput>
	}


	/**
	 * EntityVersion createMany
	 */
	export type EntityVersionCreateManyArgs = {
		/**
		 * The data used to create many EntityVersions.
		 *
		 **/
		data: Enumerable<EntityVersionCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * EntityVersion update
	 */
	export type EntityVersionUpdateArgs = {
		/**
		 * Select specific fields to fetch from the EntityVersion
		 *
		 **/
		select?: EntityVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityVersionInclude | null
		/**
		 * The data needed to update a EntityVersion.
		 *
		 **/
		data: XOR<EntityVersionUpdateInput, EntityVersionUncheckedUpdateInput>
		/**
		 * Choose, which EntityVersion to update.
		 *
		 **/
		where: EntityVersionWhereUniqueInput
	}


	/**
	 * EntityVersion updateMany
	 */
	export type EntityVersionUpdateManyArgs = {
		/**
		 * The data used to update EntityVersions.
		 *
		 **/
		data: XOR<EntityVersionUpdateManyMutationInput, EntityVersionUncheckedUpdateManyInput>
		/**
		 * Filter which EntityVersions to update
		 *
		 **/
		where?: EntityVersionWhereInput
	}


	/**
	 * EntityVersion upsert
	 */
	export type EntityVersionUpsertArgs = {
		/**
		 * Select specific fields to fetch from the EntityVersion
		 *
		 **/
		select?: EntityVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityVersionInclude | null
		/**
		 * The filter to search for the EntityVersion to update in case it exists.
		 *
		 **/
		where: EntityVersionWhereUniqueInput
		/**
		 * In case the EntityVersion found by the `where` argument doesn't exist, create a new EntityVersion with this data.
		 *
		 **/
		create: XOR<EntityVersionCreateInput, EntityVersionUncheckedCreateInput>
		/**
		 * In case the EntityVersion was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<EntityVersionUpdateInput, EntityVersionUncheckedUpdateInput>
	}


	/**
	 * EntityVersion delete
	 */
	export type EntityVersionDeleteArgs = {
		/**
		 * Select specific fields to fetch from the EntityVersion
		 *
		 **/
		select?: EntityVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityVersionInclude | null
		/**
		 * Filter which EntityVersion to delete.
		 *
		 **/
		where: EntityVersionWhereUniqueInput
	}


	/**
	 * EntityVersion deleteMany
	 */
	export type EntityVersionDeleteManyArgs = {
		/**
		 * Filter which EntityVersions to delete
		 *
		 **/
		where?: EntityVersionWhereInput
	}


	/**
	 * EntityVersion without action
	 */
	export type EntityVersionArgs = {
		/**
		 * Select specific fields to fetch from the EntityVersion
		 *
		 **/
		select?: EntityVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityVersionInclude | null
	}



	/**
	 * Model EntityPermission
	 */


	export type AggregateEntityPermission = {
		_count: EntityPermissionCountAggregateOutputType | null
		_min: EntityPermissionMinAggregateOutputType | null
		_max: EntityPermissionMaxAggregateOutputType | null
	}

	export type EntityPermissionMinAggregateOutputType = {
		id: string | null
		entityVersionId: string | null
		action: EnumEntityAction | null
		type: EnumEntityPermissionType | null
	}

	export type EntityPermissionMaxAggregateOutputType = {
		id: string | null
		entityVersionId: string | null
		action: EnumEntityAction | null
		type: EnumEntityPermissionType | null
	}

	export type EntityPermissionCountAggregateOutputType = {
		id: number
		entityVersionId: number
		action: number
		type: number
		_all: number
	}


	export type EntityPermissionMinAggregateInputType = {
		id?: true
		entityVersionId?: true
		action?: true
		type?: true
	}

	export type EntityPermissionMaxAggregateInputType = {
		id?: true
		entityVersionId?: true
		action?: true
		type?: true
	}

	export type EntityPermissionCountAggregateInputType = {
		id?: true
		entityVersionId?: true
		action?: true
		type?: true
		_all?: true
	}

	export type EntityPermissionAggregateArgs = {
		/**
		 * Filter which EntityPermission to aggregate.
		 *
		 **/
		where?: EntityPermissionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityPermissions to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityPermissionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: EntityPermissionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityPermissions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityPermissions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned EntityPermissions
		 **/
		_count?: true | EntityPermissionCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: EntityPermissionMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: EntityPermissionMaxAggregateInputType
	}

	export type GetEntityPermissionAggregateType<T extends EntityPermissionAggregateArgs> = {
		[P in keyof T & keyof AggregateEntityPermission]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateEntityPermission[P]>
			: GetScalarType<T[P], AggregateEntityPermission[P]>
	}




	export type EntityPermissionGroupByArgs = {
		where?: EntityPermissionWhereInput
		orderBy?: Enumerable<EntityPermissionOrderByWithAggregationInput>
		by: Array<EntityPermissionScalarFieldEnum>
		having?: EntityPermissionScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: EntityPermissionCountAggregateInputType | true
		_min?: EntityPermissionMinAggregateInputType
		_max?: EntityPermissionMaxAggregateInputType
	}


	export type EntityPermissionGroupByOutputType = {
		id: string
		entityVersionId: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
		_count: EntityPermissionCountAggregateOutputType | null
		_min: EntityPermissionMinAggregateOutputType | null
		_max: EntityPermissionMaxAggregateOutputType | null
	}

	type GetEntityPermissionGroupByPayload<T extends EntityPermissionGroupByArgs> = PrismaPromise<
		Array<
			PickArray<EntityPermissionGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof EntityPermissionGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], EntityPermissionGroupByOutputType[P]>
				: GetScalarType<T[P], EntityPermissionGroupByOutputType[P]>
			}
			>
		>


	export type EntityPermissionSelect = {
		id?: boolean
		entityVersionId?: boolean
		action?: boolean
		type?: boolean
		entityVersion?: boolean | EntityVersionArgs
		permissionFields?: boolean | EntityPermissionFieldFindManyArgs
		permissionRoles?: boolean | EntityPermissionRoleFindManyArgs
		_count?: boolean | EntityPermissionCountOutputTypeArgs
	}

	export type EntityPermissionInclude = {
		entityVersion?: boolean | EntityVersionArgs
		permissionFields?: boolean | EntityPermissionFieldFindManyArgs
		permissionRoles?: boolean | EntityPermissionRoleFindManyArgs
		_count?: boolean | EntityPermissionCountOutputTypeArgs
	}

	export type EntityPermissionGetPayload<
		S extends boolean | null | undefined | EntityPermissionArgs,
		U = keyof S
		> = S extends true
		? EntityPermission
		: S extends undefined
			? never
			: S extends EntityPermissionArgs | EntityPermissionFindManyArgs
				?'include' extends U
					? EntityPermission  & {
					[P in TrueKeys<S['include']>]:
					P extends 'entityVersion' ? EntityVersionGetPayload<S['include'][P]> :
						P extends 'permissionFields' ? Array < EntityPermissionFieldGetPayload<S['include'][P]>>  :
							P extends 'permissionRoles' ? Array < EntityPermissionRoleGetPayload<S['include'][P]>>  :
								P extends '_count' ? EntityPermissionCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'entityVersion' ? EntityVersionGetPayload<S['select'][P]> :
								P extends 'permissionFields' ? Array < EntityPermissionFieldGetPayload<S['select'][P]>>  :
									P extends 'permissionRoles' ? Array < EntityPermissionRoleGetPayload<S['select'][P]>>  :
										P extends '_count' ? EntityPermissionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof EntityPermission ? EntityPermission[P] : never
						}
						: EntityPermission
				: EntityPermission


	type EntityPermissionCountArgs = Merge<
		Omit<EntityPermissionFindManyArgs, 'select' | 'include'> & {
		select?: EntityPermissionCountAggregateInputType | true
	}
		>

	export interface EntityPermissionDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one EntityPermission that matches the filter.
		 * @param {EntityPermissionFindUniqueArgs} args - Arguments to find a EntityPermission
		 * @example
		 * // Get one EntityPermission
		 * const entityPermission = await prisma.entityPermission.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends EntityPermissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, EntityPermissionFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EntityPermission'> extends True ? CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission>, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T>>> : CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission | null >, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T> | null >>

		/**
		 * Find the first EntityPermission that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionFindFirstArgs} args - Arguments to find a EntityPermission
		 * @example
		 * // Get one EntityPermission
		 * const entityPermission = await prisma.entityPermission.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends EntityPermissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, EntityPermissionFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EntityPermission'> extends True ? CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission>, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T>>> : CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission | null >, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T> | null >>

		/**
		 * Find zero or more EntityPermissions that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all EntityPermissions
		 * const entityPermissions = await prisma.entityPermission.findMany()
		 *
		 * // Get first 10 EntityPermissions
		 * const entityPermissions = await prisma.entityPermission.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const entityPermissionWithIdOnly = await prisma.entityPermission.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends EntityPermissionFindManyArgs>(
			args?: SelectSubset<T, EntityPermissionFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<EntityPermission>>, PrismaPromise<Array<EntityPermissionGetPayload<T>>>>

		/**
		 * Create a EntityPermission.
		 * @param {EntityPermissionCreateArgs} args - Arguments to create a EntityPermission.
		 * @example
		 * // Create one EntityPermission
		 * const EntityPermission = await prisma.entityPermission.create({
		 *   data: {
		 *     // ... data to create a EntityPermission
		 *   }
		 * })
		 *
		 **/
		create<T extends EntityPermissionCreateArgs>(
			args: SelectSubset<T, EntityPermissionCreateArgs>
		): CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission>, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T>>>

		/**
		 * Create many EntityPermissions.
		 *     @param {EntityPermissionCreateManyArgs} args - Arguments to create many EntityPermissions.
		 *     @example
		 *     // Create many EntityPermissions
		 *     const entityPermission = await prisma.entityPermission.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends EntityPermissionCreateManyArgs>(
			args?: SelectSubset<T, EntityPermissionCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a EntityPermission.
		 * @param {EntityPermissionDeleteArgs} args - Arguments to delete one EntityPermission.
		 * @example
		 * // Delete one EntityPermission
		 * const EntityPermission = await prisma.entityPermission.delete({
		 *   where: {
		 *     // ... filter to delete one EntityPermission
		 *   }
		 * })
		 *
		 **/
		delete<T extends EntityPermissionDeleteArgs>(
			args: SelectSubset<T, EntityPermissionDeleteArgs>
		): CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission>, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T>>>

		/**
		 * Update one EntityPermission.
		 * @param {EntityPermissionUpdateArgs} args - Arguments to update one EntityPermission.
		 * @example
		 * // Update one EntityPermission
		 * const entityPermission = await prisma.entityPermission.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends EntityPermissionUpdateArgs>(
			args: SelectSubset<T, EntityPermissionUpdateArgs>
		): CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission>, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T>>>

		/**
		 * Delete zero or more EntityPermissions.
		 * @param {EntityPermissionDeleteManyArgs} args - Arguments to filter EntityPermissions to delete.
		 * @example
		 * // Delete a few EntityPermissions
		 * const { count } = await prisma.entityPermission.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends EntityPermissionDeleteManyArgs>(
			args?: SelectSubset<T, EntityPermissionDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more EntityPermissions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many EntityPermissions
		 * const entityPermission = await prisma.entityPermission.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends EntityPermissionUpdateManyArgs>(
			args: SelectSubset<T, EntityPermissionUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one EntityPermission.
		 * @param {EntityPermissionUpsertArgs} args - Arguments to update or create a EntityPermission.
		 * @example
		 * // Update or create a EntityPermission
		 * const entityPermission = await prisma.entityPermission.upsert({
		 *   create: {
		 *     // ... data to create a EntityPermission
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the EntityPermission we want to update
		 *   }
		 * })
		 **/
		upsert<T extends EntityPermissionUpsertArgs>(
			args: SelectSubset<T, EntityPermissionUpsertArgs>
		): CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission>, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T>>>

		/**
		 * Count the number of EntityPermissions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionCountArgs} args - Arguments to filter EntityPermissions to count.
		 * @example
		 * // Count the number of EntityPermissions
		 * const count = await prisma.entityPermission.count({
		 *   where: {
		 *     // ... the filter for the EntityPermissions we want to count
		 *   }
		 * })
		 **/
		count<T extends EntityPermissionCountArgs>(
			args?: Subset<T, EntityPermissionCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], EntityPermissionCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a EntityPermission.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends EntityPermissionAggregateArgs>(args: Subset<T, EntityPermissionAggregateArgs>): PrismaPromise<GetEntityPermissionAggregateType<T>>

		/**
		 * Group by EntityPermission.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends EntityPermissionGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: EntityPermissionGroupByArgs['orderBy'] }
				: { orderBy?: EntityPermissionGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, EntityPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityPermissionGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for EntityPermission.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__EntityPermissionClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		entityVersion<T extends EntityVersionArgs = {}>(args?: Subset<T, EntityVersionArgs>): CheckSelect<T, Prisma__EntityVersionClient<EntityVersion | null >, Prisma__EntityVersionClient<EntityVersionGetPayload<T> | null >>;

		permissionFields<T extends EntityPermissionFieldFindManyArgs = {}>(args?: Subset<T, EntityPermissionFieldFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityPermissionField>>, PrismaPromise<Array<EntityPermissionFieldGetPayload<T>>>>;

		permissionRoles<T extends EntityPermissionRoleFindManyArgs = {}>(args?: Subset<T, EntityPermissionRoleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityPermissionRole>>, PrismaPromise<Array<EntityPermissionRoleGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * EntityPermission findUnique
	 */
	export type EntityPermissionFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermission
		 *
		 **/
		select?: EntityPermissionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionInclude | null
		/**
		 * Throw an Error if a EntityPermission can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityPermission to fetch.
		 *
		 **/
		where: EntityPermissionWhereUniqueInput
	}


	/**
	 * EntityPermission findFirst
	 */
	export type EntityPermissionFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermission
		 *
		 **/
		select?: EntityPermissionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionInclude | null
		/**
		 * Throw an Error if a EntityPermission can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityPermission to fetch.
		 *
		 **/
		where?: EntityPermissionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityPermissions to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityPermissionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for EntityPermissions.
		 *
		 **/
		cursor?: EntityPermissionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityPermissions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityPermissions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of EntityPermissions.
		 *
		 **/
		distinct?: Enumerable<EntityPermissionScalarFieldEnum>
	}


	/**
	 * EntityPermission findMany
	 */
	export type EntityPermissionFindManyArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermission
		 *
		 **/
		select?: EntityPermissionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionInclude | null
		/**
		 * Filter, which EntityPermissions to fetch.
		 *
		 **/
		where?: EntityPermissionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityPermissions to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityPermissionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing EntityPermissions.
		 *
		 **/
		cursor?: EntityPermissionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityPermissions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityPermissions.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<EntityPermissionScalarFieldEnum>
	}


	/**
	 * EntityPermission create
	 */
	export type EntityPermissionCreateArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermission
		 *
		 **/
		select?: EntityPermissionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionInclude | null
		/**
		 * The data needed to create a EntityPermission.
		 *
		 **/
		data: XOR<EntityPermissionCreateInput, EntityPermissionUncheckedCreateInput>
	}


	/**
	 * EntityPermission createMany
	 */
	export type EntityPermissionCreateManyArgs = {
		/**
		 * The data used to create many EntityPermissions.
		 *
		 **/
		data: Enumerable<EntityPermissionCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * EntityPermission update
	 */
	export type EntityPermissionUpdateArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermission
		 *
		 **/
		select?: EntityPermissionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionInclude | null
		/**
		 * The data needed to update a EntityPermission.
		 *
		 **/
		data: XOR<EntityPermissionUpdateInput, EntityPermissionUncheckedUpdateInput>
		/**
		 * Choose, which EntityPermission to update.
		 *
		 **/
		where: EntityPermissionWhereUniqueInput
	}


	/**
	 * EntityPermission updateMany
	 */
	export type EntityPermissionUpdateManyArgs = {
		/**
		 * The data used to update EntityPermissions.
		 *
		 **/
		data: XOR<EntityPermissionUpdateManyMutationInput, EntityPermissionUncheckedUpdateManyInput>
		/**
		 * Filter which EntityPermissions to update
		 *
		 **/
		where?: EntityPermissionWhereInput
	}


	/**
	 * EntityPermission upsert
	 */
	export type EntityPermissionUpsertArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermission
		 *
		 **/
		select?: EntityPermissionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionInclude | null
		/**
		 * The filter to search for the EntityPermission to update in case it exists.
		 *
		 **/
		where: EntityPermissionWhereUniqueInput
		/**
		 * In case the EntityPermission found by the `where` argument doesn't exist, create a new EntityPermission with this data.
		 *
		 **/
		create: XOR<EntityPermissionCreateInput, EntityPermissionUncheckedCreateInput>
		/**
		 * In case the EntityPermission was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<EntityPermissionUpdateInput, EntityPermissionUncheckedUpdateInput>
	}


	/**
	 * EntityPermission delete
	 */
	export type EntityPermissionDeleteArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermission
		 *
		 **/
		select?: EntityPermissionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionInclude | null
		/**
		 * Filter which EntityPermission to delete.
		 *
		 **/
		where: EntityPermissionWhereUniqueInput
	}


	/**
	 * EntityPermission deleteMany
	 */
	export type EntityPermissionDeleteManyArgs = {
		/**
		 * Filter which EntityPermissions to delete
		 *
		 **/
		where?: EntityPermissionWhereInput
	}


	/**
	 * EntityPermission without action
	 */
	export type EntityPermissionArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermission
		 *
		 **/
		select?: EntityPermissionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionInclude | null
	}



	/**
	 * Model EntityPermissionRole
	 */


	export type AggregateEntityPermissionRole = {
		_count: EntityPermissionRoleCountAggregateOutputType | null
		_min: EntityPermissionRoleMinAggregateOutputType | null
		_max: EntityPermissionRoleMaxAggregateOutputType | null
	}

	export type EntityPermissionRoleMinAggregateOutputType = {
		id: string | null
		entityVersionId: string | null
		action: EnumEntityAction | null
		resourceRoleId: string | null
	}

	export type EntityPermissionRoleMaxAggregateOutputType = {
		id: string | null
		entityVersionId: string | null
		action: EnumEntityAction | null
		resourceRoleId: string | null
	}

	export type EntityPermissionRoleCountAggregateOutputType = {
		id: number
		entityVersionId: number
		action: number
		resourceRoleId: number
		_all: number
	}


	export type EntityPermissionRoleMinAggregateInputType = {
		id?: true
		entityVersionId?: true
		action?: true
		resourceRoleId?: true
	}

	export type EntityPermissionRoleMaxAggregateInputType = {
		id?: true
		entityVersionId?: true
		action?: true
		resourceRoleId?: true
	}

	export type EntityPermissionRoleCountAggregateInputType = {
		id?: true
		entityVersionId?: true
		action?: true
		resourceRoleId?: true
		_all?: true
	}

	export type EntityPermissionRoleAggregateArgs = {
		/**
		 * Filter which EntityPermissionRole to aggregate.
		 *
		 **/
		where?: EntityPermissionRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityPermissionRoles to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityPermissionRoleOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: EntityPermissionRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityPermissionRoles from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityPermissionRoles.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned EntityPermissionRoles
		 **/
		_count?: true | EntityPermissionRoleCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: EntityPermissionRoleMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: EntityPermissionRoleMaxAggregateInputType
	}

	export type GetEntityPermissionRoleAggregateType<T extends EntityPermissionRoleAggregateArgs> = {
		[P in keyof T & keyof AggregateEntityPermissionRole]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateEntityPermissionRole[P]>
			: GetScalarType<T[P], AggregateEntityPermissionRole[P]>
	}




	export type EntityPermissionRoleGroupByArgs = {
		where?: EntityPermissionRoleWhereInput
		orderBy?: Enumerable<EntityPermissionRoleOrderByWithAggregationInput>
		by: Array<EntityPermissionRoleScalarFieldEnum>
		having?: EntityPermissionRoleScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: EntityPermissionRoleCountAggregateInputType | true
		_min?: EntityPermissionRoleMinAggregateInputType
		_max?: EntityPermissionRoleMaxAggregateInputType
	}


	export type EntityPermissionRoleGroupByOutputType = {
		id: string
		entityVersionId: string
		action: EnumEntityAction
		resourceRoleId: string
		_count: EntityPermissionRoleCountAggregateOutputType | null
		_min: EntityPermissionRoleMinAggregateOutputType | null
		_max: EntityPermissionRoleMaxAggregateOutputType | null
	}

	type GetEntityPermissionRoleGroupByPayload<T extends EntityPermissionRoleGroupByArgs> = PrismaPromise<
		Array<
			PickArray<EntityPermissionRoleGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof EntityPermissionRoleGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], EntityPermissionRoleGroupByOutputType[P]>
				: GetScalarType<T[P], EntityPermissionRoleGroupByOutputType[P]>
			}
			>
		>


	export type EntityPermissionRoleSelect = {
		id?: boolean
		entityVersionId?: boolean
		action?: boolean
		resourceRoleId?: boolean
		resourceRole?: boolean | ResourceRoleArgs
		permission?: boolean | EntityPermissionArgs
		permissionFields?: boolean | EntityPermissionFieldFindManyArgs
		_count?: boolean | EntityPermissionRoleCountOutputTypeArgs
	}

	export type EntityPermissionRoleInclude = {
		resourceRole?: boolean | ResourceRoleArgs
		permission?: boolean | EntityPermissionArgs
		permissionFields?: boolean | EntityPermissionFieldFindManyArgs
		_count?: boolean | EntityPermissionRoleCountOutputTypeArgs
	}

	export type EntityPermissionRoleGetPayload<
		S extends boolean | null | undefined | EntityPermissionRoleArgs,
		U = keyof S
		> = S extends true
		? EntityPermissionRole
		: S extends undefined
			? never
			: S extends EntityPermissionRoleArgs | EntityPermissionRoleFindManyArgs
				?'include' extends U
					? EntityPermissionRole  & {
					[P in TrueKeys<S['include']>]:
					P extends 'resourceRole' ? ResourceRoleGetPayload<S['include'][P]> :
						P extends 'permission' ? EntityPermissionGetPayload<S['include'][P]> :
							P extends 'permissionFields' ? Array < EntityPermissionFieldGetPayload<S['include'][P]>>  :
								P extends '_count' ? EntityPermissionRoleCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'resourceRole' ? ResourceRoleGetPayload<S['select'][P]> :
								P extends 'permission' ? EntityPermissionGetPayload<S['select'][P]> :
									P extends 'permissionFields' ? Array < EntityPermissionFieldGetPayload<S['select'][P]>>  :
										P extends '_count' ? EntityPermissionRoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof EntityPermissionRole ? EntityPermissionRole[P] : never
						}
						: EntityPermissionRole
				: EntityPermissionRole


	type EntityPermissionRoleCountArgs = Merge<
		Omit<EntityPermissionRoleFindManyArgs, 'select' | 'include'> & {
		select?: EntityPermissionRoleCountAggregateInputType | true
	}
		>

	export interface EntityPermissionRoleDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one EntityPermissionRole that matches the filter.
		 * @param {EntityPermissionRoleFindUniqueArgs} args - Arguments to find a EntityPermissionRole
		 * @example
		 * // Get one EntityPermissionRole
		 * const entityPermissionRole = await prisma.entityPermissionRole.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends EntityPermissionRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, EntityPermissionRoleFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EntityPermissionRole'> extends True ? CheckSelect<T, Prisma__EntityPermissionRoleClient<EntityPermissionRole>, Prisma__EntityPermissionRoleClient<EntityPermissionRoleGetPayload<T>>> : CheckSelect<T, Prisma__EntityPermissionRoleClient<EntityPermissionRole | null >, Prisma__EntityPermissionRoleClient<EntityPermissionRoleGetPayload<T> | null >>

		/**
		 * Find the first EntityPermissionRole that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionRoleFindFirstArgs} args - Arguments to find a EntityPermissionRole
		 * @example
		 * // Get one EntityPermissionRole
		 * const entityPermissionRole = await prisma.entityPermissionRole.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends EntityPermissionRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, EntityPermissionRoleFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EntityPermissionRole'> extends True ? CheckSelect<T, Prisma__EntityPermissionRoleClient<EntityPermissionRole>, Prisma__EntityPermissionRoleClient<EntityPermissionRoleGetPayload<T>>> : CheckSelect<T, Prisma__EntityPermissionRoleClient<EntityPermissionRole | null >, Prisma__EntityPermissionRoleClient<EntityPermissionRoleGetPayload<T> | null >>

		/**
		 * Find zero or more EntityPermissionRoles that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all EntityPermissionRoles
		 * const entityPermissionRoles = await prisma.entityPermissionRole.findMany()
		 *
		 * // Get first 10 EntityPermissionRoles
		 * const entityPermissionRoles = await prisma.entityPermissionRole.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const entityPermissionRoleWithIdOnly = await prisma.entityPermissionRole.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends EntityPermissionRoleFindManyArgs>(
			args?: SelectSubset<T, EntityPermissionRoleFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<EntityPermissionRole>>, PrismaPromise<Array<EntityPermissionRoleGetPayload<T>>>>

		/**
		 * Create a EntityPermissionRole.
		 * @param {EntityPermissionRoleCreateArgs} args - Arguments to create a EntityPermissionRole.
		 * @example
		 * // Create one EntityPermissionRole
		 * const EntityPermissionRole = await prisma.entityPermissionRole.create({
		 *   data: {
		 *     // ... data to create a EntityPermissionRole
		 *   }
		 * })
		 *
		 **/
		create<T extends EntityPermissionRoleCreateArgs>(
			args: SelectSubset<T, EntityPermissionRoleCreateArgs>
		): CheckSelect<T, Prisma__EntityPermissionRoleClient<EntityPermissionRole>, Prisma__EntityPermissionRoleClient<EntityPermissionRoleGetPayload<T>>>

		/**
		 * Create many EntityPermissionRoles.
		 *     @param {EntityPermissionRoleCreateManyArgs} args - Arguments to create many EntityPermissionRoles.
		 *     @example
		 *     // Create many EntityPermissionRoles
		 *     const entityPermissionRole = await prisma.entityPermissionRole.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends EntityPermissionRoleCreateManyArgs>(
			args?: SelectSubset<T, EntityPermissionRoleCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a EntityPermissionRole.
		 * @param {EntityPermissionRoleDeleteArgs} args - Arguments to delete one EntityPermissionRole.
		 * @example
		 * // Delete one EntityPermissionRole
		 * const EntityPermissionRole = await prisma.entityPermissionRole.delete({
		 *   where: {
		 *     // ... filter to delete one EntityPermissionRole
		 *   }
		 * })
		 *
		 **/
		delete<T extends EntityPermissionRoleDeleteArgs>(
			args: SelectSubset<T, EntityPermissionRoleDeleteArgs>
		): CheckSelect<T, Prisma__EntityPermissionRoleClient<EntityPermissionRole>, Prisma__EntityPermissionRoleClient<EntityPermissionRoleGetPayload<T>>>

		/**
		 * Update one EntityPermissionRole.
		 * @param {EntityPermissionRoleUpdateArgs} args - Arguments to update one EntityPermissionRole.
		 * @example
		 * // Update one EntityPermissionRole
		 * const entityPermissionRole = await prisma.entityPermissionRole.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends EntityPermissionRoleUpdateArgs>(
			args: SelectSubset<T, EntityPermissionRoleUpdateArgs>
		): CheckSelect<T, Prisma__EntityPermissionRoleClient<EntityPermissionRole>, Prisma__EntityPermissionRoleClient<EntityPermissionRoleGetPayload<T>>>

		/**
		 * Delete zero or more EntityPermissionRoles.
		 * @param {EntityPermissionRoleDeleteManyArgs} args - Arguments to filter EntityPermissionRoles to delete.
		 * @example
		 * // Delete a few EntityPermissionRoles
		 * const { count } = await prisma.entityPermissionRole.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends EntityPermissionRoleDeleteManyArgs>(
			args?: SelectSubset<T, EntityPermissionRoleDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more EntityPermissionRoles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionRoleUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many EntityPermissionRoles
		 * const entityPermissionRole = await prisma.entityPermissionRole.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends EntityPermissionRoleUpdateManyArgs>(
			args: SelectSubset<T, EntityPermissionRoleUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one EntityPermissionRole.
		 * @param {EntityPermissionRoleUpsertArgs} args - Arguments to update or create a EntityPermissionRole.
		 * @example
		 * // Update or create a EntityPermissionRole
		 * const entityPermissionRole = await prisma.entityPermissionRole.upsert({
		 *   create: {
		 *     // ... data to create a EntityPermissionRole
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the EntityPermissionRole we want to update
		 *   }
		 * })
		 **/
		upsert<T extends EntityPermissionRoleUpsertArgs>(
			args: SelectSubset<T, EntityPermissionRoleUpsertArgs>
		): CheckSelect<T, Prisma__EntityPermissionRoleClient<EntityPermissionRole>, Prisma__EntityPermissionRoleClient<EntityPermissionRoleGetPayload<T>>>

		/**
		 * Count the number of EntityPermissionRoles.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionRoleCountArgs} args - Arguments to filter EntityPermissionRoles to count.
		 * @example
		 * // Count the number of EntityPermissionRoles
		 * const count = await prisma.entityPermissionRole.count({
		 *   where: {
		 *     // ... the filter for the EntityPermissionRoles we want to count
		 *   }
		 * })
		 **/
		count<T extends EntityPermissionRoleCountArgs>(
			args?: Subset<T, EntityPermissionRoleCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], EntityPermissionRoleCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a EntityPermissionRole.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends EntityPermissionRoleAggregateArgs>(args: Subset<T, EntityPermissionRoleAggregateArgs>): PrismaPromise<GetEntityPermissionRoleAggregateType<T>>

		/**
		 * Group by EntityPermissionRole.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionRoleGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends EntityPermissionRoleGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: EntityPermissionRoleGroupByArgs['orderBy'] }
				: { orderBy?: EntityPermissionRoleGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, EntityPermissionRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityPermissionRoleGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for EntityPermissionRole.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__EntityPermissionRoleClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		resourceRole<T extends ResourceRoleArgs = {}>(args?: Subset<T, ResourceRoleArgs>): CheckSelect<T, Prisma__ResourceRoleClient<ResourceRole | null >, Prisma__ResourceRoleClient<ResourceRoleGetPayload<T> | null >>;

		permission<T extends EntityPermissionArgs = {}>(args?: Subset<T, EntityPermissionArgs>): CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission | null >, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T> | null >>;

		permissionFields<T extends EntityPermissionFieldFindManyArgs = {}>(args?: Subset<T, EntityPermissionFieldFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityPermissionField>>, PrismaPromise<Array<EntityPermissionFieldGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * EntityPermissionRole findUnique
	 */
	export type EntityPermissionRoleFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionRole
		 *
		 **/
		select?: EntityPermissionRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionRoleInclude | null
		/**
		 * Throw an Error if a EntityPermissionRole can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityPermissionRole to fetch.
		 *
		 **/
		where: EntityPermissionRoleWhereUniqueInput
	}


	/**
	 * EntityPermissionRole findFirst
	 */
	export type EntityPermissionRoleFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionRole
		 *
		 **/
		select?: EntityPermissionRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionRoleInclude | null
		/**
		 * Throw an Error if a EntityPermissionRole can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityPermissionRole to fetch.
		 *
		 **/
		where?: EntityPermissionRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityPermissionRoles to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityPermissionRoleOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for EntityPermissionRoles.
		 *
		 **/
		cursor?: EntityPermissionRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityPermissionRoles from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityPermissionRoles.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of EntityPermissionRoles.
		 *
		 **/
		distinct?: Enumerable<EntityPermissionRoleScalarFieldEnum>
	}


	/**
	 * EntityPermissionRole findMany
	 */
	export type EntityPermissionRoleFindManyArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionRole
		 *
		 **/
		select?: EntityPermissionRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionRoleInclude | null
		/**
		 * Filter, which EntityPermissionRoles to fetch.
		 *
		 **/
		where?: EntityPermissionRoleWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityPermissionRoles to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityPermissionRoleOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing EntityPermissionRoles.
		 *
		 **/
		cursor?: EntityPermissionRoleWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityPermissionRoles from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityPermissionRoles.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<EntityPermissionRoleScalarFieldEnum>
	}


	/**
	 * EntityPermissionRole create
	 */
	export type EntityPermissionRoleCreateArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionRole
		 *
		 **/
		select?: EntityPermissionRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionRoleInclude | null
		/**
		 * The data needed to create a EntityPermissionRole.
		 *
		 **/
		data: XOR<EntityPermissionRoleCreateInput, EntityPermissionRoleUncheckedCreateInput>
	}


	/**
	 * EntityPermissionRole createMany
	 */
	export type EntityPermissionRoleCreateManyArgs = {
		/**
		 * The data used to create many EntityPermissionRoles.
		 *
		 **/
		data: Enumerable<EntityPermissionRoleCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * EntityPermissionRole update
	 */
	export type EntityPermissionRoleUpdateArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionRole
		 *
		 **/
		select?: EntityPermissionRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionRoleInclude | null
		/**
		 * The data needed to update a EntityPermissionRole.
		 *
		 **/
		data: XOR<EntityPermissionRoleUpdateInput, EntityPermissionRoleUncheckedUpdateInput>
		/**
		 * Choose, which EntityPermissionRole to update.
		 *
		 **/
		where: EntityPermissionRoleWhereUniqueInput
	}


	/**
	 * EntityPermissionRole updateMany
	 */
	export type EntityPermissionRoleUpdateManyArgs = {
		/**
		 * The data used to update EntityPermissionRoles.
		 *
		 **/
		data: XOR<EntityPermissionRoleUpdateManyMutationInput, EntityPermissionRoleUncheckedUpdateManyInput>
		/**
		 * Filter which EntityPermissionRoles to update
		 *
		 **/
		where?: EntityPermissionRoleWhereInput
	}


	/**
	 * EntityPermissionRole upsert
	 */
	export type EntityPermissionRoleUpsertArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionRole
		 *
		 **/
		select?: EntityPermissionRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionRoleInclude | null
		/**
		 * The filter to search for the EntityPermissionRole to update in case it exists.
		 *
		 **/
		where: EntityPermissionRoleWhereUniqueInput
		/**
		 * In case the EntityPermissionRole found by the `where` argument doesn't exist, create a new EntityPermissionRole with this data.
		 *
		 **/
		create: XOR<EntityPermissionRoleCreateInput, EntityPermissionRoleUncheckedCreateInput>
		/**
		 * In case the EntityPermissionRole was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<EntityPermissionRoleUpdateInput, EntityPermissionRoleUncheckedUpdateInput>
	}


	/**
	 * EntityPermissionRole delete
	 */
	export type EntityPermissionRoleDeleteArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionRole
		 *
		 **/
		select?: EntityPermissionRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionRoleInclude | null
		/**
		 * Filter which EntityPermissionRole to delete.
		 *
		 **/
		where: EntityPermissionRoleWhereUniqueInput
	}


	/**
	 * EntityPermissionRole deleteMany
	 */
	export type EntityPermissionRoleDeleteManyArgs = {
		/**
		 * Filter which EntityPermissionRoles to delete
		 *
		 **/
		where?: EntityPermissionRoleWhereInput
	}


	/**
	 * EntityPermissionRole without action
	 */
	export type EntityPermissionRoleArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionRole
		 *
		 **/
		select?: EntityPermissionRoleSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionRoleInclude | null
	}



	/**
	 * Model EntityPermissionField
	 */


	export type AggregateEntityPermissionField = {
		_count: EntityPermissionFieldCountAggregateOutputType | null
		_min: EntityPermissionFieldMinAggregateOutputType | null
		_max: EntityPermissionFieldMaxAggregateOutputType | null
	}

	export type EntityPermissionFieldMinAggregateOutputType = {
		id: string | null
		permissionId: string | null
		fieldPermanentId: string | null
		entityVersionId: string | null
	}

	export type EntityPermissionFieldMaxAggregateOutputType = {
		id: string | null
		permissionId: string | null
		fieldPermanentId: string | null
		entityVersionId: string | null
	}

	export type EntityPermissionFieldCountAggregateOutputType = {
		id: number
		permissionId: number
		fieldPermanentId: number
		entityVersionId: number
		_all: number
	}


	export type EntityPermissionFieldMinAggregateInputType = {
		id?: true
		permissionId?: true
		fieldPermanentId?: true
		entityVersionId?: true
	}

	export type EntityPermissionFieldMaxAggregateInputType = {
		id?: true
		permissionId?: true
		fieldPermanentId?: true
		entityVersionId?: true
	}

	export type EntityPermissionFieldCountAggregateInputType = {
		id?: true
		permissionId?: true
		fieldPermanentId?: true
		entityVersionId?: true
		_all?: true
	}

	export type EntityPermissionFieldAggregateArgs = {
		/**
		 * Filter which EntityPermissionField to aggregate.
		 *
		 **/
		where?: EntityPermissionFieldWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityPermissionFields to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityPermissionFieldOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: EntityPermissionFieldWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityPermissionFields from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityPermissionFields.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned EntityPermissionFields
		 **/
		_count?: true | EntityPermissionFieldCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: EntityPermissionFieldMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: EntityPermissionFieldMaxAggregateInputType
	}

	export type GetEntityPermissionFieldAggregateType<T extends EntityPermissionFieldAggregateArgs> = {
		[P in keyof T & keyof AggregateEntityPermissionField]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateEntityPermissionField[P]>
			: GetScalarType<T[P], AggregateEntityPermissionField[P]>
	}




	export type EntityPermissionFieldGroupByArgs = {
		where?: EntityPermissionFieldWhereInput
		orderBy?: Enumerable<EntityPermissionFieldOrderByWithAggregationInput>
		by: Array<EntityPermissionFieldScalarFieldEnum>
		having?: EntityPermissionFieldScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: EntityPermissionFieldCountAggregateInputType | true
		_min?: EntityPermissionFieldMinAggregateInputType
		_max?: EntityPermissionFieldMaxAggregateInputType
	}


	export type EntityPermissionFieldGroupByOutputType = {
		id: string
		permissionId: string
		fieldPermanentId: string
		entityVersionId: string
		_count: EntityPermissionFieldCountAggregateOutputType | null
		_min: EntityPermissionFieldMinAggregateOutputType | null
		_max: EntityPermissionFieldMaxAggregateOutputType | null
	}

	type GetEntityPermissionFieldGroupByPayload<T extends EntityPermissionFieldGroupByArgs> = PrismaPromise<
		Array<
			PickArray<EntityPermissionFieldGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof EntityPermissionFieldGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], EntityPermissionFieldGroupByOutputType[P]>
				: GetScalarType<T[P], EntityPermissionFieldGroupByOutputType[P]>
			}
			>
		>


	export type EntityPermissionFieldSelect = {
		id?: boolean
		permissionId?: boolean
		fieldPermanentId?: boolean
		entityVersionId?: boolean
		field?: boolean | EntityFieldArgs
		permission?: boolean | EntityPermissionArgs
		permissionRoles?: boolean | EntityPermissionRoleFindManyArgs
		_count?: boolean | EntityPermissionFieldCountOutputTypeArgs
	}

	export type EntityPermissionFieldInclude = {
		field?: boolean | EntityFieldArgs
		permission?: boolean | EntityPermissionArgs
		permissionRoles?: boolean | EntityPermissionRoleFindManyArgs
		_count?: boolean | EntityPermissionFieldCountOutputTypeArgs
	}

	export type EntityPermissionFieldGetPayload<
		S extends boolean | null | undefined | EntityPermissionFieldArgs,
		U = keyof S
		> = S extends true
		? EntityPermissionField
		: S extends undefined
			? never
			: S extends EntityPermissionFieldArgs | EntityPermissionFieldFindManyArgs
				?'include' extends U
					? EntityPermissionField  & {
					[P in TrueKeys<S['include']>]:
					P extends 'field' ? EntityFieldGetPayload<S['include'][P]> :
						P extends 'permission' ? EntityPermissionGetPayload<S['include'][P]> :
							P extends 'permissionRoles' ? Array < EntityPermissionRoleGetPayload<S['include'][P]>>  :
								P extends '_count' ? EntityPermissionFieldCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'field' ? EntityFieldGetPayload<S['select'][P]> :
								P extends 'permission' ? EntityPermissionGetPayload<S['select'][P]> :
									P extends 'permissionRoles' ? Array < EntityPermissionRoleGetPayload<S['select'][P]>>  :
										P extends '_count' ? EntityPermissionFieldCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof EntityPermissionField ? EntityPermissionField[P] : never
						}
						: EntityPermissionField
				: EntityPermissionField


	type EntityPermissionFieldCountArgs = Merge<
		Omit<EntityPermissionFieldFindManyArgs, 'select' | 'include'> & {
		select?: EntityPermissionFieldCountAggregateInputType | true
	}
		>

	export interface EntityPermissionFieldDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one EntityPermissionField that matches the filter.
		 * @param {EntityPermissionFieldFindUniqueArgs} args - Arguments to find a EntityPermissionField
		 * @example
		 * // Get one EntityPermissionField
		 * const entityPermissionField = await prisma.entityPermissionField.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends EntityPermissionFieldFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, EntityPermissionFieldFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EntityPermissionField'> extends True ? CheckSelect<T, Prisma__EntityPermissionFieldClient<EntityPermissionField>, Prisma__EntityPermissionFieldClient<EntityPermissionFieldGetPayload<T>>> : CheckSelect<T, Prisma__EntityPermissionFieldClient<EntityPermissionField | null >, Prisma__EntityPermissionFieldClient<EntityPermissionFieldGetPayload<T> | null >>

		/**
		 * Find the first EntityPermissionField that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionFieldFindFirstArgs} args - Arguments to find a EntityPermissionField
		 * @example
		 * // Get one EntityPermissionField
		 * const entityPermissionField = await prisma.entityPermissionField.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends EntityPermissionFieldFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, EntityPermissionFieldFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EntityPermissionField'> extends True ? CheckSelect<T, Prisma__EntityPermissionFieldClient<EntityPermissionField>, Prisma__EntityPermissionFieldClient<EntityPermissionFieldGetPayload<T>>> : CheckSelect<T, Prisma__EntityPermissionFieldClient<EntityPermissionField | null >, Prisma__EntityPermissionFieldClient<EntityPermissionFieldGetPayload<T> | null >>

		/**
		 * Find zero or more EntityPermissionFields that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionFieldFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all EntityPermissionFields
		 * const entityPermissionFields = await prisma.entityPermissionField.findMany()
		 *
		 * // Get first 10 EntityPermissionFields
		 * const entityPermissionFields = await prisma.entityPermissionField.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const entityPermissionFieldWithIdOnly = await prisma.entityPermissionField.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends EntityPermissionFieldFindManyArgs>(
			args?: SelectSubset<T, EntityPermissionFieldFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<EntityPermissionField>>, PrismaPromise<Array<EntityPermissionFieldGetPayload<T>>>>

		/**
		 * Create a EntityPermissionField.
		 * @param {EntityPermissionFieldCreateArgs} args - Arguments to create a EntityPermissionField.
		 * @example
		 * // Create one EntityPermissionField
		 * const EntityPermissionField = await prisma.entityPermissionField.create({
		 *   data: {
		 *     // ... data to create a EntityPermissionField
		 *   }
		 * })
		 *
		 **/
		create<T extends EntityPermissionFieldCreateArgs>(
			args: SelectSubset<T, EntityPermissionFieldCreateArgs>
		): CheckSelect<T, Prisma__EntityPermissionFieldClient<EntityPermissionField>, Prisma__EntityPermissionFieldClient<EntityPermissionFieldGetPayload<T>>>

		/**
		 * Create many EntityPermissionFields.
		 *     @param {EntityPermissionFieldCreateManyArgs} args - Arguments to create many EntityPermissionFields.
		 *     @example
		 *     // Create many EntityPermissionFields
		 *     const entityPermissionField = await prisma.entityPermissionField.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends EntityPermissionFieldCreateManyArgs>(
			args?: SelectSubset<T, EntityPermissionFieldCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a EntityPermissionField.
		 * @param {EntityPermissionFieldDeleteArgs} args - Arguments to delete one EntityPermissionField.
		 * @example
		 * // Delete one EntityPermissionField
		 * const EntityPermissionField = await prisma.entityPermissionField.delete({
		 *   where: {
		 *     // ... filter to delete one EntityPermissionField
		 *   }
		 * })
		 *
		 **/
		delete<T extends EntityPermissionFieldDeleteArgs>(
			args: SelectSubset<T, EntityPermissionFieldDeleteArgs>
		): CheckSelect<T, Prisma__EntityPermissionFieldClient<EntityPermissionField>, Prisma__EntityPermissionFieldClient<EntityPermissionFieldGetPayload<T>>>

		/**
		 * Update one EntityPermissionField.
		 * @param {EntityPermissionFieldUpdateArgs} args - Arguments to update one EntityPermissionField.
		 * @example
		 * // Update one EntityPermissionField
		 * const entityPermissionField = await prisma.entityPermissionField.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends EntityPermissionFieldUpdateArgs>(
			args: SelectSubset<T, EntityPermissionFieldUpdateArgs>
		): CheckSelect<T, Prisma__EntityPermissionFieldClient<EntityPermissionField>, Prisma__EntityPermissionFieldClient<EntityPermissionFieldGetPayload<T>>>

		/**
		 * Delete zero or more EntityPermissionFields.
		 * @param {EntityPermissionFieldDeleteManyArgs} args - Arguments to filter EntityPermissionFields to delete.
		 * @example
		 * // Delete a few EntityPermissionFields
		 * const { count } = await prisma.entityPermissionField.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends EntityPermissionFieldDeleteManyArgs>(
			args?: SelectSubset<T, EntityPermissionFieldDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more EntityPermissionFields.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionFieldUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many EntityPermissionFields
		 * const entityPermissionField = await prisma.entityPermissionField.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends EntityPermissionFieldUpdateManyArgs>(
			args: SelectSubset<T, EntityPermissionFieldUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one EntityPermissionField.
		 * @param {EntityPermissionFieldUpsertArgs} args - Arguments to update or create a EntityPermissionField.
		 * @example
		 * // Update or create a EntityPermissionField
		 * const entityPermissionField = await prisma.entityPermissionField.upsert({
		 *   create: {
		 *     // ... data to create a EntityPermissionField
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the EntityPermissionField we want to update
		 *   }
		 * })
		 **/
		upsert<T extends EntityPermissionFieldUpsertArgs>(
			args: SelectSubset<T, EntityPermissionFieldUpsertArgs>
		): CheckSelect<T, Prisma__EntityPermissionFieldClient<EntityPermissionField>, Prisma__EntityPermissionFieldClient<EntityPermissionFieldGetPayload<T>>>

		/**
		 * Count the number of EntityPermissionFields.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionFieldCountArgs} args - Arguments to filter EntityPermissionFields to count.
		 * @example
		 * // Count the number of EntityPermissionFields
		 * const count = await prisma.entityPermissionField.count({
		 *   where: {
		 *     // ... the filter for the EntityPermissionFields we want to count
		 *   }
		 * })
		 **/
		count<T extends EntityPermissionFieldCountArgs>(
			args?: Subset<T, EntityPermissionFieldCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], EntityPermissionFieldCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a EntityPermissionField.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends EntityPermissionFieldAggregateArgs>(args: Subset<T, EntityPermissionFieldAggregateArgs>): PrismaPromise<GetEntityPermissionFieldAggregateType<T>>

		/**
		 * Group by EntityPermissionField.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityPermissionFieldGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends EntityPermissionFieldGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: EntityPermissionFieldGroupByArgs['orderBy'] }
				: { orderBy?: EntityPermissionFieldGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, EntityPermissionFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityPermissionFieldGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for EntityPermissionField.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__EntityPermissionFieldClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		field<T extends EntityFieldArgs = {}>(args?: Subset<T, EntityFieldArgs>): CheckSelect<T, Prisma__EntityFieldClient<EntityField | null >, Prisma__EntityFieldClient<EntityFieldGetPayload<T> | null >>;

		permission<T extends EntityPermissionArgs = {}>(args?: Subset<T, EntityPermissionArgs>): CheckSelect<T, Prisma__EntityPermissionClient<EntityPermission | null >, Prisma__EntityPermissionClient<EntityPermissionGetPayload<T> | null >>;

		permissionRoles<T extends EntityPermissionRoleFindManyArgs = {}>(args?: Subset<T, EntityPermissionRoleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityPermissionRole>>, PrismaPromise<Array<EntityPermissionRoleGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * EntityPermissionField findUnique
	 */
	export type EntityPermissionFieldFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionField
		 *
		 **/
		select?: EntityPermissionFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionFieldInclude | null
		/**
		 * Throw an Error if a EntityPermissionField can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityPermissionField to fetch.
		 *
		 **/
		where: EntityPermissionFieldWhereUniqueInput
	}


	/**
	 * EntityPermissionField findFirst
	 */
	export type EntityPermissionFieldFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionField
		 *
		 **/
		select?: EntityPermissionFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionFieldInclude | null
		/**
		 * Throw an Error if a EntityPermissionField can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityPermissionField to fetch.
		 *
		 **/
		where?: EntityPermissionFieldWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityPermissionFields to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityPermissionFieldOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for EntityPermissionFields.
		 *
		 **/
		cursor?: EntityPermissionFieldWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityPermissionFields from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityPermissionFields.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of EntityPermissionFields.
		 *
		 **/
		distinct?: Enumerable<EntityPermissionFieldScalarFieldEnum>
	}


	/**
	 * EntityPermissionField findMany
	 */
	export type EntityPermissionFieldFindManyArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionField
		 *
		 **/
		select?: EntityPermissionFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionFieldInclude | null
		/**
		 * Filter, which EntityPermissionFields to fetch.
		 *
		 **/
		where?: EntityPermissionFieldWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityPermissionFields to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityPermissionFieldOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing EntityPermissionFields.
		 *
		 **/
		cursor?: EntityPermissionFieldWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityPermissionFields from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityPermissionFields.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<EntityPermissionFieldScalarFieldEnum>
	}


	/**
	 * EntityPermissionField create
	 */
	export type EntityPermissionFieldCreateArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionField
		 *
		 **/
		select?: EntityPermissionFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionFieldInclude | null
		/**
		 * The data needed to create a EntityPermissionField.
		 *
		 **/
		data: XOR<EntityPermissionFieldCreateInput, EntityPermissionFieldUncheckedCreateInput>
	}


	/**
	 * EntityPermissionField createMany
	 */
	export type EntityPermissionFieldCreateManyArgs = {
		/**
		 * The data used to create many EntityPermissionFields.
		 *
		 **/
		data: Enumerable<EntityPermissionFieldCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * EntityPermissionField update
	 */
	export type EntityPermissionFieldUpdateArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionField
		 *
		 **/
		select?: EntityPermissionFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionFieldInclude | null
		/**
		 * The data needed to update a EntityPermissionField.
		 *
		 **/
		data: XOR<EntityPermissionFieldUpdateInput, EntityPermissionFieldUncheckedUpdateInput>
		/**
		 * Choose, which EntityPermissionField to update.
		 *
		 **/
		where: EntityPermissionFieldWhereUniqueInput
	}


	/**
	 * EntityPermissionField updateMany
	 */
	export type EntityPermissionFieldUpdateManyArgs = {
		/**
		 * The data used to update EntityPermissionFields.
		 *
		 **/
		data: XOR<EntityPermissionFieldUpdateManyMutationInput, EntityPermissionFieldUncheckedUpdateManyInput>
		/**
		 * Filter which EntityPermissionFields to update
		 *
		 **/
		where?: EntityPermissionFieldWhereInput
	}


	/**
	 * EntityPermissionField upsert
	 */
	export type EntityPermissionFieldUpsertArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionField
		 *
		 **/
		select?: EntityPermissionFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionFieldInclude | null
		/**
		 * The filter to search for the EntityPermissionField to update in case it exists.
		 *
		 **/
		where: EntityPermissionFieldWhereUniqueInput
		/**
		 * In case the EntityPermissionField found by the `where` argument doesn't exist, create a new EntityPermissionField with this data.
		 *
		 **/
		create: XOR<EntityPermissionFieldCreateInput, EntityPermissionFieldUncheckedCreateInput>
		/**
		 * In case the EntityPermissionField was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<EntityPermissionFieldUpdateInput, EntityPermissionFieldUncheckedUpdateInput>
	}


	/**
	 * EntityPermissionField delete
	 */
	export type EntityPermissionFieldDeleteArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionField
		 *
		 **/
		select?: EntityPermissionFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionFieldInclude | null
		/**
		 * Filter which EntityPermissionField to delete.
		 *
		 **/
		where: EntityPermissionFieldWhereUniqueInput
	}


	/**
	 * EntityPermissionField deleteMany
	 */
	export type EntityPermissionFieldDeleteManyArgs = {
		/**
		 * Filter which EntityPermissionFields to delete
		 *
		 **/
		where?: EntityPermissionFieldWhereInput
	}


	/**
	 * EntityPermissionField without action
	 */
	export type EntityPermissionFieldArgs = {
		/**
		 * Select specific fields to fetch from the EntityPermissionField
		 *
		 **/
		select?: EntityPermissionFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityPermissionFieldInclude | null
	}



	/**
	 * Model EntityField
	 */


	export type AggregateEntityField = {
		_count: EntityFieldCountAggregateOutputType | null
		_avg: EntityFieldAvgAggregateOutputType | null
		_sum: EntityFieldSumAggregateOutputType | null
		_min: EntityFieldMinAggregateOutputType | null
		_max: EntityFieldMaxAggregateOutputType | null
	}

	export type EntityFieldAvgAggregateOutputType = {
		position: number | null
	}

	export type EntityFieldSumAggregateOutputType = {
		position: number | null
	}

	export type EntityFieldMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		entityVersionId: string | null
		permanentId: string | null
		name: string | null
		displayName: string | null
		dataType: EnumDataType | null
		required: boolean | null
		searchable: boolean | null
		description: string | null
		position: number | null
		unique: boolean | null
	}

	export type EntityFieldMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		entityVersionId: string | null
		permanentId: string | null
		name: string | null
		displayName: string | null
		dataType: EnumDataType | null
		required: boolean | null
		searchable: boolean | null
		description: string | null
		position: number | null
		unique: boolean | null
	}

	export type EntityFieldCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		entityVersionId: number
		permanentId: number
		name: number
		displayName: number
		dataType: number
		properties: number
		required: number
		searchable: number
		description: number
		position: number
		unique: number
		_all: number
	}


	export type EntityFieldAvgAggregateInputType = {
		position?: true
	}

	export type EntityFieldSumAggregateInputType = {
		position?: true
	}

	export type EntityFieldMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		entityVersionId?: true
		permanentId?: true
		name?: true
		displayName?: true
		dataType?: true
		required?: true
		searchable?: true
		description?: true
		position?: true
		unique?: true
	}

	export type EntityFieldMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		entityVersionId?: true
		permanentId?: true
		name?: true
		displayName?: true
		dataType?: true
		required?: true
		searchable?: true
		description?: true
		position?: true
		unique?: true
	}

	export type EntityFieldCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		entityVersionId?: true
		permanentId?: true
		name?: true
		displayName?: true
		dataType?: true
		properties?: true
		required?: true
		searchable?: true
		description?: true
		position?: true
		unique?: true
		_all?: true
	}

	export type EntityFieldAggregateArgs = {
		/**
		 * Filter which EntityField to aggregate.
		 *
		 **/
		where?: EntityFieldWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityFields to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityFieldOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: EntityFieldWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityFields from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityFields.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned EntityFields
		 **/
		_count?: true | EntityFieldCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: EntityFieldAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: EntityFieldSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: EntityFieldMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: EntityFieldMaxAggregateInputType
	}

	export type GetEntityFieldAggregateType<T extends EntityFieldAggregateArgs> = {
		[P in keyof T & keyof AggregateEntityField]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateEntityField[P]>
			: GetScalarType<T[P], AggregateEntityField[P]>
	}




	export type EntityFieldGroupByArgs = {
		where?: EntityFieldWhereInput
		orderBy?: Enumerable<EntityFieldOrderByWithAggregationInput>
		by: Array<EntityFieldScalarFieldEnum>
		having?: EntityFieldScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: EntityFieldCountAggregateInputType | true
		_avg?: EntityFieldAvgAggregateInputType
		_sum?: EntityFieldSumAggregateInputType
		_min?: EntityFieldMinAggregateInputType
		_max?: EntityFieldMaxAggregateInputType
	}


	export type EntityFieldGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		entityVersionId: string
		permanentId: string
		name: string
		displayName: string
		dataType: EnumDataType
		properties: JsonValue
		required: boolean
		searchable: boolean
		description: string
		position: number | null
		unique: boolean
		_count: EntityFieldCountAggregateOutputType | null
		_avg: EntityFieldAvgAggregateOutputType | null
		_sum: EntityFieldSumAggregateOutputType | null
		_min: EntityFieldMinAggregateOutputType | null
		_max: EntityFieldMaxAggregateOutputType | null
	}

	type GetEntityFieldGroupByPayload<T extends EntityFieldGroupByArgs> = PrismaPromise<
		Array<
			PickArray<EntityFieldGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof EntityFieldGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], EntityFieldGroupByOutputType[P]>
				: GetScalarType<T[P], EntityFieldGroupByOutputType[P]>
			}
			>
		>


	export type EntityFieldSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		entityVersionId?: boolean
		permanentId?: boolean
		name?: boolean
		displayName?: boolean
		dataType?: boolean
		properties?: boolean
		required?: boolean
		searchable?: boolean
		description?: boolean
		position?: boolean
		unique?: boolean
		entityVersion?: boolean | EntityVersionArgs
		permissionField?: boolean | EntityPermissionFieldFindManyArgs
		_count?: boolean | EntityFieldCountOutputTypeArgs
	}

	export type EntityFieldInclude = {
		entityVersion?: boolean | EntityVersionArgs
		permissionField?: boolean | EntityPermissionFieldFindManyArgs
		_count?: boolean | EntityFieldCountOutputTypeArgs
	}

	export type EntityFieldGetPayload<
		S extends boolean | null | undefined | EntityFieldArgs,
		U = keyof S
		> = S extends true
		? EntityField
		: S extends undefined
			? never
			: S extends EntityFieldArgs | EntityFieldFindManyArgs
				?'include' extends U
					? EntityField  & {
					[P in TrueKeys<S['include']>]:
					P extends 'entityVersion' ? EntityVersionGetPayload<S['include'][P]> :
						P extends 'permissionField' ? Array < EntityPermissionFieldGetPayload<S['include'][P]>>  :
							P extends '_count' ? EntityFieldCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'entityVersion' ? EntityVersionGetPayload<S['select'][P]> :
								P extends 'permissionField' ? Array < EntityPermissionFieldGetPayload<S['select'][P]>>  :
									P extends '_count' ? EntityFieldCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof EntityField ? EntityField[P] : never
						}
						: EntityField
				: EntityField


	type EntityFieldCountArgs = Merge<
		Omit<EntityFieldFindManyArgs, 'select' | 'include'> & {
		select?: EntityFieldCountAggregateInputType | true
	}
		>

	export interface EntityFieldDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one EntityField that matches the filter.
		 * @param {EntityFieldFindUniqueArgs} args - Arguments to find a EntityField
		 * @example
		 * // Get one EntityField
		 * const entityField = await prisma.entityField.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends EntityFieldFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, EntityFieldFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EntityField'> extends True ? CheckSelect<T, Prisma__EntityFieldClient<EntityField>, Prisma__EntityFieldClient<EntityFieldGetPayload<T>>> : CheckSelect<T, Prisma__EntityFieldClient<EntityField | null >, Prisma__EntityFieldClient<EntityFieldGetPayload<T> | null >>

		/**
		 * Find the first EntityField that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityFieldFindFirstArgs} args - Arguments to find a EntityField
		 * @example
		 * // Get one EntityField
		 * const entityField = await prisma.entityField.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends EntityFieldFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, EntityFieldFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EntityField'> extends True ? CheckSelect<T, Prisma__EntityFieldClient<EntityField>, Prisma__EntityFieldClient<EntityFieldGetPayload<T>>> : CheckSelect<T, Prisma__EntityFieldClient<EntityField | null >, Prisma__EntityFieldClient<EntityFieldGetPayload<T> | null >>

		/**
		 * Find zero or more EntityFields that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityFieldFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all EntityFields
		 * const entityFields = await prisma.entityField.findMany()
		 *
		 * // Get first 10 EntityFields
		 * const entityFields = await prisma.entityField.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const entityFieldWithIdOnly = await prisma.entityField.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends EntityFieldFindManyArgs>(
			args?: SelectSubset<T, EntityFieldFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<EntityField>>, PrismaPromise<Array<EntityFieldGetPayload<T>>>>

		/**
		 * Create a EntityField.
		 * @param {EntityFieldCreateArgs} args - Arguments to create a EntityField.
		 * @example
		 * // Create one EntityField
		 * const EntityField = await prisma.entityField.create({
		 *   data: {
		 *     // ... data to create a EntityField
		 *   }
		 * })
		 *
		 **/
		create<T extends EntityFieldCreateArgs>(
			args: SelectSubset<T, EntityFieldCreateArgs>
		): CheckSelect<T, Prisma__EntityFieldClient<EntityField>, Prisma__EntityFieldClient<EntityFieldGetPayload<T>>>

		/**
		 * Create many EntityFields.
		 *     @param {EntityFieldCreateManyArgs} args - Arguments to create many EntityFields.
		 *     @example
		 *     // Create many EntityFields
		 *     const entityField = await prisma.entityField.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends EntityFieldCreateManyArgs>(
			args?: SelectSubset<T, EntityFieldCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a EntityField.
		 * @param {EntityFieldDeleteArgs} args - Arguments to delete one EntityField.
		 * @example
		 * // Delete one EntityField
		 * const EntityField = await prisma.entityField.delete({
		 *   where: {
		 *     // ... filter to delete one EntityField
		 *   }
		 * })
		 *
		 **/
		delete<T extends EntityFieldDeleteArgs>(
			args: SelectSubset<T, EntityFieldDeleteArgs>
		): CheckSelect<T, Prisma__EntityFieldClient<EntityField>, Prisma__EntityFieldClient<EntityFieldGetPayload<T>>>

		/**
		 * Update one EntityField.
		 * @param {EntityFieldUpdateArgs} args - Arguments to update one EntityField.
		 * @example
		 * // Update one EntityField
		 * const entityField = await prisma.entityField.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends EntityFieldUpdateArgs>(
			args: SelectSubset<T, EntityFieldUpdateArgs>
		): CheckSelect<T, Prisma__EntityFieldClient<EntityField>, Prisma__EntityFieldClient<EntityFieldGetPayload<T>>>

		/**
		 * Delete zero or more EntityFields.
		 * @param {EntityFieldDeleteManyArgs} args - Arguments to filter EntityFields to delete.
		 * @example
		 * // Delete a few EntityFields
		 * const { count } = await prisma.entityField.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends EntityFieldDeleteManyArgs>(
			args?: SelectSubset<T, EntityFieldDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more EntityFields.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityFieldUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many EntityFields
		 * const entityField = await prisma.entityField.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends EntityFieldUpdateManyArgs>(
			args: SelectSubset<T, EntityFieldUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one EntityField.
		 * @param {EntityFieldUpsertArgs} args - Arguments to update or create a EntityField.
		 * @example
		 * // Update or create a EntityField
		 * const entityField = await prisma.entityField.upsert({
		 *   create: {
		 *     // ... data to create a EntityField
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the EntityField we want to update
		 *   }
		 * })
		 **/
		upsert<T extends EntityFieldUpsertArgs>(
			args: SelectSubset<T, EntityFieldUpsertArgs>
		): CheckSelect<T, Prisma__EntityFieldClient<EntityField>, Prisma__EntityFieldClient<EntityFieldGetPayload<T>>>

		/**
		 * Count the number of EntityFields.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityFieldCountArgs} args - Arguments to filter EntityFields to count.
		 * @example
		 * // Count the number of EntityFields
		 * const count = await prisma.entityField.count({
		 *   where: {
		 *     // ... the filter for the EntityFields we want to count
		 *   }
		 * })
		 **/
		count<T extends EntityFieldCountArgs>(
			args?: Subset<T, EntityFieldCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], EntityFieldCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a EntityField.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends EntityFieldAggregateArgs>(args: Subset<T, EntityFieldAggregateArgs>): PrismaPromise<GetEntityFieldAggregateType<T>>

		/**
		 * Group by EntityField.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EntityFieldGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends EntityFieldGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: EntityFieldGroupByArgs['orderBy'] }
				: { orderBy?: EntityFieldGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, EntityFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityFieldGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for EntityField.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__EntityFieldClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		entityVersion<T extends EntityVersionArgs = {}>(args?: Subset<T, EntityVersionArgs>): CheckSelect<T, Prisma__EntityVersionClient<EntityVersion | null >, Prisma__EntityVersionClient<EntityVersionGetPayload<T> | null >>;

		permissionField<T extends EntityPermissionFieldFindManyArgs = {}>(args?: Subset<T, EntityPermissionFieldFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityPermissionField>>, PrismaPromise<Array<EntityPermissionFieldGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * EntityField findUnique
	 */
	export type EntityFieldFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the EntityField
		 *
		 **/
		select?: EntityFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityFieldInclude | null
		/**
		 * Throw an Error if a EntityField can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityField to fetch.
		 *
		 **/
		where: EntityFieldWhereUniqueInput
	}


	/**
	 * EntityField findFirst
	 */
	export type EntityFieldFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the EntityField
		 *
		 **/
		select?: EntityFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityFieldInclude | null
		/**
		 * Throw an Error if a EntityField can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which EntityField to fetch.
		 *
		 **/
		where?: EntityFieldWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityFields to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityFieldOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for EntityFields.
		 *
		 **/
		cursor?: EntityFieldWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityFields from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityFields.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of EntityFields.
		 *
		 **/
		distinct?: Enumerable<EntityFieldScalarFieldEnum>
	}


	/**
	 * EntityField findMany
	 */
	export type EntityFieldFindManyArgs = {
		/**
		 * Select specific fields to fetch from the EntityField
		 *
		 **/
		select?: EntityFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityFieldInclude | null
		/**
		 * Filter, which EntityFields to fetch.
		 *
		 **/
		where?: EntityFieldWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of EntityFields to fetch.
		 *
		 **/
		orderBy?: Enumerable<EntityFieldOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing EntityFields.
		 *
		 **/
		cursor?: EntityFieldWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` EntityFields from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` EntityFields.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<EntityFieldScalarFieldEnum>
	}


	/**
	 * EntityField create
	 */
	export type EntityFieldCreateArgs = {
		/**
		 * Select specific fields to fetch from the EntityField
		 *
		 **/
		select?: EntityFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityFieldInclude | null
		/**
		 * The data needed to create a EntityField.
		 *
		 **/
		data: XOR<EntityFieldCreateInput, EntityFieldUncheckedCreateInput>
	}


	/**
	 * EntityField createMany
	 */
	export type EntityFieldCreateManyArgs = {
		/**
		 * The data used to create many EntityFields.
		 *
		 **/
		data: Enumerable<EntityFieldCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * EntityField update
	 */
	export type EntityFieldUpdateArgs = {
		/**
		 * Select specific fields to fetch from the EntityField
		 *
		 **/
		select?: EntityFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityFieldInclude | null
		/**
		 * The data needed to update a EntityField.
		 *
		 **/
		data: XOR<EntityFieldUpdateInput, EntityFieldUncheckedUpdateInput>
		/**
		 * Choose, which EntityField to update.
		 *
		 **/
		where: EntityFieldWhereUniqueInput
	}


	/**
	 * EntityField updateMany
	 */
	export type EntityFieldUpdateManyArgs = {
		/**
		 * The data used to update EntityFields.
		 *
		 **/
		data: XOR<EntityFieldUpdateManyMutationInput, EntityFieldUncheckedUpdateManyInput>
		/**
		 * Filter which EntityFields to update
		 *
		 **/
		where?: EntityFieldWhereInput
	}


	/**
	 * EntityField upsert
	 */
	export type EntityFieldUpsertArgs = {
		/**
		 * Select specific fields to fetch from the EntityField
		 *
		 **/
		select?: EntityFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityFieldInclude | null
		/**
		 * The filter to search for the EntityField to update in case it exists.
		 *
		 **/
		where: EntityFieldWhereUniqueInput
		/**
		 * In case the EntityField found by the `where` argument doesn't exist, create a new EntityField with this data.
		 *
		 **/
		create: XOR<EntityFieldCreateInput, EntityFieldUncheckedCreateInput>
		/**
		 * In case the EntityField was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<EntityFieldUpdateInput, EntityFieldUncheckedUpdateInput>
	}


	/**
	 * EntityField delete
	 */
	export type EntityFieldDeleteArgs = {
		/**
		 * Select specific fields to fetch from the EntityField
		 *
		 **/
		select?: EntityFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityFieldInclude | null
		/**
		 * Filter which EntityField to delete.
		 *
		 **/
		where: EntityFieldWhereUniqueInput
	}


	/**
	 * EntityField deleteMany
	 */
	export type EntityFieldDeleteManyArgs = {
		/**
		 * Filter which EntityFields to delete
		 *
		 **/
		where?: EntityFieldWhereInput
	}


	/**
	 * EntityField without action
	 */
	export type EntityFieldArgs = {
		/**
		 * Select specific fields to fetch from the EntityField
		 *
		 **/
		select?: EntityFieldSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EntityFieldInclude | null
	}



	/**
	 * Model Block
	 */


	export type AggregateBlock = {
		_count: BlockCountAggregateOutputType | null
		_min: BlockMinAggregateOutputType | null
		_max: BlockMaxAggregateOutputType | null
	}

	export type BlockMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		resourceId: string | null
		parentBlockId: string | null
		blockType: EnumBlockType | null
		displayName: string | null
		description: string | null
		lockedByUserId: string | null
		lockedAt: Date | null
		deletedAt: Date | null
	}

	export type BlockMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		resourceId: string | null
		parentBlockId: string | null
		blockType: EnumBlockType | null
		displayName: string | null
		description: string | null
		lockedByUserId: string | null
		lockedAt: Date | null
		deletedAt: Date | null
	}

	export type BlockCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		resourceId: number
		parentBlockId: number
		blockType: number
		displayName: number
		description: number
		lockedByUserId: number
		lockedAt: number
		deletedAt: number
		_all: number
	}


	export type BlockMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		parentBlockId?: true
		blockType?: true
		displayName?: true
		description?: true
		lockedByUserId?: true
		lockedAt?: true
		deletedAt?: true
	}

	export type BlockMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		parentBlockId?: true
		blockType?: true
		displayName?: true
		description?: true
		lockedByUserId?: true
		lockedAt?: true
		deletedAt?: true
	}

	export type BlockCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		parentBlockId?: true
		blockType?: true
		displayName?: true
		description?: true
		lockedByUserId?: true
		lockedAt?: true
		deletedAt?: true
		_all?: true
	}

	export type BlockAggregateArgs = {
		/**
		 * Filter which Block to aggregate.
		 *
		 **/
		where?: BlockWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Blocks to fetch.
		 *
		 **/
		orderBy?: Enumerable<BlockOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: BlockWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Blocks from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Blocks.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Blocks
		 **/
		_count?: true | BlockCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: BlockMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: BlockMaxAggregateInputType
	}

	export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
		[P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateBlock[P]>
			: GetScalarType<T[P], AggregateBlock[P]>
	}




	export type BlockGroupByArgs = {
		where?: BlockWhereInput
		orderBy?: Enumerable<BlockOrderByWithAggregationInput>
		by: Array<BlockScalarFieldEnum>
		having?: BlockScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: BlockCountAggregateInputType | true
		_min?: BlockMinAggregateInputType
		_max?: BlockMaxAggregateInputType
	}


	export type BlockGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		resourceId: string
		parentBlockId: string | null
		blockType: EnumBlockType
		displayName: string
		description: string | null
		lockedByUserId: string | null
		lockedAt: Date | null
		deletedAt: Date | null
		_count: BlockCountAggregateOutputType | null
		_min: BlockMinAggregateOutputType | null
		_max: BlockMaxAggregateOutputType | null
	}

	type GetBlockGroupByPayload<T extends BlockGroupByArgs> = PrismaPromise<
		Array<
			PickArray<BlockGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], BlockGroupByOutputType[P]>
				: GetScalarType<T[P], BlockGroupByOutputType[P]>
			}
			>
		>


	export type BlockSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		resourceId?: boolean
		parentBlockId?: boolean
		blockType?: boolean
		displayName?: boolean
		description?: boolean
		lockedByUserId?: boolean
		lockedAt?: boolean
		deletedAt?: boolean
		resource?: boolean | ResourceArgs
		lockedByUser?: boolean | UserArgs
		parentBlock?: boolean | BlockArgs
		blocks?: boolean | BlockFindManyArgs
		versions?: boolean | BlockVersionFindManyArgs
		_count?: boolean | BlockCountOutputTypeArgs
	}

	export type BlockInclude = {
		resource?: boolean | ResourceArgs
		lockedByUser?: boolean | UserArgs
		parentBlock?: boolean | BlockArgs
		blocks?: boolean | BlockFindManyArgs
		versions?: boolean | BlockVersionFindManyArgs
		_count?: boolean | BlockCountOutputTypeArgs
	}

	export type BlockGetPayload<
		S extends boolean | null | undefined | BlockArgs,
		U = keyof S
		> = S extends true
		? Block
		: S extends undefined
			? never
			: S extends BlockArgs | BlockFindManyArgs
				?'include' extends U
					? Block  & {
					[P in TrueKeys<S['include']>]:
					P extends 'resource' ? ResourceGetPayload<S['include'][P]> :
						P extends 'lockedByUser' ? UserGetPayload<S['include'][P]> | null :
							P extends 'parentBlock' ? BlockGetPayload<S['include'][P]> | null :
								P extends 'blocks' ? Array < BlockGetPayload<S['include'][P]>>  :
									P extends 'versions' ? Array < BlockVersionGetPayload<S['include'][P]>>  :
										P extends '_count' ? BlockCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'resource' ? ResourceGetPayload<S['select'][P]> :
								P extends 'lockedByUser' ? UserGetPayload<S['select'][P]> | null :
									P extends 'parentBlock' ? BlockGetPayload<S['select'][P]> | null :
										P extends 'blocks' ? Array < BlockGetPayload<S['select'][P]>>  :
											P extends 'versions' ? Array < BlockVersionGetPayload<S['select'][P]>>  :
												P extends '_count' ? BlockCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Block ? Block[P] : never
						}
						: Block
				: Block


	type BlockCountArgs = Merge<
		Omit<BlockFindManyArgs, 'select' | 'include'> & {
		select?: BlockCountAggregateInputType | true
	}
		>

	export interface BlockDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Block that matches the filter.
		 * @param {BlockFindUniqueArgs} args - Arguments to find a Block
		 * @example
		 * // Get one Block
		 * const block = await prisma.block.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends BlockFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, BlockFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Block'> extends True ? CheckSelect<T, Prisma__BlockClient<Block>, Prisma__BlockClient<BlockGetPayload<T>>> : CheckSelect<T, Prisma__BlockClient<Block | null >, Prisma__BlockClient<BlockGetPayload<T> | null >>

		/**
		 * Find the first Block that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockFindFirstArgs} args - Arguments to find a Block
		 * @example
		 * // Get one Block
		 * const block = await prisma.block.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends BlockFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, BlockFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Block'> extends True ? CheckSelect<T, Prisma__BlockClient<Block>, Prisma__BlockClient<BlockGetPayload<T>>> : CheckSelect<T, Prisma__BlockClient<Block | null >, Prisma__BlockClient<BlockGetPayload<T> | null >>

		/**
		 * Find zero or more Blocks that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Blocks
		 * const blocks = await prisma.block.findMany()
		 *
		 * // Get first 10 Blocks
		 * const blocks = await prisma.block.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends BlockFindManyArgs>(
			args?: SelectSubset<T, BlockFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Block>>, PrismaPromise<Array<BlockGetPayload<T>>>>

		/**
		 * Create a Block.
		 * @param {BlockCreateArgs} args - Arguments to create a Block.
		 * @example
		 * // Create one Block
		 * const Block = await prisma.block.create({
		 *   data: {
		 *     // ... data to create a Block
		 *   }
		 * })
		 *
		 **/
		create<T extends BlockCreateArgs>(
			args: SelectSubset<T, BlockCreateArgs>
		): CheckSelect<T, Prisma__BlockClient<Block>, Prisma__BlockClient<BlockGetPayload<T>>>

		/**
		 * Create many Blocks.
		 *     @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
		 *     @example
		 *     // Create many Blocks
		 *     const block = await prisma.block.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends BlockCreateManyArgs>(
			args?: SelectSubset<T, BlockCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Block.
		 * @param {BlockDeleteArgs} args - Arguments to delete one Block.
		 * @example
		 * // Delete one Block
		 * const Block = await prisma.block.delete({
		 *   where: {
		 *     // ... filter to delete one Block
		 *   }
		 * })
		 *
		 **/
		delete<T extends BlockDeleteArgs>(
			args: SelectSubset<T, BlockDeleteArgs>
		): CheckSelect<T, Prisma__BlockClient<Block>, Prisma__BlockClient<BlockGetPayload<T>>>

		/**
		 * Update one Block.
		 * @param {BlockUpdateArgs} args - Arguments to update one Block.
		 * @example
		 * // Update one Block
		 * const block = await prisma.block.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends BlockUpdateArgs>(
			args: SelectSubset<T, BlockUpdateArgs>
		): CheckSelect<T, Prisma__BlockClient<Block>, Prisma__BlockClient<BlockGetPayload<T>>>

		/**
		 * Delete zero or more Blocks.
		 * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
		 * @example
		 * // Delete a few Blocks
		 * const { count } = await prisma.block.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends BlockDeleteManyArgs>(
			args?: SelectSubset<T, BlockDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Blocks.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Blocks
		 * const block = await prisma.block.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends BlockUpdateManyArgs>(
			args: SelectSubset<T, BlockUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Block.
		 * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
		 * @example
		 * // Update or create a Block
		 * const block = await prisma.block.upsert({
		 *   create: {
		 *     // ... data to create a Block
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Block we want to update
		 *   }
		 * })
		 **/
		upsert<T extends BlockUpsertArgs>(
			args: SelectSubset<T, BlockUpsertArgs>
		): CheckSelect<T, Prisma__BlockClient<Block>, Prisma__BlockClient<BlockGetPayload<T>>>

		/**
		 * Count the number of Blocks.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
		 * @example
		 * // Count the number of Blocks
		 * const count = await prisma.block.count({
		 *   where: {
		 *     // ... the filter for the Blocks we want to count
		 *   }
		 * })
		 **/
		count<T extends BlockCountArgs>(
			args?: Subset<T, BlockCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], BlockCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Block.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): PrismaPromise<GetBlockAggregateType<T>>

		/**
		 * Group by Block.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends BlockGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: BlockGroupByArgs['orderBy'] }
				: { orderBy?: BlockGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Block.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__BlockClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		resource<T extends ResourceArgs = {}>(args?: Subset<T, ResourceArgs>): CheckSelect<T, Prisma__ResourceClient<Resource | null >, Prisma__ResourceClient<ResourceGetPayload<T> | null >>;

		lockedByUser<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		parentBlock<T extends BlockArgs = {}>(args?: Subset<T, BlockArgs>): CheckSelect<T, Prisma__BlockClient<Block | null >, Prisma__BlockClient<BlockGetPayload<T> | null >>;

		blocks<T extends BlockFindManyArgs = {}>(args?: Subset<T, BlockFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Block>>, PrismaPromise<Array<BlockGetPayload<T>>>>;

		versions<T extends BlockVersionFindManyArgs = {}>(args?: Subset<T, BlockVersionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<BlockVersion>>, PrismaPromise<Array<BlockVersionGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Block findUnique
	 */
	export type BlockFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Block
		 *
		 **/
		select?: BlockSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockInclude | null
		/**
		 * Throw an Error if a Block can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Block to fetch.
		 *
		 **/
		where: BlockWhereUniqueInput
	}


	/**
	 * Block findFirst
	 */
	export type BlockFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Block
		 *
		 **/
		select?: BlockSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockInclude | null
		/**
		 * Throw an Error if a Block can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Block to fetch.
		 *
		 **/
		where?: BlockWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Blocks to fetch.
		 *
		 **/
		orderBy?: Enumerable<BlockOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Blocks.
		 *
		 **/
		cursor?: BlockWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Blocks from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Blocks.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Blocks.
		 *
		 **/
		distinct?: Enumerable<BlockScalarFieldEnum>
	}


	/**
	 * Block findMany
	 */
	export type BlockFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Block
		 *
		 **/
		select?: BlockSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockInclude | null
		/**
		 * Filter, which Blocks to fetch.
		 *
		 **/
		where?: BlockWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Blocks to fetch.
		 *
		 **/
		orderBy?: Enumerable<BlockOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Blocks.
		 *
		 **/
		cursor?: BlockWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Blocks from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Blocks.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<BlockScalarFieldEnum>
	}


	/**
	 * Block create
	 */
	export type BlockCreateArgs = {
		/**
		 * Select specific fields to fetch from the Block
		 *
		 **/
		select?: BlockSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockInclude | null
		/**
		 * The data needed to create a Block.
		 *
		 **/
		data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
	}


	/**
	 * Block createMany
	 */
	export type BlockCreateManyArgs = {
		/**
		 * The data used to create many Blocks.
		 *
		 **/
		data: Enumerable<BlockCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Block update
	 */
	export type BlockUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Block
		 *
		 **/
		select?: BlockSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockInclude | null
		/**
		 * The data needed to update a Block.
		 *
		 **/
		data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
		/**
		 * Choose, which Block to update.
		 *
		 **/
		where: BlockWhereUniqueInput
	}


	/**
	 * Block updateMany
	 */
	export type BlockUpdateManyArgs = {
		/**
		 * The data used to update Blocks.
		 *
		 **/
		data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
		/**
		 * Filter which Blocks to update
		 *
		 **/
		where?: BlockWhereInput
	}


	/**
	 * Block upsert
	 */
	export type BlockUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Block
		 *
		 **/
		select?: BlockSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockInclude | null
		/**
		 * The filter to search for the Block to update in case it exists.
		 *
		 **/
		where: BlockWhereUniqueInput
		/**
		 * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
		 *
		 **/
		create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
		/**
		 * In case the Block was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
	}


	/**
	 * Block delete
	 */
	export type BlockDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Block
		 *
		 **/
		select?: BlockSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockInclude | null
		/**
		 * Filter which Block to delete.
		 *
		 **/
		where: BlockWhereUniqueInput
	}


	/**
	 * Block deleteMany
	 */
	export type BlockDeleteManyArgs = {
		/**
		 * Filter which Blocks to delete
		 *
		 **/
		where?: BlockWhereInput
	}


	/**
	 * Block without action
	 */
	export type BlockArgs = {
		/**
		 * Select specific fields to fetch from the Block
		 *
		 **/
		select?: BlockSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockInclude | null
	}



	/**
	 * Model BlockVersion
	 */


	export type AggregateBlockVersion = {
		_count: BlockVersionCountAggregateOutputType | null
		_avg: BlockVersionAvgAggregateOutputType | null
		_sum: BlockVersionSumAggregateOutputType | null
		_min: BlockVersionMinAggregateOutputType | null
		_max: BlockVersionMaxAggregateOutputType | null
	}

	export type BlockVersionAvgAggregateOutputType = {
		versionNumber: number | null
	}

	export type BlockVersionSumAggregateOutputType = {
		versionNumber: number | null
	}

	export type BlockVersionMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		blockId: string | null
		versionNumber: number | null
		displayName: string | null
		description: string | null
		commitId: string | null
		deleted: boolean | null
	}

	export type BlockVersionMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		blockId: string | null
		versionNumber: number | null
		displayName: string | null
		description: string | null
		commitId: string | null
		deleted: boolean | null
	}

	export type BlockVersionCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		blockId: number
		versionNumber: number
		inputParameters: number
		outputParameters: number
		settings: number
		displayName: number
		description: number
		commitId: number
		deleted: number
		_all: number
	}


	export type BlockVersionAvgAggregateInputType = {
		versionNumber?: true
	}

	export type BlockVersionSumAggregateInputType = {
		versionNumber?: true
	}

	export type BlockVersionMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		blockId?: true
		versionNumber?: true
		displayName?: true
		description?: true
		commitId?: true
		deleted?: true
	}

	export type BlockVersionMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		blockId?: true
		versionNumber?: true
		displayName?: true
		description?: true
		commitId?: true
		deleted?: true
	}

	export type BlockVersionCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		blockId?: true
		versionNumber?: true
		inputParameters?: true
		outputParameters?: true
		settings?: true
		displayName?: true
		description?: true
		commitId?: true
		deleted?: true
		_all?: true
	}

	export type BlockVersionAggregateArgs = {
		/**
		 * Filter which BlockVersion to aggregate.
		 *
		 **/
		where?: BlockVersionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of BlockVersions to fetch.
		 *
		 **/
		orderBy?: Enumerable<BlockVersionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: BlockVersionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` BlockVersions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` BlockVersions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned BlockVersions
		 **/
		_count?: true | BlockVersionCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to average
		 **/
		_avg?: BlockVersionAvgAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to sum
		 **/
		_sum?: BlockVersionSumAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: BlockVersionMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: BlockVersionMaxAggregateInputType
	}

	export type GetBlockVersionAggregateType<T extends BlockVersionAggregateArgs> = {
		[P in keyof T & keyof AggregateBlockVersion]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateBlockVersion[P]>
			: GetScalarType<T[P], AggregateBlockVersion[P]>
	}




	export type BlockVersionGroupByArgs = {
		where?: BlockVersionWhereInput
		orderBy?: Enumerable<BlockVersionOrderByWithAggregationInput>
		by: Array<BlockVersionScalarFieldEnum>
		having?: BlockVersionScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: BlockVersionCountAggregateInputType | true
		_avg?: BlockVersionAvgAggregateInputType
		_sum?: BlockVersionSumAggregateInputType
		_min?: BlockVersionMinAggregateInputType
		_max?: BlockVersionMaxAggregateInputType
	}


	export type BlockVersionGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		blockId: string
		versionNumber: number
		inputParameters: JsonValue | null
		outputParameters: JsonValue | null
		settings: JsonValue
		displayName: string
		description: string | null
		commitId: string | null
		deleted: boolean | null
		_count: BlockVersionCountAggregateOutputType | null
		_avg: BlockVersionAvgAggregateOutputType | null
		_sum: BlockVersionSumAggregateOutputType | null
		_min: BlockVersionMinAggregateOutputType | null
		_max: BlockVersionMaxAggregateOutputType | null
	}

	type GetBlockVersionGroupByPayload<T extends BlockVersionGroupByArgs> = PrismaPromise<
		Array<
			PickArray<BlockVersionGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof BlockVersionGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], BlockVersionGroupByOutputType[P]>
				: GetScalarType<T[P], BlockVersionGroupByOutputType[P]>
			}
			>
		>


	export type BlockVersionSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		blockId?: boolean
		versionNumber?: boolean
		inputParameters?: boolean
		outputParameters?: boolean
		settings?: boolean
		displayName?: boolean
		description?: boolean
		commitId?: boolean
		deleted?: boolean
		block?: boolean | BlockArgs
		commit?: boolean | CommitArgs
		builds?: boolean | BuildFindManyArgs
		_count?: boolean | BlockVersionCountOutputTypeArgs
	}

	export type BlockVersionInclude = {
		block?: boolean | BlockArgs
		commit?: boolean | CommitArgs
		builds?: boolean | BuildFindManyArgs
		_count?: boolean | BlockVersionCountOutputTypeArgs
	}

	export type BlockVersionGetPayload<
		S extends boolean | null | undefined | BlockVersionArgs,
		U = keyof S
		> = S extends true
		? BlockVersion
		: S extends undefined
			? never
			: S extends BlockVersionArgs | BlockVersionFindManyArgs
				?'include' extends U
					? BlockVersion  & {
					[P in TrueKeys<S['include']>]:
					P extends 'block' ? BlockGetPayload<S['include'][P]> :
						P extends 'commit' ? CommitGetPayload<S['include'][P]> | null :
							P extends 'builds' ? Array < BuildGetPayload<S['include'][P]>>  :
								P extends '_count' ? BlockVersionCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'block' ? BlockGetPayload<S['select'][P]> :
								P extends 'commit' ? CommitGetPayload<S['select'][P]> | null :
									P extends 'builds' ? Array < BuildGetPayload<S['select'][P]>>  :
										P extends '_count' ? BlockVersionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BlockVersion ? BlockVersion[P] : never
						}
						: BlockVersion
				: BlockVersion


	type BlockVersionCountArgs = Merge<
		Omit<BlockVersionFindManyArgs, 'select' | 'include'> & {
		select?: BlockVersionCountAggregateInputType | true
	}
		>

	export interface BlockVersionDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one BlockVersion that matches the filter.
		 * @param {BlockVersionFindUniqueArgs} args - Arguments to find a BlockVersion
		 * @example
		 * // Get one BlockVersion
		 * const blockVersion = await prisma.blockVersion.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends BlockVersionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, BlockVersionFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BlockVersion'> extends True ? CheckSelect<T, Prisma__BlockVersionClient<BlockVersion>, Prisma__BlockVersionClient<BlockVersionGetPayload<T>>> : CheckSelect<T, Prisma__BlockVersionClient<BlockVersion | null >, Prisma__BlockVersionClient<BlockVersionGetPayload<T> | null >>

		/**
		 * Find the first BlockVersion that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockVersionFindFirstArgs} args - Arguments to find a BlockVersion
		 * @example
		 * // Get one BlockVersion
		 * const blockVersion = await prisma.blockVersion.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends BlockVersionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, BlockVersionFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BlockVersion'> extends True ? CheckSelect<T, Prisma__BlockVersionClient<BlockVersion>, Prisma__BlockVersionClient<BlockVersionGetPayload<T>>> : CheckSelect<T, Prisma__BlockVersionClient<BlockVersion | null >, Prisma__BlockVersionClient<BlockVersionGetPayload<T> | null >>

		/**
		 * Find zero or more BlockVersions that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockVersionFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all BlockVersions
		 * const blockVersions = await prisma.blockVersion.findMany()
		 *
		 * // Get first 10 BlockVersions
		 * const blockVersions = await prisma.blockVersion.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const blockVersionWithIdOnly = await prisma.blockVersion.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends BlockVersionFindManyArgs>(
			args?: SelectSubset<T, BlockVersionFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<BlockVersion>>, PrismaPromise<Array<BlockVersionGetPayload<T>>>>

		/**
		 * Create a BlockVersion.
		 * @param {BlockVersionCreateArgs} args - Arguments to create a BlockVersion.
		 * @example
		 * // Create one BlockVersion
		 * const BlockVersion = await prisma.blockVersion.create({
		 *   data: {
		 *     // ... data to create a BlockVersion
		 *   }
		 * })
		 *
		 **/
		create<T extends BlockVersionCreateArgs>(
			args: SelectSubset<T, BlockVersionCreateArgs>
		): CheckSelect<T, Prisma__BlockVersionClient<BlockVersion>, Prisma__BlockVersionClient<BlockVersionGetPayload<T>>>

		/**
		 * Create many BlockVersions.
		 *     @param {BlockVersionCreateManyArgs} args - Arguments to create many BlockVersions.
		 *     @example
		 *     // Create many BlockVersions
		 *     const blockVersion = await prisma.blockVersion.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends BlockVersionCreateManyArgs>(
			args?: SelectSubset<T, BlockVersionCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a BlockVersion.
		 * @param {BlockVersionDeleteArgs} args - Arguments to delete one BlockVersion.
		 * @example
		 * // Delete one BlockVersion
		 * const BlockVersion = await prisma.blockVersion.delete({
		 *   where: {
		 *     // ... filter to delete one BlockVersion
		 *   }
		 * })
		 *
		 **/
		delete<T extends BlockVersionDeleteArgs>(
			args: SelectSubset<T, BlockVersionDeleteArgs>
		): CheckSelect<T, Prisma__BlockVersionClient<BlockVersion>, Prisma__BlockVersionClient<BlockVersionGetPayload<T>>>

		/**
		 * Update one BlockVersion.
		 * @param {BlockVersionUpdateArgs} args - Arguments to update one BlockVersion.
		 * @example
		 * // Update one BlockVersion
		 * const blockVersion = await prisma.blockVersion.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends BlockVersionUpdateArgs>(
			args: SelectSubset<T, BlockVersionUpdateArgs>
		): CheckSelect<T, Prisma__BlockVersionClient<BlockVersion>, Prisma__BlockVersionClient<BlockVersionGetPayload<T>>>

		/**
		 * Delete zero or more BlockVersions.
		 * @param {BlockVersionDeleteManyArgs} args - Arguments to filter BlockVersions to delete.
		 * @example
		 * // Delete a few BlockVersions
		 * const { count } = await prisma.blockVersion.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends BlockVersionDeleteManyArgs>(
			args?: SelectSubset<T, BlockVersionDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more BlockVersions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockVersionUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many BlockVersions
		 * const blockVersion = await prisma.blockVersion.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends BlockVersionUpdateManyArgs>(
			args: SelectSubset<T, BlockVersionUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one BlockVersion.
		 * @param {BlockVersionUpsertArgs} args - Arguments to update or create a BlockVersion.
		 * @example
		 * // Update or create a BlockVersion
		 * const blockVersion = await prisma.blockVersion.upsert({
		 *   create: {
		 *     // ... data to create a BlockVersion
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the BlockVersion we want to update
		 *   }
		 * })
		 **/
		upsert<T extends BlockVersionUpsertArgs>(
			args: SelectSubset<T, BlockVersionUpsertArgs>
		): CheckSelect<T, Prisma__BlockVersionClient<BlockVersion>, Prisma__BlockVersionClient<BlockVersionGetPayload<T>>>

		/**
		 * Count the number of BlockVersions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockVersionCountArgs} args - Arguments to filter BlockVersions to count.
		 * @example
		 * // Count the number of BlockVersions
		 * const count = await prisma.blockVersion.count({
		 *   where: {
		 *     // ... the filter for the BlockVersions we want to count
		 *   }
		 * })
		 **/
		count<T extends BlockVersionCountArgs>(
			args?: Subset<T, BlockVersionCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], BlockVersionCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a BlockVersion.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends BlockVersionAggregateArgs>(args: Subset<T, BlockVersionAggregateArgs>): PrismaPromise<GetBlockVersionAggregateType<T>>

		/**
		 * Group by BlockVersion.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BlockVersionGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends BlockVersionGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: BlockVersionGroupByArgs['orderBy'] }
				: { orderBy?: BlockVersionGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, BlockVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockVersionGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for BlockVersion.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__BlockVersionClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		block<T extends BlockArgs = {}>(args?: Subset<T, BlockArgs>): CheckSelect<T, Prisma__BlockClient<Block | null >, Prisma__BlockClient<BlockGetPayload<T> | null >>;

		commit<T extends CommitArgs = {}>(args?: Subset<T, CommitArgs>): CheckSelect<T, Prisma__CommitClient<Commit | null >, Prisma__CommitClient<CommitGetPayload<T> | null >>;

		builds<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * BlockVersion findUnique
	 */
	export type BlockVersionFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the BlockVersion
		 *
		 **/
		select?: BlockVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockVersionInclude | null
		/**
		 * Throw an Error if a BlockVersion can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which BlockVersion to fetch.
		 *
		 **/
		where: BlockVersionWhereUniqueInput
	}


	/**
	 * BlockVersion findFirst
	 */
	export type BlockVersionFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the BlockVersion
		 *
		 **/
		select?: BlockVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockVersionInclude | null
		/**
		 * Throw an Error if a BlockVersion can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which BlockVersion to fetch.
		 *
		 **/
		where?: BlockVersionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of BlockVersions to fetch.
		 *
		 **/
		orderBy?: Enumerable<BlockVersionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for BlockVersions.
		 *
		 **/
		cursor?: BlockVersionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` BlockVersions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` BlockVersions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of BlockVersions.
		 *
		 **/
		distinct?: Enumerable<BlockVersionScalarFieldEnum>
	}


	/**
	 * BlockVersion findMany
	 */
	export type BlockVersionFindManyArgs = {
		/**
		 * Select specific fields to fetch from the BlockVersion
		 *
		 **/
		select?: BlockVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockVersionInclude | null
		/**
		 * Filter, which BlockVersions to fetch.
		 *
		 **/
		where?: BlockVersionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of BlockVersions to fetch.
		 *
		 **/
		orderBy?: Enumerable<BlockVersionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing BlockVersions.
		 *
		 **/
		cursor?: BlockVersionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` BlockVersions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` BlockVersions.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<BlockVersionScalarFieldEnum>
	}


	/**
	 * BlockVersion create
	 */
	export type BlockVersionCreateArgs = {
		/**
		 * Select specific fields to fetch from the BlockVersion
		 *
		 **/
		select?: BlockVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockVersionInclude | null
		/**
		 * The data needed to create a BlockVersion.
		 *
		 **/
		data: XOR<BlockVersionCreateInput, BlockVersionUncheckedCreateInput>
	}


	/**
	 * BlockVersion createMany
	 */
	export type BlockVersionCreateManyArgs = {
		/**
		 * The data used to create many BlockVersions.
		 *
		 **/
		data: Enumerable<BlockVersionCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * BlockVersion update
	 */
	export type BlockVersionUpdateArgs = {
		/**
		 * Select specific fields to fetch from the BlockVersion
		 *
		 **/
		select?: BlockVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockVersionInclude | null
		/**
		 * The data needed to update a BlockVersion.
		 *
		 **/
		data: XOR<BlockVersionUpdateInput, BlockVersionUncheckedUpdateInput>
		/**
		 * Choose, which BlockVersion to update.
		 *
		 **/
		where: BlockVersionWhereUniqueInput
	}


	/**
	 * BlockVersion updateMany
	 */
	export type BlockVersionUpdateManyArgs = {
		/**
		 * The data used to update BlockVersions.
		 *
		 **/
		data: XOR<BlockVersionUpdateManyMutationInput, BlockVersionUncheckedUpdateManyInput>
		/**
		 * Filter which BlockVersions to update
		 *
		 **/
		where?: BlockVersionWhereInput
	}


	/**
	 * BlockVersion upsert
	 */
	export type BlockVersionUpsertArgs = {
		/**
		 * Select specific fields to fetch from the BlockVersion
		 *
		 **/
		select?: BlockVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockVersionInclude | null
		/**
		 * The filter to search for the BlockVersion to update in case it exists.
		 *
		 **/
		where: BlockVersionWhereUniqueInput
		/**
		 * In case the BlockVersion found by the `where` argument doesn't exist, create a new BlockVersion with this data.
		 *
		 **/
		create: XOR<BlockVersionCreateInput, BlockVersionUncheckedCreateInput>
		/**
		 * In case the BlockVersion was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<BlockVersionUpdateInput, BlockVersionUncheckedUpdateInput>
	}


	/**
	 * BlockVersion delete
	 */
	export type BlockVersionDeleteArgs = {
		/**
		 * Select specific fields to fetch from the BlockVersion
		 *
		 **/
		select?: BlockVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockVersionInclude | null
		/**
		 * Filter which BlockVersion to delete.
		 *
		 **/
		where: BlockVersionWhereUniqueInput
	}


	/**
	 * BlockVersion deleteMany
	 */
	export type BlockVersionDeleteManyArgs = {
		/**
		 * Filter which BlockVersions to delete
		 *
		 **/
		where?: BlockVersionWhereInput
	}


	/**
	 * BlockVersion without action
	 */
	export type BlockVersionArgs = {
		/**
		 * Select specific fields to fetch from the BlockVersion
		 *
		 **/
		select?: BlockVersionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BlockVersionInclude | null
	}



	/**
	 * Model Action
	 */


	export type AggregateAction = {
		_count: ActionCountAggregateOutputType | null
		_min: ActionMinAggregateOutputType | null
		_max: ActionMaxAggregateOutputType | null
	}

	export type ActionMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
	}

	export type ActionMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
	}

	export type ActionCountAggregateOutputType = {
		id: number
		createdAt: number
		_all: number
	}


	export type ActionMinAggregateInputType = {
		id?: true
		createdAt?: true
	}

	export type ActionMaxAggregateInputType = {
		id?: true
		createdAt?: true
	}

	export type ActionCountAggregateInputType = {
		id?: true
		createdAt?: true
		_all?: true
	}

	export type ActionAggregateArgs = {
		/**
		 * Filter which Action to aggregate.
		 *
		 **/
		where?: ActionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Actions to fetch.
		 *
		 **/
		orderBy?: Enumerable<ActionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: ActionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Actions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Actions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Actions
		 **/
		_count?: true | ActionCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ActionMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ActionMaxAggregateInputType
	}

	export type GetActionAggregateType<T extends ActionAggregateArgs> = {
		[P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateAction[P]>
			: GetScalarType<T[P], AggregateAction[P]>
	}




	export type ActionGroupByArgs = {
		where?: ActionWhereInput
		orderBy?: Enumerable<ActionOrderByWithAggregationInput>
		by: Array<ActionScalarFieldEnum>
		having?: ActionScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ActionCountAggregateInputType | true
		_min?: ActionMinAggregateInputType
		_max?: ActionMaxAggregateInputType
	}


	export type ActionGroupByOutputType = {
		id: string
		createdAt: Date
		_count: ActionCountAggregateOutputType | null
		_min: ActionMinAggregateOutputType | null
		_max: ActionMaxAggregateOutputType | null
	}

	type GetActionGroupByPayload<T extends ActionGroupByArgs> = PrismaPromise<
		Array<
			PickArray<ActionGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], ActionGroupByOutputType[P]>
				: GetScalarType<T[P], ActionGroupByOutputType[P]>
			}
			>
		>


	export type ActionSelect = {
		id?: boolean
		createdAt?: boolean
		steps?: boolean | ActionStepFindManyArgs
		builds?: boolean | BuildFindManyArgs
		deployments?: boolean | DeploymentFindManyArgs
		_count?: boolean | ActionCountOutputTypeArgs
	}

	export type ActionInclude = {
		steps?: boolean | ActionStepFindManyArgs
		builds?: boolean | BuildFindManyArgs
		deployments?: boolean | DeploymentFindManyArgs
		_count?: boolean | ActionCountOutputTypeArgs
	}

	export type ActionGetPayload<
		S extends boolean | null | undefined | ActionArgs,
		U = keyof S
		> = S extends true
		? Action
		: S extends undefined
			? never
			: S extends ActionArgs | ActionFindManyArgs
				?'include' extends U
					? Action  & {
					[P in TrueKeys<S['include']>]:
					P extends 'steps' ? Array < ActionStepGetPayload<S['include'][P]>>  :
						P extends 'builds' ? Array < BuildGetPayload<S['include'][P]>>  :
							P extends 'deployments' ? Array < DeploymentGetPayload<S['include'][P]>>  :
								P extends '_count' ? ActionCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'steps' ? Array < ActionStepGetPayload<S['select'][P]>>  :
								P extends 'builds' ? Array < BuildGetPayload<S['select'][P]>>  :
									P extends 'deployments' ? Array < DeploymentGetPayload<S['select'][P]>>  :
										P extends '_count' ? ActionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Action ? Action[P] : never
						}
						: Action
				: Action


	type ActionCountArgs = Merge<
		Omit<ActionFindManyArgs, 'select' | 'include'> & {
		select?: ActionCountAggregateInputType | true
	}
		>

	export interface ActionDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Action that matches the filter.
		 * @param {ActionFindUniqueArgs} args - Arguments to find a Action
		 * @example
		 * // Get one Action
		 * const action = await prisma.action.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends ActionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, ActionFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Action'> extends True ? CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>> : CheckSelect<T, Prisma__ActionClient<Action | null >, Prisma__ActionClient<ActionGetPayload<T> | null >>

		/**
		 * Find the first Action that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionFindFirstArgs} args - Arguments to find a Action
		 * @example
		 * // Get one Action
		 * const action = await prisma.action.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends ActionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, ActionFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Action'> extends True ? CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>> : CheckSelect<T, Prisma__ActionClient<Action | null >, Prisma__ActionClient<ActionGetPayload<T> | null >>

		/**
		 * Find zero or more Actions that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Actions
		 * const actions = await prisma.action.findMany()
		 *
		 * // Get first 10 Actions
		 * const actions = await prisma.action.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends ActionFindManyArgs>(
			args?: SelectSubset<T, ActionFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Action>>, PrismaPromise<Array<ActionGetPayload<T>>>>

		/**
		 * Create a Action.
		 * @param {ActionCreateArgs} args - Arguments to create a Action.
		 * @example
		 * // Create one Action
		 * const Action = await prisma.action.create({
		 *   data: {
		 *     // ... data to create a Action
		 *   }
		 * })
		 *
		 **/
		create<T extends ActionCreateArgs>(
			args: SelectSubset<T, ActionCreateArgs>
		): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

		/**
		 * Create many Actions.
		 *     @param {ActionCreateManyArgs} args - Arguments to create many Actions.
		 *     @example
		 *     // Create many Actions
		 *     const action = await prisma.action.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends ActionCreateManyArgs>(
			args?: SelectSubset<T, ActionCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Action.
		 * @param {ActionDeleteArgs} args - Arguments to delete one Action.
		 * @example
		 * // Delete one Action
		 * const Action = await prisma.action.delete({
		 *   where: {
		 *     // ... filter to delete one Action
		 *   }
		 * })
		 *
		 **/
		delete<T extends ActionDeleteArgs>(
			args: SelectSubset<T, ActionDeleteArgs>
		): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

		/**
		 * Update one Action.
		 * @param {ActionUpdateArgs} args - Arguments to update one Action.
		 * @example
		 * // Update one Action
		 * const action = await prisma.action.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends ActionUpdateArgs>(
			args: SelectSubset<T, ActionUpdateArgs>
		): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

		/**
		 * Delete zero or more Actions.
		 * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
		 * @example
		 * // Delete a few Actions
		 * const { count } = await prisma.action.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends ActionDeleteManyArgs>(
			args?: SelectSubset<T, ActionDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Actions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Actions
		 * const action = await prisma.action.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends ActionUpdateManyArgs>(
			args: SelectSubset<T, ActionUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Action.
		 * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
		 * @example
		 * // Update or create a Action
		 * const action = await prisma.action.upsert({
		 *   create: {
		 *     // ... data to create a Action
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Action we want to update
		 *   }
		 * })
		 **/
		upsert<T extends ActionUpsertArgs>(
			args: SelectSubset<T, ActionUpsertArgs>
		): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

		/**
		 * Count the number of Actions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionCountArgs} args - Arguments to filter Actions to count.
		 * @example
		 * // Count the number of Actions
		 * const count = await prisma.action.count({
		 *   where: {
		 *     // ... the filter for the Actions we want to count
		 *   }
		 * })
		 **/
		count<T extends ActionCountArgs>(
			args?: Subset<T, ActionCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ActionCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Action.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): PrismaPromise<GetActionAggregateType<T>>

		/**
		 * Group by Action.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ActionGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ActionGroupByArgs['orderBy'] }
				: { orderBy?: ActionGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Action.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__ActionClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		steps<T extends ActionStepFindManyArgs = {}>(args?: Subset<T, ActionStepFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ActionStep>>, PrismaPromise<Array<ActionStepGetPayload<T>>>>;

		builds<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

		deployments<T extends DeploymentFindManyArgs = {}>(args?: Subset<T, DeploymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Deployment>>, PrismaPromise<Array<DeploymentGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Action findUnique
	 */
	export type ActionFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Action
		 *
		 **/
		select?: ActionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionInclude | null
		/**
		 * Throw an Error if a Action can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Action to fetch.
		 *
		 **/
		where: ActionWhereUniqueInput
	}


	/**
	 * Action findFirst
	 */
	export type ActionFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Action
		 *
		 **/
		select?: ActionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionInclude | null
		/**
		 * Throw an Error if a Action can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Action to fetch.
		 *
		 **/
		where?: ActionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Actions to fetch.
		 *
		 **/
		orderBy?: Enumerable<ActionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Actions.
		 *
		 **/
		cursor?: ActionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Actions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Actions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Actions.
		 *
		 **/
		distinct?: Enumerable<ActionScalarFieldEnum>
	}


	/**
	 * Action findMany
	 */
	export type ActionFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Action
		 *
		 **/
		select?: ActionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionInclude | null
		/**
		 * Filter, which Actions to fetch.
		 *
		 **/
		where?: ActionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Actions to fetch.
		 *
		 **/
		orderBy?: Enumerable<ActionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Actions.
		 *
		 **/
		cursor?: ActionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Actions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Actions.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<ActionScalarFieldEnum>
	}


	/**
	 * Action create
	 */
	export type ActionCreateArgs = {
		/**
		 * Select specific fields to fetch from the Action
		 *
		 **/
		select?: ActionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionInclude | null
		/**
		 * The data needed to create a Action.
		 *
		 **/
		data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
	}


	/**
	 * Action createMany
	 */
	export type ActionCreateManyArgs = {
		/**
		 * The data used to create many Actions.
		 *
		 **/
		data: Enumerable<ActionCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Action update
	 */
	export type ActionUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Action
		 *
		 **/
		select?: ActionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionInclude | null
		/**
		 * The data needed to update a Action.
		 *
		 **/
		data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
		/**
		 * Choose, which Action to update.
		 *
		 **/
		where: ActionWhereUniqueInput
	}


	/**
	 * Action updateMany
	 */
	export type ActionUpdateManyArgs = {
		/**
		 * The data used to update Actions.
		 *
		 **/
		data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
		/**
		 * Filter which Actions to update
		 *
		 **/
		where?: ActionWhereInput
	}


	/**
	 * Action upsert
	 */
	export type ActionUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Action
		 *
		 **/
		select?: ActionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionInclude | null
		/**
		 * The filter to search for the Action to update in case it exists.
		 *
		 **/
		where: ActionWhereUniqueInput
		/**
		 * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
		 *
		 **/
		create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
		/**
		 * In case the Action was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
	}


	/**
	 * Action delete
	 */
	export type ActionDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Action
		 *
		 **/
		select?: ActionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionInclude | null
		/**
		 * Filter which Action to delete.
		 *
		 **/
		where: ActionWhereUniqueInput
	}


	/**
	 * Action deleteMany
	 */
	export type ActionDeleteManyArgs = {
		/**
		 * Filter which Actions to delete
		 *
		 **/
		where?: ActionWhereInput
	}


	/**
	 * Action without action
	 */
	export type ActionArgs = {
		/**
		 * Select specific fields to fetch from the Action
		 *
		 **/
		select?: ActionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionInclude | null
	}



	/**
	 * Model ActionStep
	 */


	export type AggregateActionStep = {
		_count: ActionStepCountAggregateOutputType | null
		_min: ActionStepMinAggregateOutputType | null
		_max: ActionStepMaxAggregateOutputType | null
	}

	export type ActionStepMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		message: string | null
		status: ActionStepStatus | null
		completedAt: Date | null
		actionId: string | null
		name: string | null
	}

	export type ActionStepMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		message: string | null
		status: ActionStepStatus | null
		completedAt: Date | null
		actionId: string | null
		name: string | null
	}

	export type ActionStepCountAggregateOutputType = {
		id: number
		createdAt: number
		message: number
		status: number
		completedAt: number
		actionId: number
		name: number
		_all: number
	}


	export type ActionStepMinAggregateInputType = {
		id?: true
		createdAt?: true
		message?: true
		status?: true
		completedAt?: true
		actionId?: true
		name?: true
	}

	export type ActionStepMaxAggregateInputType = {
		id?: true
		createdAt?: true
		message?: true
		status?: true
		completedAt?: true
		actionId?: true
		name?: true
	}

	export type ActionStepCountAggregateInputType = {
		id?: true
		createdAt?: true
		message?: true
		status?: true
		completedAt?: true
		actionId?: true
		name?: true
		_all?: true
	}

	export type ActionStepAggregateArgs = {
		/**
		 * Filter which ActionStep to aggregate.
		 *
		 **/
		where?: ActionStepWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ActionSteps to fetch.
		 *
		 **/
		orderBy?: Enumerable<ActionStepOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: ActionStepWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ActionSteps from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ActionSteps.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned ActionSteps
		 **/
		_count?: true | ActionStepCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ActionStepMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ActionStepMaxAggregateInputType
	}

	export type GetActionStepAggregateType<T extends ActionStepAggregateArgs> = {
		[P in keyof T & keyof AggregateActionStep]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateActionStep[P]>
			: GetScalarType<T[P], AggregateActionStep[P]>
	}




	export type ActionStepGroupByArgs = {
		where?: ActionStepWhereInput
		orderBy?: Enumerable<ActionStepOrderByWithAggregationInput>
		by: Array<ActionStepScalarFieldEnum>
		having?: ActionStepScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ActionStepCountAggregateInputType | true
		_min?: ActionStepMinAggregateInputType
		_max?: ActionStepMaxAggregateInputType
	}


	export type ActionStepGroupByOutputType = {
		id: string
		createdAt: Date
		message: string
		status: ActionStepStatus
		completedAt: Date | null
		actionId: string
		name: string
		_count: ActionStepCountAggregateOutputType | null
		_min: ActionStepMinAggregateOutputType | null
		_max: ActionStepMaxAggregateOutputType | null
	}

	type GetActionStepGroupByPayload<T extends ActionStepGroupByArgs> = PrismaPromise<
		Array<
			PickArray<ActionStepGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof ActionStepGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], ActionStepGroupByOutputType[P]>
				: GetScalarType<T[P], ActionStepGroupByOutputType[P]>
			}
			>
		>


	export type ActionStepSelect = {
		id?: boolean
		createdAt?: boolean
		message?: boolean
		status?: boolean
		completedAt?: boolean
		actionId?: boolean
		name?: boolean
		action?: boolean | ActionArgs
		logs?: boolean | ActionLogFindManyArgs
		_count?: boolean | ActionStepCountOutputTypeArgs
	}

	export type ActionStepInclude = {
		action?: boolean | ActionArgs
		logs?: boolean | ActionLogFindManyArgs
		_count?: boolean | ActionStepCountOutputTypeArgs
	}

	export type ActionStepGetPayload<
		S extends boolean | null | undefined | ActionStepArgs,
		U = keyof S
		> = S extends true
		? ActionStep
		: S extends undefined
			? never
			: S extends ActionStepArgs | ActionStepFindManyArgs
				?'include' extends U
					? ActionStep  & {
					[P in TrueKeys<S['include']>]:
					P extends 'action' ? ActionGetPayload<S['include'][P]> :
						P extends 'logs' ? Array < ActionLogGetPayload<S['include'][P]>>  :
							P extends '_count' ? ActionStepCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'action' ? ActionGetPayload<S['select'][P]> :
								P extends 'logs' ? Array < ActionLogGetPayload<S['select'][P]>>  :
									P extends '_count' ? ActionStepCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ActionStep ? ActionStep[P] : never
						}
						: ActionStep
				: ActionStep


	type ActionStepCountArgs = Merge<
		Omit<ActionStepFindManyArgs, 'select' | 'include'> & {
		select?: ActionStepCountAggregateInputType | true
	}
		>

	export interface ActionStepDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one ActionStep that matches the filter.
		 * @param {ActionStepFindUniqueArgs} args - Arguments to find a ActionStep
		 * @example
		 * // Get one ActionStep
		 * const actionStep = await prisma.actionStep.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends ActionStepFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, ActionStepFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ActionStep'> extends True ? CheckSelect<T, Prisma__ActionStepClient<ActionStep>, Prisma__ActionStepClient<ActionStepGetPayload<T>>> : CheckSelect<T, Prisma__ActionStepClient<ActionStep | null >, Prisma__ActionStepClient<ActionStepGetPayload<T> | null >>

		/**
		 * Find the first ActionStep that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionStepFindFirstArgs} args - Arguments to find a ActionStep
		 * @example
		 * // Get one ActionStep
		 * const actionStep = await prisma.actionStep.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends ActionStepFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, ActionStepFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ActionStep'> extends True ? CheckSelect<T, Prisma__ActionStepClient<ActionStep>, Prisma__ActionStepClient<ActionStepGetPayload<T>>> : CheckSelect<T, Prisma__ActionStepClient<ActionStep | null >, Prisma__ActionStepClient<ActionStepGetPayload<T> | null >>

		/**
		 * Find zero or more ActionSteps that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionStepFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all ActionSteps
		 * const actionSteps = await prisma.actionStep.findMany()
		 *
		 * // Get first 10 ActionSteps
		 * const actionSteps = await prisma.actionStep.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const actionStepWithIdOnly = await prisma.actionStep.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends ActionStepFindManyArgs>(
			args?: SelectSubset<T, ActionStepFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<ActionStep>>, PrismaPromise<Array<ActionStepGetPayload<T>>>>

		/**
		 * Create a ActionStep.
		 * @param {ActionStepCreateArgs} args - Arguments to create a ActionStep.
		 * @example
		 * // Create one ActionStep
		 * const ActionStep = await prisma.actionStep.create({
		 *   data: {
		 *     // ... data to create a ActionStep
		 *   }
		 * })
		 *
		 **/
		create<T extends ActionStepCreateArgs>(
			args: SelectSubset<T, ActionStepCreateArgs>
		): CheckSelect<T, Prisma__ActionStepClient<ActionStep>, Prisma__ActionStepClient<ActionStepGetPayload<T>>>

		/**
		 * Create many ActionSteps.
		 *     @param {ActionStepCreateManyArgs} args - Arguments to create many ActionSteps.
		 *     @example
		 *     // Create many ActionSteps
		 *     const actionStep = await prisma.actionStep.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends ActionStepCreateManyArgs>(
			args?: SelectSubset<T, ActionStepCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a ActionStep.
		 * @param {ActionStepDeleteArgs} args - Arguments to delete one ActionStep.
		 * @example
		 * // Delete one ActionStep
		 * const ActionStep = await prisma.actionStep.delete({
		 *   where: {
		 *     // ... filter to delete one ActionStep
		 *   }
		 * })
		 *
		 **/
		delete<T extends ActionStepDeleteArgs>(
			args: SelectSubset<T, ActionStepDeleteArgs>
		): CheckSelect<T, Prisma__ActionStepClient<ActionStep>, Prisma__ActionStepClient<ActionStepGetPayload<T>>>

		/**
		 * Update one ActionStep.
		 * @param {ActionStepUpdateArgs} args - Arguments to update one ActionStep.
		 * @example
		 * // Update one ActionStep
		 * const actionStep = await prisma.actionStep.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends ActionStepUpdateArgs>(
			args: SelectSubset<T, ActionStepUpdateArgs>
		): CheckSelect<T, Prisma__ActionStepClient<ActionStep>, Prisma__ActionStepClient<ActionStepGetPayload<T>>>

		/**
		 * Delete zero or more ActionSteps.
		 * @param {ActionStepDeleteManyArgs} args - Arguments to filter ActionSteps to delete.
		 * @example
		 * // Delete a few ActionSteps
		 * const { count } = await prisma.actionStep.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends ActionStepDeleteManyArgs>(
			args?: SelectSubset<T, ActionStepDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more ActionSteps.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionStepUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many ActionSteps
		 * const actionStep = await prisma.actionStep.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends ActionStepUpdateManyArgs>(
			args: SelectSubset<T, ActionStepUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one ActionStep.
		 * @param {ActionStepUpsertArgs} args - Arguments to update or create a ActionStep.
		 * @example
		 * // Update or create a ActionStep
		 * const actionStep = await prisma.actionStep.upsert({
		 *   create: {
		 *     // ... data to create a ActionStep
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the ActionStep we want to update
		 *   }
		 * })
		 **/
		upsert<T extends ActionStepUpsertArgs>(
			args: SelectSubset<T, ActionStepUpsertArgs>
		): CheckSelect<T, Prisma__ActionStepClient<ActionStep>, Prisma__ActionStepClient<ActionStepGetPayload<T>>>

		/**
		 * Count the number of ActionSteps.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionStepCountArgs} args - Arguments to filter ActionSteps to count.
		 * @example
		 * // Count the number of ActionSteps
		 * const count = await prisma.actionStep.count({
		 *   where: {
		 *     // ... the filter for the ActionSteps we want to count
		 *   }
		 * })
		 **/
		count<T extends ActionStepCountArgs>(
			args?: Subset<T, ActionStepCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ActionStepCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a ActionStep.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ActionStepAggregateArgs>(args: Subset<T, ActionStepAggregateArgs>): PrismaPromise<GetActionStepAggregateType<T>>

		/**
		 * Group by ActionStep.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionStepGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ActionStepGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ActionStepGroupByArgs['orderBy'] }
				: { orderBy?: ActionStepGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, ActionStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionStepGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for ActionStep.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__ActionStepClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		action<T extends ActionArgs = {}>(args?: Subset<T, ActionArgs>): CheckSelect<T, Prisma__ActionClient<Action | null >, Prisma__ActionClient<ActionGetPayload<T> | null >>;

		logs<T extends ActionLogFindManyArgs = {}>(args?: Subset<T, ActionLogFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ActionLog>>, PrismaPromise<Array<ActionLogGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * ActionStep findUnique
	 */
	export type ActionStepFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the ActionStep
		 *
		 **/
		select?: ActionStepSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionStepInclude | null
		/**
		 * Throw an Error if a ActionStep can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which ActionStep to fetch.
		 *
		 **/
		where: ActionStepWhereUniqueInput
	}


	/**
	 * ActionStep findFirst
	 */
	export type ActionStepFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the ActionStep
		 *
		 **/
		select?: ActionStepSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionStepInclude | null
		/**
		 * Throw an Error if a ActionStep can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which ActionStep to fetch.
		 *
		 **/
		where?: ActionStepWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ActionSteps to fetch.
		 *
		 **/
		orderBy?: Enumerable<ActionStepOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for ActionSteps.
		 *
		 **/
		cursor?: ActionStepWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ActionSteps from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ActionSteps.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of ActionSteps.
		 *
		 **/
		distinct?: Enumerable<ActionStepScalarFieldEnum>
	}


	/**
	 * ActionStep findMany
	 */
	export type ActionStepFindManyArgs = {
		/**
		 * Select specific fields to fetch from the ActionStep
		 *
		 **/
		select?: ActionStepSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionStepInclude | null
		/**
		 * Filter, which ActionSteps to fetch.
		 *
		 **/
		where?: ActionStepWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ActionSteps to fetch.
		 *
		 **/
		orderBy?: Enumerable<ActionStepOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing ActionSteps.
		 *
		 **/
		cursor?: ActionStepWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ActionSteps from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ActionSteps.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<ActionStepScalarFieldEnum>
	}


	/**
	 * ActionStep create
	 */
	export type ActionStepCreateArgs = {
		/**
		 * Select specific fields to fetch from the ActionStep
		 *
		 **/
		select?: ActionStepSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionStepInclude | null
		/**
		 * The data needed to create a ActionStep.
		 *
		 **/
		data: XOR<ActionStepCreateInput, ActionStepUncheckedCreateInput>
	}


	/**
	 * ActionStep createMany
	 */
	export type ActionStepCreateManyArgs = {
		/**
		 * The data used to create many ActionSteps.
		 *
		 **/
		data: Enumerable<ActionStepCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * ActionStep update
	 */
	export type ActionStepUpdateArgs = {
		/**
		 * Select specific fields to fetch from the ActionStep
		 *
		 **/
		select?: ActionStepSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionStepInclude | null
		/**
		 * The data needed to update a ActionStep.
		 *
		 **/
		data: XOR<ActionStepUpdateInput, ActionStepUncheckedUpdateInput>
		/**
		 * Choose, which ActionStep to update.
		 *
		 **/
		where: ActionStepWhereUniqueInput
	}


	/**
	 * ActionStep updateMany
	 */
	export type ActionStepUpdateManyArgs = {
		/**
		 * The data used to update ActionSteps.
		 *
		 **/
		data: XOR<ActionStepUpdateManyMutationInput, ActionStepUncheckedUpdateManyInput>
		/**
		 * Filter which ActionSteps to update
		 *
		 **/
		where?: ActionStepWhereInput
	}


	/**
	 * ActionStep upsert
	 */
	export type ActionStepUpsertArgs = {
		/**
		 * Select specific fields to fetch from the ActionStep
		 *
		 **/
		select?: ActionStepSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionStepInclude | null
		/**
		 * The filter to search for the ActionStep to update in case it exists.
		 *
		 **/
		where: ActionStepWhereUniqueInput
		/**
		 * In case the ActionStep found by the `where` argument doesn't exist, create a new ActionStep with this data.
		 *
		 **/
		create: XOR<ActionStepCreateInput, ActionStepUncheckedCreateInput>
		/**
		 * In case the ActionStep was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<ActionStepUpdateInput, ActionStepUncheckedUpdateInput>
	}


	/**
	 * ActionStep delete
	 */
	export type ActionStepDeleteArgs = {
		/**
		 * Select specific fields to fetch from the ActionStep
		 *
		 **/
		select?: ActionStepSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionStepInclude | null
		/**
		 * Filter which ActionStep to delete.
		 *
		 **/
		where: ActionStepWhereUniqueInput
	}


	/**
	 * ActionStep deleteMany
	 */
	export type ActionStepDeleteManyArgs = {
		/**
		 * Filter which ActionSteps to delete
		 *
		 **/
		where?: ActionStepWhereInput
	}


	/**
	 * ActionStep without action
	 */
	export type ActionStepArgs = {
		/**
		 * Select specific fields to fetch from the ActionStep
		 *
		 **/
		select?: ActionStepSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionStepInclude | null
	}



	/**
	 * Model ActionLog
	 */


	export type AggregateActionLog = {
		_count: ActionLogCountAggregateOutputType | null
		_min: ActionLogMinAggregateOutputType | null
		_max: ActionLogMaxAggregateOutputType | null
	}

	export type ActionLogMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		message: string | null
		level: EnumLogLevel | null
		stepId: string | null
	}

	export type ActionLogMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		message: string | null
		level: EnumLogLevel | null
		stepId: string | null
	}

	export type ActionLogCountAggregateOutputType = {
		id: number
		createdAt: number
		message: number
		meta: number
		level: number
		stepId: number
		_all: number
	}


	export type ActionLogMinAggregateInputType = {
		id?: true
		createdAt?: true
		message?: true
		level?: true
		stepId?: true
	}

	export type ActionLogMaxAggregateInputType = {
		id?: true
		createdAt?: true
		message?: true
		level?: true
		stepId?: true
	}

	export type ActionLogCountAggregateInputType = {
		id?: true
		createdAt?: true
		message?: true
		meta?: true
		level?: true
		stepId?: true
		_all?: true
	}

	export type ActionLogAggregateArgs = {
		/**
		 * Filter which ActionLog to aggregate.
		 *
		 **/
		where?: ActionLogWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ActionLogs to fetch.
		 *
		 **/
		orderBy?: Enumerable<ActionLogOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: ActionLogWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ActionLogs from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ActionLogs.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned ActionLogs
		 **/
		_count?: true | ActionLogCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ActionLogMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ActionLogMaxAggregateInputType
	}

	export type GetActionLogAggregateType<T extends ActionLogAggregateArgs> = {
		[P in keyof T & keyof AggregateActionLog]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateActionLog[P]>
			: GetScalarType<T[P], AggregateActionLog[P]>
	}




	export type ActionLogGroupByArgs = {
		where?: ActionLogWhereInput
		orderBy?: Enumerable<ActionLogOrderByWithAggregationInput>
		by: Array<ActionLogScalarFieldEnum>
		having?: ActionLogScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ActionLogCountAggregateInputType | true
		_min?: ActionLogMinAggregateInputType
		_max?: ActionLogMaxAggregateInputType
	}


	export type ActionLogGroupByOutputType = {
		id: string
		createdAt: Date
		message: string
		meta: JsonValue
		level: EnumLogLevel
		stepId: string
		_count: ActionLogCountAggregateOutputType | null
		_min: ActionLogMinAggregateOutputType | null
		_max: ActionLogMaxAggregateOutputType | null
	}

	type GetActionLogGroupByPayload<T extends ActionLogGroupByArgs> = PrismaPromise<
		Array<
			PickArray<ActionLogGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof ActionLogGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], ActionLogGroupByOutputType[P]>
				: GetScalarType<T[P], ActionLogGroupByOutputType[P]>
			}
			>
		>


	export type ActionLogSelect = {
		id?: boolean
		createdAt?: boolean
		message?: boolean
		meta?: boolean
		level?: boolean
		stepId?: boolean
		step?: boolean | ActionStepArgs
	}

	export type ActionLogInclude = {
		step?: boolean | ActionStepArgs
	}

	export type ActionLogGetPayload<
		S extends boolean | null | undefined | ActionLogArgs,
		U = keyof S
		> = S extends true
		? ActionLog
		: S extends undefined
			? never
			: S extends ActionLogArgs | ActionLogFindManyArgs
				?'include' extends U
					? ActionLog  & {
					[P in TrueKeys<S['include']>]:
					P extends 'step' ? ActionStepGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'step' ? ActionStepGetPayload<S['select'][P]> :  P extends keyof ActionLog ? ActionLog[P] : never
						}
						: ActionLog
				: ActionLog


	type ActionLogCountArgs = Merge<
		Omit<ActionLogFindManyArgs, 'select' | 'include'> & {
		select?: ActionLogCountAggregateInputType | true
	}
		>

	export interface ActionLogDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one ActionLog that matches the filter.
		 * @param {ActionLogFindUniqueArgs} args - Arguments to find a ActionLog
		 * @example
		 * // Get one ActionLog
		 * const actionLog = await prisma.actionLog.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends ActionLogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, ActionLogFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ActionLog'> extends True ? CheckSelect<T, Prisma__ActionLogClient<ActionLog>, Prisma__ActionLogClient<ActionLogGetPayload<T>>> : CheckSelect<T, Prisma__ActionLogClient<ActionLog | null >, Prisma__ActionLogClient<ActionLogGetPayload<T> | null >>

		/**
		 * Find the first ActionLog that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionLogFindFirstArgs} args - Arguments to find a ActionLog
		 * @example
		 * // Get one ActionLog
		 * const actionLog = await prisma.actionLog.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends ActionLogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, ActionLogFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ActionLog'> extends True ? CheckSelect<T, Prisma__ActionLogClient<ActionLog>, Prisma__ActionLogClient<ActionLogGetPayload<T>>> : CheckSelect<T, Prisma__ActionLogClient<ActionLog | null >, Prisma__ActionLogClient<ActionLogGetPayload<T> | null >>

		/**
		 * Find zero or more ActionLogs that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionLogFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all ActionLogs
		 * const actionLogs = await prisma.actionLog.findMany()
		 *
		 * // Get first 10 ActionLogs
		 * const actionLogs = await prisma.actionLog.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const actionLogWithIdOnly = await prisma.actionLog.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends ActionLogFindManyArgs>(
			args?: SelectSubset<T, ActionLogFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<ActionLog>>, PrismaPromise<Array<ActionLogGetPayload<T>>>>

		/**
		 * Create a ActionLog.
		 * @param {ActionLogCreateArgs} args - Arguments to create a ActionLog.
		 * @example
		 * // Create one ActionLog
		 * const ActionLog = await prisma.actionLog.create({
		 *   data: {
		 *     // ... data to create a ActionLog
		 *   }
		 * })
		 *
		 **/
		create<T extends ActionLogCreateArgs>(
			args: SelectSubset<T, ActionLogCreateArgs>
		): CheckSelect<T, Prisma__ActionLogClient<ActionLog>, Prisma__ActionLogClient<ActionLogGetPayload<T>>>

		/**
		 * Create many ActionLogs.
		 *     @param {ActionLogCreateManyArgs} args - Arguments to create many ActionLogs.
		 *     @example
		 *     // Create many ActionLogs
		 *     const actionLog = await prisma.actionLog.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends ActionLogCreateManyArgs>(
			args?: SelectSubset<T, ActionLogCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a ActionLog.
		 * @param {ActionLogDeleteArgs} args - Arguments to delete one ActionLog.
		 * @example
		 * // Delete one ActionLog
		 * const ActionLog = await prisma.actionLog.delete({
		 *   where: {
		 *     // ... filter to delete one ActionLog
		 *   }
		 * })
		 *
		 **/
		delete<T extends ActionLogDeleteArgs>(
			args: SelectSubset<T, ActionLogDeleteArgs>
		): CheckSelect<T, Prisma__ActionLogClient<ActionLog>, Prisma__ActionLogClient<ActionLogGetPayload<T>>>

		/**
		 * Update one ActionLog.
		 * @param {ActionLogUpdateArgs} args - Arguments to update one ActionLog.
		 * @example
		 * // Update one ActionLog
		 * const actionLog = await prisma.actionLog.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends ActionLogUpdateArgs>(
			args: SelectSubset<T, ActionLogUpdateArgs>
		): CheckSelect<T, Prisma__ActionLogClient<ActionLog>, Prisma__ActionLogClient<ActionLogGetPayload<T>>>

		/**
		 * Delete zero or more ActionLogs.
		 * @param {ActionLogDeleteManyArgs} args - Arguments to filter ActionLogs to delete.
		 * @example
		 * // Delete a few ActionLogs
		 * const { count } = await prisma.actionLog.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends ActionLogDeleteManyArgs>(
			args?: SelectSubset<T, ActionLogDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more ActionLogs.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionLogUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many ActionLogs
		 * const actionLog = await prisma.actionLog.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends ActionLogUpdateManyArgs>(
			args: SelectSubset<T, ActionLogUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one ActionLog.
		 * @param {ActionLogUpsertArgs} args - Arguments to update or create a ActionLog.
		 * @example
		 * // Update or create a ActionLog
		 * const actionLog = await prisma.actionLog.upsert({
		 *   create: {
		 *     // ... data to create a ActionLog
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the ActionLog we want to update
		 *   }
		 * })
		 **/
		upsert<T extends ActionLogUpsertArgs>(
			args: SelectSubset<T, ActionLogUpsertArgs>
		): CheckSelect<T, Prisma__ActionLogClient<ActionLog>, Prisma__ActionLogClient<ActionLogGetPayload<T>>>

		/**
		 * Count the number of ActionLogs.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionLogCountArgs} args - Arguments to filter ActionLogs to count.
		 * @example
		 * // Count the number of ActionLogs
		 * const count = await prisma.actionLog.count({
		 *   where: {
		 *     // ... the filter for the ActionLogs we want to count
		 *   }
		 * })
		 **/
		count<T extends ActionLogCountArgs>(
			args?: Subset<T, ActionLogCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ActionLogCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a ActionLog.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ActionLogAggregateArgs>(args: Subset<T, ActionLogAggregateArgs>): PrismaPromise<GetActionLogAggregateType<T>>

		/**
		 * Group by ActionLog.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ActionLogGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ActionLogGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ActionLogGroupByArgs['orderBy'] }
				: { orderBy?: ActionLogGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, ActionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionLogGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for ActionLog.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__ActionLogClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		step<T extends ActionStepArgs = {}>(args?: Subset<T, ActionStepArgs>): CheckSelect<T, Prisma__ActionStepClient<ActionStep | null >, Prisma__ActionStepClient<ActionStepGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * ActionLog findUnique
	 */
	export type ActionLogFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the ActionLog
		 *
		 **/
		select?: ActionLogSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionLogInclude | null
		/**
		 * Throw an Error if a ActionLog can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which ActionLog to fetch.
		 *
		 **/
		where: ActionLogWhereUniqueInput
	}


	/**
	 * ActionLog findFirst
	 */
	export type ActionLogFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the ActionLog
		 *
		 **/
		select?: ActionLogSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionLogInclude | null
		/**
		 * Throw an Error if a ActionLog can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which ActionLog to fetch.
		 *
		 **/
		where?: ActionLogWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ActionLogs to fetch.
		 *
		 **/
		orderBy?: Enumerable<ActionLogOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for ActionLogs.
		 *
		 **/
		cursor?: ActionLogWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ActionLogs from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ActionLogs.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of ActionLogs.
		 *
		 **/
		distinct?: Enumerable<ActionLogScalarFieldEnum>
	}


	/**
	 * ActionLog findMany
	 */
	export type ActionLogFindManyArgs = {
		/**
		 * Select specific fields to fetch from the ActionLog
		 *
		 **/
		select?: ActionLogSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionLogInclude | null
		/**
		 * Filter, which ActionLogs to fetch.
		 *
		 **/
		where?: ActionLogWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of ActionLogs to fetch.
		 *
		 **/
		orderBy?: Enumerable<ActionLogOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing ActionLogs.
		 *
		 **/
		cursor?: ActionLogWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` ActionLogs from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` ActionLogs.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<ActionLogScalarFieldEnum>
	}


	/**
	 * ActionLog create
	 */
	export type ActionLogCreateArgs = {
		/**
		 * Select specific fields to fetch from the ActionLog
		 *
		 **/
		select?: ActionLogSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionLogInclude | null
		/**
		 * The data needed to create a ActionLog.
		 *
		 **/
		data: XOR<ActionLogCreateInput, ActionLogUncheckedCreateInput>
	}


	/**
	 * ActionLog createMany
	 */
	export type ActionLogCreateManyArgs = {
		/**
		 * The data used to create many ActionLogs.
		 *
		 **/
		data: Enumerable<ActionLogCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * ActionLog update
	 */
	export type ActionLogUpdateArgs = {
		/**
		 * Select specific fields to fetch from the ActionLog
		 *
		 **/
		select?: ActionLogSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionLogInclude | null
		/**
		 * The data needed to update a ActionLog.
		 *
		 **/
		data: XOR<ActionLogUpdateInput, ActionLogUncheckedUpdateInput>
		/**
		 * Choose, which ActionLog to update.
		 *
		 **/
		where: ActionLogWhereUniqueInput
	}


	/**
	 * ActionLog updateMany
	 */
	export type ActionLogUpdateManyArgs = {
		/**
		 * The data used to update ActionLogs.
		 *
		 **/
		data: XOR<ActionLogUpdateManyMutationInput, ActionLogUncheckedUpdateManyInput>
		/**
		 * Filter which ActionLogs to update
		 *
		 **/
		where?: ActionLogWhereInput
	}


	/**
	 * ActionLog upsert
	 */
	export type ActionLogUpsertArgs = {
		/**
		 * Select specific fields to fetch from the ActionLog
		 *
		 **/
		select?: ActionLogSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionLogInclude | null
		/**
		 * The filter to search for the ActionLog to update in case it exists.
		 *
		 **/
		where: ActionLogWhereUniqueInput
		/**
		 * In case the ActionLog found by the `where` argument doesn't exist, create a new ActionLog with this data.
		 *
		 **/
		create: XOR<ActionLogCreateInput, ActionLogUncheckedCreateInput>
		/**
		 * In case the ActionLog was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<ActionLogUpdateInput, ActionLogUncheckedUpdateInput>
	}


	/**
	 * ActionLog delete
	 */
	export type ActionLogDeleteArgs = {
		/**
		 * Select specific fields to fetch from the ActionLog
		 *
		 **/
		select?: ActionLogSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionLogInclude | null
		/**
		 * Filter which ActionLog to delete.
		 *
		 **/
		where: ActionLogWhereUniqueInput
	}


	/**
	 * ActionLog deleteMany
	 */
	export type ActionLogDeleteManyArgs = {
		/**
		 * Filter which ActionLogs to delete
		 *
		 **/
		where?: ActionLogWhereInput
	}


	/**
	 * ActionLog without action
	 */
	export type ActionLogArgs = {
		/**
		 * Select specific fields to fetch from the ActionLog
		 *
		 **/
		select?: ActionLogSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ActionLogInclude | null
	}



	/**
	 * Model Build
	 */


	export type AggregateBuild = {
		_count: BuildCountAggregateOutputType | null
		_min: BuildMinAggregateOutputType | null
		_max: BuildMaxAggregateOutputType | null
	}

	export type BuildMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		resourceId: string | null
		userId: string | null
		version: string | null
		message: string | null
		actionId: string | null
		containerStatusUpdatedAt: Date | null
		commitId: string | null
	}

	export type BuildMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		resourceId: string | null
		userId: string | null
		version: string | null
		message: string | null
		actionId: string | null
		containerStatusUpdatedAt: Date | null
		commitId: string | null
	}

	export type BuildCountAggregateOutputType = {
		id: number
		createdAt: number
		resourceId: number
		userId: number
		version: number
		message: number
		actionId: number
		images: number
		containerStatusQuery: number
		containerStatusUpdatedAt: number
		commitId: number
		_all: number
	}


	export type BuildMinAggregateInputType = {
		id?: true
		createdAt?: true
		resourceId?: true
		userId?: true
		version?: true
		message?: true
		actionId?: true
		containerStatusUpdatedAt?: true
		commitId?: true
	}

	export type BuildMaxAggregateInputType = {
		id?: true
		createdAt?: true
		resourceId?: true
		userId?: true
		version?: true
		message?: true
		actionId?: true
		containerStatusUpdatedAt?: true
		commitId?: true
	}

	export type BuildCountAggregateInputType = {
		id?: true
		createdAt?: true
		resourceId?: true
		userId?: true
		version?: true
		message?: true
		actionId?: true
		images?: true
		containerStatusQuery?: true
		containerStatusUpdatedAt?: true
		commitId?: true
		_all?: true
	}

	export type BuildAggregateArgs = {
		/**
		 * Filter which Build to aggregate.
		 *
		 **/
		where?: BuildWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Builds to fetch.
		 *
		 **/
		orderBy?: Enumerable<BuildOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: BuildWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Builds from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Builds.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Builds
		 **/
		_count?: true | BuildCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: BuildMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: BuildMaxAggregateInputType
	}

	export type GetBuildAggregateType<T extends BuildAggregateArgs> = {
		[P in keyof T & keyof AggregateBuild]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateBuild[P]>
			: GetScalarType<T[P], AggregateBuild[P]>
	}




	export type BuildGroupByArgs = {
		where?: BuildWhereInput
		orderBy?: Enumerable<BuildOrderByWithAggregationInput>
		by: Array<BuildScalarFieldEnum>
		having?: BuildScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: BuildCountAggregateInputType | true
		_min?: BuildMinAggregateInputType
		_max?: BuildMaxAggregateInputType
	}


	export type BuildGroupByOutputType = {
		id: string
		createdAt: Date
		resourceId: string
		userId: string
		version: string
		message: string | null
		actionId: string
		images: string[]
		containerStatusQuery: JsonValue | null
		containerStatusUpdatedAt: Date | null
		commitId: string | null
		_count: BuildCountAggregateOutputType | null
		_min: BuildMinAggregateOutputType | null
		_max: BuildMaxAggregateOutputType | null
	}

	type GetBuildGroupByPayload<T extends BuildGroupByArgs> = PrismaPromise<
		Array<
			PickArray<BuildGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof BuildGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], BuildGroupByOutputType[P]>
				: GetScalarType<T[P], BuildGroupByOutputType[P]>
			}
			>
		>


	export type BuildSelect = {
		id?: boolean
		createdAt?: boolean
		resourceId?: boolean
		userId?: boolean
		version?: boolean
		message?: boolean
		actionId?: boolean
		images?: boolean
		containerStatusQuery?: boolean
		containerStatusUpdatedAt?: boolean
		commitId?: boolean
		action?: boolean | ActionArgs
		resource?: boolean | ResourceArgs
		commit?: boolean | CommitArgs
		createdBy?: boolean | UserArgs
		deployments?: boolean | DeploymentFindManyArgs
		blockVersions?: boolean | BlockVersionFindManyArgs
		entityVersions?: boolean | EntityVersionFindManyArgs
		_count?: boolean | BuildCountOutputTypeArgs
	}

	export type BuildInclude = {
		action?: boolean | ActionArgs
		resource?: boolean | ResourceArgs
		commit?: boolean | CommitArgs
		createdBy?: boolean | UserArgs
		deployments?: boolean | DeploymentFindManyArgs
		blockVersions?: boolean | BlockVersionFindManyArgs
		entityVersions?: boolean | EntityVersionFindManyArgs
		_count?: boolean | BuildCountOutputTypeArgs
	}

	export type BuildGetPayload<
		S extends boolean | null | undefined | BuildArgs,
		U = keyof S
		> = S extends true
		? Build
		: S extends undefined
			? never
			: S extends BuildArgs | BuildFindManyArgs
				?'include' extends U
					? Build  & {
					[P in TrueKeys<S['include']>]:
					P extends 'action' ? ActionGetPayload<S['include'][P]> :
						P extends 'resource' ? ResourceGetPayload<S['include'][P]> :
							P extends 'commit' ? CommitGetPayload<S['include'][P]> | null :
								P extends 'createdBy' ? UserGetPayload<S['include'][P]> :
									P extends 'deployments' ? Array < DeploymentGetPayload<S['include'][P]>>  :
										P extends 'blockVersions' ? Array < BlockVersionGetPayload<S['include'][P]>>  :
											P extends 'entityVersions' ? Array < EntityVersionGetPayload<S['include'][P]>>  :
												P extends '_count' ? BuildCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'action' ? ActionGetPayload<S['select'][P]> :
								P extends 'resource' ? ResourceGetPayload<S['select'][P]> :
									P extends 'commit' ? CommitGetPayload<S['select'][P]> | null :
										P extends 'createdBy' ? UserGetPayload<S['select'][P]> :
											P extends 'deployments' ? Array < DeploymentGetPayload<S['select'][P]>>  :
												P extends 'blockVersions' ? Array < BlockVersionGetPayload<S['select'][P]>>  :
													P extends 'entityVersions' ? Array < EntityVersionGetPayload<S['select'][P]>>  :
														P extends '_count' ? BuildCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Build ? Build[P] : never
						}
						: Build
				: Build


	type BuildCountArgs = Merge<
		Omit<BuildFindManyArgs, 'select' | 'include'> & {
		select?: BuildCountAggregateInputType | true
	}
		>

	export interface BuildDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Build that matches the filter.
		 * @param {BuildFindUniqueArgs} args - Arguments to find a Build
		 * @example
		 * // Get one Build
		 * const build = await prisma.build.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends BuildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, BuildFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Build'> extends True ? CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>> : CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>

		/**
		 * Find the first Build that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BuildFindFirstArgs} args - Arguments to find a Build
		 * @example
		 * // Get one Build
		 * const build = await prisma.build.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends BuildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, BuildFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Build'> extends True ? CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>> : CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>

		/**
		 * Find zero or more Builds that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BuildFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Builds
		 * const builds = await prisma.build.findMany()
		 *
		 * // Get first 10 Builds
		 * const builds = await prisma.build.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const buildWithIdOnly = await prisma.build.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends BuildFindManyArgs>(
			args?: SelectSubset<T, BuildFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>

		/**
		 * Create a Build.
		 * @param {BuildCreateArgs} args - Arguments to create a Build.
		 * @example
		 * // Create one Build
		 * const Build = await prisma.build.create({
		 *   data: {
		 *     // ... data to create a Build
		 *   }
		 * })
		 *
		 **/
		create<T extends BuildCreateArgs>(
			args: SelectSubset<T, BuildCreateArgs>
		): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

		/**
		 * Create many Builds.
		 *     @param {BuildCreateManyArgs} args - Arguments to create many Builds.
		 *     @example
		 *     // Create many Builds
		 *     const build = await prisma.build.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends BuildCreateManyArgs>(
			args?: SelectSubset<T, BuildCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Build.
		 * @param {BuildDeleteArgs} args - Arguments to delete one Build.
		 * @example
		 * // Delete one Build
		 * const Build = await prisma.build.delete({
		 *   where: {
		 *     // ... filter to delete one Build
		 *   }
		 * })
		 *
		 **/
		delete<T extends BuildDeleteArgs>(
			args: SelectSubset<T, BuildDeleteArgs>
		): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

		/**
		 * Update one Build.
		 * @param {BuildUpdateArgs} args - Arguments to update one Build.
		 * @example
		 * // Update one Build
		 * const build = await prisma.build.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends BuildUpdateArgs>(
			args: SelectSubset<T, BuildUpdateArgs>
		): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

		/**
		 * Delete zero or more Builds.
		 * @param {BuildDeleteManyArgs} args - Arguments to filter Builds to delete.
		 * @example
		 * // Delete a few Builds
		 * const { count } = await prisma.build.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends BuildDeleteManyArgs>(
			args?: SelectSubset<T, BuildDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Builds.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BuildUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Builds
		 * const build = await prisma.build.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends BuildUpdateManyArgs>(
			args: SelectSubset<T, BuildUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Build.
		 * @param {BuildUpsertArgs} args - Arguments to update or create a Build.
		 * @example
		 * // Update or create a Build
		 * const build = await prisma.build.upsert({
		 *   create: {
		 *     // ... data to create a Build
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Build we want to update
		 *   }
		 * })
		 **/
		upsert<T extends BuildUpsertArgs>(
			args: SelectSubset<T, BuildUpsertArgs>
		): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

		/**
		 * Count the number of Builds.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BuildCountArgs} args - Arguments to filter Builds to count.
		 * @example
		 * // Count the number of Builds
		 * const count = await prisma.build.count({
		 *   where: {
		 *     // ... the filter for the Builds we want to count
		 *   }
		 * })
		 **/
		count<T extends BuildCountArgs>(
			args?: Subset<T, BuildCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], BuildCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Build.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends BuildAggregateArgs>(args: Subset<T, BuildAggregateArgs>): PrismaPromise<GetBuildAggregateType<T>>

		/**
		 * Group by Build.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {BuildGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends BuildGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: BuildGroupByArgs['orderBy'] }
				: { orderBy?: BuildGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, BuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Build.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__BuildClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		action<T extends ActionArgs = {}>(args?: Subset<T, ActionArgs>): CheckSelect<T, Prisma__ActionClient<Action | null >, Prisma__ActionClient<ActionGetPayload<T> | null >>;

		resource<T extends ResourceArgs = {}>(args?: Subset<T, ResourceArgs>): CheckSelect<T, Prisma__ResourceClient<Resource | null >, Prisma__ResourceClient<ResourceGetPayload<T> | null >>;

		commit<T extends CommitArgs = {}>(args?: Subset<T, CommitArgs>): CheckSelect<T, Prisma__CommitClient<Commit | null >, Prisma__CommitClient<CommitGetPayload<T> | null >>;

		createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		deployments<T extends DeploymentFindManyArgs = {}>(args?: Subset<T, DeploymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Deployment>>, PrismaPromise<Array<DeploymentGetPayload<T>>>>;

		blockVersions<T extends BlockVersionFindManyArgs = {}>(args?: Subset<T, BlockVersionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<BlockVersion>>, PrismaPromise<Array<BlockVersionGetPayload<T>>>>;

		entityVersions<T extends EntityVersionFindManyArgs = {}>(args?: Subset<T, EntityVersionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EntityVersion>>, PrismaPromise<Array<EntityVersionGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Build findUnique
	 */
	export type BuildFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Build
		 *
		 **/
		select?: BuildSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BuildInclude | null
		/**
		 * Throw an Error if a Build can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Build to fetch.
		 *
		 **/
		where: BuildWhereUniqueInput
	}


	/**
	 * Build findFirst
	 */
	export type BuildFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Build
		 *
		 **/
		select?: BuildSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BuildInclude | null
		/**
		 * Throw an Error if a Build can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Build to fetch.
		 *
		 **/
		where?: BuildWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Builds to fetch.
		 *
		 **/
		orderBy?: Enumerable<BuildOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Builds.
		 *
		 **/
		cursor?: BuildWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Builds from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Builds.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Builds.
		 *
		 **/
		distinct?: Enumerable<BuildScalarFieldEnum>
	}


	/**
	 * Build findMany
	 */
	export type BuildFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Build
		 *
		 **/
		select?: BuildSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BuildInclude | null
		/**
		 * Filter, which Builds to fetch.
		 *
		 **/
		where?: BuildWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Builds to fetch.
		 *
		 **/
		orderBy?: Enumerable<BuildOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Builds.
		 *
		 **/
		cursor?: BuildWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Builds from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Builds.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<BuildScalarFieldEnum>
	}


	/**
	 * Build create
	 */
	export type BuildCreateArgs = {
		/**
		 * Select specific fields to fetch from the Build
		 *
		 **/
		select?: BuildSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BuildInclude | null
		/**
		 * The data needed to create a Build.
		 *
		 **/
		data: XOR<BuildCreateInput, BuildUncheckedCreateInput>
	}


	/**
	 * Build createMany
	 */
	export type BuildCreateManyArgs = {
		/**
		 * The data used to create many Builds.
		 *
		 **/
		data: Enumerable<BuildCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Build update
	 */
	export type BuildUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Build
		 *
		 **/
		select?: BuildSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BuildInclude | null
		/**
		 * The data needed to update a Build.
		 *
		 **/
		data: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
		/**
		 * Choose, which Build to update.
		 *
		 **/
		where: BuildWhereUniqueInput
	}


	/**
	 * Build updateMany
	 */
	export type BuildUpdateManyArgs = {
		/**
		 * The data used to update Builds.
		 *
		 **/
		data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyInput>
		/**
		 * Filter which Builds to update
		 *
		 **/
		where?: BuildWhereInput
	}


	/**
	 * Build upsert
	 */
	export type BuildUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Build
		 *
		 **/
		select?: BuildSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BuildInclude | null
		/**
		 * The filter to search for the Build to update in case it exists.
		 *
		 **/
		where: BuildWhereUniqueInput
		/**
		 * In case the Build found by the `where` argument doesn't exist, create a new Build with this data.
		 *
		 **/
		create: XOR<BuildCreateInput, BuildUncheckedCreateInput>
		/**
		 * In case the Build was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
	}


	/**
	 * Build delete
	 */
	export type BuildDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Build
		 *
		 **/
		select?: BuildSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BuildInclude | null
		/**
		 * Filter which Build to delete.
		 *
		 **/
		where: BuildWhereUniqueInput
	}


	/**
	 * Build deleteMany
	 */
	export type BuildDeleteManyArgs = {
		/**
		 * Filter which Builds to delete
		 *
		 **/
		where?: BuildWhereInput
	}


	/**
	 * Build without action
	 */
	export type BuildArgs = {
		/**
		 * Select specific fields to fetch from the Build
		 *
		 **/
		select?: BuildSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: BuildInclude | null
	}



	/**
	 * Model Release
	 */


	export type AggregateRelease = {
		_count: ReleaseCountAggregateOutputType | null
		_min: ReleaseMinAggregateOutputType | null
		_max: ReleaseMaxAggregateOutputType | null
	}

	export type ReleaseMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		version: string | null
		description: string | null
		commitId: string | null
	}

	export type ReleaseMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		version: string | null
		description: string | null
		commitId: string | null
	}

	export type ReleaseCountAggregateOutputType = {
		id: number
		createdAt: number
		version: number
		description: number
		commitId: number
		_all: number
	}


	export type ReleaseMinAggregateInputType = {
		id?: true
		createdAt?: true
		version?: true
		description?: true
		commitId?: true
	}

	export type ReleaseMaxAggregateInputType = {
		id?: true
		createdAt?: true
		version?: true
		description?: true
		commitId?: true
	}

	export type ReleaseCountAggregateInputType = {
		id?: true
		createdAt?: true
		version?: true
		description?: true
		commitId?: true
		_all?: true
	}

	export type ReleaseAggregateArgs = {
		/**
		 * Filter which Release to aggregate.
		 *
		 **/
		where?: ReleaseWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Releases to fetch.
		 *
		 **/
		orderBy?: Enumerable<ReleaseOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: ReleaseWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Releases from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Releases.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Releases
		 **/
		_count?: true | ReleaseCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: ReleaseMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: ReleaseMaxAggregateInputType
	}

	export type GetReleaseAggregateType<T extends ReleaseAggregateArgs> = {
		[P in keyof T & keyof AggregateRelease]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateRelease[P]>
			: GetScalarType<T[P], AggregateRelease[P]>
	}




	export type ReleaseGroupByArgs = {
		where?: ReleaseWhereInput
		orderBy?: Enumerable<ReleaseOrderByWithAggregationInput>
		by: Array<ReleaseScalarFieldEnum>
		having?: ReleaseScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: ReleaseCountAggregateInputType | true
		_min?: ReleaseMinAggregateInputType
		_max?: ReleaseMaxAggregateInputType
	}


	export type ReleaseGroupByOutputType = {
		id: string
		createdAt: Date
		version: string
		description: string | null
		commitId: string
		_count: ReleaseCountAggregateOutputType | null
		_min: ReleaseMinAggregateOutputType | null
		_max: ReleaseMaxAggregateOutputType | null
	}

	type GetReleaseGroupByPayload<T extends ReleaseGroupByArgs> = PrismaPromise<
		Array<
			PickArray<ReleaseGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof ReleaseGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], ReleaseGroupByOutputType[P]>
				: GetScalarType<T[P], ReleaseGroupByOutputType[P]>
			}
			>
		>


	export type ReleaseSelect = {
		id?: boolean
		createdAt?: boolean
		version?: boolean
		description?: boolean
		commitId?: boolean
		commit?: boolean | CommitArgs
	}

	export type ReleaseInclude = {
		commit?: boolean | CommitArgs
	}

	export type ReleaseGetPayload<
		S extends boolean | null | undefined | ReleaseArgs,
		U = keyof S
		> = S extends true
		? Release
		: S extends undefined
			? never
			: S extends ReleaseArgs | ReleaseFindManyArgs
				?'include' extends U
					? Release  & {
					[P in TrueKeys<S['include']>]:
					P extends 'commit' ? CommitGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'commit' ? CommitGetPayload<S['select'][P]> :  P extends keyof Release ? Release[P] : never
						}
						: Release
				: Release


	type ReleaseCountArgs = Merge<
		Omit<ReleaseFindManyArgs, 'select' | 'include'> & {
		select?: ReleaseCountAggregateInputType | true
	}
		>

	export interface ReleaseDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Release that matches the filter.
		 * @param {ReleaseFindUniqueArgs} args - Arguments to find a Release
		 * @example
		 * // Get one Release
		 * const release = await prisma.release.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends ReleaseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, ReleaseFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Release'> extends True ? CheckSelect<T, Prisma__ReleaseClient<Release>, Prisma__ReleaseClient<ReleaseGetPayload<T>>> : CheckSelect<T, Prisma__ReleaseClient<Release | null >, Prisma__ReleaseClient<ReleaseGetPayload<T> | null >>

		/**
		 * Find the first Release that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ReleaseFindFirstArgs} args - Arguments to find a Release
		 * @example
		 * // Get one Release
		 * const release = await prisma.release.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends ReleaseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, ReleaseFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Release'> extends True ? CheckSelect<T, Prisma__ReleaseClient<Release>, Prisma__ReleaseClient<ReleaseGetPayload<T>>> : CheckSelect<T, Prisma__ReleaseClient<Release | null >, Prisma__ReleaseClient<ReleaseGetPayload<T> | null >>

		/**
		 * Find zero or more Releases that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ReleaseFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Releases
		 * const releases = await prisma.release.findMany()
		 *
		 * // Get first 10 Releases
		 * const releases = await prisma.release.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const releaseWithIdOnly = await prisma.release.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends ReleaseFindManyArgs>(
			args?: SelectSubset<T, ReleaseFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Release>>, PrismaPromise<Array<ReleaseGetPayload<T>>>>

		/**
		 * Create a Release.
		 * @param {ReleaseCreateArgs} args - Arguments to create a Release.
		 * @example
		 * // Create one Release
		 * const Release = await prisma.release.create({
		 *   data: {
		 *     // ... data to create a Release
		 *   }
		 * })
		 *
		 **/
		create<T extends ReleaseCreateArgs>(
			args: SelectSubset<T, ReleaseCreateArgs>
		): CheckSelect<T, Prisma__ReleaseClient<Release>, Prisma__ReleaseClient<ReleaseGetPayload<T>>>

		/**
		 * Create many Releases.
		 *     @param {ReleaseCreateManyArgs} args - Arguments to create many Releases.
		 *     @example
		 *     // Create many Releases
		 *     const release = await prisma.release.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends ReleaseCreateManyArgs>(
			args?: SelectSubset<T, ReleaseCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Release.
		 * @param {ReleaseDeleteArgs} args - Arguments to delete one Release.
		 * @example
		 * // Delete one Release
		 * const Release = await prisma.release.delete({
		 *   where: {
		 *     // ... filter to delete one Release
		 *   }
		 * })
		 *
		 **/
		delete<T extends ReleaseDeleteArgs>(
			args: SelectSubset<T, ReleaseDeleteArgs>
		): CheckSelect<T, Prisma__ReleaseClient<Release>, Prisma__ReleaseClient<ReleaseGetPayload<T>>>

		/**
		 * Update one Release.
		 * @param {ReleaseUpdateArgs} args - Arguments to update one Release.
		 * @example
		 * // Update one Release
		 * const release = await prisma.release.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends ReleaseUpdateArgs>(
			args: SelectSubset<T, ReleaseUpdateArgs>
		): CheckSelect<T, Prisma__ReleaseClient<Release>, Prisma__ReleaseClient<ReleaseGetPayload<T>>>

		/**
		 * Delete zero or more Releases.
		 * @param {ReleaseDeleteManyArgs} args - Arguments to filter Releases to delete.
		 * @example
		 * // Delete a few Releases
		 * const { count } = await prisma.release.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends ReleaseDeleteManyArgs>(
			args?: SelectSubset<T, ReleaseDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Releases.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ReleaseUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Releases
		 * const release = await prisma.release.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends ReleaseUpdateManyArgs>(
			args: SelectSubset<T, ReleaseUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Release.
		 * @param {ReleaseUpsertArgs} args - Arguments to update or create a Release.
		 * @example
		 * // Update or create a Release
		 * const release = await prisma.release.upsert({
		 *   create: {
		 *     // ... data to create a Release
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Release we want to update
		 *   }
		 * })
		 **/
		upsert<T extends ReleaseUpsertArgs>(
			args: SelectSubset<T, ReleaseUpsertArgs>
		): CheckSelect<T, Prisma__ReleaseClient<Release>, Prisma__ReleaseClient<ReleaseGetPayload<T>>>

		/**
		 * Count the number of Releases.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ReleaseCountArgs} args - Arguments to filter Releases to count.
		 * @example
		 * // Count the number of Releases
		 * const count = await prisma.release.count({
		 *   where: {
		 *     // ... the filter for the Releases we want to count
		 *   }
		 * })
		 **/
		count<T extends ReleaseCountArgs>(
			args?: Subset<T, ReleaseCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], ReleaseCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Release.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ReleaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends ReleaseAggregateArgs>(args: Subset<T, ReleaseAggregateArgs>): PrismaPromise<GetReleaseAggregateType<T>>

		/**
		 * Group by Release.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {ReleaseGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends ReleaseGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: ReleaseGroupByArgs['orderBy'] }
				: { orderBy?: ReleaseGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, ReleaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Release.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__ReleaseClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		commit<T extends CommitArgs = {}>(args?: Subset<T, CommitArgs>): CheckSelect<T, Prisma__CommitClient<Commit | null >, Prisma__CommitClient<CommitGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Release findUnique
	 */
	export type ReleaseFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Release
		 *
		 **/
		select?: ReleaseSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ReleaseInclude | null
		/**
		 * Throw an Error if a Release can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Release to fetch.
		 *
		 **/
		where: ReleaseWhereUniqueInput
	}


	/**
	 * Release findFirst
	 */
	export type ReleaseFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Release
		 *
		 **/
		select?: ReleaseSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ReleaseInclude | null
		/**
		 * Throw an Error if a Release can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Release to fetch.
		 *
		 **/
		where?: ReleaseWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Releases to fetch.
		 *
		 **/
		orderBy?: Enumerable<ReleaseOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Releases.
		 *
		 **/
		cursor?: ReleaseWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Releases from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Releases.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Releases.
		 *
		 **/
		distinct?: Enumerable<ReleaseScalarFieldEnum>
	}


	/**
	 * Release findMany
	 */
	export type ReleaseFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Release
		 *
		 **/
		select?: ReleaseSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ReleaseInclude | null
		/**
		 * Filter, which Releases to fetch.
		 *
		 **/
		where?: ReleaseWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Releases to fetch.
		 *
		 **/
		orderBy?: Enumerable<ReleaseOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Releases.
		 *
		 **/
		cursor?: ReleaseWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Releases from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Releases.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<ReleaseScalarFieldEnum>
	}


	/**
	 * Release create
	 */
	export type ReleaseCreateArgs = {
		/**
		 * Select specific fields to fetch from the Release
		 *
		 **/
		select?: ReleaseSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ReleaseInclude | null
		/**
		 * The data needed to create a Release.
		 *
		 **/
		data: XOR<ReleaseCreateInput, ReleaseUncheckedCreateInput>
	}


	/**
	 * Release createMany
	 */
	export type ReleaseCreateManyArgs = {
		/**
		 * The data used to create many Releases.
		 *
		 **/
		data: Enumerable<ReleaseCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Release update
	 */
	export type ReleaseUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Release
		 *
		 **/
		select?: ReleaseSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ReleaseInclude | null
		/**
		 * The data needed to update a Release.
		 *
		 **/
		data: XOR<ReleaseUpdateInput, ReleaseUncheckedUpdateInput>
		/**
		 * Choose, which Release to update.
		 *
		 **/
		where: ReleaseWhereUniqueInput
	}


	/**
	 * Release updateMany
	 */
	export type ReleaseUpdateManyArgs = {
		/**
		 * The data used to update Releases.
		 *
		 **/
		data: XOR<ReleaseUpdateManyMutationInput, ReleaseUncheckedUpdateManyInput>
		/**
		 * Filter which Releases to update
		 *
		 **/
		where?: ReleaseWhereInput
	}


	/**
	 * Release upsert
	 */
	export type ReleaseUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Release
		 *
		 **/
		select?: ReleaseSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ReleaseInclude | null
		/**
		 * The filter to search for the Release to update in case it exists.
		 *
		 **/
		where: ReleaseWhereUniqueInput
		/**
		 * In case the Release found by the `where` argument doesn't exist, create a new Release with this data.
		 *
		 **/
		create: XOR<ReleaseCreateInput, ReleaseUncheckedCreateInput>
		/**
		 * In case the Release was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<ReleaseUpdateInput, ReleaseUncheckedUpdateInput>
	}


	/**
	 * Release delete
	 */
	export type ReleaseDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Release
		 *
		 **/
		select?: ReleaseSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ReleaseInclude | null
		/**
		 * Filter which Release to delete.
		 *
		 **/
		where: ReleaseWhereUniqueInput
	}


	/**
	 * Release deleteMany
	 */
	export type ReleaseDeleteManyArgs = {
		/**
		 * Filter which Releases to delete
		 *
		 **/
		where?: ReleaseWhereInput
	}


	/**
	 * Release without action
	 */
	export type ReleaseArgs = {
		/**
		 * Select specific fields to fetch from the Release
		 *
		 **/
		select?: ReleaseSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: ReleaseInclude | null
	}



	/**
	 * Model Environment
	 */


	export type AggregateEnvironment = {
		_count: EnvironmentCountAggregateOutputType | null
		_min: EnvironmentMinAggregateOutputType | null
		_max: EnvironmentMaxAggregateOutputType | null
	}

	export type EnvironmentMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		resourceId: string | null
		name: string | null
		description: string | null
		address: string | null
	}

	export type EnvironmentMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		resourceId: string | null
		name: string | null
		description: string | null
		address: string | null
	}

	export type EnvironmentCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		resourceId: number
		name: number
		description: number
		address: number
		_all: number
	}


	export type EnvironmentMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		name?: true
		description?: true
		address?: true
	}

	export type EnvironmentMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		name?: true
		description?: true
		address?: true
	}

	export type EnvironmentCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		resourceId?: true
		name?: true
		description?: true
		address?: true
		_all?: true
	}

	export type EnvironmentAggregateArgs = {
		/**
		 * Filter which Environment to aggregate.
		 *
		 **/
		where?: EnvironmentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Environments to fetch.
		 *
		 **/
		orderBy?: Enumerable<EnvironmentOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: EnvironmentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Environments from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Environments.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Environments
		 **/
		_count?: true | EnvironmentCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: EnvironmentMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: EnvironmentMaxAggregateInputType
	}

	export type GetEnvironmentAggregateType<T extends EnvironmentAggregateArgs> = {
		[P in keyof T & keyof AggregateEnvironment]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateEnvironment[P]>
			: GetScalarType<T[P], AggregateEnvironment[P]>
	}




	export type EnvironmentGroupByArgs = {
		where?: EnvironmentWhereInput
		orderBy?: Enumerable<EnvironmentOrderByWithAggregationInput>
		by: Array<EnvironmentScalarFieldEnum>
		having?: EnvironmentScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: EnvironmentCountAggregateInputType | true
		_min?: EnvironmentMinAggregateInputType
		_max?: EnvironmentMaxAggregateInputType
	}


	export type EnvironmentGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		resourceId: string
		name: string
		description: string | null
		address: string
		_count: EnvironmentCountAggregateOutputType | null
		_min: EnvironmentMinAggregateOutputType | null
		_max: EnvironmentMaxAggregateOutputType | null
	}

	type GetEnvironmentGroupByPayload<T extends EnvironmentGroupByArgs> = PrismaPromise<
		Array<
			PickArray<EnvironmentGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof EnvironmentGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
				: GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
			}
			>
		>


	export type EnvironmentSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		resourceId?: boolean
		name?: boolean
		description?: boolean
		address?: boolean
		resource?: boolean | ResourceArgs
		deployments?: boolean | DeploymentFindManyArgs
		_count?: boolean | EnvironmentCountOutputTypeArgs
	}

	export type EnvironmentInclude = {
		resource?: boolean | ResourceArgs
		deployments?: boolean | DeploymentFindManyArgs
		_count?: boolean | EnvironmentCountOutputTypeArgs
	}

	export type EnvironmentGetPayload<
		S extends boolean | null | undefined | EnvironmentArgs,
		U = keyof S
		> = S extends true
		? Environment
		: S extends undefined
			? never
			: S extends EnvironmentArgs | EnvironmentFindManyArgs
				?'include' extends U
					? Environment  & {
					[P in TrueKeys<S['include']>]:
					P extends 'resource' ? ResourceGetPayload<S['include'][P]> :
						P extends 'deployments' ? Array < DeploymentGetPayload<S['include'][P]>>  :
							P extends '_count' ? EnvironmentCountOutputTypeGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'resource' ? ResourceGetPayload<S['select'][P]> :
								P extends 'deployments' ? Array < DeploymentGetPayload<S['select'][P]>>  :
									P extends '_count' ? EnvironmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Environment ? Environment[P] : never
						}
						: Environment
				: Environment


	type EnvironmentCountArgs = Merge<
		Omit<EnvironmentFindManyArgs, 'select' | 'include'> & {
		select?: EnvironmentCountAggregateInputType | true
	}
		>

	export interface EnvironmentDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Environment that matches the filter.
		 * @param {EnvironmentFindUniqueArgs} args - Arguments to find a Environment
		 * @example
		 * // Get one Environment
		 * const environment = await prisma.environment.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends EnvironmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, EnvironmentFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Environment'> extends True ? CheckSelect<T, Prisma__EnvironmentClient<Environment>, Prisma__EnvironmentClient<EnvironmentGetPayload<T>>> : CheckSelect<T, Prisma__EnvironmentClient<Environment | null >, Prisma__EnvironmentClient<EnvironmentGetPayload<T> | null >>

		/**
		 * Find the first Environment that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EnvironmentFindFirstArgs} args - Arguments to find a Environment
		 * @example
		 * // Get one Environment
		 * const environment = await prisma.environment.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends EnvironmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, EnvironmentFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Environment'> extends True ? CheckSelect<T, Prisma__EnvironmentClient<Environment>, Prisma__EnvironmentClient<EnvironmentGetPayload<T>>> : CheckSelect<T, Prisma__EnvironmentClient<Environment | null >, Prisma__EnvironmentClient<EnvironmentGetPayload<T> | null >>

		/**
		 * Find zero or more Environments that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EnvironmentFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Environments
		 * const environments = await prisma.environment.findMany()
		 *
		 * // Get first 10 Environments
		 * const environments = await prisma.environment.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const environmentWithIdOnly = await prisma.environment.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends EnvironmentFindManyArgs>(
			args?: SelectSubset<T, EnvironmentFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Environment>>, PrismaPromise<Array<EnvironmentGetPayload<T>>>>

		/**
		 * Create a Environment.
		 * @param {EnvironmentCreateArgs} args - Arguments to create a Environment.
		 * @example
		 * // Create one Environment
		 * const Environment = await prisma.environment.create({
		 *   data: {
		 *     // ... data to create a Environment
		 *   }
		 * })
		 *
		 **/
		create<T extends EnvironmentCreateArgs>(
			args: SelectSubset<T, EnvironmentCreateArgs>
		): CheckSelect<T, Prisma__EnvironmentClient<Environment>, Prisma__EnvironmentClient<EnvironmentGetPayload<T>>>

		/**
		 * Create many Environments.
		 *     @param {EnvironmentCreateManyArgs} args - Arguments to create many Environments.
		 *     @example
		 *     // Create many Environments
		 *     const environment = await prisma.environment.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends EnvironmentCreateManyArgs>(
			args?: SelectSubset<T, EnvironmentCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Environment.
		 * @param {EnvironmentDeleteArgs} args - Arguments to delete one Environment.
		 * @example
		 * // Delete one Environment
		 * const Environment = await prisma.environment.delete({
		 *   where: {
		 *     // ... filter to delete one Environment
		 *   }
		 * })
		 *
		 **/
		delete<T extends EnvironmentDeleteArgs>(
			args: SelectSubset<T, EnvironmentDeleteArgs>
		): CheckSelect<T, Prisma__EnvironmentClient<Environment>, Prisma__EnvironmentClient<EnvironmentGetPayload<T>>>

		/**
		 * Update one Environment.
		 * @param {EnvironmentUpdateArgs} args - Arguments to update one Environment.
		 * @example
		 * // Update one Environment
		 * const environment = await prisma.environment.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends EnvironmentUpdateArgs>(
			args: SelectSubset<T, EnvironmentUpdateArgs>
		): CheckSelect<T, Prisma__EnvironmentClient<Environment>, Prisma__EnvironmentClient<EnvironmentGetPayload<T>>>

		/**
		 * Delete zero or more Environments.
		 * @param {EnvironmentDeleteManyArgs} args - Arguments to filter Environments to delete.
		 * @example
		 * // Delete a few Environments
		 * const { count } = await prisma.environment.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends EnvironmentDeleteManyArgs>(
			args?: SelectSubset<T, EnvironmentDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Environments.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EnvironmentUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Environments
		 * const environment = await prisma.environment.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends EnvironmentUpdateManyArgs>(
			args: SelectSubset<T, EnvironmentUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Environment.
		 * @param {EnvironmentUpsertArgs} args - Arguments to update or create a Environment.
		 * @example
		 * // Update or create a Environment
		 * const environment = await prisma.environment.upsert({
		 *   create: {
		 *     // ... data to create a Environment
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Environment we want to update
		 *   }
		 * })
		 **/
		upsert<T extends EnvironmentUpsertArgs>(
			args: SelectSubset<T, EnvironmentUpsertArgs>
		): CheckSelect<T, Prisma__EnvironmentClient<Environment>, Prisma__EnvironmentClient<EnvironmentGetPayload<T>>>

		/**
		 * Count the number of Environments.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EnvironmentCountArgs} args - Arguments to filter Environments to count.
		 * @example
		 * // Count the number of Environments
		 * const count = await prisma.environment.count({
		 *   where: {
		 *     // ... the filter for the Environments we want to count
		 *   }
		 * })
		 **/
		count<T extends EnvironmentCountArgs>(
			args?: Subset<T, EnvironmentCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], EnvironmentCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Environment.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EnvironmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends EnvironmentAggregateArgs>(args: Subset<T, EnvironmentAggregateArgs>): PrismaPromise<GetEnvironmentAggregateType<T>>

		/**
		 * Group by Environment.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {EnvironmentGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends EnvironmentGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: EnvironmentGroupByArgs['orderBy'] }
				: { orderBy?: EnvironmentGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, EnvironmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvironmentGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Environment.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__EnvironmentClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		resource<T extends ResourceArgs = {}>(args?: Subset<T, ResourceArgs>): CheckSelect<T, Prisma__ResourceClient<Resource | null >, Prisma__ResourceClient<ResourceGetPayload<T> | null >>;

		deployments<T extends DeploymentFindManyArgs = {}>(args?: Subset<T, DeploymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Deployment>>, PrismaPromise<Array<DeploymentGetPayload<T>>>>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Environment findUnique
	 */
	export type EnvironmentFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Environment
		 *
		 **/
		select?: EnvironmentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EnvironmentInclude | null
		/**
		 * Throw an Error if a Environment can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Environment to fetch.
		 *
		 **/
		where: EnvironmentWhereUniqueInput
	}


	/**
	 * Environment findFirst
	 */
	export type EnvironmentFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Environment
		 *
		 **/
		select?: EnvironmentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EnvironmentInclude | null
		/**
		 * Throw an Error if a Environment can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Environment to fetch.
		 *
		 **/
		where?: EnvironmentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Environments to fetch.
		 *
		 **/
		orderBy?: Enumerable<EnvironmentOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Environments.
		 *
		 **/
		cursor?: EnvironmentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Environments from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Environments.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Environments.
		 *
		 **/
		distinct?: Enumerable<EnvironmentScalarFieldEnum>
	}


	/**
	 * Environment findMany
	 */
	export type EnvironmentFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Environment
		 *
		 **/
		select?: EnvironmentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EnvironmentInclude | null
		/**
		 * Filter, which Environments to fetch.
		 *
		 **/
		where?: EnvironmentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Environments to fetch.
		 *
		 **/
		orderBy?: Enumerable<EnvironmentOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Environments.
		 *
		 **/
		cursor?: EnvironmentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Environments from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Environments.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<EnvironmentScalarFieldEnum>
	}


	/**
	 * Environment create
	 */
	export type EnvironmentCreateArgs = {
		/**
		 * Select specific fields to fetch from the Environment
		 *
		 **/
		select?: EnvironmentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EnvironmentInclude | null
		/**
		 * The data needed to create a Environment.
		 *
		 **/
		data: XOR<EnvironmentCreateInput, EnvironmentUncheckedCreateInput>
	}


	/**
	 * Environment createMany
	 */
	export type EnvironmentCreateManyArgs = {
		/**
		 * The data used to create many Environments.
		 *
		 **/
		data: Enumerable<EnvironmentCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Environment update
	 */
	export type EnvironmentUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Environment
		 *
		 **/
		select?: EnvironmentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EnvironmentInclude | null
		/**
		 * The data needed to update a Environment.
		 *
		 **/
		data: XOR<EnvironmentUpdateInput, EnvironmentUncheckedUpdateInput>
		/**
		 * Choose, which Environment to update.
		 *
		 **/
		where: EnvironmentWhereUniqueInput
	}


	/**
	 * Environment updateMany
	 */
	export type EnvironmentUpdateManyArgs = {
		/**
		 * The data used to update Environments.
		 *
		 **/
		data: XOR<EnvironmentUpdateManyMutationInput, EnvironmentUncheckedUpdateManyInput>
		/**
		 * Filter which Environments to update
		 *
		 **/
		where?: EnvironmentWhereInput
	}


	/**
	 * Environment upsert
	 */
	export type EnvironmentUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Environment
		 *
		 **/
		select?: EnvironmentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EnvironmentInclude | null
		/**
		 * The filter to search for the Environment to update in case it exists.
		 *
		 **/
		where: EnvironmentWhereUniqueInput
		/**
		 * In case the Environment found by the `where` argument doesn't exist, create a new Environment with this data.
		 *
		 **/
		create: XOR<EnvironmentCreateInput, EnvironmentUncheckedCreateInput>
		/**
		 * In case the Environment was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<EnvironmentUpdateInput, EnvironmentUncheckedUpdateInput>
	}


	/**
	 * Environment delete
	 */
	export type EnvironmentDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Environment
		 *
		 **/
		select?: EnvironmentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EnvironmentInclude | null
		/**
		 * Filter which Environment to delete.
		 *
		 **/
		where: EnvironmentWhereUniqueInput
	}


	/**
	 * Environment deleteMany
	 */
	export type EnvironmentDeleteManyArgs = {
		/**
		 * Filter which Environments to delete
		 *
		 **/
		where?: EnvironmentWhereInput
	}


	/**
	 * Environment without action
	 */
	export type EnvironmentArgs = {
		/**
		 * Select specific fields to fetch from the Environment
		 *
		 **/
		select?: EnvironmentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: EnvironmentInclude | null
	}



	/**
	 * Model Deployment
	 */


	export type AggregateDeployment = {
		_count: DeploymentCountAggregateOutputType | null
		_min: DeploymentMinAggregateOutputType | null
		_max: DeploymentMaxAggregateOutputType | null
	}

	export type DeploymentMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		userId: string | null
		buildId: string | null
		environmentId: string | null
		status: EnumDeploymentStatus | null
		message: string | null
		actionId: string | null
		statusUpdatedAt: Date | null
	}

	export type DeploymentMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		userId: string | null
		buildId: string | null
		environmentId: string | null
		status: EnumDeploymentStatus | null
		message: string | null
		actionId: string | null
		statusUpdatedAt: Date | null
	}

	export type DeploymentCountAggregateOutputType = {
		id: number
		createdAt: number
		userId: number
		buildId: number
		environmentId: number
		status: number
		message: number
		actionId: number
		statusQuery: number
		statusUpdatedAt: number
		_all: number
	}


	export type DeploymentMinAggregateInputType = {
		id?: true
		createdAt?: true
		userId?: true
		buildId?: true
		environmentId?: true
		status?: true
		message?: true
		actionId?: true
		statusUpdatedAt?: true
	}

	export type DeploymentMaxAggregateInputType = {
		id?: true
		createdAt?: true
		userId?: true
		buildId?: true
		environmentId?: true
		status?: true
		message?: true
		actionId?: true
		statusUpdatedAt?: true
	}

	export type DeploymentCountAggregateInputType = {
		id?: true
		createdAt?: true
		userId?: true
		buildId?: true
		environmentId?: true
		status?: true
		message?: true
		actionId?: true
		statusQuery?: true
		statusUpdatedAt?: true
		_all?: true
	}

	export type DeploymentAggregateArgs = {
		/**
		 * Filter which Deployment to aggregate.
		 *
		 **/
		where?: DeploymentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Deployments to fetch.
		 *
		 **/
		orderBy?: Enumerable<DeploymentOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: DeploymentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Deployments from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Deployments.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Deployments
		 **/
		_count?: true | DeploymentCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: DeploymentMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: DeploymentMaxAggregateInputType
	}

	export type GetDeploymentAggregateType<T extends DeploymentAggregateArgs> = {
		[P in keyof T & keyof AggregateDeployment]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateDeployment[P]>
			: GetScalarType<T[P], AggregateDeployment[P]>
	}




	export type DeploymentGroupByArgs = {
		where?: DeploymentWhereInput
		orderBy?: Enumerable<DeploymentOrderByWithAggregationInput>
		by: Array<DeploymentScalarFieldEnum>
		having?: DeploymentScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: DeploymentCountAggregateInputType | true
		_min?: DeploymentMinAggregateInputType
		_max?: DeploymentMaxAggregateInputType
	}


	export type DeploymentGroupByOutputType = {
		id: string
		createdAt: Date
		userId: string
		buildId: string
		environmentId: string
		status: EnumDeploymentStatus
		message: string | null
		actionId: string
		statusQuery: JsonValue | null
		statusUpdatedAt: Date | null
		_count: DeploymentCountAggregateOutputType | null
		_min: DeploymentMinAggregateOutputType | null
		_max: DeploymentMaxAggregateOutputType | null
	}

	type GetDeploymentGroupByPayload<T extends DeploymentGroupByArgs> = PrismaPromise<
		Array<
			PickArray<DeploymentGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof DeploymentGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], DeploymentGroupByOutputType[P]>
				: GetScalarType<T[P], DeploymentGroupByOutputType[P]>
			}
			>
		>


	export type DeploymentSelect = {
		id?: boolean
		createdAt?: boolean
		userId?: boolean
		buildId?: boolean
		environmentId?: boolean
		status?: boolean
		message?: boolean
		actionId?: boolean
		statusQuery?: boolean
		statusUpdatedAt?: boolean
		action?: boolean | ActionArgs
		build?: boolean | BuildArgs
		environment?: boolean | EnvironmentArgs
		createdBy?: boolean | UserArgs
	}

	export type DeploymentInclude = {
		action?: boolean | ActionArgs
		build?: boolean | BuildArgs
		environment?: boolean | EnvironmentArgs
		createdBy?: boolean | UserArgs
	}

	export type DeploymentGetPayload<
		S extends boolean | null | undefined | DeploymentArgs,
		U = keyof S
		> = S extends true
		? Deployment
		: S extends undefined
			? never
			: S extends DeploymentArgs | DeploymentFindManyArgs
				?'include' extends U
					? Deployment  & {
					[P in TrueKeys<S['include']>]:
					P extends 'action' ? ActionGetPayload<S['include'][P]> :
						P extends 'build' ? BuildGetPayload<S['include'][P]> :
							P extends 'environment' ? EnvironmentGetPayload<S['include'][P]> :
								P extends 'createdBy' ? UserGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'action' ? ActionGetPayload<S['select'][P]> :
								P extends 'build' ? BuildGetPayload<S['select'][P]> :
									P extends 'environment' ? EnvironmentGetPayload<S['select'][P]> :
										P extends 'createdBy' ? UserGetPayload<S['select'][P]> :  P extends keyof Deployment ? Deployment[P] : never
						}
						: Deployment
				: Deployment


	type DeploymentCountArgs = Merge<
		Omit<DeploymentFindManyArgs, 'select' | 'include'> & {
		select?: DeploymentCountAggregateInputType | true
	}
		>

	export interface DeploymentDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Deployment that matches the filter.
		 * @param {DeploymentFindUniqueArgs} args - Arguments to find a Deployment
		 * @example
		 * // Get one Deployment
		 * const deployment = await prisma.deployment.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends DeploymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, DeploymentFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Deployment'> extends True ? CheckSelect<T, Prisma__DeploymentClient<Deployment>, Prisma__DeploymentClient<DeploymentGetPayload<T>>> : CheckSelect<T, Prisma__DeploymentClient<Deployment | null >, Prisma__DeploymentClient<DeploymentGetPayload<T> | null >>

		/**
		 * Find the first Deployment that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeploymentFindFirstArgs} args - Arguments to find a Deployment
		 * @example
		 * // Get one Deployment
		 * const deployment = await prisma.deployment.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends DeploymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, DeploymentFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Deployment'> extends True ? CheckSelect<T, Prisma__DeploymentClient<Deployment>, Prisma__DeploymentClient<DeploymentGetPayload<T>>> : CheckSelect<T, Prisma__DeploymentClient<Deployment | null >, Prisma__DeploymentClient<DeploymentGetPayload<T> | null >>

		/**
		 * Find zero or more Deployments that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeploymentFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Deployments
		 * const deployments = await prisma.deployment.findMany()
		 *
		 * // Get first 10 Deployments
		 * const deployments = await prisma.deployment.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const deploymentWithIdOnly = await prisma.deployment.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends DeploymentFindManyArgs>(
			args?: SelectSubset<T, DeploymentFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Deployment>>, PrismaPromise<Array<DeploymentGetPayload<T>>>>

		/**
		 * Create a Deployment.
		 * @param {DeploymentCreateArgs} args - Arguments to create a Deployment.
		 * @example
		 * // Create one Deployment
		 * const Deployment = await prisma.deployment.create({
		 *   data: {
		 *     // ... data to create a Deployment
		 *   }
		 * })
		 *
		 **/
		create<T extends DeploymentCreateArgs>(
			args: SelectSubset<T, DeploymentCreateArgs>
		): CheckSelect<T, Prisma__DeploymentClient<Deployment>, Prisma__DeploymentClient<DeploymentGetPayload<T>>>

		/**
		 * Create many Deployments.
		 *     @param {DeploymentCreateManyArgs} args - Arguments to create many Deployments.
		 *     @example
		 *     // Create many Deployments
		 *     const deployment = await prisma.deployment.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends DeploymentCreateManyArgs>(
			args?: SelectSubset<T, DeploymentCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Deployment.
		 * @param {DeploymentDeleteArgs} args - Arguments to delete one Deployment.
		 * @example
		 * // Delete one Deployment
		 * const Deployment = await prisma.deployment.delete({
		 *   where: {
		 *     // ... filter to delete one Deployment
		 *   }
		 * })
		 *
		 **/
		delete<T extends DeploymentDeleteArgs>(
			args: SelectSubset<T, DeploymentDeleteArgs>
		): CheckSelect<T, Prisma__DeploymentClient<Deployment>, Prisma__DeploymentClient<DeploymentGetPayload<T>>>

		/**
		 * Update one Deployment.
		 * @param {DeploymentUpdateArgs} args - Arguments to update one Deployment.
		 * @example
		 * // Update one Deployment
		 * const deployment = await prisma.deployment.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends DeploymentUpdateArgs>(
			args: SelectSubset<T, DeploymentUpdateArgs>
		): CheckSelect<T, Prisma__DeploymentClient<Deployment>, Prisma__DeploymentClient<DeploymentGetPayload<T>>>

		/**
		 * Delete zero or more Deployments.
		 * @param {DeploymentDeleteManyArgs} args - Arguments to filter Deployments to delete.
		 * @example
		 * // Delete a few Deployments
		 * const { count } = await prisma.deployment.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends DeploymentDeleteManyArgs>(
			args?: SelectSubset<T, DeploymentDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Deployments.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeploymentUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Deployments
		 * const deployment = await prisma.deployment.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends DeploymentUpdateManyArgs>(
			args: SelectSubset<T, DeploymentUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Deployment.
		 * @param {DeploymentUpsertArgs} args - Arguments to update or create a Deployment.
		 * @example
		 * // Update or create a Deployment
		 * const deployment = await prisma.deployment.upsert({
		 *   create: {
		 *     // ... data to create a Deployment
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Deployment we want to update
		 *   }
		 * })
		 **/
		upsert<T extends DeploymentUpsertArgs>(
			args: SelectSubset<T, DeploymentUpsertArgs>
		): CheckSelect<T, Prisma__DeploymentClient<Deployment>, Prisma__DeploymentClient<DeploymentGetPayload<T>>>

		/**
		 * Count the number of Deployments.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeploymentCountArgs} args - Arguments to filter Deployments to count.
		 * @example
		 * // Count the number of Deployments
		 * const count = await prisma.deployment.count({
		 *   where: {
		 *     // ... the filter for the Deployments we want to count
		 *   }
		 * })
		 **/
		count<T extends DeploymentCountArgs>(
			args?: Subset<T, DeploymentCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], DeploymentCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Deployment.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeploymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends DeploymentAggregateArgs>(args: Subset<T, DeploymentAggregateArgs>): PrismaPromise<GetDeploymentAggregateType<T>>

		/**
		 * Group by Deployment.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {DeploymentGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends DeploymentGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: DeploymentGroupByArgs['orderBy'] }
				: { orderBy?: DeploymentGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, DeploymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeploymentGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Deployment.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__DeploymentClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		action<T extends ActionArgs = {}>(args?: Subset<T, ActionArgs>): CheckSelect<T, Prisma__ActionClient<Action | null >, Prisma__ActionClient<ActionGetPayload<T> | null >>;

		build<T extends BuildArgs = {}>(args?: Subset<T, BuildArgs>): CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>;

		environment<T extends EnvironmentArgs = {}>(args?: Subset<T, EnvironmentArgs>): CheckSelect<T, Prisma__EnvironmentClient<Environment | null >, Prisma__EnvironmentClient<EnvironmentGetPayload<T> | null >>;

		createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Deployment findUnique
	 */
	export type DeploymentFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Deployment
		 *
		 **/
		select?: DeploymentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: DeploymentInclude | null
		/**
		 * Throw an Error if a Deployment can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Deployment to fetch.
		 *
		 **/
		where: DeploymentWhereUniqueInput
	}


	/**
	 * Deployment findFirst
	 */
	export type DeploymentFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Deployment
		 *
		 **/
		select?: DeploymentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: DeploymentInclude | null
		/**
		 * Throw an Error if a Deployment can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Deployment to fetch.
		 *
		 **/
		where?: DeploymentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Deployments to fetch.
		 *
		 **/
		orderBy?: Enumerable<DeploymentOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Deployments.
		 *
		 **/
		cursor?: DeploymentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Deployments from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Deployments.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Deployments.
		 *
		 **/
		distinct?: Enumerable<DeploymentScalarFieldEnum>
	}


	/**
	 * Deployment findMany
	 */
	export type DeploymentFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Deployment
		 *
		 **/
		select?: DeploymentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: DeploymentInclude | null
		/**
		 * Filter, which Deployments to fetch.
		 *
		 **/
		where?: DeploymentWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Deployments to fetch.
		 *
		 **/
		orderBy?: Enumerable<DeploymentOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Deployments.
		 *
		 **/
		cursor?: DeploymentWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Deployments from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Deployments.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<DeploymentScalarFieldEnum>
	}


	/**
	 * Deployment create
	 */
	export type DeploymentCreateArgs = {
		/**
		 * Select specific fields to fetch from the Deployment
		 *
		 **/
		select?: DeploymentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: DeploymentInclude | null
		/**
		 * The data needed to create a Deployment.
		 *
		 **/
		data: XOR<DeploymentCreateInput, DeploymentUncheckedCreateInput>
	}


	/**
	 * Deployment createMany
	 */
	export type DeploymentCreateManyArgs = {
		/**
		 * The data used to create many Deployments.
		 *
		 **/
		data: Enumerable<DeploymentCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Deployment update
	 */
	export type DeploymentUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Deployment
		 *
		 **/
		select?: DeploymentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: DeploymentInclude | null
		/**
		 * The data needed to update a Deployment.
		 *
		 **/
		data: XOR<DeploymentUpdateInput, DeploymentUncheckedUpdateInput>
		/**
		 * Choose, which Deployment to update.
		 *
		 **/
		where: DeploymentWhereUniqueInput
	}


	/**
	 * Deployment updateMany
	 */
	export type DeploymentUpdateManyArgs = {
		/**
		 * The data used to update Deployments.
		 *
		 **/
		data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyInput>
		/**
		 * Filter which Deployments to update
		 *
		 **/
		where?: DeploymentWhereInput
	}


	/**
	 * Deployment upsert
	 */
	export type DeploymentUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Deployment
		 *
		 **/
		select?: DeploymentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: DeploymentInclude | null
		/**
		 * The filter to search for the Deployment to update in case it exists.
		 *
		 **/
		where: DeploymentWhereUniqueInput
		/**
		 * In case the Deployment found by the `where` argument doesn't exist, create a new Deployment with this data.
		 *
		 **/
		create: XOR<DeploymentCreateInput, DeploymentUncheckedCreateInput>
		/**
		 * In case the Deployment was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<DeploymentUpdateInput, DeploymentUncheckedUpdateInput>
	}


	/**
	 * Deployment delete
	 */
	export type DeploymentDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Deployment
		 *
		 **/
		select?: DeploymentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: DeploymentInclude | null
		/**
		 * Filter which Deployment to delete.
		 *
		 **/
		where: DeploymentWhereUniqueInput
	}


	/**
	 * Deployment deleteMany
	 */
	export type DeploymentDeleteManyArgs = {
		/**
		 * Filter which Deployments to delete
		 *
		 **/
		where?: DeploymentWhereInput
	}


	/**
	 * Deployment without action
	 */
	export type DeploymentArgs = {
		/**
		 * Select specific fields to fetch from the Deployment
		 *
		 **/
		select?: DeploymentSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: DeploymentInclude | null
	}



	/**
	 * Model Invitation
	 */


	export type AggregateInvitation = {
		_count: InvitationCountAggregateOutputType | null
		_min: InvitationMinAggregateOutputType | null
		_max: InvitationMaxAggregateOutputType | null
	}

	export type InvitationMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		email: string | null
		invitedByUserId: string | null
		workspaceId: string | null
		newUserId: string | null
		token: string | null
		tokenExpiration: Date | null
	}

	export type InvitationMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		email: string | null
		invitedByUserId: string | null
		workspaceId: string | null
		newUserId: string | null
		token: string | null
		tokenExpiration: Date | null
	}

	export type InvitationCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		email: number
		invitedByUserId: number
		workspaceId: number
		newUserId: number
		token: number
		tokenExpiration: number
		_all: number
	}


	export type InvitationMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		email?: true
		invitedByUserId?: true
		workspaceId?: true
		newUserId?: true
		token?: true
		tokenExpiration?: true
	}

	export type InvitationMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		email?: true
		invitedByUserId?: true
		workspaceId?: true
		newUserId?: true
		token?: true
		tokenExpiration?: true
	}

	export type InvitationCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		email?: true
		invitedByUserId?: true
		workspaceId?: true
		newUserId?: true
		token?: true
		tokenExpiration?: true
		_all?: true
	}

	export type InvitationAggregateArgs = {
		/**
		 * Filter which Invitation to aggregate.
		 *
		 **/
		where?: InvitationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Invitations to fetch.
		 *
		 **/
		orderBy?: Enumerable<InvitationOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: InvitationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Invitations from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Invitations.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Invitations
		 **/
		_count?: true | InvitationCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: InvitationMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: InvitationMaxAggregateInputType
	}

	export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
		[P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateInvitation[P]>
			: GetScalarType<T[P], AggregateInvitation[P]>
	}




	export type InvitationGroupByArgs = {
		where?: InvitationWhereInput
		orderBy?: Enumerable<InvitationOrderByWithAggregationInput>
		by: Array<InvitationScalarFieldEnum>
		having?: InvitationScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: InvitationCountAggregateInputType | true
		_min?: InvitationMinAggregateInputType
		_max?: InvitationMaxAggregateInputType
	}


	export type InvitationGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		email: string
		invitedByUserId: string
		workspaceId: string
		newUserId: string | null
		token: string
		tokenExpiration: Date
		_count: InvitationCountAggregateOutputType | null
		_min: InvitationMinAggregateOutputType | null
		_max: InvitationMaxAggregateOutputType | null
	}

	type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = PrismaPromise<
		Array<
			PickArray<InvitationGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], InvitationGroupByOutputType[P]>
				: GetScalarType<T[P], InvitationGroupByOutputType[P]>
			}
			>
		>


	export type InvitationSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		email?: boolean
		invitedByUserId?: boolean
		invitedByUser?: boolean | UserArgs
		workspaceId?: boolean
		workspace?: boolean | WorkspaceArgs
		newUserId?: boolean
		newUser?: boolean | UserArgs
		token?: boolean
		tokenExpiration?: boolean
	}

	export type InvitationInclude = {
		invitedByUser?: boolean | UserArgs
		workspace?: boolean | WorkspaceArgs
		newUser?: boolean | UserArgs
	}

	export type InvitationGetPayload<
		S extends boolean | null | undefined | InvitationArgs,
		U = keyof S
		> = S extends true
		? Invitation
		: S extends undefined
			? never
			: S extends InvitationArgs | InvitationFindManyArgs
				?'include' extends U
					? Invitation  & {
					[P in TrueKeys<S['include']>]:
					P extends 'invitedByUser' ? UserGetPayload<S['include'][P]> :
						P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :
							P extends 'newUser' ? UserGetPayload<S['include'][P]> | null :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'invitedByUser' ? UserGetPayload<S['select'][P]> :
								P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :
									P extends 'newUser' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Invitation ? Invitation[P] : never
						}
						: Invitation
				: Invitation


	type InvitationCountArgs = Merge<
		Omit<InvitationFindManyArgs, 'select' | 'include'> & {
		select?: InvitationCountAggregateInputType | true
	}
		>

	export interface InvitationDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Invitation that matches the filter.
		 * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
		 * @example
		 * // Get one Invitation
		 * const invitation = await prisma.invitation.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends InvitationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, InvitationFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invitation'> extends True ? CheckSelect<T, Prisma__InvitationClient<Invitation>, Prisma__InvitationClient<InvitationGetPayload<T>>> : CheckSelect<T, Prisma__InvitationClient<Invitation | null >, Prisma__InvitationClient<InvitationGetPayload<T> | null >>

		/**
		 * Find the first Invitation that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
		 * @example
		 * // Get one Invitation
		 * const invitation = await prisma.invitation.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends InvitationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, InvitationFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invitation'> extends True ? CheckSelect<T, Prisma__InvitationClient<Invitation>, Prisma__InvitationClient<InvitationGetPayload<T>>> : CheckSelect<T, Prisma__InvitationClient<Invitation | null >, Prisma__InvitationClient<InvitationGetPayload<T> | null >>

		/**
		 * Find zero or more Invitations that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {InvitationFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Invitations
		 * const invitations = await prisma.invitation.findMany()
		 *
		 * // Get first 10 Invitations
		 * const invitations = await prisma.invitation.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends InvitationFindManyArgs>(
			args?: SelectSubset<T, InvitationFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Invitation>>, PrismaPromise<Array<InvitationGetPayload<T>>>>

		/**
		 * Create a Invitation.
		 * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
		 * @example
		 * // Create one Invitation
		 * const Invitation = await prisma.invitation.create({
		 *   data: {
		 *     // ... data to create a Invitation
		 *   }
		 * })
		 *
		 **/
		create<T extends InvitationCreateArgs>(
			args: SelectSubset<T, InvitationCreateArgs>
		): CheckSelect<T, Prisma__InvitationClient<Invitation>, Prisma__InvitationClient<InvitationGetPayload<T>>>

		/**
		 * Create many Invitations.
		 *     @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
		 *     @example
		 *     // Create many Invitations
		 *     const invitation = await prisma.invitation.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends InvitationCreateManyArgs>(
			args?: SelectSubset<T, InvitationCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Invitation.
		 * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
		 * @example
		 * // Delete one Invitation
		 * const Invitation = await prisma.invitation.delete({
		 *   where: {
		 *     // ... filter to delete one Invitation
		 *   }
		 * })
		 *
		 **/
		delete<T extends InvitationDeleteArgs>(
			args: SelectSubset<T, InvitationDeleteArgs>
		): CheckSelect<T, Prisma__InvitationClient<Invitation>, Prisma__InvitationClient<InvitationGetPayload<T>>>

		/**
		 * Update one Invitation.
		 * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
		 * @example
		 * // Update one Invitation
		 * const invitation = await prisma.invitation.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends InvitationUpdateArgs>(
			args: SelectSubset<T, InvitationUpdateArgs>
		): CheckSelect<T, Prisma__InvitationClient<Invitation>, Prisma__InvitationClient<InvitationGetPayload<T>>>

		/**
		 * Delete zero or more Invitations.
		 * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
		 * @example
		 * // Delete a few Invitations
		 * const { count } = await prisma.invitation.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends InvitationDeleteManyArgs>(
			args?: SelectSubset<T, InvitationDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Invitations.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Invitations
		 * const invitation = await prisma.invitation.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends InvitationUpdateManyArgs>(
			args: SelectSubset<T, InvitationUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Invitation.
		 * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
		 * @example
		 * // Update or create a Invitation
		 * const invitation = await prisma.invitation.upsert({
		 *   create: {
		 *     // ... data to create a Invitation
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Invitation we want to update
		 *   }
		 * })
		 **/
		upsert<T extends InvitationUpsertArgs>(
			args: SelectSubset<T, InvitationUpsertArgs>
		): CheckSelect<T, Prisma__InvitationClient<Invitation>, Prisma__InvitationClient<InvitationGetPayload<T>>>

		/**
		 * Count the number of Invitations.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
		 * @example
		 * // Count the number of Invitations
		 * const count = await prisma.invitation.count({
		 *   where: {
		 *     // ... the filter for the Invitations we want to count
		 *   }
		 * })
		 **/
		count<T extends InvitationCountArgs>(
			args?: Subset<T, InvitationCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], InvitationCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Invitation.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): PrismaPromise<GetInvitationAggregateType<T>>

		/**
		 * Group by Invitation.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {InvitationGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends InvitationGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: InvitationGroupByArgs['orderBy'] }
				: { orderBy?: InvitationGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Invitation.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__InvitationClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		invitedByUser<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null >, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null >>;

		newUser<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Invitation findUnique
	 */
	export type InvitationFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Invitation
		 *
		 **/
		select?: InvitationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: InvitationInclude | null
		/**
		 * Throw an Error if a Invitation can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Invitation to fetch.
		 *
		 **/
		where: InvitationWhereUniqueInput
	}


	/**
	 * Invitation findFirst
	 */
	export type InvitationFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Invitation
		 *
		 **/
		select?: InvitationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: InvitationInclude | null
		/**
		 * Throw an Error if a Invitation can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Invitation to fetch.
		 *
		 **/
		where?: InvitationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Invitations to fetch.
		 *
		 **/
		orderBy?: Enumerable<InvitationOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Invitations.
		 *
		 **/
		cursor?: InvitationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Invitations from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Invitations.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Invitations.
		 *
		 **/
		distinct?: Enumerable<InvitationScalarFieldEnum>
	}


	/**
	 * Invitation findMany
	 */
	export type InvitationFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Invitation
		 *
		 **/
		select?: InvitationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: InvitationInclude | null
		/**
		 * Filter, which Invitations to fetch.
		 *
		 **/
		where?: InvitationWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Invitations to fetch.
		 *
		 **/
		orderBy?: Enumerable<InvitationOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Invitations.
		 *
		 **/
		cursor?: InvitationWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Invitations from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Invitations.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<InvitationScalarFieldEnum>
	}


	/**
	 * Invitation create
	 */
	export type InvitationCreateArgs = {
		/**
		 * Select specific fields to fetch from the Invitation
		 *
		 **/
		select?: InvitationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: InvitationInclude | null
		/**
		 * The data needed to create a Invitation.
		 *
		 **/
		data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
	}


	/**
	 * Invitation createMany
	 */
	export type InvitationCreateManyArgs = {
		/**
		 * The data used to create many Invitations.
		 *
		 **/
		data: Enumerable<InvitationCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Invitation update
	 */
	export type InvitationUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Invitation
		 *
		 **/
		select?: InvitationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: InvitationInclude | null
		/**
		 * The data needed to update a Invitation.
		 *
		 **/
		data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
		/**
		 * Choose, which Invitation to update.
		 *
		 **/
		where: InvitationWhereUniqueInput
	}


	/**
	 * Invitation updateMany
	 */
	export type InvitationUpdateManyArgs = {
		/**
		 * The data used to update Invitations.
		 *
		 **/
		data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
		/**
		 * Filter which Invitations to update
		 *
		 **/
		where?: InvitationWhereInput
	}


	/**
	 * Invitation upsert
	 */
	export type InvitationUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Invitation
		 *
		 **/
		select?: InvitationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: InvitationInclude | null
		/**
		 * The filter to search for the Invitation to update in case it exists.
		 *
		 **/
		where: InvitationWhereUniqueInput
		/**
		 * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
		 *
		 **/
		create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
		/**
		 * In case the Invitation was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
	}


	/**
	 * Invitation delete
	 */
	export type InvitationDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Invitation
		 *
		 **/
		select?: InvitationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: InvitationInclude | null
		/**
		 * Filter which Invitation to delete.
		 *
		 **/
		where: InvitationWhereUniqueInput
	}


	/**
	 * Invitation deleteMany
	 */
	export type InvitationDeleteManyArgs = {
		/**
		 * Filter which Invitations to delete
		 *
		 **/
		where?: InvitationWhereInput
	}


	/**
	 * Invitation without action
	 */
	export type InvitationArgs = {
		/**
		 * Select specific fields to fetch from the Invitation
		 *
		 **/
		select?: InvitationSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: InvitationInclude | null
	}



	/**
	 * Model Subscription
	 */


	export type AggregateSubscription = {
		_count: SubscriptionCountAggregateOutputType | null
		_min: SubscriptionMinAggregateOutputType | null
		_max: SubscriptionMaxAggregateOutputType | null
	}

	export type SubscriptionMinAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		workspaceId: string | null
		subscriptionPlan: EnumSubscriptionPlan | null
		status: EnumSubscriptionStatus | null
		cancellationEffectiveDate: Date | null
	}

	export type SubscriptionMaxAggregateOutputType = {
		id: string | null
		createdAt: Date | null
		updatedAt: Date | null
		workspaceId: string | null
		subscriptionPlan: EnumSubscriptionPlan | null
		status: EnumSubscriptionStatus | null
		cancellationEffectiveDate: Date | null
	}

	export type SubscriptionCountAggregateOutputType = {
		id: number
		createdAt: number
		updatedAt: number
		workspaceId: number
		subscriptionPlan: number
		status: number
		subscriptionData: number
		cancellationEffectiveDate: number
		_all: number
	}


	export type SubscriptionMinAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		workspaceId?: true
		subscriptionPlan?: true
		status?: true
		cancellationEffectiveDate?: true
	}

	export type SubscriptionMaxAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		workspaceId?: true
		subscriptionPlan?: true
		status?: true
		cancellationEffectiveDate?: true
	}

	export type SubscriptionCountAggregateInputType = {
		id?: true
		createdAt?: true
		updatedAt?: true
		workspaceId?: true
		subscriptionPlan?: true
		status?: true
		subscriptionData?: true
		cancellationEffectiveDate?: true
		_all?: true
	}

	export type SubscriptionAggregateArgs = {
		/**
		 * Filter which Subscription to aggregate.
		 *
		 **/
		where?: SubscriptionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Subscriptions to fetch.
		 *
		 **/
		orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the start position
		 *
		 **/
		cursor?: SubscriptionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Subscriptions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Subscriptions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Count returned Subscriptions
		 **/
		_count?: true | SubscriptionCountAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the minimum value
		 **/
		_min?: SubscriptionMinAggregateInputType
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
		 *
		 * Select which fields to find the maximum value
		 **/
		_max?: SubscriptionMaxAggregateInputType
	}

	export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
		[P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
			? T[P] extends true
				? number
				: GetScalarType<T[P], AggregateSubscription[P]>
			: GetScalarType<T[P], AggregateSubscription[P]>
	}




	export type SubscriptionGroupByArgs = {
		where?: SubscriptionWhereInput
		orderBy?: Enumerable<SubscriptionOrderByWithAggregationInput>
		by: Array<SubscriptionScalarFieldEnum>
		having?: SubscriptionScalarWhereWithAggregatesInput
		take?: number
		skip?: number
		_count?: SubscriptionCountAggregateInputType | true
		_min?: SubscriptionMinAggregateInputType
		_max?: SubscriptionMaxAggregateInputType
	}


	export type SubscriptionGroupByOutputType = {
		id: string
		createdAt: Date
		updatedAt: Date
		workspaceId: string
		subscriptionPlan: EnumSubscriptionPlan
		status: EnumSubscriptionStatus
		subscriptionData: JsonValue
		cancellationEffectiveDate: Date | null
		_count: SubscriptionCountAggregateOutputType | null
		_min: SubscriptionMinAggregateOutputType | null
		_max: SubscriptionMaxAggregateOutputType | null
	}

	type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = PrismaPromise<
		Array<
			PickArray<SubscriptionGroupByOutputType, T['by']> &
			{
				[P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
				? T[P] extends boolean
					? number
					: GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
				: GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
			}
			>
		>


	export type SubscriptionSelect = {
		id?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		workspaceId?: boolean
		workspace?: boolean | WorkspaceArgs
		subscriptionPlan?: boolean
		status?: boolean
		subscriptionData?: boolean
		cancellationEffectiveDate?: boolean
	}

	export type SubscriptionInclude = {
		workspace?: boolean | WorkspaceArgs
	}

	export type SubscriptionGetPayload<
		S extends boolean | null | undefined | SubscriptionArgs,
		U = keyof S
		> = S extends true
		? Subscription
		: S extends undefined
			? never
			: S extends SubscriptionArgs | SubscriptionFindManyArgs
				?'include' extends U
					? Subscription  & {
					[P in TrueKeys<S['include']>]:
					P extends 'workspace' ? WorkspaceGetPayload<S['include'][P]> :  never
				}
					: 'select' extends U
						? {
							[P in TrueKeys<S['select']>]:
							P extends 'workspace' ? WorkspaceGetPayload<S['select'][P]> :  P extends keyof Subscription ? Subscription[P] : never
						}
						: Subscription
				: Subscription


	type SubscriptionCountArgs = Merge<
		Omit<SubscriptionFindManyArgs, 'select' | 'include'> & {
		select?: SubscriptionCountAggregateInputType | true
	}
		>

	export interface SubscriptionDelegate<GlobalRejectSettings> {
		/**
		 * Find zero or one Subscription that matches the filter.
		 * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
		 * @example
		 * // Get one Subscription
		 * const subscription = await prisma.subscription.findUnique({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findUnique<T extends SubscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args: SelectSubset<T, SubscriptionFindUniqueArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscription'> extends True ? CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__SubscriptionClient<Subscription | null >, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null >>

		/**
		 * Find the first Subscription that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
		 * @example
		 * // Get one Subscription
		 * const subscription = await prisma.subscription.findFirst({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 **/
		findFirst<T extends SubscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
			args?: SelectSubset<T, SubscriptionFindFirstArgs>
		): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscription'> extends True ? CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__SubscriptionClient<Subscription | null >, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null >>

		/**
		 * Find zero or more Subscriptions that matches the filter.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
		 * @example
		 * // Get all Subscriptions
		 * const subscriptions = await prisma.subscription.findMany()
		 *
		 * // Get first 10 Subscriptions
		 * const subscriptions = await prisma.subscription.findMany({ take: 10 })
		 *
		 * // Only select the `id`
		 * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
		 *
		 **/
		findMany<T extends SubscriptionFindManyArgs>(
			args?: SelectSubset<T, SubscriptionFindManyArgs>
		): CheckSelect<T, PrismaPromise<Array<Subscription>>, PrismaPromise<Array<SubscriptionGetPayload<T>>>>

		/**
		 * Create a Subscription.
		 * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
		 * @example
		 * // Create one Subscription
		 * const Subscription = await prisma.subscription.create({
		 *   data: {
		 *     // ... data to create a Subscription
		 *   }
		 * })
		 *
		 **/
		create<T extends SubscriptionCreateArgs>(
			args: SelectSubset<T, SubscriptionCreateArgs>
		): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

		/**
		 * Create many Subscriptions.
		 *     @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
		 *     @example
		 *     // Create many Subscriptions
		 *     const subscription = await prisma.subscription.createMany({
		 *       data: {
		 *         // ... provide data here
		 *       }
		 *     })
		 *
		 **/
		createMany<T extends SubscriptionCreateManyArgs>(
			args?: SelectSubset<T, SubscriptionCreateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Delete a Subscription.
		 * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
		 * @example
		 * // Delete one Subscription
		 * const Subscription = await prisma.subscription.delete({
		 *   where: {
		 *     // ... filter to delete one Subscription
		 *   }
		 * })
		 *
		 **/
		delete<T extends SubscriptionDeleteArgs>(
			args: SelectSubset<T, SubscriptionDeleteArgs>
		): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

		/**
		 * Update one Subscription.
		 * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
		 * @example
		 * // Update one Subscription
		 * const subscription = await prisma.subscription.update({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		update<T extends SubscriptionUpdateArgs>(
			args: SelectSubset<T, SubscriptionUpdateArgs>
		): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

		/**
		 * Delete zero or more Subscriptions.
		 * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
		 * @example
		 * // Delete a few Subscriptions
		 * const { count } = await prisma.subscription.deleteMany({
		 *   where: {
		 *     // ... provide filter here
		 *   }
		 * })
		 *
		 **/
		deleteMany<T extends SubscriptionDeleteManyArgs>(
			args?: SelectSubset<T, SubscriptionDeleteManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Update zero or more Subscriptions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
		 * @example
		 * // Update many Subscriptions
		 * const subscription = await prisma.subscription.updateMany({
		 *   where: {
		 *     // ... provide filter here
		 *   },
		 *   data: {
		 *     // ... provide data here
		 *   }
		 * })
		 *
		 **/
		updateMany<T extends SubscriptionUpdateManyArgs>(
			args: SelectSubset<T, SubscriptionUpdateManyArgs>
		): PrismaPromise<BatchPayload>

		/**
		 * Create or update one Subscription.
		 * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
		 * @example
		 * // Update or create a Subscription
		 * const subscription = await prisma.subscription.upsert({
		 *   create: {
		 *     // ... data to create a Subscription
		 *   },
		 *   update: {
		 *     // ... in case it already exists, update
		 *   },
		 *   where: {
		 *     // ... the filter for the Subscription we want to update
		 *   }
		 * })
		 **/
		upsert<T extends SubscriptionUpsertArgs>(
			args: SelectSubset<T, SubscriptionUpsertArgs>
		): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

		/**
		 * Count the number of Subscriptions.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
		 * @example
		 * // Count the number of Subscriptions
		 * const count = await prisma.subscription.count({
		 *   where: {
		 *     // ... the filter for the Subscriptions we want to count
		 *   }
		 * })
		 **/
		count<T extends SubscriptionCountArgs>(
			args?: Subset<T, SubscriptionCountArgs>,
		): PrismaPromise<
			T extends _Record<'select', any>
				? T['select'] extends true
					? number
					: GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
				: number
			>

		/**
		 * Allows you to perform aggregations operations on a Subscription.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
		 * @example
		 * // Ordered by age ascending
		 * // Where email contains prisma.io
		 * // Limited to the 10 users
		 * const aggregations = await prisma.user.aggregate({
		 *   _avg: {
		 *     age: true,
		 *   },
		 *   where: {
		 *     email: {
		 *       contains: "prisma.io",
		 *     },
		 *   },
		 *   orderBy: {
		 *     age: "asc",
		 *   },
		 *   take: 10,
		 * })
		 **/
		aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): PrismaPromise<GetSubscriptionAggregateType<T>>

		/**
		 * Group by Subscription.
		 * Note, that providing `undefined` is treated as the value not being there.
		 * Read more here: https://pris.ly/d/null-undefined
		 * @param {SubscriptionGroupByArgs} args - Group by arguments.
		 * @example
		 * // Group by city, order by createdAt, get count
		 * const result = await prisma.user.groupBy({
		 *   by: ['city', 'createdAt'],
		 *   orderBy: {
		 *     createdAt: true
		 *   },
		 *   _count: {
		 *     _all: true
		 *   },
		 * })
		 *
		 **/
		groupBy<
			T extends SubscriptionGroupByArgs,
			HasSelectOrTake extends Or<
				Extends<'skip', Keys<T>>,
				Extends<'take', Keys<T>>
				>,
			OrderByArg extends True extends HasSelectOrTake
				? { orderBy: SubscriptionGroupByArgs['orderBy'] }
				: { orderBy?: SubscriptionGroupByArgs['orderBy'] },
			OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
			ByFields extends TupleToUnion<T['by']>,
			ByValid extends Has<ByFields, OrderFields>,
			HavingFields extends GetHavingFields<T['having']>,
			HavingValid extends Has<ByFields, HavingFields>,
			ByEmpty extends T['by'] extends never[] ? True : False,
			InputErrors extends ByEmpty extends True
				? `Error: "by" must not be empty.`
				: HavingValid extends False
					? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
									Error,
									'Field ',
									P,
									` in "having" needs to be provided in "by"`,
								]
					}[HavingFields]
					: 'take' extends Keys<T>
						? 'orderBy' extends Keys<T>
							? ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
							: 'Error: If you provide "take", you also need to provide "orderBy"'
						: 'skip' extends Keys<T>
							? 'orderBy' extends Keys<T>
								? ByValid extends True
									? {}
									: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
								: 'Error: If you provide "skip", you also need to provide "orderBy"'
							: ByValid extends True
								? {}
								: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
			>(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : PrismaPromise<InputErrors>
	}

	/**
	 * The delegate class that acts as a "Promise-like" for Subscription.
	 * Why is this prefixed with `Prisma__`?
	 * Because we want to prevent naming conflicts as mentioned in
	 * https://github.com/prisma/prisma-client-js/issues/707
	 */
	export class Prisma__SubscriptionClient<T> implements PrismaPromise<T> {
		[prisma]: true;
		private readonly _dmmf;
		private readonly _fetcher;
		private readonly _queryType;
		private readonly _rootField;
		private readonly _clientMethod;
		private readonly _args;
		private readonly _dataPath;
		private readonly _errorFormat;
		private readonly _measurePerformance?;
		private _isList;
		private _callsite;
		private _requestPromise?;
		constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
		readonly [Symbol.toStringTag]: 'PrismaClientPromise';

		workspace<T extends WorkspaceArgs = {}>(args?: Subset<T, WorkspaceArgs>): CheckSelect<T, Prisma__WorkspaceClient<Workspace | null >, Prisma__WorkspaceClient<WorkspaceGetPayload<T> | null >>;

		private get _document();
		/**
		 * Attaches callbacks for the resolution and/or rejection of the Promise.
		 * @param onfulfilled The callback to execute when the Promise is resolved.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of which ever callback is executed.
		 */
		then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
		/**
		 * Attaches a callback for only the rejection of the Promise.
		 * @param onrejected The callback to execute when the Promise is rejected.
		 * @returns A Promise for the completion of the callback.
		 */
		catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
		/**
		 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
		 * resolved value cannot be modified from the callback.
		 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
		 * @returns A Promise for the completion of the callback.
		 */
		finally(onfinally?: (() => void) | undefined | null): Promise<T>;
	}

	// Custom InputTypes

	/**
	 * Subscription findUnique
	 */
	export type SubscriptionFindUniqueArgs = {
		/**
		 * Select specific fields to fetch from the Subscription
		 *
		 **/
		select?: SubscriptionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: SubscriptionInclude | null
		/**
		 * Throw an Error if a Subscription can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Subscription to fetch.
		 *
		 **/
		where: SubscriptionWhereUniqueInput
	}


	/**
	 * Subscription findFirst
	 */
	export type SubscriptionFindFirstArgs = {
		/**
		 * Select specific fields to fetch from the Subscription
		 *
		 **/
		select?: SubscriptionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: SubscriptionInclude | null
		/**
		 * Throw an Error if a Subscription can't be found
		 *
		 **/
		rejectOnNotFound?: RejectOnNotFound
		/**
		 * Filter, which Subscription to fetch.
		 *
		 **/
		where?: SubscriptionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Subscriptions to fetch.
		 *
		 **/
		orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for searching for Subscriptions.
		 *
		 **/
		cursor?: SubscriptionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Subscriptions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Subscriptions.
		 *
		 **/
		skip?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
		 *
		 * Filter by unique combinations of Subscriptions.
		 *
		 **/
		distinct?: Enumerable<SubscriptionScalarFieldEnum>
	}


	/**
	 * Subscription findMany
	 */
	export type SubscriptionFindManyArgs = {
		/**
		 * Select specific fields to fetch from the Subscription
		 *
		 **/
		select?: SubscriptionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: SubscriptionInclude | null
		/**
		 * Filter, which Subscriptions to fetch.
		 *
		 **/
		where?: SubscriptionWhereInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
		 *
		 * Determine the order of Subscriptions to fetch.
		 *
		 **/
		orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
		 *
		 * Sets the position for listing Subscriptions.
		 *
		 **/
		cursor?: SubscriptionWhereUniqueInput
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Take `±n` Subscriptions from the position of the cursor.
		 *
		 **/
		take?: number
		/**
		 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
		 *
		 * Skip the first `n` Subscriptions.
		 *
		 **/
		skip?: number
		distinct?: Enumerable<SubscriptionScalarFieldEnum>
	}


	/**
	 * Subscription create
	 */
	export type SubscriptionCreateArgs = {
		/**
		 * Select specific fields to fetch from the Subscription
		 *
		 **/
		select?: SubscriptionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: SubscriptionInclude | null
		/**
		 * The data needed to create a Subscription.
		 *
		 **/
		data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
	}


	/**
	 * Subscription createMany
	 */
	export type SubscriptionCreateManyArgs = {
		/**
		 * The data used to create many Subscriptions.
		 *
		 **/
		data: Enumerable<SubscriptionCreateManyInput>
		skipDuplicates?: boolean
	}


	/**
	 * Subscription update
	 */
	export type SubscriptionUpdateArgs = {
		/**
		 * Select specific fields to fetch from the Subscription
		 *
		 **/
		select?: SubscriptionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: SubscriptionInclude | null
		/**
		 * The data needed to update a Subscription.
		 *
		 **/
		data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
		/**
		 * Choose, which Subscription to update.
		 *
		 **/
		where: SubscriptionWhereUniqueInput
	}


	/**
	 * Subscription updateMany
	 */
	export type SubscriptionUpdateManyArgs = {
		/**
		 * The data used to update Subscriptions.
		 *
		 **/
		data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
		/**
		 * Filter which Subscriptions to update
		 *
		 **/
		where?: SubscriptionWhereInput
	}


	/**
	 * Subscription upsert
	 */
	export type SubscriptionUpsertArgs = {
		/**
		 * Select specific fields to fetch from the Subscription
		 *
		 **/
		select?: SubscriptionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: SubscriptionInclude | null
		/**
		 * The filter to search for the Subscription to update in case it exists.
		 *
		 **/
		where: SubscriptionWhereUniqueInput
		/**
		 * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
		 *
		 **/
		create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
		/**
		 * In case the Subscription was found with the provided `where` argument, update it with this data.
		 *
		 **/
		update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
	}


	/**
	 * Subscription delete
	 */
	export type SubscriptionDeleteArgs = {
		/**
		 * Select specific fields to fetch from the Subscription
		 *
		 **/
		select?: SubscriptionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: SubscriptionInclude | null
		/**
		 * Filter which Subscription to delete.
		 *
		 **/
		where: SubscriptionWhereUniqueInput
	}


	/**
	 * Subscription deleteMany
	 */
	export type SubscriptionDeleteManyArgs = {
		/**
		 * Filter which Subscriptions to delete
		 *
		 **/
		where?: SubscriptionWhereInput
	}


	/**
	 * Subscription without action
	 */
	export type SubscriptionArgs = {
		/**
		 * Select specific fields to fetch from the Subscription
		 *
		 **/
		select?: SubscriptionSelect | null
		/**
		 * Choose, which related nodes to fetch as well.
		 *
		 **/
		include?: SubscriptionInclude | null
	}



	/**
	 * Enums
	 */

		// Based on
		// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

	export const AccountScalarFieldEnum: {
			id: 'id',
			createdAt: 'createdAt',
			updatedAt: 'updatedAt',
			email: 'email',
			firstName: 'firstName',
			lastName: 'lastName',
			password: 'password',
			currentUserId: 'currentUserId',
			githubId: 'githubId'
		};

	export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


	export const WorkspaceScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		name: 'name'
	};

	export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


	export const ProjectScalarFieldEnum: {
		id: 'id',
		name: 'name',
		workspaceId: 'workspaceId',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		deletedAt: 'deletedAt'
	};

	export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


	export const GitOrganizationScalarFieldEnum: {
		id: 'id',
		provider: 'provider',
		name: 'name',
		installationId: 'installationId',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		workspaceId: 'workspaceId',
		type: 'type'
	};

	export type GitOrganizationScalarFieldEnum = (typeof GitOrganizationScalarFieldEnum)[keyof typeof GitOrganizationScalarFieldEnum]


	export const GitRepositoryScalarFieldEnum: {
		id: 'id',
		name: 'name',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		gitOrganizationId: 'gitOrganizationId'
	};

	export type GitRepositoryScalarFieldEnum = (typeof GitRepositoryScalarFieldEnum)[keyof typeof GitRepositoryScalarFieldEnum]


	export const UserScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		accountId: 'accountId',
		workspaceId: 'workspaceId',
		isOwner: 'isOwner',
		deletedAt: 'deletedAt'
	};

	export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


	export const UserRoleScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		userId: 'userId',
		role: 'role'
	};

	export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


	export const ApiTokenScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		name: 'name',
		userId: 'userId',
		token: 'token',
		previewChars: 'previewChars',
		lastAccessAt: 'lastAccessAt'
	};

	export type ApiTokenScalarFieldEnum = (typeof ApiTokenScalarFieldEnum)[keyof typeof ApiTokenScalarFieldEnum]


	export const ResourceScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		name: 'name',
		description: 'description',
		gitRepositoryOverride: 'gitRepositoryOverride',
		githubLastSync: 'githubLastSync',
		githubLastMessage: 'githubLastMessage',
		deletedAt: 'deletedAt',
		gitRepositoryId: 'gitRepositoryId',
		projectId: 'projectId',
		resourceType: 'resourceType'
	};

	export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


	export const ResourceRoleScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		resourceId: 'resourceId',
		name: 'name',
		displayName: 'displayName',
		description: 'description'
	};

	export type ResourceRoleScalarFieldEnum = (typeof ResourceRoleScalarFieldEnum)[keyof typeof ResourceRoleScalarFieldEnum]


	export const CommitScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		userId: 'userId',
		message: 'message',
		projectId: 'projectId'
	};

	export type CommitScalarFieldEnum = (typeof CommitScalarFieldEnum)[keyof typeof CommitScalarFieldEnum]


	export const EntityScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		resourceId: 'resourceId',
		name: 'name',
		displayName: 'displayName',
		pluralDisplayName: 'pluralDisplayName',
		description: 'description',
		lockedByUserId: 'lockedByUserId',
		lockedAt: 'lockedAt',
		deletedAt: 'deletedAt'
	};

	export type EntityScalarFieldEnum = (typeof EntityScalarFieldEnum)[keyof typeof EntityScalarFieldEnum]


	export const EntityVersionScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		entityId: 'entityId',
		versionNumber: 'versionNumber',
		name: 'name',
		displayName: 'displayName',
		pluralDisplayName: 'pluralDisplayName',
		description: 'description',
		commitId: 'commitId',
		deleted: 'deleted'
	};

	export type EntityVersionScalarFieldEnum = (typeof EntityVersionScalarFieldEnum)[keyof typeof EntityVersionScalarFieldEnum]


	export const EntityPermissionScalarFieldEnum: {
		id: 'id',
		entityVersionId: 'entityVersionId',
		action: 'action',
		type: 'type'
	};

	export type EntityPermissionScalarFieldEnum = (typeof EntityPermissionScalarFieldEnum)[keyof typeof EntityPermissionScalarFieldEnum]


	export const EntityPermissionRoleScalarFieldEnum: {
		id: 'id',
		entityVersionId: 'entityVersionId',
		action: 'action',
		resourceRoleId: 'resourceRoleId'
	};

	export type EntityPermissionRoleScalarFieldEnum = (typeof EntityPermissionRoleScalarFieldEnum)[keyof typeof EntityPermissionRoleScalarFieldEnum]


	export const EntityPermissionFieldScalarFieldEnum: {
		id: 'id',
		permissionId: 'permissionId',
		fieldPermanentId: 'fieldPermanentId',
		entityVersionId: 'entityVersionId'
	};

	export type EntityPermissionFieldScalarFieldEnum = (typeof EntityPermissionFieldScalarFieldEnum)[keyof typeof EntityPermissionFieldScalarFieldEnum]


	export const EntityFieldScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		entityVersionId: 'entityVersionId',
		permanentId: 'permanentId',
		name: 'name',
		displayName: 'displayName',
		dataType: 'dataType',
		properties: 'properties',
		required: 'required',
		searchable: 'searchable',
		description: 'description',
		position: 'position',
		unique: 'unique'
	};

	export type EntityFieldScalarFieldEnum = (typeof EntityFieldScalarFieldEnum)[keyof typeof EntityFieldScalarFieldEnum]


	export const BlockScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		resourceId: 'resourceId',
		parentBlockId: 'parentBlockId',
		blockType: 'blockType',
		displayName: 'displayName',
		description: 'description',
		lockedByUserId: 'lockedByUserId',
		lockedAt: 'lockedAt',
		deletedAt: 'deletedAt'
	};

	export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


	export const BlockVersionScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		blockId: 'blockId',
		versionNumber: 'versionNumber',
		inputParameters: 'inputParameters',
		outputParameters: 'outputParameters',
		settings: 'settings',
		displayName: 'displayName',
		description: 'description',
		commitId: 'commitId',
		deleted: 'deleted'
	};

	export type BlockVersionScalarFieldEnum = (typeof BlockVersionScalarFieldEnum)[keyof typeof BlockVersionScalarFieldEnum]


	export const ActionScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt'
	};

	export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


	export const ActionStepScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		message: 'message',
		status: 'status',
		completedAt: 'completedAt',
		actionId: 'actionId',
		name: 'name'
	};

	export type ActionStepScalarFieldEnum = (typeof ActionStepScalarFieldEnum)[keyof typeof ActionStepScalarFieldEnum]


	export const ActionLogScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		message: 'message',
		meta: 'meta',
		level: 'level',
		stepId: 'stepId'
	};

	export type ActionLogScalarFieldEnum = (typeof ActionLogScalarFieldEnum)[keyof typeof ActionLogScalarFieldEnum]


	export const BuildScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		resourceId: 'resourceId',
		userId: 'userId',
		version: 'version',
		message: 'message',
		actionId: 'actionId',
		images: 'images',
		containerStatusQuery: 'containerStatusQuery',
		containerStatusUpdatedAt: 'containerStatusUpdatedAt',
		commitId: 'commitId'
	};

	export type BuildScalarFieldEnum = (typeof BuildScalarFieldEnum)[keyof typeof BuildScalarFieldEnum]


	export const ReleaseScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		version: 'version',
		description: 'description',
		commitId: 'commitId'
	};

	export type ReleaseScalarFieldEnum = (typeof ReleaseScalarFieldEnum)[keyof typeof ReleaseScalarFieldEnum]


	export const EnvironmentScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		resourceId: 'resourceId',
		name: 'name',
		description: 'description',
		address: 'address'
	};

	export type EnvironmentScalarFieldEnum = (typeof EnvironmentScalarFieldEnum)[keyof typeof EnvironmentScalarFieldEnum]


	export const DeploymentScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		userId: 'userId',
		buildId: 'buildId',
		environmentId: 'environmentId',
		status: 'status',
		message: 'message',
		actionId: 'actionId',
		statusQuery: 'statusQuery',
		statusUpdatedAt: 'statusUpdatedAt'
	};

	export type DeploymentScalarFieldEnum = (typeof DeploymentScalarFieldEnum)[keyof typeof DeploymentScalarFieldEnum]


	export const InvitationScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		email: 'email',
		invitedByUserId: 'invitedByUserId',
		workspaceId: 'workspaceId',
		newUserId: 'newUserId',
		token: 'token',
		tokenExpiration: 'tokenExpiration'
	};

	export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


	export const SubscriptionScalarFieldEnum: {
		id: 'id',
		createdAt: 'createdAt',
		updatedAt: 'updatedAt',
		workspaceId: 'workspaceId',
		subscriptionPlan: 'subscriptionPlan',
		status: 'status',
		subscriptionData: 'subscriptionData',
		cancellationEffectiveDate: 'cancellationEffectiveDate'
	};

	export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


	export const SortOrder: {
		asc: 'asc',
		desc: 'desc'
	};

	export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


	export const JsonNullValueInput: {
		JsonNull: 'JsonNull'
	};

	export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


	export const NullableJsonNullValueInput: {
		DbNull: 'DbNull',
		JsonNull: 'JsonNull'
	};

	export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


	export const QueryMode: {
		default: 'default',
		insensitive: 'insensitive'
	};

	export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


	export const JsonNullValueFilter: {
		DbNull: 'DbNull',
		JsonNull: 'JsonNull',
		AnyNull: 'AnyNull'
	};

	export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


	/**
	 * Deep Input Types
	 */


	export type AccountWhereInput = {
		AND?: Enumerable<AccountWhereInput>
		OR?: Enumerable<AccountWhereInput>
		NOT?: Enumerable<AccountWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		email?: StringFilter | string
		firstName?: StringFilter | string
		lastName?: StringFilter | string
		password?: StringFilter | string
		currentUserId?: StringNullableFilter | string | null
		githubId?: StringNullableFilter | string | null
		currentUser?: XOR<UserRelationFilter, UserWhereInput> | null
		users?: UserListRelationFilter
	}

	export type AccountOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		password?: SortOrder
		currentUserId?: SortOrder
		githubId?: SortOrder
		currentUser?: UserOrderByWithRelationInput
		users?: UserOrderByRelationAggregateInput
	}

	export type AccountWhereUniqueInput = {
		id?: string
		email?: string
		currentUserId?: string
	}

	export type AccountOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		password?: SortOrder
		currentUserId?: SortOrder
		githubId?: SortOrder
		_count?: AccountCountOrderByAggregateInput
		_max?: AccountMaxOrderByAggregateInput
		_min?: AccountMinOrderByAggregateInput
	}

	export type AccountScalarWhereWithAggregatesInput = {
		AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
		OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
		NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		email?: StringWithAggregatesFilter | string
		firstName?: StringWithAggregatesFilter | string
		lastName?: StringWithAggregatesFilter | string
		password?: StringWithAggregatesFilter | string
		currentUserId?: StringNullableWithAggregatesFilter | string | null
		githubId?: StringNullableWithAggregatesFilter | string | null
	}

	export type WorkspaceWhereInput = {
		AND?: Enumerable<WorkspaceWhereInput>
		OR?: Enumerable<WorkspaceWhereInput>
		NOT?: Enumerable<WorkspaceWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		name?: StringFilter | string
		users?: UserListRelationFilter
		invitations?: InvitationListRelationFilter
		subscriptions?: SubscriptionListRelationFilter
		gitOrganizations?: GitOrganizationListRelationFilter
		projects?: ProjectListRelationFilter
	}

	export type WorkspaceOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		users?: UserOrderByRelationAggregateInput
		invitations?: InvitationOrderByRelationAggregateInput
		subscriptions?: SubscriptionOrderByRelationAggregateInput
		gitOrganizations?: GitOrganizationOrderByRelationAggregateInput
		projects?: ProjectOrderByRelationAggregateInput
	}

	export type WorkspaceWhereUniqueInput = {
		id?: string
		name?: string
	}

	export type WorkspaceOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		_count?: WorkspaceCountOrderByAggregateInput
		_max?: WorkspaceMaxOrderByAggregateInput
		_min?: WorkspaceMinOrderByAggregateInput
	}

	export type WorkspaceScalarWhereWithAggregatesInput = {
		AND?: Enumerable<WorkspaceScalarWhereWithAggregatesInput>
		OR?: Enumerable<WorkspaceScalarWhereWithAggregatesInput>
		NOT?: Enumerable<WorkspaceScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		name?: StringWithAggregatesFilter | string
	}

	export type ProjectWhereInput = {
		AND?: Enumerable<ProjectWhereInput>
		OR?: Enumerable<ProjectWhereInput>
		NOT?: Enumerable<ProjectWhereInput>
		id?: StringFilter | string
		name?: StringFilter | string
		workspaceId?: StringFilter | string
		workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
		resources?: ResourceListRelationFilter
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		deletedAt?: DateTimeNullableFilter | Date | string | null
		commits?: CommitListRelationFilter
	}

	export type ProjectOrderByWithRelationInput = {
		id?: SortOrder
		name?: SortOrder
		workspaceId?: SortOrder
		workspace?: WorkspaceOrderByWithRelationInput
		resources?: ResourceOrderByRelationAggregateInput
		createdAt?: SortOrder
		updatedAt?: SortOrder
		deletedAt?: SortOrder
		commits?: CommitOrderByRelationAggregateInput
	}

	export type ProjectWhereUniqueInput = {
		id?: string
		workspaceId_name?: ProjectWorkspaceIdNameCompoundUniqueInput
	}

	export type ProjectOrderByWithAggregationInput = {
		id?: SortOrder
		name?: SortOrder
		workspaceId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		deletedAt?: SortOrder
		_count?: ProjectCountOrderByAggregateInput
		_max?: ProjectMaxOrderByAggregateInput
		_min?: ProjectMinOrderByAggregateInput
	}

	export type ProjectScalarWhereWithAggregatesInput = {
		AND?: Enumerable<ProjectScalarWhereWithAggregatesInput>
		OR?: Enumerable<ProjectScalarWhereWithAggregatesInput>
		NOT?: Enumerable<ProjectScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		name?: StringWithAggregatesFilter | string
		workspaceId?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
	}

	export type GitOrganizationWhereInput = {
		AND?: Enumerable<GitOrganizationWhereInput>
		OR?: Enumerable<GitOrganizationWhereInput>
		NOT?: Enumerable<GitOrganizationWhereInput>
		id?: StringFilter | string
		provider?: EnumEnumGitProviderFilter | EnumGitProvider
		name?: StringFilter | string
		installationId?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		workspaceId?: StringFilter | string
		type?: EnumEnumGitOrganizationTypeNullableFilter | EnumGitOrganizationType | null
		workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
		gitRepositories?: GitRepositoryListRelationFilter
	}

	export type GitOrganizationOrderByWithRelationInput = {
		id?: SortOrder
		provider?: SortOrder
		name?: SortOrder
		installationId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		type?: SortOrder
		workspace?: WorkspaceOrderByWithRelationInput
		gitRepositories?: GitRepositoryOrderByRelationAggregateInput
	}

	export type GitOrganizationWhereUniqueInput = {
		id?: string
		provider_installationId?: GitOrganizationProviderInstallationIdCompoundUniqueInput
	}

	export type GitOrganizationOrderByWithAggregationInput = {
		id?: SortOrder
		provider?: SortOrder
		name?: SortOrder
		installationId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		type?: SortOrder
		_count?: GitOrganizationCountOrderByAggregateInput
		_max?: GitOrganizationMaxOrderByAggregateInput
		_min?: GitOrganizationMinOrderByAggregateInput
	}

	export type GitOrganizationScalarWhereWithAggregatesInput = {
		AND?: Enumerable<GitOrganizationScalarWhereWithAggregatesInput>
		OR?: Enumerable<GitOrganizationScalarWhereWithAggregatesInput>
		NOT?: Enumerable<GitOrganizationScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		provider?: EnumEnumGitProviderWithAggregatesFilter | EnumGitProvider
		name?: StringWithAggregatesFilter | string
		installationId?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		workspaceId?: StringWithAggregatesFilter | string
		type?: EnumEnumGitOrganizationTypeNullableWithAggregatesFilter | EnumGitOrganizationType | null
	}

	export type GitRepositoryWhereInput = {
		AND?: Enumerable<GitRepositoryWhereInput>
		OR?: Enumerable<GitRepositoryWhereInput>
		NOT?: Enumerable<GitRepositoryWhereInput>
		id?: StringFilter | string
		name?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		gitOrganizationId?: StringFilter | string
		resources?: ResourceListRelationFilter
		gitOrganization?: XOR<GitOrganizationRelationFilter, GitOrganizationWhereInput>
	}

	export type GitRepositoryOrderByWithRelationInput = {
		id?: SortOrder
		name?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		gitOrganizationId?: SortOrder
		resources?: ResourceOrderByRelationAggregateInput
		gitOrganization?: GitOrganizationOrderByWithRelationInput
	}

	export type GitRepositoryWhereUniqueInput = {
		id?: string
	}

	export type GitRepositoryOrderByWithAggregationInput = {
		id?: SortOrder
		name?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		gitOrganizationId?: SortOrder
		_count?: GitRepositoryCountOrderByAggregateInput
		_max?: GitRepositoryMaxOrderByAggregateInput
		_min?: GitRepositoryMinOrderByAggregateInput
	}

	export type GitRepositoryScalarWhereWithAggregatesInput = {
		AND?: Enumerable<GitRepositoryScalarWhereWithAggregatesInput>
		OR?: Enumerable<GitRepositoryScalarWhereWithAggregatesInput>
		NOT?: Enumerable<GitRepositoryScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		name?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		gitOrganizationId?: StringWithAggregatesFilter | string
	}

	export type UserWhereInput = {
		AND?: Enumerable<UserWhereInput>
		OR?: Enumerable<UserWhereInput>
		NOT?: Enumerable<UserWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		accountId?: StringFilter | string
		workspaceId?: StringFilter | string
		isOwner?: BoolFilter | boolean
		account?: XOR<AccountRelationFilter, AccountWhereInput>
		workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
		assignedCurrentTo?: XOR<AccountRelationFilter, AccountWhereInput> | null
		apiTokens?: ApiTokenListRelationFilter
		lockedBlocks?: BlockListRelationFilter
		builds?: BuildListRelationFilter
		commits?: CommitListRelationFilter
		deployments?: DeploymentListRelationFilter
		lockedEntitis?: EntityListRelationFilter
		userRoles?: UserRoleListRelationFilter
		sentInvitations?: InvitationListRelationFilter
		createdFromInvitation?: XOR<InvitationRelationFilter, InvitationWhereInput> | null
		deletedAt?: DateTimeNullableFilter | Date | string | null
	}

	export type UserOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		accountId?: SortOrder
		workspaceId?: SortOrder
		isOwner?: SortOrder
		account?: AccountOrderByWithRelationInput
		workspace?: WorkspaceOrderByWithRelationInput
		assignedCurrentTo?: AccountOrderByWithRelationInput
		apiTokens?: ApiTokenOrderByRelationAggregateInput
		lockedBlocks?: BlockOrderByRelationAggregateInput
		builds?: BuildOrderByRelationAggregateInput
		commits?: CommitOrderByRelationAggregateInput
		deployments?: DeploymentOrderByRelationAggregateInput
		lockedEntitis?: EntityOrderByRelationAggregateInput
		userRoles?: UserRoleOrderByRelationAggregateInput
		sentInvitations?: InvitationOrderByRelationAggregateInput
		createdFromInvitation?: InvitationOrderByWithRelationInput
		deletedAt?: SortOrder
	}

	export type UserWhereUniqueInput = {
		id?: string
		accountId_workspaceId?: UserAccountIdWorkspaceIdCompoundUniqueInput
	}

	export type UserOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		accountId?: SortOrder
		workspaceId?: SortOrder
		isOwner?: SortOrder
		deletedAt?: SortOrder
		_count?: UserCountOrderByAggregateInput
		_max?: UserMaxOrderByAggregateInput
		_min?: UserMinOrderByAggregateInput
	}

	export type UserScalarWhereWithAggregatesInput = {
		AND?: Enumerable<UserScalarWhereWithAggregatesInput>
		OR?: Enumerable<UserScalarWhereWithAggregatesInput>
		NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		accountId?: StringWithAggregatesFilter | string
		workspaceId?: StringWithAggregatesFilter | string
		isOwner?: BoolWithAggregatesFilter | boolean
		deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
	}

	export type UserRoleWhereInput = {
		AND?: Enumerable<UserRoleWhereInput>
		OR?: Enumerable<UserRoleWhereInput>
		NOT?: Enumerable<UserRoleWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		userId?: StringFilter | string
		role?: StringFilter | string
		user?: XOR<UserRelationFilter, UserWhereInput>
	}

	export type UserRoleOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		userId?: SortOrder
		role?: SortOrder
		user?: UserOrderByWithRelationInput
	}

	export type UserRoleWhereUniqueInput = {
		id?: string
		userId_role?: UserRoleUserIdRoleCompoundUniqueInput
	}

	export type UserRoleOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		userId?: SortOrder
		role?: SortOrder
		_count?: UserRoleCountOrderByAggregateInput
		_max?: UserRoleMaxOrderByAggregateInput
		_min?: UserRoleMinOrderByAggregateInput
	}

	export type UserRoleScalarWhereWithAggregatesInput = {
		AND?: Enumerable<UserRoleScalarWhereWithAggregatesInput>
		OR?: Enumerable<UserRoleScalarWhereWithAggregatesInput>
		NOT?: Enumerable<UserRoleScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		userId?: StringWithAggregatesFilter | string
		role?: StringWithAggregatesFilter | string
	}

	export type ApiTokenWhereInput = {
		AND?: Enumerable<ApiTokenWhereInput>
		OR?: Enumerable<ApiTokenWhereInput>
		NOT?: Enumerable<ApiTokenWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		name?: StringFilter | string
		userId?: StringFilter | string
		token?: StringFilter | string
		previewChars?: StringFilter | string
		lastAccessAt?: DateTimeFilter | Date | string
		user?: XOR<UserRelationFilter, UserWhereInput>
	}

	export type ApiTokenOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		userId?: SortOrder
		token?: SortOrder
		previewChars?: SortOrder
		lastAccessAt?: SortOrder
		user?: UserOrderByWithRelationInput
	}

	export type ApiTokenWhereUniqueInput = {
		id?: string
		userId_name?: ApiTokenUserIdNameCompoundUniqueInput
	}

	export type ApiTokenOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		userId?: SortOrder
		token?: SortOrder
		previewChars?: SortOrder
		lastAccessAt?: SortOrder
		_count?: ApiTokenCountOrderByAggregateInput
		_max?: ApiTokenMaxOrderByAggregateInput
		_min?: ApiTokenMinOrderByAggregateInput
	}

	export type ApiTokenScalarWhereWithAggregatesInput = {
		AND?: Enumerable<ApiTokenScalarWhereWithAggregatesInput>
		OR?: Enumerable<ApiTokenScalarWhereWithAggregatesInput>
		NOT?: Enumerable<ApiTokenScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		name?: StringWithAggregatesFilter | string
		userId?: StringWithAggregatesFilter | string
		token?: StringWithAggregatesFilter | string
		previewChars?: StringWithAggregatesFilter | string
		lastAccessAt?: DateTimeWithAggregatesFilter | Date | string
	}

	export type ResourceWhereInput = {
		AND?: Enumerable<ResourceWhereInput>
		OR?: Enumerable<ResourceWhereInput>
		NOT?: Enumerable<ResourceWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		name?: StringFilter | string
		description?: StringFilter | string
		gitRepositoryOverride?: BoolFilter | boolean
		githubLastSync?: DateTimeNullableFilter | Date | string | null
		githubLastMessage?: StringNullableFilter | string | null
		deletedAt?: DateTimeNullableFilter | Date | string | null
		gitRepositoryId?: StringNullableFilter | string | null
		roles?: ResourceRoleListRelationFilter
		blocks?: BlockListRelationFilter
		builds?: BuildListRelationFilter
		entities?: EntityListRelationFilter
		environments?: EnvironmentListRelationFilter
		gitRepository?: XOR<GitRepositoryRelationFilter, GitRepositoryWhereInput> | null
		projectId?: StringFilter | string
		project?: XOR<ProjectRelationFilter, ProjectWhereInput>
		resourceType?: EnumEnumResourceTypeFilter | EnumResourceType
	}

	export type ResourceOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		description?: SortOrder
		gitRepositoryOverride?: SortOrder
		githubLastSync?: SortOrder
		githubLastMessage?: SortOrder
		deletedAt?: SortOrder
		gitRepositoryId?: SortOrder
		roles?: ResourceRoleOrderByRelationAggregateInput
		blocks?: BlockOrderByRelationAggregateInput
		builds?: BuildOrderByRelationAggregateInput
		entities?: EntityOrderByRelationAggregateInput
		environments?: EnvironmentOrderByRelationAggregateInput
		gitRepository?: GitRepositoryOrderByWithRelationInput
		projectId?: SortOrder
		project?: ProjectOrderByWithRelationInput
		resourceType?: SortOrder
	}

	export type ResourceWhereUniqueInput = {
		id?: string
		projectId_name?: ResourceProjectIdNameCompoundUniqueInput
	}

	export type ResourceOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		description?: SortOrder
		gitRepositoryOverride?: SortOrder
		githubLastSync?: SortOrder
		githubLastMessage?: SortOrder
		deletedAt?: SortOrder
		gitRepositoryId?: SortOrder
		projectId?: SortOrder
		resourceType?: SortOrder
		_count?: ResourceCountOrderByAggregateInput
		_max?: ResourceMaxOrderByAggregateInput
		_min?: ResourceMinOrderByAggregateInput
	}

	export type ResourceScalarWhereWithAggregatesInput = {
		AND?: Enumerable<ResourceScalarWhereWithAggregatesInput>
		OR?: Enumerable<ResourceScalarWhereWithAggregatesInput>
		NOT?: Enumerable<ResourceScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		name?: StringWithAggregatesFilter | string
		description?: StringWithAggregatesFilter | string
		gitRepositoryOverride?: BoolWithAggregatesFilter | boolean
		githubLastSync?: DateTimeNullableWithAggregatesFilter | Date | string | null
		githubLastMessage?: StringNullableWithAggregatesFilter | string | null
		deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
		gitRepositoryId?: StringNullableWithAggregatesFilter | string | null
		projectId?: StringWithAggregatesFilter | string
		resourceType?: EnumEnumResourceTypeWithAggregatesFilter | EnumResourceType
	}

	export type ResourceRoleWhereInput = {
		AND?: Enumerable<ResourceRoleWhereInput>
		OR?: Enumerable<ResourceRoleWhereInput>
		NOT?: Enumerable<ResourceRoleWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		name?: StringFilter | string
		displayName?: StringFilter | string
		description?: StringNullableFilter | string | null
		resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
		entityPermissionRoles?: EntityPermissionRoleListRelationFilter
	}

	export type ResourceRoleOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		resource?: ResourceOrderByWithRelationInput
		entityPermissionRoles?: EntityPermissionRoleOrderByRelationAggregateInput
	}

	export type ResourceRoleWhereUniqueInput = {
		id?: string
		resourceId_displayName?: ResourceRoleResourceIdDisplayNameCompoundUniqueInput
		resourceId_name?: ResourceRoleResourceIdNameCompoundUniqueInput
	}

	export type ResourceRoleOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		_count?: ResourceRoleCountOrderByAggregateInput
		_max?: ResourceRoleMaxOrderByAggregateInput
		_min?: ResourceRoleMinOrderByAggregateInput
	}

	export type ResourceRoleScalarWhereWithAggregatesInput = {
		AND?: Enumerable<ResourceRoleScalarWhereWithAggregatesInput>
		OR?: Enumerable<ResourceRoleScalarWhereWithAggregatesInput>
		NOT?: Enumerable<ResourceRoleScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		resourceId?: StringWithAggregatesFilter | string
		name?: StringWithAggregatesFilter | string
		displayName?: StringWithAggregatesFilter | string
		description?: StringNullableWithAggregatesFilter | string | null
	}

	export type CommitWhereInput = {
		AND?: Enumerable<CommitWhereInput>
		OR?: Enumerable<CommitWhereInput>
		NOT?: Enumerable<CommitWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		userId?: StringFilter | string
		message?: StringFilter | string
		user?: XOR<UserRelationFilter, UserWhereInput>
		blockVersions?: BlockVersionListRelationFilter
		builds?: BuildListRelationFilter
		entityVersions?: EntityVersionListRelationFilter
		releases?: ReleaseListRelationFilter
		project?: XOR<ProjectRelationFilter, ProjectWhereInput>
		projectId?: StringFilter | string
	}

	export type CommitOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		message?: SortOrder
		user?: UserOrderByWithRelationInput
		blockVersions?: BlockVersionOrderByRelationAggregateInput
		builds?: BuildOrderByRelationAggregateInput
		entityVersions?: EntityVersionOrderByRelationAggregateInput
		releases?: ReleaseOrderByRelationAggregateInput
		project?: ProjectOrderByWithRelationInput
		projectId?: SortOrder
	}

	export type CommitWhereUniqueInput = {
		id?: string
	}

	export type CommitOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		message?: SortOrder
		projectId?: SortOrder
		_count?: CommitCountOrderByAggregateInput
		_max?: CommitMaxOrderByAggregateInput
		_min?: CommitMinOrderByAggregateInput
	}

	export type CommitScalarWhereWithAggregatesInput = {
		AND?: Enumerable<CommitScalarWhereWithAggregatesInput>
		OR?: Enumerable<CommitScalarWhereWithAggregatesInput>
		NOT?: Enumerable<CommitScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		userId?: StringWithAggregatesFilter | string
		message?: StringWithAggregatesFilter | string
		projectId?: StringWithAggregatesFilter | string
	}

	export type EntityWhereInput = {
		AND?: Enumerable<EntityWhereInput>
		OR?: Enumerable<EntityWhereInput>
		NOT?: Enumerable<EntityWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		name?: StringFilter | string
		displayName?: StringFilter | string
		pluralDisplayName?: StringFilter | string
		description?: StringNullableFilter | string | null
		lockedByUserId?: StringNullableFilter | string | null
		lockedAt?: DateTimeNullableFilter | Date | string | null
		deletedAt?: DateTimeNullableFilter | Date | string | null
		resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
		lockedByUser?: XOR<UserRelationFilter, UserWhereInput> | null
		versions?: EntityVersionListRelationFilter
	}

	export type EntityOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
		resource?: ResourceOrderByWithRelationInput
		lockedByUser?: UserOrderByWithRelationInput
		versions?: EntityVersionOrderByRelationAggregateInput
	}

	export type EntityWhereUniqueInput = {
		id?: string
		resourceId_displayName?: EntityResourceIdDisplayNameCompoundUniqueInput
		resourceId_name?: EntityResourceIdNameCompoundUniqueInput
		resourceId_pluralDisplayName?: EntityResourceIdPluralDisplayNameCompoundUniqueInput
	}

	export type EntityOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
		_count?: EntityCountOrderByAggregateInput
		_max?: EntityMaxOrderByAggregateInput
		_min?: EntityMinOrderByAggregateInput
	}

	export type EntityScalarWhereWithAggregatesInput = {
		AND?: Enumerable<EntityScalarWhereWithAggregatesInput>
		OR?: Enumerable<EntityScalarWhereWithAggregatesInput>
		NOT?: Enumerable<EntityScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		resourceId?: StringWithAggregatesFilter | string
		name?: StringWithAggregatesFilter | string
		displayName?: StringWithAggregatesFilter | string
		pluralDisplayName?: StringWithAggregatesFilter | string
		description?: StringNullableWithAggregatesFilter | string | null
		lockedByUserId?: StringNullableWithAggregatesFilter | string | null
		lockedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
		deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
	}

	export type EntityVersionWhereInput = {
		AND?: Enumerable<EntityVersionWhereInput>
		OR?: Enumerable<EntityVersionWhereInput>
		NOT?: Enumerable<EntityVersionWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		entityId?: StringFilter | string
		versionNumber?: IntFilter | number
		name?: StringFilter | string
		displayName?: StringFilter | string
		pluralDisplayName?: StringFilter | string
		description?: StringNullableFilter | string | null
		commitId?: StringNullableFilter | string | null
		deleted?: BoolNullableFilter | boolean | null
		commit?: XOR<CommitRelationFilter, CommitWhereInput> | null
		entity?: XOR<EntityRelationFilter, EntityWhereInput>
		fields?: EntityFieldListRelationFilter
		permissions?: EntityPermissionListRelationFilter
		builds?: BuildListRelationFilter
	}

	export type EntityVersionOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityId?: SortOrder
		versionNumber?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
		commit?: CommitOrderByWithRelationInput
		entity?: EntityOrderByWithRelationInput
		fields?: EntityFieldOrderByRelationAggregateInput
		permissions?: EntityPermissionOrderByRelationAggregateInput
		builds?: BuildOrderByRelationAggregateInput
	}

	export type EntityVersionWhereUniqueInput = {
		id?: string
		entityId_versionNumber?: EntityVersionEntityIdVersionNumberCompoundUniqueInput
	}

	export type EntityVersionOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityId?: SortOrder
		versionNumber?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
		_count?: EntityVersionCountOrderByAggregateInput
		_avg?: EntityVersionAvgOrderByAggregateInput
		_max?: EntityVersionMaxOrderByAggregateInput
		_min?: EntityVersionMinOrderByAggregateInput
		_sum?: EntityVersionSumOrderByAggregateInput
	}

	export type EntityVersionScalarWhereWithAggregatesInput = {
		AND?: Enumerable<EntityVersionScalarWhereWithAggregatesInput>
		OR?: Enumerable<EntityVersionScalarWhereWithAggregatesInput>
		NOT?: Enumerable<EntityVersionScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		entityId?: StringWithAggregatesFilter | string
		versionNumber?: IntWithAggregatesFilter | number
		name?: StringWithAggregatesFilter | string
		displayName?: StringWithAggregatesFilter | string
		pluralDisplayName?: StringWithAggregatesFilter | string
		description?: StringNullableWithAggregatesFilter | string | null
		commitId?: StringNullableWithAggregatesFilter | string | null
		deleted?: BoolNullableWithAggregatesFilter | boolean | null
	}

	export type EntityPermissionWhereInput = {
		AND?: Enumerable<EntityPermissionWhereInput>
		OR?: Enumerable<EntityPermissionWhereInput>
		NOT?: Enumerable<EntityPermissionWhereInput>
		id?: StringFilter | string
		entityVersionId?: StringFilter | string
		action?: EnumEnumEntityActionFilter | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFilter | EnumEntityPermissionType
		entityVersion?: XOR<EntityVersionRelationFilter, EntityVersionWhereInput>
		permissionFields?: EntityPermissionFieldListRelationFilter
		permissionRoles?: EntityPermissionRoleListRelationFilter
	}

	export type EntityPermissionOrderByWithRelationInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		type?: SortOrder
		entityVersion?: EntityVersionOrderByWithRelationInput
		permissionFields?: EntityPermissionFieldOrderByRelationAggregateInput
		permissionRoles?: EntityPermissionRoleOrderByRelationAggregateInput
	}

	export type EntityPermissionWhereUniqueInput = {
		id?: string
		entityVersionId_action?: EntityPermissionEntityVersionIdActionCompoundUniqueInput
	}

	export type EntityPermissionOrderByWithAggregationInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		type?: SortOrder
		_count?: EntityPermissionCountOrderByAggregateInput
		_max?: EntityPermissionMaxOrderByAggregateInput
		_min?: EntityPermissionMinOrderByAggregateInput
	}

	export type EntityPermissionScalarWhereWithAggregatesInput = {
		AND?: Enumerable<EntityPermissionScalarWhereWithAggregatesInput>
		OR?: Enumerable<EntityPermissionScalarWhereWithAggregatesInput>
		NOT?: Enumerable<EntityPermissionScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		entityVersionId?: StringWithAggregatesFilter | string
		action?: EnumEnumEntityActionWithAggregatesFilter | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeWithAggregatesFilter | EnumEntityPermissionType
	}

	export type EntityPermissionRoleWhereInput = {
		AND?: Enumerable<EntityPermissionRoleWhereInput>
		OR?: Enumerable<EntityPermissionRoleWhereInput>
		NOT?: Enumerable<EntityPermissionRoleWhereInput>
		id?: StringFilter | string
		entityVersionId?: StringFilter | string
		action?: EnumEnumEntityActionFilter | EnumEntityAction
		resourceRoleId?: StringFilter | string
		resourceRole?: XOR<ResourceRoleRelationFilter, ResourceRoleWhereInput>
		permission?: XOR<EntityPermissionRelationFilter, EntityPermissionWhereInput>
		permissionFields?: EntityPermissionFieldListRelationFilter
	}

	export type EntityPermissionRoleOrderByWithRelationInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		resourceRoleId?: SortOrder
		resourceRole?: ResourceRoleOrderByWithRelationInput
		permission?: EntityPermissionOrderByWithRelationInput
		permissionFields?: EntityPermissionFieldOrderByRelationAggregateInput
	}

	export type EntityPermissionRoleWhereUniqueInput = {
		id?: string
		entityVersionId_action_resourceRoleId?: EntityPermissionRoleEntityVersionIdActionResourceRoleIdCompoundUniqueInput
	}

	export type EntityPermissionRoleOrderByWithAggregationInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		resourceRoleId?: SortOrder
		_count?: EntityPermissionRoleCountOrderByAggregateInput
		_max?: EntityPermissionRoleMaxOrderByAggregateInput
		_min?: EntityPermissionRoleMinOrderByAggregateInput
	}

	export type EntityPermissionRoleScalarWhereWithAggregatesInput = {
		AND?: Enumerable<EntityPermissionRoleScalarWhereWithAggregatesInput>
		OR?: Enumerable<EntityPermissionRoleScalarWhereWithAggregatesInput>
		NOT?: Enumerable<EntityPermissionRoleScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		entityVersionId?: StringWithAggregatesFilter | string
		action?: EnumEnumEntityActionWithAggregatesFilter | EnumEntityAction
		resourceRoleId?: StringWithAggregatesFilter | string
	}

	export type EntityPermissionFieldWhereInput = {
		AND?: Enumerable<EntityPermissionFieldWhereInput>
		OR?: Enumerable<EntityPermissionFieldWhereInput>
		NOT?: Enumerable<EntityPermissionFieldWhereInput>
		id?: StringFilter | string
		permissionId?: StringFilter | string
		fieldPermanentId?: StringFilter | string
		entityVersionId?: StringFilter | string
		field?: XOR<EntityFieldRelationFilter, EntityFieldWhereInput>
		permission?: XOR<EntityPermissionRelationFilter, EntityPermissionWhereInput>
		permissionRoles?: EntityPermissionRoleListRelationFilter
	}

	export type EntityPermissionFieldOrderByWithRelationInput = {
		id?: SortOrder
		permissionId?: SortOrder
		fieldPermanentId?: SortOrder
		entityVersionId?: SortOrder
		field?: EntityFieldOrderByWithRelationInput
		permission?: EntityPermissionOrderByWithRelationInput
		permissionRoles?: EntityPermissionRoleOrderByRelationAggregateInput
	}

	export type EntityPermissionFieldWhereUniqueInput = {
		id?: string
		permissionId_fieldPermanentId?: EntityPermissionFieldPermissionIdFieldPermanentIdCompoundUniqueInput
	}

	export type EntityPermissionFieldOrderByWithAggregationInput = {
		id?: SortOrder
		permissionId?: SortOrder
		fieldPermanentId?: SortOrder
		entityVersionId?: SortOrder
		_count?: EntityPermissionFieldCountOrderByAggregateInput
		_max?: EntityPermissionFieldMaxOrderByAggregateInput
		_min?: EntityPermissionFieldMinOrderByAggregateInput
	}

	export type EntityPermissionFieldScalarWhereWithAggregatesInput = {
		AND?: Enumerable<EntityPermissionFieldScalarWhereWithAggregatesInput>
		OR?: Enumerable<EntityPermissionFieldScalarWhereWithAggregatesInput>
		NOT?: Enumerable<EntityPermissionFieldScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		permissionId?: StringWithAggregatesFilter | string
		fieldPermanentId?: StringWithAggregatesFilter | string
		entityVersionId?: StringWithAggregatesFilter | string
	}

	export type EntityFieldWhereInput = {
		AND?: Enumerable<EntityFieldWhereInput>
		OR?: Enumerable<EntityFieldWhereInput>
		NOT?: Enumerable<EntityFieldWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		entityVersionId?: StringFilter | string
		permanentId?: StringFilter | string
		name?: StringFilter | string
		displayName?: StringFilter | string
		dataType?: EnumEnumDataTypeFilter | EnumDataType
		properties?: JsonFilter
		required?: BoolFilter | boolean
		searchable?: BoolFilter | boolean
		description?: StringFilter | string
		position?: IntNullableFilter | number | null
		unique?: BoolFilter | boolean
		entityVersion?: XOR<EntityVersionRelationFilter, EntityVersionWhereInput>
		permissionField?: EntityPermissionFieldListRelationFilter
	}

	export type EntityFieldOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityVersionId?: SortOrder
		permanentId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		dataType?: SortOrder
		properties?: SortOrder
		required?: SortOrder
		searchable?: SortOrder
		description?: SortOrder
		position?: SortOrder
		unique?: SortOrder
		entityVersion?: EntityVersionOrderByWithRelationInput
		permissionField?: EntityPermissionFieldOrderByRelationAggregateInput
	}

	export type EntityFieldWhereUniqueInput = {
		id?: string
		entityVersionId_displayName?: EntityFieldEntityVersionIdDisplayNameCompoundUniqueInput
		entityVersionId_name?: EntityFieldEntityVersionIdNameCompoundUniqueInput
		entityVersionId_permanentId?: EntityFieldEntityVersionIdPermanentIdCompoundUniqueInput
	}

	export type EntityFieldOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityVersionId?: SortOrder
		permanentId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		dataType?: SortOrder
		properties?: SortOrder
		required?: SortOrder
		searchable?: SortOrder
		description?: SortOrder
		position?: SortOrder
		unique?: SortOrder
		_count?: EntityFieldCountOrderByAggregateInput
		_avg?: EntityFieldAvgOrderByAggregateInput
		_max?: EntityFieldMaxOrderByAggregateInput
		_min?: EntityFieldMinOrderByAggregateInput
		_sum?: EntityFieldSumOrderByAggregateInput
	}

	export type EntityFieldScalarWhereWithAggregatesInput = {
		AND?: Enumerable<EntityFieldScalarWhereWithAggregatesInput>
		OR?: Enumerable<EntityFieldScalarWhereWithAggregatesInput>
		NOT?: Enumerable<EntityFieldScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		entityVersionId?: StringWithAggregatesFilter | string
		permanentId?: StringWithAggregatesFilter | string
		name?: StringWithAggregatesFilter | string
		displayName?: StringWithAggregatesFilter | string
		dataType?: EnumEnumDataTypeWithAggregatesFilter | EnumDataType
		properties?: JsonWithAggregatesFilter
		required?: BoolWithAggregatesFilter | boolean
		searchable?: BoolWithAggregatesFilter | boolean
		description?: StringWithAggregatesFilter | string
		position?: IntNullableWithAggregatesFilter | number | null
		unique?: BoolWithAggregatesFilter | boolean
	}

	export type BlockWhereInput = {
		AND?: Enumerable<BlockWhereInput>
		OR?: Enumerable<BlockWhereInput>
		NOT?: Enumerable<BlockWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		parentBlockId?: StringNullableFilter | string | null
		blockType?: EnumEnumBlockTypeFilter | EnumBlockType
		displayName?: StringFilter | string
		description?: StringNullableFilter | string | null
		lockedByUserId?: StringNullableFilter | string | null
		lockedAt?: DateTimeNullableFilter | Date | string | null
		deletedAt?: DateTimeNullableFilter | Date | string | null
		resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
		lockedByUser?: XOR<UserRelationFilter, UserWhereInput> | null
		parentBlock?: XOR<BlockRelationFilter, BlockWhereInput> | null
		blocks?: BlockListRelationFilter
		versions?: BlockVersionListRelationFilter
	}

	export type BlockOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		parentBlockId?: SortOrder
		blockType?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
		resource?: ResourceOrderByWithRelationInput
		lockedByUser?: UserOrderByWithRelationInput
		parentBlock?: BlockOrderByWithRelationInput
		blocks?: BlockOrderByRelationAggregateInput
		versions?: BlockVersionOrderByRelationAggregateInput
	}

	export type BlockWhereUniqueInput = {
		id?: string
		resourceId_displayName?: BlockResourceIdDisplayNameCompoundUniqueInput
	}

	export type BlockOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		parentBlockId?: SortOrder
		blockType?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
		_count?: BlockCountOrderByAggregateInput
		_max?: BlockMaxOrderByAggregateInput
		_min?: BlockMinOrderByAggregateInput
	}

	export type BlockScalarWhereWithAggregatesInput = {
		AND?: Enumerable<BlockScalarWhereWithAggregatesInput>
		OR?: Enumerable<BlockScalarWhereWithAggregatesInput>
		NOT?: Enumerable<BlockScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		resourceId?: StringWithAggregatesFilter | string
		parentBlockId?: StringNullableWithAggregatesFilter | string | null
		blockType?: EnumEnumBlockTypeWithAggregatesFilter | EnumBlockType
		displayName?: StringWithAggregatesFilter | string
		description?: StringNullableWithAggregatesFilter | string | null
		lockedByUserId?: StringNullableWithAggregatesFilter | string | null
		lockedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
		deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
	}

	export type BlockVersionWhereInput = {
		AND?: Enumerable<BlockVersionWhereInput>
		OR?: Enumerable<BlockVersionWhereInput>
		NOT?: Enumerable<BlockVersionWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		blockId?: StringFilter | string
		versionNumber?: IntFilter | number
		inputParameters?: JsonNullableFilter
		outputParameters?: JsonNullableFilter
		settings?: JsonFilter
		displayName?: StringFilter | string
		description?: StringNullableFilter | string | null
		commitId?: StringNullableFilter | string | null
		deleted?: BoolNullableFilter | boolean | null
		block?: XOR<BlockRelationFilter, BlockWhereInput>
		commit?: XOR<CommitRelationFilter, CommitWhereInput> | null
		builds?: BuildListRelationFilter
	}

	export type BlockVersionOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		blockId?: SortOrder
		versionNumber?: SortOrder
		inputParameters?: SortOrder
		outputParameters?: SortOrder
		settings?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
		block?: BlockOrderByWithRelationInput
		commit?: CommitOrderByWithRelationInput
		builds?: BuildOrderByRelationAggregateInput
	}

	export type BlockVersionWhereUniqueInput = {
		id?: string
		blockId_versionNumber?: BlockVersionBlockIdVersionNumberCompoundUniqueInput
	}

	export type BlockVersionOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		blockId?: SortOrder
		versionNumber?: SortOrder
		inputParameters?: SortOrder
		outputParameters?: SortOrder
		settings?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
		_count?: BlockVersionCountOrderByAggregateInput
		_avg?: BlockVersionAvgOrderByAggregateInput
		_max?: BlockVersionMaxOrderByAggregateInput
		_min?: BlockVersionMinOrderByAggregateInput
		_sum?: BlockVersionSumOrderByAggregateInput
	}

	export type BlockVersionScalarWhereWithAggregatesInput = {
		AND?: Enumerable<BlockVersionScalarWhereWithAggregatesInput>
		OR?: Enumerable<BlockVersionScalarWhereWithAggregatesInput>
		NOT?: Enumerable<BlockVersionScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		blockId?: StringWithAggregatesFilter | string
		versionNumber?: IntWithAggregatesFilter | number
		inputParameters?: JsonNullableWithAggregatesFilter
		outputParameters?: JsonNullableWithAggregatesFilter
		settings?: JsonWithAggregatesFilter
		displayName?: StringWithAggregatesFilter | string
		description?: StringNullableWithAggregatesFilter | string | null
		commitId?: StringNullableWithAggregatesFilter | string | null
		deleted?: BoolNullableWithAggregatesFilter | boolean | null
	}

	export type ActionWhereInput = {
		AND?: Enumerable<ActionWhereInput>
		OR?: Enumerable<ActionWhereInput>
		NOT?: Enumerable<ActionWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		steps?: ActionStepListRelationFilter
		builds?: BuildListRelationFilter
		deployments?: DeploymentListRelationFilter
	}

	export type ActionOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		steps?: ActionStepOrderByRelationAggregateInput
		builds?: BuildOrderByRelationAggregateInput
		deployments?: DeploymentOrderByRelationAggregateInput
	}

	export type ActionWhereUniqueInput = {
		id?: string
	}

	export type ActionOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		_count?: ActionCountOrderByAggregateInput
		_max?: ActionMaxOrderByAggregateInput
		_min?: ActionMinOrderByAggregateInput
	}

	export type ActionScalarWhereWithAggregatesInput = {
		AND?: Enumerable<ActionScalarWhereWithAggregatesInput>
		OR?: Enumerable<ActionScalarWhereWithAggregatesInput>
		NOT?: Enumerable<ActionScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
	}

	export type ActionStepWhereInput = {
		AND?: Enumerable<ActionStepWhereInput>
		OR?: Enumerable<ActionStepWhereInput>
		NOT?: Enumerable<ActionStepWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		message?: StringFilter | string
		status?: EnumActionStepStatusFilter | ActionStepStatus
		completedAt?: DateTimeNullableFilter | Date | string | null
		actionId?: StringFilter | string
		name?: StringFilter | string
		action?: XOR<ActionRelationFilter, ActionWhereInput>
		logs?: ActionLogListRelationFilter
	}

	export type ActionStepOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		status?: SortOrder
		completedAt?: SortOrder
		actionId?: SortOrder
		name?: SortOrder
		action?: ActionOrderByWithRelationInput
		logs?: ActionLogOrderByRelationAggregateInput
	}

	export type ActionStepWhereUniqueInput = {
		id?: string
	}

	export type ActionStepOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		status?: SortOrder
		completedAt?: SortOrder
		actionId?: SortOrder
		name?: SortOrder
		_count?: ActionStepCountOrderByAggregateInput
		_max?: ActionStepMaxOrderByAggregateInput
		_min?: ActionStepMinOrderByAggregateInput
	}

	export type ActionStepScalarWhereWithAggregatesInput = {
		AND?: Enumerable<ActionStepScalarWhereWithAggregatesInput>
		OR?: Enumerable<ActionStepScalarWhereWithAggregatesInput>
		NOT?: Enumerable<ActionStepScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		message?: StringWithAggregatesFilter | string
		status?: EnumActionStepStatusWithAggregatesFilter | ActionStepStatus
		completedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
		actionId?: StringWithAggregatesFilter | string
		name?: StringWithAggregatesFilter | string
	}

	export type ActionLogWhereInput = {
		AND?: Enumerable<ActionLogWhereInput>
		OR?: Enumerable<ActionLogWhereInput>
		NOT?: Enumerable<ActionLogWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		message?: StringFilter | string
		meta?: JsonFilter
		level?: EnumEnumLogLevelFilter | EnumLogLevel
		stepId?: StringFilter | string
		step?: XOR<ActionStepRelationFilter, ActionStepWhereInput>
	}

	export type ActionLogOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		meta?: SortOrder
		level?: SortOrder
		stepId?: SortOrder
		step?: ActionStepOrderByWithRelationInput
	}

	export type ActionLogWhereUniqueInput = {
		id?: string
	}

	export type ActionLogOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		meta?: SortOrder
		level?: SortOrder
		stepId?: SortOrder
		_count?: ActionLogCountOrderByAggregateInput
		_max?: ActionLogMaxOrderByAggregateInput
		_min?: ActionLogMinOrderByAggregateInput
	}

	export type ActionLogScalarWhereWithAggregatesInput = {
		AND?: Enumerable<ActionLogScalarWhereWithAggregatesInput>
		OR?: Enumerable<ActionLogScalarWhereWithAggregatesInput>
		NOT?: Enumerable<ActionLogScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		message?: StringWithAggregatesFilter | string
		meta?: JsonWithAggregatesFilter
		level?: EnumEnumLogLevelWithAggregatesFilter | EnumLogLevel
		stepId?: StringWithAggregatesFilter | string
	}

	export type BuildWhereInput = {
		AND?: Enumerable<BuildWhereInput>
		OR?: Enumerable<BuildWhereInput>
		NOT?: Enumerable<BuildWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		userId?: StringFilter | string
		version?: StringFilter | string
		message?: StringNullableFilter | string | null
		actionId?: StringFilter | string
		images?: StringNullableListFilter
		containerStatusQuery?: JsonNullableFilter
		containerStatusUpdatedAt?: DateTimeNullableFilter | Date | string | null
		commitId?: StringNullableFilter | string | null
		action?: XOR<ActionRelationFilter, ActionWhereInput>
		resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
		commit?: XOR<CommitRelationFilter, CommitWhereInput> | null
		createdBy?: XOR<UserRelationFilter, UserWhereInput>
		deployments?: DeploymentListRelationFilter
		blockVersions?: BlockVersionListRelationFilter
		entityVersions?: EntityVersionListRelationFilter
	}

	export type BuildOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		resourceId?: SortOrder
		userId?: SortOrder
		version?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		images?: SortOrder
		containerStatusQuery?: SortOrder
		containerStatusUpdatedAt?: SortOrder
		commitId?: SortOrder
		action?: ActionOrderByWithRelationInput
		resource?: ResourceOrderByWithRelationInput
		commit?: CommitOrderByWithRelationInput
		createdBy?: UserOrderByWithRelationInput
		deployments?: DeploymentOrderByRelationAggregateInput
		blockVersions?: BlockVersionOrderByRelationAggregateInput
		entityVersions?: EntityVersionOrderByRelationAggregateInput
	}

	export type BuildWhereUniqueInput = {
		id?: string
		resourceId_version?: BuildResourceIdVersionCompoundUniqueInput
	}

	export type BuildOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		resourceId?: SortOrder
		userId?: SortOrder
		version?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		images?: SortOrder
		containerStatusQuery?: SortOrder
		containerStatusUpdatedAt?: SortOrder
		commitId?: SortOrder
		_count?: BuildCountOrderByAggregateInput
		_max?: BuildMaxOrderByAggregateInput
		_min?: BuildMinOrderByAggregateInput
	}

	export type BuildScalarWhereWithAggregatesInput = {
		AND?: Enumerable<BuildScalarWhereWithAggregatesInput>
		OR?: Enumerable<BuildScalarWhereWithAggregatesInput>
		NOT?: Enumerable<BuildScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		resourceId?: StringWithAggregatesFilter | string
		userId?: StringWithAggregatesFilter | string
		version?: StringWithAggregatesFilter | string
		message?: StringNullableWithAggregatesFilter | string | null
		actionId?: StringWithAggregatesFilter | string
		images?: StringNullableListFilter
		containerStatusQuery?: JsonNullableWithAggregatesFilter
		containerStatusUpdatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
		commitId?: StringNullableWithAggregatesFilter | string | null
	}

	export type ReleaseWhereInput = {
		AND?: Enumerable<ReleaseWhereInput>
		OR?: Enumerable<ReleaseWhereInput>
		NOT?: Enumerable<ReleaseWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		version?: StringFilter | string
		description?: StringNullableFilter | string | null
		commitId?: StringFilter | string
		commit?: XOR<CommitRelationFilter, CommitWhereInput>
	}

	export type ReleaseOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		version?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		commit?: CommitOrderByWithRelationInput
	}

	export type ReleaseWhereUniqueInput = {
		id?: string
	}

	export type ReleaseOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		version?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		_count?: ReleaseCountOrderByAggregateInput
		_max?: ReleaseMaxOrderByAggregateInput
		_min?: ReleaseMinOrderByAggregateInput
	}

	export type ReleaseScalarWhereWithAggregatesInput = {
		AND?: Enumerable<ReleaseScalarWhereWithAggregatesInput>
		OR?: Enumerable<ReleaseScalarWhereWithAggregatesInput>
		NOT?: Enumerable<ReleaseScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		version?: StringWithAggregatesFilter | string
		description?: StringNullableWithAggregatesFilter | string | null
		commitId?: StringWithAggregatesFilter | string
	}

	export type EnvironmentWhereInput = {
		AND?: Enumerable<EnvironmentWhereInput>
		OR?: Enumerable<EnvironmentWhereInput>
		NOT?: Enumerable<EnvironmentWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		name?: StringFilter | string
		description?: StringNullableFilter | string | null
		address?: StringFilter | string
		resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
		deployments?: DeploymentListRelationFilter
	}

	export type EnvironmentOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		description?: SortOrder
		address?: SortOrder
		resource?: ResourceOrderByWithRelationInput
		deployments?: DeploymentOrderByRelationAggregateInput
	}

	export type EnvironmentWhereUniqueInput = {
		id?: string
		resourceId_name?: EnvironmentResourceIdNameCompoundUniqueInput
	}

	export type EnvironmentOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		description?: SortOrder
		address?: SortOrder
		_count?: EnvironmentCountOrderByAggregateInput
		_max?: EnvironmentMaxOrderByAggregateInput
		_min?: EnvironmentMinOrderByAggregateInput
	}

	export type EnvironmentScalarWhereWithAggregatesInput = {
		AND?: Enumerable<EnvironmentScalarWhereWithAggregatesInput>
		OR?: Enumerable<EnvironmentScalarWhereWithAggregatesInput>
		NOT?: Enumerable<EnvironmentScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		resourceId?: StringWithAggregatesFilter | string
		name?: StringWithAggregatesFilter | string
		description?: StringNullableWithAggregatesFilter | string | null
		address?: StringWithAggregatesFilter | string
	}

	export type DeploymentWhereInput = {
		AND?: Enumerable<DeploymentWhereInput>
		OR?: Enumerable<DeploymentWhereInput>
		NOT?: Enumerable<DeploymentWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		userId?: StringFilter | string
		buildId?: StringFilter | string
		environmentId?: StringFilter | string
		status?: EnumEnumDeploymentStatusFilter | EnumDeploymentStatus
		message?: StringNullableFilter | string | null
		actionId?: StringFilter | string
		statusQuery?: JsonNullableFilter
		statusUpdatedAt?: DateTimeNullableFilter | Date | string | null
		action?: XOR<ActionRelationFilter, ActionWhereInput>
		build?: XOR<BuildRelationFilter, BuildWhereInput>
		environment?: XOR<EnvironmentRelationFilter, EnvironmentWhereInput>
		createdBy?: XOR<UserRelationFilter, UserWhereInput>
	}

	export type DeploymentOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		buildId?: SortOrder
		environmentId?: SortOrder
		status?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		statusQuery?: SortOrder
		statusUpdatedAt?: SortOrder
		action?: ActionOrderByWithRelationInput
		build?: BuildOrderByWithRelationInput
		environment?: EnvironmentOrderByWithRelationInput
		createdBy?: UserOrderByWithRelationInput
	}

	export type DeploymentWhereUniqueInput = {
		id?: string
	}

	export type DeploymentOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		buildId?: SortOrder
		environmentId?: SortOrder
		status?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		statusQuery?: SortOrder
		statusUpdatedAt?: SortOrder
		_count?: DeploymentCountOrderByAggregateInput
		_max?: DeploymentMaxOrderByAggregateInput
		_min?: DeploymentMinOrderByAggregateInput
	}

	export type DeploymentScalarWhereWithAggregatesInput = {
		AND?: Enumerable<DeploymentScalarWhereWithAggregatesInput>
		OR?: Enumerable<DeploymentScalarWhereWithAggregatesInput>
		NOT?: Enumerable<DeploymentScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		userId?: StringWithAggregatesFilter | string
		buildId?: StringWithAggregatesFilter | string
		environmentId?: StringWithAggregatesFilter | string
		status?: EnumEnumDeploymentStatusWithAggregatesFilter | EnumDeploymentStatus
		message?: StringNullableWithAggregatesFilter | string | null
		actionId?: StringWithAggregatesFilter | string
		statusQuery?: JsonNullableWithAggregatesFilter
		statusUpdatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
	}

	export type InvitationWhereInput = {
		AND?: Enumerable<InvitationWhereInput>
		OR?: Enumerable<InvitationWhereInput>
		NOT?: Enumerable<InvitationWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		email?: StringFilter | string
		invitedByUserId?: StringFilter | string
		invitedByUser?: XOR<UserRelationFilter, UserWhereInput>
		workspaceId?: StringFilter | string
		workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
		newUserId?: StringNullableFilter | string | null
		newUser?: XOR<UserRelationFilter, UserWhereInput> | null
		token?: StringFilter | string
		tokenExpiration?: DateTimeFilter | Date | string
	}

	export type InvitationOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		invitedByUserId?: SortOrder
		invitedByUser?: UserOrderByWithRelationInput
		workspaceId?: SortOrder
		workspace?: WorkspaceOrderByWithRelationInput
		newUserId?: SortOrder
		newUser?: UserOrderByWithRelationInput
		token?: SortOrder
		tokenExpiration?: SortOrder
	}

	export type InvitationWhereUniqueInput = {
		id?: string
		newUserId?: string
		workspaceId_email?: InvitationWorkspaceIdEmailCompoundUniqueInput
	}

	export type InvitationOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		invitedByUserId?: SortOrder
		workspaceId?: SortOrder
		newUserId?: SortOrder
		token?: SortOrder
		tokenExpiration?: SortOrder
		_count?: InvitationCountOrderByAggregateInput
		_max?: InvitationMaxOrderByAggregateInput
		_min?: InvitationMinOrderByAggregateInput
	}

	export type InvitationScalarWhereWithAggregatesInput = {
		AND?: Enumerable<InvitationScalarWhereWithAggregatesInput>
		OR?: Enumerable<InvitationScalarWhereWithAggregatesInput>
		NOT?: Enumerable<InvitationScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		email?: StringWithAggregatesFilter | string
		invitedByUserId?: StringWithAggregatesFilter | string
		workspaceId?: StringWithAggregatesFilter | string
		newUserId?: StringNullableWithAggregatesFilter | string | null
		token?: StringWithAggregatesFilter | string
		tokenExpiration?: DateTimeWithAggregatesFilter | Date | string
	}

	export type SubscriptionWhereInput = {
		AND?: Enumerable<SubscriptionWhereInput>
		OR?: Enumerable<SubscriptionWhereInput>
		NOT?: Enumerable<SubscriptionWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		workspaceId?: StringFilter | string
		workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
		subscriptionPlan?: EnumEnumSubscriptionPlanFilter | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusFilter | EnumSubscriptionStatus
		subscriptionData?: JsonFilter
		cancellationEffectiveDate?: DateTimeNullableFilter | Date | string | null
	}

	export type SubscriptionOrderByWithRelationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		workspace?: WorkspaceOrderByWithRelationInput
		subscriptionPlan?: SortOrder
		status?: SortOrder
		subscriptionData?: SortOrder
		cancellationEffectiveDate?: SortOrder
	}

	export type SubscriptionWhereUniqueInput = {
		id?: string
	}

	export type SubscriptionOrderByWithAggregationInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		subscriptionPlan?: SortOrder
		status?: SortOrder
		subscriptionData?: SortOrder
		cancellationEffectiveDate?: SortOrder
		_count?: SubscriptionCountOrderByAggregateInput
		_max?: SubscriptionMaxOrderByAggregateInput
		_min?: SubscriptionMinOrderByAggregateInput
	}

	export type SubscriptionScalarWhereWithAggregatesInput = {
		AND?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
		OR?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
		NOT?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
		id?: StringWithAggregatesFilter | string
		createdAt?: DateTimeWithAggregatesFilter | Date | string
		updatedAt?: DateTimeWithAggregatesFilter | Date | string
		workspaceId?: StringWithAggregatesFilter | string
		subscriptionPlan?: EnumEnumSubscriptionPlanWithAggregatesFilter | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusWithAggregatesFilter | EnumSubscriptionStatus
		subscriptionData?: JsonWithAggregatesFilter
		cancellationEffectiveDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
	}

	export type AccountCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		firstName: string
		lastName: string
		password: string
		githubId?: string | null
		currentUser?: UserCreateNestedOneWithoutAssignedCurrentToInput
		users?: UserCreateNestedManyWithoutAccountInput
	}

	export type AccountUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		firstName: string
		lastName: string
		password: string
		currentUserId?: string | null
		githubId?: string | null
		users?: UserUncheckedCreateNestedManyWithoutAccountInput
	}

	export type AccountUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		githubId?: NullableStringFieldUpdateOperationsInput | string | null
		currentUser?: UserUpdateOneWithoutAssignedCurrentToInput
		users?: UserUpdateManyWithoutAccountInput
	}

	export type AccountUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
		githubId?: NullableStringFieldUpdateOperationsInput | string | null
		users?: UserUncheckedUpdateManyWithoutAccountInput
	}

	export type AccountCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		firstName: string
		lastName: string
		password: string
		currentUserId?: string | null
		githubId?: string | null
	}

	export type AccountUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		githubId?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type AccountUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
		githubId?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type WorkspaceCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserCreateNestedManyWithoutWorkspaceInput
		invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserUncheckedCreateNestedManyWithoutWorkspaceInput
		invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUpdateManyWithoutWorkspaceInput
		invitations?: InvitationUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUpdateManyWithoutWorkspaceInput
		projects?: ProjectUpdateManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUncheckedUpdateManyWithoutWorkspaceInput
		invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedUpdateManyWithoutWorkspaceInput
		projects?: ProjectUncheckedUpdateManyWithoutWorkspaceInput
	}

	export type WorkspaceCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
	}

	export type WorkspaceUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
	}

	export type WorkspaceUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
	}

	export type ProjectCreateInput = {
		id?: string
		name: string
		workspace: WorkspaceCreateNestedOneWithoutProjectsInput
		resources?: ResourceCreateNestedManyWithoutProjectInput
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
		commits?: CommitCreateNestedManyWithoutProjectInput
	}

	export type ProjectUncheckedCreateInput = {
		id?: string
		name: string
		workspaceId: string
		resources?: ResourceUncheckedCreateNestedManyWithoutProjectInput
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
		commits?: CommitUncheckedCreateNestedManyWithoutProjectInput
	}

	export type ProjectUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		workspace?: WorkspaceUpdateOneRequiredWithoutProjectsInput
		resources?: ResourceUpdateManyWithoutProjectInput
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commits?: CommitUpdateManyWithoutProjectInput
	}

	export type ProjectUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		resources?: ResourceUncheckedUpdateManyWithoutProjectInput
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commits?: CommitUncheckedUpdateManyWithoutProjectInput
	}

	export type ProjectCreateManyInput = {
		id?: string
		name: string
		workspaceId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
	}

	export type ProjectUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type ProjectUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type GitOrganizationCreateInput = {
		id?: string
		provider: EnumGitProvider
		name: string
		installationId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		type?: EnumGitOrganizationType | null
		workspace: WorkspaceCreateNestedOneWithoutGitOrganizationsInput
		gitRepositories?: GitRepositoryCreateNestedManyWithoutGitOrganizationInput
	}

	export type GitOrganizationUncheckedCreateInput = {
		id?: string
		provider: EnumGitProvider
		name: string
		installationId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		workspaceId: string
		type?: EnumGitOrganizationType | null
		gitRepositories?: GitRepositoryUncheckedCreateNestedManyWithoutGitOrganizationInput
	}

	export type GitOrganizationUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		provider?: EnumEnumGitProviderFieldUpdateOperationsInput | EnumGitProvider
		name?: StringFieldUpdateOperationsInput | string
		installationId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		type?: NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput | EnumGitOrganizationType | null
		workspace?: WorkspaceUpdateOneRequiredWithoutGitOrganizationsInput
		gitRepositories?: GitRepositoryUpdateManyWithoutGitOrganizationInput
	}

	export type GitOrganizationUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		provider?: EnumEnumGitProviderFieldUpdateOperationsInput | EnumGitProvider
		name?: StringFieldUpdateOperationsInput | string
		installationId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		type?: NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput | EnumGitOrganizationType | null
		gitRepositories?: GitRepositoryUncheckedUpdateManyWithoutGitOrganizationInput
	}

	export type GitOrganizationCreateManyInput = {
		id?: string
		provider: EnumGitProvider
		name: string
		installationId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		workspaceId: string
		type?: EnumGitOrganizationType | null
	}

	export type GitOrganizationUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		provider?: EnumEnumGitProviderFieldUpdateOperationsInput | EnumGitProvider
		name?: StringFieldUpdateOperationsInput | string
		installationId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		type?: NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput | EnumGitOrganizationType | null
	}

	export type GitOrganizationUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		provider?: EnumEnumGitProviderFieldUpdateOperationsInput | EnumGitProvider
		name?: StringFieldUpdateOperationsInput | string
		installationId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		type?: NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput | EnumGitOrganizationType | null
	}

	export type GitRepositoryCreateInput = {
		id?: string
		name: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resources?: ResourceCreateNestedManyWithoutGitRepositoryInput
		gitOrganization: GitOrganizationCreateNestedOneWithoutGitRepositoriesInput
	}

	export type GitRepositoryUncheckedCreateInput = {
		id?: string
		name: string
		createdAt?: Date | string
		updatedAt?: Date | string
		gitOrganizationId: string
		resources?: ResourceUncheckedCreateNestedManyWithoutGitRepositoryInput
	}

	export type GitRepositoryUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resources?: ResourceUpdateManyWithoutGitRepositoryInput
		gitOrganization?: GitOrganizationUpdateOneRequiredWithoutGitRepositoriesInput
	}

	export type GitRepositoryUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		gitOrganizationId?: StringFieldUpdateOperationsInput | string
		resources?: ResourceUncheckedUpdateManyWithoutGitRepositoryInput
	}

	export type GitRepositoryCreateManyInput = {
		id?: string
		name: string
		createdAt?: Date | string
		updatedAt?: Date | string
		gitOrganizationId: string
	}

	export type GitRepositoryUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type GitRepositoryUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		gitOrganizationId?: StringFieldUpdateOperationsInput | string
	}

	export type UserCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		deletedAt?: Date | string | null
	}

	export type UserUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserRoleCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		role: string
		user: UserCreateNestedOneWithoutUserRolesInput
	}

	export type UserRoleUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		userId: string
		role: string
	}

	export type UserRoleUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		role?: StringFieldUpdateOperationsInput | string
		user?: UserUpdateOneRequiredWithoutUserRolesInput
	}

	export type UserRoleUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		role?: StringFieldUpdateOperationsInput | string
	}

	export type UserRoleCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		userId: string
		role: string
	}

	export type UserRoleUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		role?: StringFieldUpdateOperationsInput | string
	}

	export type UserRoleUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		role?: StringFieldUpdateOperationsInput | string
	}

	export type ApiTokenCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		token: string
		previewChars: string
		lastAccessAt: Date | string
		user: UserCreateNestedOneWithoutApiTokensInput
	}

	export type ApiTokenUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		userId: string
		token: string
		previewChars: string
		lastAccessAt: Date | string
	}

	export type ApiTokenUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		previewChars?: StringFieldUpdateOperationsInput | string
		lastAccessAt?: DateTimeFieldUpdateOperationsInput | Date | string
		user?: UserUpdateOneRequiredWithoutApiTokensInput
	}

	export type ApiTokenUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		userId?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		previewChars?: StringFieldUpdateOperationsInput | string
		lastAccessAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ApiTokenCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		userId: string
		token: string
		previewChars: string
		lastAccessAt: Date | string
	}

	export type ApiTokenUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		previewChars?: StringFieldUpdateOperationsInput | string
		lastAccessAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ApiTokenUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		userId?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		previewChars?: StringFieldUpdateOperationsInput | string
		lastAccessAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ResourceCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		roles?: ResourceRoleCreateNestedManyWithoutResourceInput
		blocks?: BlockCreateNestedManyWithoutResourceInput
		builds?: BuildCreateNestedManyWithoutResourceInput
		entities?: EntityCreateNestedManyWithoutResourceInput
		environments?: EnvironmentCreateNestedManyWithoutResourceInput
		gitRepository?: GitRepositoryCreateNestedOneWithoutResourcesInput
		project: ProjectCreateNestedOneWithoutResourcesInput
		resourceType: EnumResourceType
	}

	export type ResourceUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		gitRepositoryId?: string | null
		roles?: ResourceRoleUncheckedCreateNestedManyWithoutResourceInput
		blocks?: BlockUncheckedCreateNestedManyWithoutResourceInput
		builds?: BuildUncheckedCreateNestedManyWithoutResourceInput
		entities?: EntityUncheckedCreateNestedManyWithoutResourceInput
		environments?: EnvironmentUncheckedCreateNestedManyWithoutResourceInput
		projectId: string
		resourceType: EnumResourceType
	}

	export type ResourceUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		roles?: ResourceRoleUpdateManyWithoutResourceInput
		blocks?: BlockUpdateManyWithoutResourceInput
		builds?: BuildUpdateManyWithoutResourceInput
		entities?: EntityUpdateManyWithoutResourceInput
		environments?: EnvironmentUpdateManyWithoutResourceInput
		gitRepository?: GitRepositoryUpdateOneWithoutResourcesInput
		project?: ProjectUpdateOneRequiredWithoutResourcesInput
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		gitRepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
		roles?: ResourceRoleUncheckedUpdateManyWithoutResourceInput
		blocks?: BlockUncheckedUpdateManyWithoutResourceInput
		builds?: BuildUncheckedUpdateManyWithoutResourceInput
		entities?: EntityUncheckedUpdateManyWithoutResourceInput
		environments?: EnvironmentUncheckedUpdateManyWithoutResourceInput
		projectId?: StringFieldUpdateOperationsInput | string
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		gitRepositoryId?: string | null
		projectId: string
		resourceType: EnumResourceType
	}

	export type ResourceUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		gitRepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
		projectId?: StringFieldUpdateOperationsInput | string
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceRoleCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		description?: string | null
		resource: ResourceCreateNestedOneWithoutRolesInput
		entityPermissionRoles?: EntityPermissionRoleCreateNestedManyWithoutResourceRoleInput
	}

	export type ResourceRoleUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		displayName: string
		description?: string | null
		entityPermissionRoles?: EntityPermissionRoleUncheckedCreateNestedManyWithoutResourceRoleInput
	}

	export type ResourceRoleUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		resource?: ResourceUpdateOneRequiredWithoutRolesInput
		entityPermissionRoles?: EntityPermissionRoleUpdateManyWithoutResourceRoleInput
	}

	export type ResourceRoleUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		entityPermissionRoles?: EntityPermissionRoleUncheckedUpdateManyWithoutResourceRoleInput
	}

	export type ResourceRoleCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		displayName: string
		description?: string | null
	}

	export type ResourceRoleUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type ResourceRoleUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type CommitCreateInput = {
		id?: string
		createdAt?: Date | string
		message: string
		user: UserCreateNestedOneWithoutCommitsInput
		blockVersions?: BlockVersionCreateNestedManyWithoutCommitInput
		builds?: BuildCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionCreateNestedManyWithoutCommitInput
		releases?: ReleaseCreateNestedManyWithoutCommitInput
		project: ProjectCreateNestedOneWithoutCommitsInput
	}

	export type CommitUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		message: string
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutCommitInput
		builds?: BuildUncheckedCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutCommitInput
		releases?: ReleaseUncheckedCreateNestedManyWithoutCommitInput
		projectId: string
	}

	export type CommitUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		user?: UserUpdateOneRequiredWithoutCommitsInput
		blockVersions?: BlockVersionUpdateManyWithoutCommitInput
		builds?: BuildUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUpdateManyWithoutCommitInput
		releases?: ReleaseUpdateManyWithoutCommitInput
		project?: ProjectUpdateOneRequiredWithoutCommitsInput
	}

	export type CommitUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutCommitInput
		builds?: BuildUncheckedUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutCommitInput
		releases?: ReleaseUncheckedUpdateManyWithoutCommitInput
		projectId?: StringFieldUpdateOperationsInput | string
	}

	export type CommitCreateManyInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		message: string
		projectId: string
	}

	export type CommitUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
	}

	export type CommitUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		projectId?: StringFieldUpdateOperationsInput | string
	}

	export type EntityCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		resource: ResourceCreateNestedOneWithoutEntitiesInput
		lockedByUser?: UserCreateNestedOneWithoutLockedEntitisInput
		versions?: EntityVersionCreateNestedManyWithoutEntityInput
	}

	export type EntityUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		versions?: EntityVersionUncheckedCreateNestedManyWithoutEntityInput
	}

	export type EntityUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resource?: ResourceUpdateOneRequiredWithoutEntitiesInput
		lockedByUser?: UserUpdateOneWithoutLockedEntitisInput
		versions?: EntityVersionUpdateManyWithoutEntityInput
	}

	export type EntityUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		versions?: EntityVersionUncheckedUpdateManyWithoutEntityInput
	}

	export type EntityCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
	}

	export type EntityUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type EntityUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type EntityVersionCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		deleted?: boolean | null
		commit?: CommitCreateNestedOneWithoutEntityVersionsInput
		entity: EntityCreateNestedOneWithoutVersionsInput
		fields?: EntityFieldCreateNestedManyWithoutEntityVersionInput
		permissions?: EntityPermissionCreateNestedManyWithoutEntityVersionInput
		builds?: BuildCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityId: string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
		fields?: EntityFieldUncheckedCreateNestedManyWithoutEntityVersionInput
		permissions?: EntityPermissionUncheckedCreateNestedManyWithoutEntityVersionInput
		builds?: BuildUncheckedCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		commit?: CommitUpdateOneWithoutEntityVersionsInput
		entity?: EntityUpdateOneRequiredWithoutVersionsInput
		fields?: EntityFieldUpdateManyWithoutEntityVersionInput
		permissions?: EntityPermissionUpdateManyWithoutEntityVersionInput
		builds?: BuildUpdateManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		fields?: EntityFieldUncheckedUpdateManyWithoutEntityVersionInput
		permissions?: EntityPermissionUncheckedUpdateManyWithoutEntityVersionInput
		builds?: BuildUncheckedUpdateManyWithoutEntityVersionsInput
	}

	export type EntityVersionCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityId: string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
	}

	export type EntityVersionUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
	}

	export type EntityVersionUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
	}

	export type EntityPermissionCreateInput = {
		id?: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
		entityVersion: EntityVersionCreateNestedOneWithoutPermissionsInput
		permissionFields?: EntityPermissionFieldCreateNestedManyWithoutPermissionInput
		permissionRoles?: EntityPermissionRoleCreateNestedManyWithoutPermissionInput
	}

	export type EntityPermissionUncheckedCreateInput = {
		id?: string
		entityVersionId: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
		permissionFields?: EntityPermissionFieldUncheckedCreateNestedManyWithoutPermissionInput
		permissionRoles?: EntityPermissionRoleUncheckedCreateNestedManyWithoutPermissionInput
	}

	export type EntityPermissionUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
		entityVersion?: EntityVersionUpdateOneRequiredWithoutPermissionsInput
		permissionFields?: EntityPermissionFieldUpdateManyWithoutPermissionInput
		permissionRoles?: EntityPermissionRoleUpdateManyWithoutPermissionInput
	}

	export type EntityPermissionUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
		permissionFields?: EntityPermissionFieldUncheckedUpdateManyWithoutPermissionInput
		permissionRoles?: EntityPermissionRoleUncheckedUpdateManyWithoutPermissionInput
	}

	export type EntityPermissionCreateManyInput = {
		id?: string
		entityVersionId: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
	}

	export type EntityPermissionUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
	}

	export type EntityPermissionUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
	}

	export type EntityPermissionRoleCreateInput = {
		id?: string
		resourceRole: ResourceRoleCreateNestedOneWithoutEntityPermissionRolesInput
		permission: EntityPermissionCreateNestedOneWithoutPermissionRolesInput
		permissionFields?: EntityPermissionFieldCreateNestedManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedCreateInput = {
		id?: string
		entityVersionId: string
		action: EnumEntityAction
		resourceRoleId: string
		permissionFields?: EntityPermissionFieldUncheckedCreateNestedManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		resourceRole?: ResourceRoleUpdateOneRequiredWithoutEntityPermissionRolesInput
		permission?: EntityPermissionUpdateOneRequiredWithoutPermissionRolesInput
		permissionFields?: EntityPermissionFieldUpdateManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		resourceRoleId?: StringFieldUpdateOperationsInput | string
		permissionFields?: EntityPermissionFieldUncheckedUpdateManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleCreateManyInput = {
		id?: string
		entityVersionId: string
		action: EnumEntityAction
		resourceRoleId: string
	}

	export type EntityPermissionRoleUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
	}

	export type EntityPermissionRoleUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		resourceRoleId?: StringFieldUpdateOperationsInput | string
	}

	export type EntityPermissionFieldCreateInput = {
		id?: string
		field: EntityFieldCreateNestedOneWithoutPermissionFieldInput
		permission: EntityPermissionCreateNestedOneWithoutPermissionFieldsInput
		permissionRoles?: EntityPermissionRoleCreateNestedManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedCreateInput = {
		id?: string
		permissionId: string
		fieldPermanentId: string
		entityVersionId: string
		permissionRoles?: EntityPermissionRoleUncheckedCreateNestedManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		field?: EntityFieldUpdateOneRequiredWithoutPermissionFieldInput
		permission?: EntityPermissionUpdateOneRequiredWithoutPermissionFieldsInput
		permissionRoles?: EntityPermissionRoleUpdateManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		permissionId?: StringFieldUpdateOperationsInput | string
		fieldPermanentId?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		permissionRoles?: EntityPermissionRoleUncheckedUpdateManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldCreateManyInput = {
		id?: string
		permissionId: string
		fieldPermanentId: string
		entityVersionId: string
	}

	export type EntityPermissionFieldUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
	}

	export type EntityPermissionFieldUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		permissionId?: StringFieldUpdateOperationsInput | string
		fieldPermanentId?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
	}

	export type EntityFieldCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		permanentId?: string
		name: string
		displayName: string
		dataType: EnumDataType
		properties: JsonNullValueInput | InputJsonValue
		required: boolean
		searchable: boolean
		description: string
		position?: number | null
		unique?: boolean
		entityVersion: EntityVersionCreateNestedOneWithoutFieldsInput
		permissionField?: EntityPermissionFieldCreateNestedManyWithoutFieldInput
	}

	export type EntityFieldUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityVersionId: string
		permanentId?: string
		name: string
		displayName: string
		dataType: EnumDataType
		properties: JsonNullValueInput | InputJsonValue
		required: boolean
		searchable: boolean
		description: string
		position?: number | null
		unique?: boolean
		permissionField?: EntityPermissionFieldUncheckedCreateNestedManyWithoutFieldInput
	}

	export type EntityFieldUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		permanentId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		dataType?: EnumEnumDataTypeFieldUpdateOperationsInput | EnumDataType
		properties?: JsonNullValueInput | InputJsonValue
		required?: BoolFieldUpdateOperationsInput | boolean
		searchable?: BoolFieldUpdateOperationsInput | boolean
		description?: StringFieldUpdateOperationsInput | string
		position?: NullableIntFieldUpdateOperationsInput | number | null
		unique?: BoolFieldUpdateOperationsInput | boolean
		entityVersion?: EntityVersionUpdateOneRequiredWithoutFieldsInput
		permissionField?: EntityPermissionFieldUpdateManyWithoutFieldInput
	}

	export type EntityFieldUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		permanentId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		dataType?: EnumEnumDataTypeFieldUpdateOperationsInput | EnumDataType
		properties?: JsonNullValueInput | InputJsonValue
		required?: BoolFieldUpdateOperationsInput | boolean
		searchable?: BoolFieldUpdateOperationsInput | boolean
		description?: StringFieldUpdateOperationsInput | string
		position?: NullableIntFieldUpdateOperationsInput | number | null
		unique?: BoolFieldUpdateOperationsInput | boolean
		permissionField?: EntityPermissionFieldUncheckedUpdateManyWithoutFieldInput
	}

	export type EntityFieldCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityVersionId: string
		permanentId?: string
		name: string
		displayName: string
		dataType: EnumDataType
		properties: JsonNullValueInput | InputJsonValue
		required: boolean
		searchable: boolean
		description: string
		position?: number | null
		unique?: boolean
	}

	export type EntityFieldUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		permanentId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		dataType?: EnumEnumDataTypeFieldUpdateOperationsInput | EnumDataType
		properties?: JsonNullValueInput | InputJsonValue
		required?: BoolFieldUpdateOperationsInput | boolean
		searchable?: BoolFieldUpdateOperationsInput | boolean
		description?: StringFieldUpdateOperationsInput | string
		position?: NullableIntFieldUpdateOperationsInput | number | null
		unique?: BoolFieldUpdateOperationsInput | boolean
	}

	export type EntityFieldUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		permanentId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		dataType?: EnumEnumDataTypeFieldUpdateOperationsInput | EnumDataType
		properties?: JsonNullValueInput | InputJsonValue
		required?: BoolFieldUpdateOperationsInput | boolean
		searchable?: BoolFieldUpdateOperationsInput | boolean
		description?: StringFieldUpdateOperationsInput | string
		position?: NullableIntFieldUpdateOperationsInput | number | null
		unique?: BoolFieldUpdateOperationsInput | boolean
	}

	export type BlockCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		resource: ResourceCreateNestedOneWithoutBlocksInput
		lockedByUser?: UserCreateNestedOneWithoutLockedBlocksInput
		parentBlock?: BlockCreateNestedOneWithoutBlocksInput
		blocks?: BlockCreateNestedManyWithoutParentBlockInput
		versions?: BlockVersionCreateNestedManyWithoutBlockInput
	}

	export type BlockUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		parentBlockId?: string | null
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		blocks?: BlockUncheckedCreateNestedManyWithoutParentBlockInput
		versions?: BlockVersionUncheckedCreateNestedManyWithoutBlockInput
	}

	export type BlockUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resource?: ResourceUpdateOneRequiredWithoutBlocksInput
		lockedByUser?: UserUpdateOneWithoutLockedBlocksInput
		parentBlock?: BlockUpdateOneWithoutBlocksInput
		blocks?: BlockUpdateManyWithoutParentBlockInput
		versions?: BlockVersionUpdateManyWithoutBlockInput
	}

	export type BlockUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		parentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		blocks?: BlockUncheckedUpdateManyWithoutParentBlockInput
		versions?: BlockVersionUncheckedUpdateManyWithoutBlockInput
	}

	export type BlockCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		parentBlockId?: string | null
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
	}

	export type BlockUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type BlockUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		parentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type BlockVersionCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		deleted?: boolean | null
		block: BlockCreateNestedOneWithoutVersionsInput
		commit?: CommitCreateNestedOneWithoutBlockVersionsInput
		builds?: BuildCreateNestedManyWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockId: string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
		builds?: BuildUncheckedCreateNestedManyWithoutBlockVersionsInput
	}

	export type BlockVersionUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		block?: BlockUpdateOneRequiredWithoutVersionsInput
		commit?: CommitUpdateOneWithoutBlockVersionsInput
		builds?: BuildUpdateManyWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		builds?: BuildUncheckedUpdateManyWithoutBlockVersionsInput
	}

	export type BlockVersionCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockId: string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
	}

	export type BlockVersionUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
	}

	export type BlockVersionUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
	}

	export type ActionCreateInput = {
		id?: string
		createdAt?: Date | string
		steps?: ActionStepCreateNestedManyWithoutActionInput
		builds?: BuildCreateNestedManyWithoutActionInput
		deployments?: DeploymentCreateNestedManyWithoutActionInput
	}

	export type ActionUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		steps?: ActionStepUncheckedCreateNestedManyWithoutActionInput
		builds?: BuildUncheckedCreateNestedManyWithoutActionInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutActionInput
	}

	export type ActionUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		steps?: ActionStepUpdateManyWithoutActionInput
		builds?: BuildUpdateManyWithoutActionInput
		deployments?: DeploymentUpdateManyWithoutActionInput
	}

	export type ActionUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		steps?: ActionStepUncheckedUpdateManyWithoutActionInput
		builds?: BuildUncheckedUpdateManyWithoutActionInput
		deployments?: DeploymentUncheckedUpdateManyWithoutActionInput
	}

	export type ActionCreateManyInput = {
		id?: string
		createdAt?: Date | string
	}

	export type ActionUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ActionUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ActionStepCreateInput = {
		id?: string
		createdAt?: Date | string
		message: string
		status: ActionStepStatus
		completedAt?: Date | string | null
		name?: string
		action: ActionCreateNestedOneWithoutStepsInput
		logs?: ActionLogCreateNestedManyWithoutStepInput
	}

	export type ActionStepUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		message: string
		status: ActionStepStatus
		completedAt?: Date | string | null
		actionId: string
		name?: string
		logs?: ActionLogUncheckedCreateNestedManyWithoutStepInput
	}

	export type ActionStepUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		status?: EnumActionStepStatusFieldUpdateOperationsInput | ActionStepStatus
		completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		name?: StringFieldUpdateOperationsInput | string
		action?: ActionUpdateOneRequiredWithoutStepsInput
		logs?: ActionLogUpdateManyWithoutStepInput
	}

	export type ActionStepUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		status?: EnumActionStepStatusFieldUpdateOperationsInput | ActionStepStatus
		completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		logs?: ActionLogUncheckedUpdateManyWithoutStepInput
	}

	export type ActionStepCreateManyInput = {
		id?: string
		createdAt?: Date | string
		message: string
		status: ActionStepStatus
		completedAt?: Date | string | null
		actionId: string
		name?: string
	}

	export type ActionStepUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		status?: EnumActionStepStatusFieldUpdateOperationsInput | ActionStepStatus
		completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		name?: StringFieldUpdateOperationsInput | string
	}

	export type ActionStepUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		status?: EnumActionStepStatusFieldUpdateOperationsInput | ActionStepStatus
		completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
	}

	export type ActionLogCreateInput = {
		id?: string
		createdAt?: Date | string
		message: string
		meta: JsonNullValueInput | InputJsonValue
		level: EnumLogLevel
		step: ActionStepCreateNestedOneWithoutLogsInput
	}

	export type ActionLogUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		message: string
		meta: JsonNullValueInput | InputJsonValue
		level: EnumLogLevel
		stepId: string
	}

	export type ActionLogUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		meta?: JsonNullValueInput | InputJsonValue
		level?: EnumEnumLogLevelFieldUpdateOperationsInput | EnumLogLevel
		step?: ActionStepUpdateOneRequiredWithoutLogsInput
	}

	export type ActionLogUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		meta?: JsonNullValueInput | InputJsonValue
		level?: EnumEnumLogLevelFieldUpdateOperationsInput | EnumLogLevel
		stepId?: StringFieldUpdateOperationsInput | string
	}

	export type ActionLogCreateManyInput = {
		id?: string
		createdAt?: Date | string
		message: string
		meta: JsonNullValueInput | InputJsonValue
		level: EnumLogLevel
		stepId: string
	}

	export type ActionLogUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		meta?: JsonNullValueInput | InputJsonValue
		level?: EnumEnumLogLevelFieldUpdateOperationsInput | EnumLogLevel
	}

	export type ActionLogUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		meta?: JsonNullValueInput | InputJsonValue
		level?: EnumEnumLogLevelFieldUpdateOperationsInput | EnumLogLevel
		stepId?: StringFieldUpdateOperationsInput | string
	}

	export type BuildCreateInput = {
		id?: string
		createdAt?: Date | string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutBuildsInput
		resource: ResourceCreateNestedOneWithoutBuildsInput
		commit?: CommitCreateNestedOneWithoutBuildsInput
		createdBy: UserCreateNestedOneWithoutBuildsInput
		deployments?: DeploymentCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionCreateNestedManyWithoutBuildsInput
	}

	export type BuildUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		userId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
		deployments?: DeploymentUncheckedCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutBuildsInput
	}

	export type BuildUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutBuildsInput
		resource?: ResourceUpdateOneRequiredWithoutBuildsInput
		commit?: CommitUpdateOneWithoutBuildsInput
		createdBy?: UserUpdateOneRequiredWithoutBuildsInput
		deployments?: DeploymentUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUpdateManyWithoutBuildsInput
	}

	export type BuildUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		userId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deployments?: DeploymentUncheckedUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutBuildsInput
	}

	export type BuildCreateManyInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		userId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
	}

	export type BuildUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type BuildUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		userId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type ReleaseCreateInput = {
		id?: string
		createdAt?: Date | string
		version: string
		description?: string | null
		commit: CommitCreateNestedOneWithoutReleasesInput
	}

	export type ReleaseUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		version: string
		description?: string | null
		commitId: string
	}

	export type ReleaseUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commit?: CommitUpdateOneRequiredWithoutReleasesInput
	}

	export type ReleaseUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: StringFieldUpdateOperationsInput | string
	}

	export type ReleaseCreateManyInput = {
		id?: string
		createdAt?: Date | string
		version: string
		description?: string | null
		commitId: string
	}

	export type ReleaseUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type ReleaseUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: StringFieldUpdateOperationsInput | string
	}

	export type EnvironmentCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description?: string | null
		address: string
		resource: ResourceCreateNestedOneWithoutEnvironmentsInput
		deployments?: DeploymentCreateNestedManyWithoutEnvironmentInput
	}

	export type EnvironmentUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		description?: string | null
		address: string
		deployments?: DeploymentUncheckedCreateNestedManyWithoutEnvironmentInput
	}

	export type EnvironmentUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		address?: StringFieldUpdateOperationsInput | string
		resource?: ResourceUpdateOneRequiredWithoutEnvironmentsInput
		deployments?: DeploymentUpdateManyWithoutEnvironmentInput
	}

	export type EnvironmentUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		address?: StringFieldUpdateOperationsInput | string
		deployments?: DeploymentUncheckedUpdateManyWithoutEnvironmentInput
	}

	export type EnvironmentCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		description?: string | null
		address: string
	}

	export type EnvironmentUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		address?: StringFieldUpdateOperationsInput | string
	}

	export type EnvironmentUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		address?: StringFieldUpdateOperationsInput | string
	}

	export type DeploymentCreateInput = {
		id?: string
		createdAt?: Date | string
		status: EnumDeploymentStatus
		message?: string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutDeploymentsInput
		build: BuildCreateNestedOneWithoutDeploymentsInput
		environment: EnvironmentCreateNestedOneWithoutDeploymentsInput
		createdBy: UserCreateNestedOneWithoutDeploymentsInput
	}

	export type DeploymentUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		buildId: string
		environmentId: string
		status: EnumDeploymentStatus
		message?: string | null
		actionId: string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type DeploymentUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutDeploymentsInput
		build?: BuildUpdateOneRequiredWithoutDeploymentsInput
		environment?: EnvironmentUpdateOneRequiredWithoutDeploymentsInput
		createdBy?: UserUpdateOneRequiredWithoutDeploymentsInput
	}

	export type DeploymentUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		buildId?: StringFieldUpdateOperationsInput | string
		environmentId?: StringFieldUpdateOperationsInput | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type DeploymentCreateManyInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		buildId: string
		environmentId: string
		status: EnumDeploymentStatus
		message?: string | null
		actionId: string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type DeploymentUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type DeploymentUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		buildId?: StringFieldUpdateOperationsInput | string
		environmentId?: StringFieldUpdateOperationsInput | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type InvitationCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		invitedByUser: UserCreateNestedOneWithoutSentInvitationsInput
		workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
		newUser?: UserCreateNestedOneWithoutCreatedFromInvitationInput
		token: string
		tokenExpiration: Date | string
	}

	export type InvitationUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		invitedByUserId: string
		workspaceId: string
		newUserId?: string | null
		token: string
		tokenExpiration: Date | string
	}

	export type InvitationUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		invitedByUser?: UserUpdateOneRequiredWithoutSentInvitationsInput
		workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsInput
		newUser?: UserUpdateOneWithoutCreatedFromInvitationInput
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type InvitationUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		invitedByUserId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		newUserId?: NullableStringFieldUpdateOperationsInput | string | null
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type InvitationCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		invitedByUserId: string
		workspaceId: string
		newUserId?: string | null
		token: string
		tokenExpiration: Date | string
	}

	export type InvitationUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type InvitationUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		invitedByUserId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		newUserId?: NullableStringFieldUpdateOperationsInput | string | null
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type SubscriptionCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		workspace: WorkspaceCreateNestedOneWithoutSubscriptionsInput
		subscriptionPlan: EnumSubscriptionPlan
		status: EnumSubscriptionStatus
		subscriptionData: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: Date | string | null
	}

	export type SubscriptionUncheckedCreateInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		workspaceId: string
		subscriptionPlan: EnumSubscriptionPlan
		status: EnumSubscriptionStatus
		subscriptionData: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: Date | string | null
	}

	export type SubscriptionUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		workspace?: WorkspaceUpdateOneRequiredWithoutSubscriptionsInput
		subscriptionPlan?: EnumEnumSubscriptionPlanFieldUpdateOperationsInput | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusFieldUpdateOperationsInput | EnumSubscriptionStatus
		subscriptionData?: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type SubscriptionUncheckedUpdateInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		subscriptionPlan?: EnumEnumSubscriptionPlanFieldUpdateOperationsInput | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusFieldUpdateOperationsInput | EnumSubscriptionStatus
		subscriptionData?: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type SubscriptionCreateManyInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		workspaceId: string
		subscriptionPlan: EnumSubscriptionPlan
		status: EnumSubscriptionStatus
		subscriptionData: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: Date | string | null
	}

	export type SubscriptionUpdateManyMutationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		subscriptionPlan?: EnumEnumSubscriptionPlanFieldUpdateOperationsInput | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusFieldUpdateOperationsInput | EnumSubscriptionStatus
		subscriptionData?: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type SubscriptionUncheckedUpdateManyInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		subscriptionPlan?: EnumEnumSubscriptionPlanFieldUpdateOperationsInput | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusFieldUpdateOperationsInput | EnumSubscriptionStatus
		subscriptionData?: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type StringFilter = {
		equals?: string
		in?: Enumerable<string>
		notIn?: Enumerable<string>
		lt?: string
		lte?: string
		gt?: string
		gte?: string
		contains?: string
		startsWith?: string
		endsWith?: string
		mode?: QueryMode
		not?: NestedStringFilter | string
	}

	export type DateTimeFilter = {
		equals?: Date | string
		in?: Enumerable<Date> | Enumerable<string>
		notIn?: Enumerable<Date> | Enumerable<string>
		lt?: Date | string
		lte?: Date | string
		gt?: Date | string
		gte?: Date | string
		not?: NestedDateTimeFilter | Date | string
	}

	export type StringNullableFilter = {
		equals?: string | null
		in?: Enumerable<string> | null
		notIn?: Enumerable<string> | null
		lt?: string
		lte?: string
		gt?: string
		gte?: string
		contains?: string
		startsWith?: string
		endsWith?: string
		mode?: QueryMode
		not?: NestedStringNullableFilter | string | null
	}

	export type UserRelationFilter = {
		is?: UserWhereInput | null
		isNot?: UserWhereInput | null
	}

	export type UserListRelationFilter = {
		every?: UserWhereInput
		some?: UserWhereInput
		none?: UserWhereInput
	}

	export type UserOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type AccountCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		password?: SortOrder
		currentUserId?: SortOrder
		githubId?: SortOrder
	}

	export type AccountMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		password?: SortOrder
		currentUserId?: SortOrder
		githubId?: SortOrder
	}

	export type AccountMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		firstName?: SortOrder
		lastName?: SortOrder
		password?: SortOrder
		currentUserId?: SortOrder
		githubId?: SortOrder
	}

	export type StringWithAggregatesFilter = {
		equals?: string
		in?: Enumerable<string>
		notIn?: Enumerable<string>
		lt?: string
		lte?: string
		gt?: string
		gte?: string
		contains?: string
		startsWith?: string
		endsWith?: string
		mode?: QueryMode
		not?: NestedStringWithAggregatesFilter | string
		_count?: NestedIntFilter
		_min?: NestedStringFilter
		_max?: NestedStringFilter
	}

	export type DateTimeWithAggregatesFilter = {
		equals?: Date | string
		in?: Enumerable<Date> | Enumerable<string>
		notIn?: Enumerable<Date> | Enumerable<string>
		lt?: Date | string
		lte?: Date | string
		gt?: Date | string
		gte?: Date | string
		not?: NestedDateTimeWithAggregatesFilter | Date | string
		_count?: NestedIntFilter
		_min?: NestedDateTimeFilter
		_max?: NestedDateTimeFilter
	}

	export type StringNullableWithAggregatesFilter = {
		equals?: string | null
		in?: Enumerable<string> | null
		notIn?: Enumerable<string> | null
		lt?: string
		lte?: string
		gt?: string
		gte?: string
		contains?: string
		startsWith?: string
		endsWith?: string
		mode?: QueryMode
		not?: NestedStringNullableWithAggregatesFilter | string | null
		_count?: NestedIntNullableFilter
		_min?: NestedStringNullableFilter
		_max?: NestedStringNullableFilter
	}

	export type InvitationListRelationFilter = {
		every?: InvitationWhereInput
		some?: InvitationWhereInput
		none?: InvitationWhereInput
	}

	export type SubscriptionListRelationFilter = {
		every?: SubscriptionWhereInput
		some?: SubscriptionWhereInput
		none?: SubscriptionWhereInput
	}

	export type GitOrganizationListRelationFilter = {
		every?: GitOrganizationWhereInput
		some?: GitOrganizationWhereInput
		none?: GitOrganizationWhereInput
	}

	export type ProjectListRelationFilter = {
		every?: ProjectWhereInput
		some?: ProjectWhereInput
		none?: ProjectWhereInput
	}

	export type InvitationOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type SubscriptionOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type GitOrganizationOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type ProjectOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type WorkspaceCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
	}

	export type WorkspaceMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
	}

	export type WorkspaceMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
	}

	export type WorkspaceRelationFilter = {
		is?: WorkspaceWhereInput
		isNot?: WorkspaceWhereInput
	}

	export type ResourceListRelationFilter = {
		every?: ResourceWhereInput
		some?: ResourceWhereInput
		none?: ResourceWhereInput
	}

	export type DateTimeNullableFilter = {
		equals?: Date | string | null
		in?: Enumerable<Date> | Enumerable<string> | null
		notIn?: Enumerable<Date> | Enumerable<string> | null
		lt?: Date | string
		lte?: Date | string
		gt?: Date | string
		gte?: Date | string
		not?: NestedDateTimeNullableFilter | Date | string | null
	}

	export type CommitListRelationFilter = {
		every?: CommitWhereInput
		some?: CommitWhereInput
		none?: CommitWhereInput
	}

	export type ResourceOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type CommitOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type ProjectWorkspaceIdNameCompoundUniqueInput = {
		workspaceId: string
		name: string
	}

	export type ProjectCountOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
		workspaceId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		deletedAt?: SortOrder
	}

	export type ProjectMaxOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
		workspaceId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		deletedAt?: SortOrder
	}

	export type ProjectMinOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
		workspaceId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		deletedAt?: SortOrder
	}

	export type DateTimeNullableWithAggregatesFilter = {
		equals?: Date | string | null
		in?: Enumerable<Date> | Enumerable<string> | null
		notIn?: Enumerable<Date> | Enumerable<string> | null
		lt?: Date | string
		lte?: Date | string
		gt?: Date | string
		gte?: Date | string
		not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
		_count?: NestedIntNullableFilter
		_min?: NestedDateTimeNullableFilter
		_max?: NestedDateTimeNullableFilter
	}

	export type EnumEnumGitProviderFilter = {
		equals?: EnumGitProvider
		in?: Enumerable<EnumGitProvider>
		notIn?: Enumerable<EnumGitProvider>
		not?: NestedEnumEnumGitProviderFilter | EnumGitProvider
	}

	export type EnumEnumGitOrganizationTypeNullableFilter = {
		equals?: EnumGitOrganizationType | null
		in?: Enumerable<EnumGitOrganizationType> | null
		notIn?: Enumerable<EnumGitOrganizationType> | null
		not?: NestedEnumEnumGitOrganizationTypeNullableFilter | EnumGitOrganizationType | null
	}

	export type GitRepositoryListRelationFilter = {
		every?: GitRepositoryWhereInput
		some?: GitRepositoryWhereInput
		none?: GitRepositoryWhereInput
	}

	export type GitRepositoryOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type GitOrganizationProviderInstallationIdCompoundUniqueInput = {
		provider: EnumGitProvider
		installationId: string
	}

	export type GitOrganizationCountOrderByAggregateInput = {
		id?: SortOrder
		provider?: SortOrder
		name?: SortOrder
		installationId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		type?: SortOrder
	}

	export type GitOrganizationMaxOrderByAggregateInput = {
		id?: SortOrder
		provider?: SortOrder
		name?: SortOrder
		installationId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		type?: SortOrder
	}

	export type GitOrganizationMinOrderByAggregateInput = {
		id?: SortOrder
		provider?: SortOrder
		name?: SortOrder
		installationId?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		type?: SortOrder
	}

	export type EnumEnumGitProviderWithAggregatesFilter = {
		equals?: EnumGitProvider
		in?: Enumerable<EnumGitProvider>
		notIn?: Enumerable<EnumGitProvider>
		not?: NestedEnumEnumGitProviderWithAggregatesFilter | EnumGitProvider
		_count?: NestedIntFilter
		_min?: NestedEnumEnumGitProviderFilter
		_max?: NestedEnumEnumGitProviderFilter
	}

	export type EnumEnumGitOrganizationTypeNullableWithAggregatesFilter = {
		equals?: EnumGitOrganizationType | null
		in?: Enumerable<EnumGitOrganizationType> | null
		notIn?: Enumerable<EnumGitOrganizationType> | null
		not?: NestedEnumEnumGitOrganizationTypeNullableWithAggregatesFilter | EnumGitOrganizationType | null
		_count?: NestedIntNullableFilter
		_min?: NestedEnumEnumGitOrganizationTypeNullableFilter
		_max?: NestedEnumEnumGitOrganizationTypeNullableFilter
	}

	export type GitOrganizationRelationFilter = {
		is?: GitOrganizationWhereInput
		isNot?: GitOrganizationWhereInput
	}

	export type GitRepositoryCountOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		gitOrganizationId?: SortOrder
	}

	export type GitRepositoryMaxOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		gitOrganizationId?: SortOrder
	}

	export type GitRepositoryMinOrderByAggregateInput = {
		id?: SortOrder
		name?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		gitOrganizationId?: SortOrder
	}

	export type BoolFilter = {
		equals?: boolean
		not?: NestedBoolFilter | boolean
	}

	export type AccountRelationFilter = {
		is?: AccountWhereInput
		isNot?: AccountWhereInput
	}

	export type ApiTokenListRelationFilter = {
		every?: ApiTokenWhereInput
		some?: ApiTokenWhereInput
		none?: ApiTokenWhereInput
	}

	export type BlockListRelationFilter = {
		every?: BlockWhereInput
		some?: BlockWhereInput
		none?: BlockWhereInput
	}

	export type BuildListRelationFilter = {
		every?: BuildWhereInput
		some?: BuildWhereInput
		none?: BuildWhereInput
	}

	export type DeploymentListRelationFilter = {
		every?: DeploymentWhereInput
		some?: DeploymentWhereInput
		none?: DeploymentWhereInput
	}

	export type EntityListRelationFilter = {
		every?: EntityWhereInput
		some?: EntityWhereInput
		none?: EntityWhereInput
	}

	export type UserRoleListRelationFilter = {
		every?: UserRoleWhereInput
		some?: UserRoleWhereInput
		none?: UserRoleWhereInput
	}

	export type InvitationRelationFilter = {
		is?: InvitationWhereInput | null
		isNot?: InvitationWhereInput | null
	}

	export type ApiTokenOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type BlockOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type BuildOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type DeploymentOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type EntityOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type UserRoleOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type UserAccountIdWorkspaceIdCompoundUniqueInput = {
		accountId: string
		workspaceId: string
	}

	export type UserCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		accountId?: SortOrder
		workspaceId?: SortOrder
		isOwner?: SortOrder
		deletedAt?: SortOrder
	}

	export type UserMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		accountId?: SortOrder
		workspaceId?: SortOrder
		isOwner?: SortOrder
		deletedAt?: SortOrder
	}

	export type UserMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		accountId?: SortOrder
		workspaceId?: SortOrder
		isOwner?: SortOrder
		deletedAt?: SortOrder
	}

	export type BoolWithAggregatesFilter = {
		equals?: boolean
		not?: NestedBoolWithAggregatesFilter | boolean
		_count?: NestedIntFilter
		_min?: NestedBoolFilter
		_max?: NestedBoolFilter
	}

	export type UserRoleUserIdRoleCompoundUniqueInput = {
		userId: string
		role: string
	}

	export type UserRoleCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		userId?: SortOrder
		role?: SortOrder
	}

	export type UserRoleMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		userId?: SortOrder
		role?: SortOrder
	}

	export type UserRoleMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		userId?: SortOrder
		role?: SortOrder
	}

	export type ApiTokenUserIdNameCompoundUniqueInput = {
		userId: string
		name: string
	}

	export type ApiTokenCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		userId?: SortOrder
		token?: SortOrder
		previewChars?: SortOrder
		lastAccessAt?: SortOrder
	}

	export type ApiTokenMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		userId?: SortOrder
		token?: SortOrder
		previewChars?: SortOrder
		lastAccessAt?: SortOrder
	}

	export type ApiTokenMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		userId?: SortOrder
		token?: SortOrder
		previewChars?: SortOrder
		lastAccessAt?: SortOrder
	}

	export type ResourceRoleListRelationFilter = {
		every?: ResourceRoleWhereInput
		some?: ResourceRoleWhereInput
		none?: ResourceRoleWhereInput
	}

	export type EnvironmentListRelationFilter = {
		every?: EnvironmentWhereInput
		some?: EnvironmentWhereInput
		none?: EnvironmentWhereInput
	}

	export type GitRepositoryRelationFilter = {
		is?: GitRepositoryWhereInput | null
		isNot?: GitRepositoryWhereInput | null
	}

	export type ProjectRelationFilter = {
		is?: ProjectWhereInput
		isNot?: ProjectWhereInput
	}

	export type EnumEnumResourceTypeFilter = {
		equals?: EnumResourceType
		in?: Enumerable<EnumResourceType>
		notIn?: Enumerable<EnumResourceType>
		not?: NestedEnumEnumResourceTypeFilter | EnumResourceType
	}

	export type ResourceRoleOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type EnvironmentOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type ResourceProjectIdNameCompoundUniqueInput = {
		projectId: string
		name: string
	}

	export type ResourceCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		description?: SortOrder
		gitRepositoryOverride?: SortOrder
		githubLastSync?: SortOrder
		githubLastMessage?: SortOrder
		deletedAt?: SortOrder
		gitRepositoryId?: SortOrder
		projectId?: SortOrder
		resourceType?: SortOrder
	}

	export type ResourceMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		description?: SortOrder
		gitRepositoryOverride?: SortOrder
		githubLastSync?: SortOrder
		githubLastMessage?: SortOrder
		deletedAt?: SortOrder
		gitRepositoryId?: SortOrder
		projectId?: SortOrder
		resourceType?: SortOrder
	}

	export type ResourceMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		name?: SortOrder
		description?: SortOrder
		gitRepositoryOverride?: SortOrder
		githubLastSync?: SortOrder
		githubLastMessage?: SortOrder
		deletedAt?: SortOrder
		gitRepositoryId?: SortOrder
		projectId?: SortOrder
		resourceType?: SortOrder
	}

	export type EnumEnumResourceTypeWithAggregatesFilter = {
		equals?: EnumResourceType
		in?: Enumerable<EnumResourceType>
		notIn?: Enumerable<EnumResourceType>
		not?: NestedEnumEnumResourceTypeWithAggregatesFilter | EnumResourceType
		_count?: NestedIntFilter
		_min?: NestedEnumEnumResourceTypeFilter
		_max?: NestedEnumEnumResourceTypeFilter
	}

	export type ResourceRelationFilter = {
		is?: ResourceWhereInput
		isNot?: ResourceWhereInput
	}

	export type EntityPermissionRoleListRelationFilter = {
		every?: EntityPermissionRoleWhereInput
		some?: EntityPermissionRoleWhereInput
		none?: EntityPermissionRoleWhereInput
	}

	export type EntityPermissionRoleOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type ResourceRoleResourceIdDisplayNameCompoundUniqueInput = {
		resourceId: string
		displayName: string
	}

	export type ResourceRoleResourceIdNameCompoundUniqueInput = {
		resourceId: string
		name: string
	}

	export type ResourceRoleCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
	}

	export type ResourceRoleMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
	}

	export type ResourceRoleMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
	}

	export type BlockVersionListRelationFilter = {
		every?: BlockVersionWhereInput
		some?: BlockVersionWhereInput
		none?: BlockVersionWhereInput
	}

	export type EntityVersionListRelationFilter = {
		every?: EntityVersionWhereInput
		some?: EntityVersionWhereInput
		none?: EntityVersionWhereInput
	}

	export type ReleaseListRelationFilter = {
		every?: ReleaseWhereInput
		some?: ReleaseWhereInput
		none?: ReleaseWhereInput
	}

	export type BlockVersionOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type EntityVersionOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type ReleaseOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type CommitCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		message?: SortOrder
		projectId?: SortOrder
	}

	export type CommitMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		message?: SortOrder
		projectId?: SortOrder
	}

	export type CommitMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		message?: SortOrder
		projectId?: SortOrder
	}

	export type EntityResourceIdDisplayNameCompoundUniqueInput = {
		resourceId: string
		displayName: string
	}

	export type EntityResourceIdNameCompoundUniqueInput = {
		resourceId: string
		name: string
	}

	export type EntityResourceIdPluralDisplayNameCompoundUniqueInput = {
		resourceId: string
		pluralDisplayName: string
	}

	export type EntityCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
	}

	export type EntityMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
	}

	export type EntityMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
	}

	export type IntFilter = {
		equals?: number
		in?: Enumerable<number>
		notIn?: Enumerable<number>
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedIntFilter | number
	}

	export type BoolNullableFilter = {
		equals?: boolean | null
		not?: NestedBoolNullableFilter | boolean | null
	}

	export type CommitRelationFilter = {
		is?: CommitWhereInput | null
		isNot?: CommitWhereInput | null
	}

	export type EntityRelationFilter = {
		is?: EntityWhereInput
		isNot?: EntityWhereInput
	}

	export type EntityFieldListRelationFilter = {
		every?: EntityFieldWhereInput
		some?: EntityFieldWhereInput
		none?: EntityFieldWhereInput
	}

	export type EntityPermissionListRelationFilter = {
		every?: EntityPermissionWhereInput
		some?: EntityPermissionWhereInput
		none?: EntityPermissionWhereInput
	}

	export type EntityFieldOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type EntityPermissionOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type EntityVersionEntityIdVersionNumberCompoundUniqueInput = {
		entityId: string
		versionNumber: number
	}

	export type EntityVersionCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityId?: SortOrder
		versionNumber?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
	}

	export type EntityVersionAvgOrderByAggregateInput = {
		versionNumber?: SortOrder
	}

	export type EntityVersionMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityId?: SortOrder
		versionNumber?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
	}

	export type EntityVersionMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityId?: SortOrder
		versionNumber?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		pluralDisplayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
	}

	export type EntityVersionSumOrderByAggregateInput = {
		versionNumber?: SortOrder
	}

	export type IntWithAggregatesFilter = {
		equals?: number
		in?: Enumerable<number>
		notIn?: Enumerable<number>
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedIntWithAggregatesFilter | number
		_count?: NestedIntFilter
		_avg?: NestedFloatFilter
		_sum?: NestedIntFilter
		_min?: NestedIntFilter
		_max?: NestedIntFilter
	}

	export type BoolNullableWithAggregatesFilter = {
		equals?: boolean | null
		not?: NestedBoolNullableWithAggregatesFilter | boolean | null
		_count?: NestedIntNullableFilter
		_min?: NestedBoolNullableFilter
		_max?: NestedBoolNullableFilter
	}

	export type EnumEnumEntityActionFilter = {
		equals?: EnumEntityAction
		in?: Enumerable<EnumEntityAction>
		notIn?: Enumerable<EnumEntityAction>
		not?: NestedEnumEnumEntityActionFilter | EnumEntityAction
	}

	export type EnumEnumEntityPermissionTypeFilter = {
		equals?: EnumEntityPermissionType
		in?: Enumerable<EnumEntityPermissionType>
		notIn?: Enumerable<EnumEntityPermissionType>
		not?: NestedEnumEnumEntityPermissionTypeFilter | EnumEntityPermissionType
	}

	export type EntityVersionRelationFilter = {
		is?: EntityVersionWhereInput
		isNot?: EntityVersionWhereInput
	}

	export type EntityPermissionFieldListRelationFilter = {
		every?: EntityPermissionFieldWhereInput
		some?: EntityPermissionFieldWhereInput
		none?: EntityPermissionFieldWhereInput
	}

	export type EntityPermissionFieldOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type EntityPermissionEntityVersionIdActionCompoundUniqueInput = {
		entityVersionId: string
		action: EnumEntityAction
	}

	export type EntityPermissionCountOrderByAggregateInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		type?: SortOrder
	}

	export type EntityPermissionMaxOrderByAggregateInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		type?: SortOrder
	}

	export type EntityPermissionMinOrderByAggregateInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		type?: SortOrder
	}

	export type EnumEnumEntityActionWithAggregatesFilter = {
		equals?: EnumEntityAction
		in?: Enumerable<EnumEntityAction>
		notIn?: Enumerable<EnumEntityAction>
		not?: NestedEnumEnumEntityActionWithAggregatesFilter | EnumEntityAction
		_count?: NestedIntFilter
		_min?: NestedEnumEnumEntityActionFilter
		_max?: NestedEnumEnumEntityActionFilter
	}

	export type EnumEnumEntityPermissionTypeWithAggregatesFilter = {
		equals?: EnumEntityPermissionType
		in?: Enumerable<EnumEntityPermissionType>
		notIn?: Enumerable<EnumEntityPermissionType>
		not?: NestedEnumEnumEntityPermissionTypeWithAggregatesFilter | EnumEntityPermissionType
		_count?: NestedIntFilter
		_min?: NestedEnumEnumEntityPermissionTypeFilter
		_max?: NestedEnumEnumEntityPermissionTypeFilter
	}

	export type ResourceRoleRelationFilter = {
		is?: ResourceRoleWhereInput
		isNot?: ResourceRoleWhereInput
	}

	export type EntityPermissionRelationFilter = {
		is?: EntityPermissionWhereInput
		isNot?: EntityPermissionWhereInput
	}

	export type EntityPermissionRoleEntityVersionIdActionResourceRoleIdCompoundUniqueInput = {
		entityVersionId: string
		action: EnumEntityAction
		resourceRoleId: string
	}

	export type EntityPermissionRoleCountOrderByAggregateInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		resourceRoleId?: SortOrder
	}

	export type EntityPermissionRoleMaxOrderByAggregateInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		resourceRoleId?: SortOrder
	}

	export type EntityPermissionRoleMinOrderByAggregateInput = {
		id?: SortOrder
		entityVersionId?: SortOrder
		action?: SortOrder
		resourceRoleId?: SortOrder
	}

	export type EntityFieldRelationFilter = {
		is?: EntityFieldWhereInput
		isNot?: EntityFieldWhereInput
	}

	export type EntityPermissionFieldPermissionIdFieldPermanentIdCompoundUniqueInput = {
		permissionId: string
		fieldPermanentId: string
	}

	export type EntityPermissionFieldCountOrderByAggregateInput = {
		id?: SortOrder
		permissionId?: SortOrder
		fieldPermanentId?: SortOrder
		entityVersionId?: SortOrder
	}

	export type EntityPermissionFieldMaxOrderByAggregateInput = {
		id?: SortOrder
		permissionId?: SortOrder
		fieldPermanentId?: SortOrder
		entityVersionId?: SortOrder
	}

	export type EntityPermissionFieldMinOrderByAggregateInput = {
		id?: SortOrder
		permissionId?: SortOrder
		fieldPermanentId?: SortOrder
		entityVersionId?: SortOrder
	}

	export type EnumEnumDataTypeFilter = {
		equals?: EnumDataType
		in?: Enumerable<EnumDataType>
		notIn?: Enumerable<EnumDataType>
		not?: NestedEnumEnumDataTypeFilter | EnumDataType
	}
	export type JsonFilter =
		| PatchUndefined<
		Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
		Required<JsonFilterBase>
		>
		| OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

	export type JsonFilterBase = {
		equals?: JsonNullValueFilter | InputJsonValue
		not?: JsonNullValueFilter | InputJsonValue
	}

	export type IntNullableFilter = {
		equals?: number | null
		in?: Enumerable<number> | null
		notIn?: Enumerable<number> | null
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedIntNullableFilter | number | null
	}

	export type EntityFieldEntityVersionIdDisplayNameCompoundUniqueInput = {
		entityVersionId: string
		displayName: string
	}

	export type EntityFieldEntityVersionIdNameCompoundUniqueInput = {
		entityVersionId: string
		name: string
	}

	export type EntityFieldEntityVersionIdPermanentIdCompoundUniqueInput = {
		entityVersionId: string
		permanentId: string
	}

	export type EntityFieldCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityVersionId?: SortOrder
		permanentId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		dataType?: SortOrder
		properties?: SortOrder
		required?: SortOrder
		searchable?: SortOrder
		description?: SortOrder
		position?: SortOrder
		unique?: SortOrder
	}

	export type EntityFieldAvgOrderByAggregateInput = {
		position?: SortOrder
	}

	export type EntityFieldMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityVersionId?: SortOrder
		permanentId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		dataType?: SortOrder
		required?: SortOrder
		searchable?: SortOrder
		description?: SortOrder
		position?: SortOrder
		unique?: SortOrder
	}

	export type EntityFieldMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		entityVersionId?: SortOrder
		permanentId?: SortOrder
		name?: SortOrder
		displayName?: SortOrder
		dataType?: SortOrder
		required?: SortOrder
		searchable?: SortOrder
		description?: SortOrder
		position?: SortOrder
		unique?: SortOrder
	}

	export type EntityFieldSumOrderByAggregateInput = {
		position?: SortOrder
	}

	export type EnumEnumDataTypeWithAggregatesFilter = {
		equals?: EnumDataType
		in?: Enumerable<EnumDataType>
		notIn?: Enumerable<EnumDataType>
		not?: NestedEnumEnumDataTypeWithAggregatesFilter | EnumDataType
		_count?: NestedIntFilter
		_min?: NestedEnumEnumDataTypeFilter
		_max?: NestedEnumEnumDataTypeFilter
	}
	export type JsonWithAggregatesFilter =
		| PatchUndefined<
		Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
		Required<JsonWithAggregatesFilterBase>
		>
		| OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

	export type JsonWithAggregatesFilterBase = {
		equals?: JsonNullValueFilter | InputJsonValue
		not?: JsonNullValueFilter | InputJsonValue
		_count?: NestedIntFilter
		_min?: NestedJsonFilter
		_max?: NestedJsonFilter
	}

	export type IntNullableWithAggregatesFilter = {
		equals?: number | null
		in?: Enumerable<number> | null
		notIn?: Enumerable<number> | null
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedIntNullableWithAggregatesFilter | number | null
		_count?: NestedIntNullableFilter
		_avg?: NestedFloatNullableFilter
		_sum?: NestedIntNullableFilter
		_min?: NestedIntNullableFilter
		_max?: NestedIntNullableFilter
	}

	export type EnumEnumBlockTypeFilter = {
		equals?: EnumBlockType
		in?: Enumerable<EnumBlockType>
		notIn?: Enumerable<EnumBlockType>
		not?: NestedEnumEnumBlockTypeFilter | EnumBlockType
	}

	export type BlockRelationFilter = {
		is?: BlockWhereInput | null
		isNot?: BlockWhereInput | null
	}

	export type BlockResourceIdDisplayNameCompoundUniqueInput = {
		resourceId: string
		displayName: string
	}

	export type BlockCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		parentBlockId?: SortOrder
		blockType?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
	}

	export type BlockMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		parentBlockId?: SortOrder
		blockType?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
	}

	export type BlockMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		parentBlockId?: SortOrder
		blockType?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		lockedByUserId?: SortOrder
		lockedAt?: SortOrder
		deletedAt?: SortOrder
	}

	export type EnumEnumBlockTypeWithAggregatesFilter = {
		equals?: EnumBlockType
		in?: Enumerable<EnumBlockType>
		notIn?: Enumerable<EnumBlockType>
		not?: NestedEnumEnumBlockTypeWithAggregatesFilter | EnumBlockType
		_count?: NestedIntFilter
		_min?: NestedEnumEnumBlockTypeFilter
		_max?: NestedEnumEnumBlockTypeFilter
	}
	export type JsonNullableFilter =
		| PatchUndefined<
		Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
		Required<JsonNullableFilterBase>
		>
		| OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

	export type JsonNullableFilterBase = {
		equals?: JsonNullValueFilter | InputJsonValue
		not?: JsonNullValueFilter | InputJsonValue
	}

	export type BlockVersionBlockIdVersionNumberCompoundUniqueInput = {
		blockId: string
		versionNumber: number
	}

	export type BlockVersionCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		blockId?: SortOrder
		versionNumber?: SortOrder
		inputParameters?: SortOrder
		outputParameters?: SortOrder
		settings?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
	}

	export type BlockVersionAvgOrderByAggregateInput = {
		versionNumber?: SortOrder
	}

	export type BlockVersionMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		blockId?: SortOrder
		versionNumber?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
	}

	export type BlockVersionMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		blockId?: SortOrder
		versionNumber?: SortOrder
		displayName?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
		deleted?: SortOrder
	}

	export type BlockVersionSumOrderByAggregateInput = {
		versionNumber?: SortOrder
	}
	export type JsonNullableWithAggregatesFilter =
		| PatchUndefined<
		Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
		Required<JsonNullableWithAggregatesFilterBase>
		>
		| OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

	export type JsonNullableWithAggregatesFilterBase = {
		equals?: JsonNullValueFilter | InputJsonValue
		not?: JsonNullValueFilter | InputJsonValue
		_count?: NestedIntNullableFilter
		_min?: NestedJsonNullableFilter
		_max?: NestedJsonNullableFilter
	}

	export type ActionStepListRelationFilter = {
		every?: ActionStepWhereInput
		some?: ActionStepWhereInput
		none?: ActionStepWhereInput
	}

	export type ActionStepOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type ActionCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
	}

	export type ActionMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
	}

	export type ActionMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
	}

	export type EnumActionStepStatusFilter = {
		equals?: ActionStepStatus
		in?: Enumerable<ActionStepStatus>
		notIn?: Enumerable<ActionStepStatus>
		not?: NestedEnumActionStepStatusFilter | ActionStepStatus
	}

	export type ActionRelationFilter = {
		is?: ActionWhereInput
		isNot?: ActionWhereInput
	}

	export type ActionLogListRelationFilter = {
		every?: ActionLogWhereInput
		some?: ActionLogWhereInput
		none?: ActionLogWhereInput
	}

	export type ActionLogOrderByRelationAggregateInput = {
		_count?: SortOrder
	}

	export type ActionStepCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		status?: SortOrder
		completedAt?: SortOrder
		actionId?: SortOrder
		name?: SortOrder
	}

	export type ActionStepMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		status?: SortOrder
		completedAt?: SortOrder
		actionId?: SortOrder
		name?: SortOrder
	}

	export type ActionStepMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		status?: SortOrder
		completedAt?: SortOrder
		actionId?: SortOrder
		name?: SortOrder
	}

	export type EnumActionStepStatusWithAggregatesFilter = {
		equals?: ActionStepStatus
		in?: Enumerable<ActionStepStatus>
		notIn?: Enumerable<ActionStepStatus>
		not?: NestedEnumActionStepStatusWithAggregatesFilter | ActionStepStatus
		_count?: NestedIntFilter
		_min?: NestedEnumActionStepStatusFilter
		_max?: NestedEnumActionStepStatusFilter
	}

	export type EnumEnumLogLevelFilter = {
		equals?: EnumLogLevel
		in?: Enumerable<EnumLogLevel>
		notIn?: Enumerable<EnumLogLevel>
		not?: NestedEnumEnumLogLevelFilter | EnumLogLevel
	}

	export type ActionStepRelationFilter = {
		is?: ActionStepWhereInput
		isNot?: ActionStepWhereInput
	}

	export type ActionLogCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		meta?: SortOrder
		level?: SortOrder
		stepId?: SortOrder
	}

	export type ActionLogMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		level?: SortOrder
		stepId?: SortOrder
	}

	export type ActionLogMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		message?: SortOrder
		level?: SortOrder
		stepId?: SortOrder
	}

	export type EnumEnumLogLevelWithAggregatesFilter = {
		equals?: EnumLogLevel
		in?: Enumerable<EnumLogLevel>
		notIn?: Enumerable<EnumLogLevel>
		not?: NestedEnumEnumLogLevelWithAggregatesFilter | EnumLogLevel
		_count?: NestedIntFilter
		_min?: NestedEnumEnumLogLevelFilter
		_max?: NestedEnumEnumLogLevelFilter
	}

	export type StringNullableListFilter = {
		equals?: Enumerable<string> | null
		has?: string | null
		hasEvery?: Enumerable<string>
		hasSome?: Enumerable<string>
		isEmpty?: boolean
	}

	export type BuildResourceIdVersionCompoundUniqueInput = {
		resourceId: string
		version: string
	}

	export type BuildCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		resourceId?: SortOrder
		userId?: SortOrder
		version?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		images?: SortOrder
		containerStatusQuery?: SortOrder
		containerStatusUpdatedAt?: SortOrder
		commitId?: SortOrder
	}

	export type BuildMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		resourceId?: SortOrder
		userId?: SortOrder
		version?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		containerStatusUpdatedAt?: SortOrder
		commitId?: SortOrder
	}

	export type BuildMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		resourceId?: SortOrder
		userId?: SortOrder
		version?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		containerStatusUpdatedAt?: SortOrder
		commitId?: SortOrder
	}

	export type ReleaseCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		version?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
	}

	export type ReleaseMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		version?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
	}

	export type ReleaseMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		version?: SortOrder
		description?: SortOrder
		commitId?: SortOrder
	}

	export type EnvironmentResourceIdNameCompoundUniqueInput = {
		resourceId: string
		name: string
	}

	export type EnvironmentCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		description?: SortOrder
		address?: SortOrder
	}

	export type EnvironmentMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		description?: SortOrder
		address?: SortOrder
	}

	export type EnvironmentMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		resourceId?: SortOrder
		name?: SortOrder
		description?: SortOrder
		address?: SortOrder
	}

	export type EnumEnumDeploymentStatusFilter = {
		equals?: EnumDeploymentStatus
		in?: Enumerable<EnumDeploymentStatus>
		notIn?: Enumerable<EnumDeploymentStatus>
		not?: NestedEnumEnumDeploymentStatusFilter | EnumDeploymentStatus
	}

	export type BuildRelationFilter = {
		is?: BuildWhereInput
		isNot?: BuildWhereInput
	}

	export type EnvironmentRelationFilter = {
		is?: EnvironmentWhereInput
		isNot?: EnvironmentWhereInput
	}

	export type DeploymentCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		buildId?: SortOrder
		environmentId?: SortOrder
		status?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		statusQuery?: SortOrder
		statusUpdatedAt?: SortOrder
	}

	export type DeploymentMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		buildId?: SortOrder
		environmentId?: SortOrder
		status?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		statusUpdatedAt?: SortOrder
	}

	export type DeploymentMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		userId?: SortOrder
		buildId?: SortOrder
		environmentId?: SortOrder
		status?: SortOrder
		message?: SortOrder
		actionId?: SortOrder
		statusUpdatedAt?: SortOrder
	}

	export type EnumEnumDeploymentStatusWithAggregatesFilter = {
		equals?: EnumDeploymentStatus
		in?: Enumerable<EnumDeploymentStatus>
		notIn?: Enumerable<EnumDeploymentStatus>
		not?: NestedEnumEnumDeploymentStatusWithAggregatesFilter | EnumDeploymentStatus
		_count?: NestedIntFilter
		_min?: NestedEnumEnumDeploymentStatusFilter
		_max?: NestedEnumEnumDeploymentStatusFilter
	}

	export type InvitationWorkspaceIdEmailCompoundUniqueInput = {
		workspaceId: string
		email: string
	}

	export type InvitationCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		invitedByUserId?: SortOrder
		workspaceId?: SortOrder
		newUserId?: SortOrder
		token?: SortOrder
		tokenExpiration?: SortOrder
	}

	export type InvitationMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		invitedByUserId?: SortOrder
		workspaceId?: SortOrder
		newUserId?: SortOrder
		token?: SortOrder
		tokenExpiration?: SortOrder
	}

	export type InvitationMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		email?: SortOrder
		invitedByUserId?: SortOrder
		workspaceId?: SortOrder
		newUserId?: SortOrder
		token?: SortOrder
		tokenExpiration?: SortOrder
	}

	export type EnumEnumSubscriptionPlanFilter = {
		equals?: EnumSubscriptionPlan
		in?: Enumerable<EnumSubscriptionPlan>
		notIn?: Enumerable<EnumSubscriptionPlan>
		not?: NestedEnumEnumSubscriptionPlanFilter | EnumSubscriptionPlan
	}

	export type EnumEnumSubscriptionStatusFilter = {
		equals?: EnumSubscriptionStatus
		in?: Enumerable<EnumSubscriptionStatus>
		notIn?: Enumerable<EnumSubscriptionStatus>
		not?: NestedEnumEnumSubscriptionStatusFilter | EnumSubscriptionStatus
	}

	export type SubscriptionCountOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		subscriptionPlan?: SortOrder
		status?: SortOrder
		subscriptionData?: SortOrder
		cancellationEffectiveDate?: SortOrder
	}

	export type SubscriptionMaxOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		subscriptionPlan?: SortOrder
		status?: SortOrder
		cancellationEffectiveDate?: SortOrder
	}

	export type SubscriptionMinOrderByAggregateInput = {
		id?: SortOrder
		createdAt?: SortOrder
		updatedAt?: SortOrder
		workspaceId?: SortOrder
		subscriptionPlan?: SortOrder
		status?: SortOrder
		cancellationEffectiveDate?: SortOrder
	}

	export type EnumEnumSubscriptionPlanWithAggregatesFilter = {
		equals?: EnumSubscriptionPlan
		in?: Enumerable<EnumSubscriptionPlan>
		notIn?: Enumerable<EnumSubscriptionPlan>
		not?: NestedEnumEnumSubscriptionPlanWithAggregatesFilter | EnumSubscriptionPlan
		_count?: NestedIntFilter
		_min?: NestedEnumEnumSubscriptionPlanFilter
		_max?: NestedEnumEnumSubscriptionPlanFilter
	}

	export type EnumEnumSubscriptionStatusWithAggregatesFilter = {
		equals?: EnumSubscriptionStatus
		in?: Enumerable<EnumSubscriptionStatus>
		notIn?: Enumerable<EnumSubscriptionStatus>
		not?: NestedEnumEnumSubscriptionStatusWithAggregatesFilter | EnumSubscriptionStatus
		_count?: NestedIntFilter
		_min?: NestedEnumEnumSubscriptionStatusFilter
		_max?: NestedEnumEnumSubscriptionStatusFilter
	}

	export type UserCreateNestedOneWithoutAssignedCurrentToInput = {
		create?: XOR<UserCreateWithoutAssignedCurrentToInput, UserUncheckedCreateWithoutAssignedCurrentToInput>
		connectOrCreate?: UserCreateOrConnectWithoutAssignedCurrentToInput
		connect?: UserWhereUniqueInput
	}

	export type UserCreateNestedManyWithoutAccountInput = {
		create?: XOR<Enumerable<UserCreateWithoutAccountInput>, Enumerable<UserUncheckedCreateWithoutAccountInput>>
		connectOrCreate?: Enumerable<UserCreateOrConnectWithoutAccountInput>
		createMany?: UserCreateManyAccountInputEnvelope
		connect?: Enumerable<UserWhereUniqueInput>
	}

	export type UserUncheckedCreateNestedManyWithoutAccountInput = {
		create?: XOR<Enumerable<UserCreateWithoutAccountInput>, Enumerable<UserUncheckedCreateWithoutAccountInput>>
		connectOrCreate?: Enumerable<UserCreateOrConnectWithoutAccountInput>
		createMany?: UserCreateManyAccountInputEnvelope
		connect?: Enumerable<UserWhereUniqueInput>
	}

	export type StringFieldUpdateOperationsInput = {
		set?: string
	}

	export type DateTimeFieldUpdateOperationsInput = {
		set?: Date | string
	}

	export type NullableStringFieldUpdateOperationsInput = {
		set?: string | null
	}

	export type UserUpdateOneWithoutAssignedCurrentToInput = {
		create?: XOR<UserCreateWithoutAssignedCurrentToInput, UserUncheckedCreateWithoutAssignedCurrentToInput>
		connectOrCreate?: UserCreateOrConnectWithoutAssignedCurrentToInput
		upsert?: UserUpsertWithoutAssignedCurrentToInput
		disconnect?: boolean
		delete?: boolean
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutAssignedCurrentToInput, UserUncheckedUpdateWithoutAssignedCurrentToInput>
	}

	export type UserUpdateManyWithoutAccountInput = {
		create?: XOR<Enumerable<UserCreateWithoutAccountInput>, Enumerable<UserUncheckedCreateWithoutAccountInput>>
		connectOrCreate?: Enumerable<UserCreateOrConnectWithoutAccountInput>
		upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutAccountInput>
		createMany?: UserCreateManyAccountInputEnvelope
		set?: Enumerable<UserWhereUniqueInput>
		disconnect?: Enumerable<UserWhereUniqueInput>
		delete?: Enumerable<UserWhereUniqueInput>
		connect?: Enumerable<UserWhereUniqueInput>
		update?: Enumerable<UserUpdateWithWhereUniqueWithoutAccountInput>
		updateMany?: Enumerable<UserUpdateManyWithWhereWithoutAccountInput>
		deleteMany?: Enumerable<UserScalarWhereInput>
	}

	export type UserUncheckedUpdateManyWithoutAccountInput = {
		create?: XOR<Enumerable<UserCreateWithoutAccountInput>, Enumerable<UserUncheckedCreateWithoutAccountInput>>
		connectOrCreate?: Enumerable<UserCreateOrConnectWithoutAccountInput>
		upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutAccountInput>
		createMany?: UserCreateManyAccountInputEnvelope
		set?: Enumerable<UserWhereUniqueInput>
		disconnect?: Enumerable<UserWhereUniqueInput>
		delete?: Enumerable<UserWhereUniqueInput>
		connect?: Enumerable<UserWhereUniqueInput>
		update?: Enumerable<UserUpdateWithWhereUniqueWithoutAccountInput>
		updateMany?: Enumerable<UserUpdateManyWithWhereWithoutAccountInput>
		deleteMany?: Enumerable<UserScalarWhereInput>
	}

	export type UserCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<UserCreateWithoutWorkspaceInput>, Enumerable<UserUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWorkspaceInput>
		createMany?: UserCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<UserWhereUniqueInput>
	}

	export type InvitationCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<InvitationCreateWithoutWorkspaceInput>, Enumerable<InvitationUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutWorkspaceInput>
		createMany?: InvitationCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<InvitationWhereUniqueInput>
	}

	export type SubscriptionCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<SubscriptionCreateWithoutWorkspaceInput>, Enumerable<SubscriptionUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutWorkspaceInput>
		createMany?: SubscriptionCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<SubscriptionWhereUniqueInput>
	}

	export type GitOrganizationCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<GitOrganizationCreateWithoutWorkspaceInput>, Enumerable<GitOrganizationUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<GitOrganizationCreateOrConnectWithoutWorkspaceInput>
		createMany?: GitOrganizationCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<GitOrganizationWhereUniqueInput>
	}

	export type ProjectCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<ProjectCreateWithoutWorkspaceInput>, Enumerable<ProjectUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutWorkspaceInput>
		createMany?: ProjectCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<ProjectWhereUniqueInput>
	}

	export type UserUncheckedCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<UserCreateWithoutWorkspaceInput>, Enumerable<UserUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWorkspaceInput>
		createMany?: UserCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<UserWhereUniqueInput>
	}

	export type InvitationUncheckedCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<InvitationCreateWithoutWorkspaceInput>, Enumerable<InvitationUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutWorkspaceInput>
		createMany?: InvitationCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<InvitationWhereUniqueInput>
	}

	export type SubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<SubscriptionCreateWithoutWorkspaceInput>, Enumerable<SubscriptionUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutWorkspaceInput>
		createMany?: SubscriptionCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<SubscriptionWhereUniqueInput>
	}

	export type GitOrganizationUncheckedCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<GitOrganizationCreateWithoutWorkspaceInput>, Enumerable<GitOrganizationUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<GitOrganizationCreateOrConnectWithoutWorkspaceInput>
		createMany?: GitOrganizationCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<GitOrganizationWhereUniqueInput>
	}

	export type ProjectUncheckedCreateNestedManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<ProjectCreateWithoutWorkspaceInput>, Enumerable<ProjectUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutWorkspaceInput>
		createMany?: ProjectCreateManyWorkspaceInputEnvelope
		connect?: Enumerable<ProjectWhereUniqueInput>
	}

	export type UserUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<UserCreateWithoutWorkspaceInput>, Enumerable<UserUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: UserCreateManyWorkspaceInputEnvelope
		set?: Enumerable<UserWhereUniqueInput>
		disconnect?: Enumerable<UserWhereUniqueInput>
		delete?: Enumerable<UserWhereUniqueInput>
		connect?: Enumerable<UserWhereUniqueInput>
		update?: Enumerable<UserUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<UserUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<UserScalarWhereInput>
	}

	export type InvitationUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<InvitationCreateWithoutWorkspaceInput>, Enumerable<InvitationUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<InvitationUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: InvitationCreateManyWorkspaceInputEnvelope
		set?: Enumerable<InvitationWhereUniqueInput>
		disconnect?: Enumerable<InvitationWhereUniqueInput>
		delete?: Enumerable<InvitationWhereUniqueInput>
		connect?: Enumerable<InvitationWhereUniqueInput>
		update?: Enumerable<InvitationUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<InvitationUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<InvitationScalarWhereInput>
	}

	export type SubscriptionUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<SubscriptionCreateWithoutWorkspaceInput>, Enumerable<SubscriptionUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: SubscriptionCreateManyWorkspaceInputEnvelope
		set?: Enumerable<SubscriptionWhereUniqueInput>
		disconnect?: Enumerable<SubscriptionWhereUniqueInput>
		delete?: Enumerable<SubscriptionWhereUniqueInput>
		connect?: Enumerable<SubscriptionWhereUniqueInput>
		update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<SubscriptionScalarWhereInput>
	}

	export type GitOrganizationUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<GitOrganizationCreateWithoutWorkspaceInput>, Enumerable<GitOrganizationUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<GitOrganizationCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<GitOrganizationUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: GitOrganizationCreateManyWorkspaceInputEnvelope
		set?: Enumerable<GitOrganizationWhereUniqueInput>
		disconnect?: Enumerable<GitOrganizationWhereUniqueInput>
		delete?: Enumerable<GitOrganizationWhereUniqueInput>
		connect?: Enumerable<GitOrganizationWhereUniqueInput>
		update?: Enumerable<GitOrganizationUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<GitOrganizationUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<GitOrganizationScalarWhereInput>
	}

	export type ProjectUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<ProjectCreateWithoutWorkspaceInput>, Enumerable<ProjectUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: ProjectCreateManyWorkspaceInputEnvelope
		set?: Enumerable<ProjectWhereUniqueInput>
		disconnect?: Enumerable<ProjectWhereUniqueInput>
		delete?: Enumerable<ProjectWhereUniqueInput>
		connect?: Enumerable<ProjectWhereUniqueInput>
		update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<ProjectScalarWhereInput>
	}

	export type UserUncheckedUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<UserCreateWithoutWorkspaceInput>, Enumerable<UserUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: UserCreateManyWorkspaceInputEnvelope
		set?: Enumerable<UserWhereUniqueInput>
		disconnect?: Enumerable<UserWhereUniqueInput>
		delete?: Enumerable<UserWhereUniqueInput>
		connect?: Enumerable<UserWhereUniqueInput>
		update?: Enumerable<UserUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<UserUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<UserScalarWhereInput>
	}

	export type InvitationUncheckedUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<InvitationCreateWithoutWorkspaceInput>, Enumerable<InvitationUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<InvitationUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: InvitationCreateManyWorkspaceInputEnvelope
		set?: Enumerable<InvitationWhereUniqueInput>
		disconnect?: Enumerable<InvitationWhereUniqueInput>
		delete?: Enumerable<InvitationWhereUniqueInput>
		connect?: Enumerable<InvitationWhereUniqueInput>
		update?: Enumerable<InvitationUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<InvitationUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<InvitationScalarWhereInput>
	}

	export type SubscriptionUncheckedUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<SubscriptionCreateWithoutWorkspaceInput>, Enumerable<SubscriptionUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: SubscriptionCreateManyWorkspaceInputEnvelope
		set?: Enumerable<SubscriptionWhereUniqueInput>
		disconnect?: Enumerable<SubscriptionWhereUniqueInput>
		delete?: Enumerable<SubscriptionWhereUniqueInput>
		connect?: Enumerable<SubscriptionWhereUniqueInput>
		update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<SubscriptionScalarWhereInput>
	}

	export type GitOrganizationUncheckedUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<GitOrganizationCreateWithoutWorkspaceInput>, Enumerable<GitOrganizationUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<GitOrganizationCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<GitOrganizationUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: GitOrganizationCreateManyWorkspaceInputEnvelope
		set?: Enumerable<GitOrganizationWhereUniqueInput>
		disconnect?: Enumerable<GitOrganizationWhereUniqueInput>
		delete?: Enumerable<GitOrganizationWhereUniqueInput>
		connect?: Enumerable<GitOrganizationWhereUniqueInput>
		update?: Enumerable<GitOrganizationUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<GitOrganizationUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<GitOrganizationScalarWhereInput>
	}

	export type ProjectUncheckedUpdateManyWithoutWorkspaceInput = {
		create?: XOR<Enumerable<ProjectCreateWithoutWorkspaceInput>, Enumerable<ProjectUncheckedCreateWithoutWorkspaceInput>>
		connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutWorkspaceInput>
		upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutWorkspaceInput>
		createMany?: ProjectCreateManyWorkspaceInputEnvelope
		set?: Enumerable<ProjectWhereUniqueInput>
		disconnect?: Enumerable<ProjectWhereUniqueInput>
		delete?: Enumerable<ProjectWhereUniqueInput>
		connect?: Enumerable<ProjectWhereUniqueInput>
		update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutWorkspaceInput>
		updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutWorkspaceInput>
		deleteMany?: Enumerable<ProjectScalarWhereInput>
	}

	export type WorkspaceCreateNestedOneWithoutProjectsInput = {
		create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
		connect?: WorkspaceWhereUniqueInput
	}

	export type ResourceCreateNestedManyWithoutProjectInput = {
		create?: XOR<Enumerable<ResourceCreateWithoutProjectInput>, Enumerable<ResourceUncheckedCreateWithoutProjectInput>>
		connectOrCreate?: Enumerable<ResourceCreateOrConnectWithoutProjectInput>
		createMany?: ResourceCreateManyProjectInputEnvelope
		connect?: Enumerable<ResourceWhereUniqueInput>
	}

	export type CommitCreateNestedManyWithoutProjectInput = {
		create?: XOR<Enumerable<CommitCreateWithoutProjectInput>, Enumerable<CommitUncheckedCreateWithoutProjectInput>>
		connectOrCreate?: Enumerable<CommitCreateOrConnectWithoutProjectInput>
		createMany?: CommitCreateManyProjectInputEnvelope
		connect?: Enumerable<CommitWhereUniqueInput>
	}

	export type ResourceUncheckedCreateNestedManyWithoutProjectInput = {
		create?: XOR<Enumerable<ResourceCreateWithoutProjectInput>, Enumerable<ResourceUncheckedCreateWithoutProjectInput>>
		connectOrCreate?: Enumerable<ResourceCreateOrConnectWithoutProjectInput>
		createMany?: ResourceCreateManyProjectInputEnvelope
		connect?: Enumerable<ResourceWhereUniqueInput>
	}

	export type CommitUncheckedCreateNestedManyWithoutProjectInput = {
		create?: XOR<Enumerable<CommitCreateWithoutProjectInput>, Enumerable<CommitUncheckedCreateWithoutProjectInput>>
		connectOrCreate?: Enumerable<CommitCreateOrConnectWithoutProjectInput>
		createMany?: CommitCreateManyProjectInputEnvelope
		connect?: Enumerable<CommitWhereUniqueInput>
	}

	export type WorkspaceUpdateOneRequiredWithoutProjectsInput = {
		create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
		upsert?: WorkspaceUpsertWithoutProjectsInput
		connect?: WorkspaceWhereUniqueInput
		update?: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
	}

	export type ResourceUpdateManyWithoutProjectInput = {
		create?: XOR<Enumerable<ResourceCreateWithoutProjectInput>, Enumerable<ResourceUncheckedCreateWithoutProjectInput>>
		connectOrCreate?: Enumerable<ResourceCreateOrConnectWithoutProjectInput>
		upsert?: Enumerable<ResourceUpsertWithWhereUniqueWithoutProjectInput>
		createMany?: ResourceCreateManyProjectInputEnvelope
		set?: Enumerable<ResourceWhereUniqueInput>
		disconnect?: Enumerable<ResourceWhereUniqueInput>
		delete?: Enumerable<ResourceWhereUniqueInput>
		connect?: Enumerable<ResourceWhereUniqueInput>
		update?: Enumerable<ResourceUpdateWithWhereUniqueWithoutProjectInput>
		updateMany?: Enumerable<ResourceUpdateManyWithWhereWithoutProjectInput>
		deleteMany?: Enumerable<ResourceScalarWhereInput>
	}

	export type NullableDateTimeFieldUpdateOperationsInput = {
		set?: Date | string | null
	}

	export type CommitUpdateManyWithoutProjectInput = {
		create?: XOR<Enumerable<CommitCreateWithoutProjectInput>, Enumerable<CommitUncheckedCreateWithoutProjectInput>>
		connectOrCreate?: Enumerable<CommitCreateOrConnectWithoutProjectInput>
		upsert?: Enumerable<CommitUpsertWithWhereUniqueWithoutProjectInput>
		createMany?: CommitCreateManyProjectInputEnvelope
		set?: Enumerable<CommitWhereUniqueInput>
		disconnect?: Enumerable<CommitWhereUniqueInput>
		delete?: Enumerable<CommitWhereUniqueInput>
		connect?: Enumerable<CommitWhereUniqueInput>
		update?: Enumerable<CommitUpdateWithWhereUniqueWithoutProjectInput>
		updateMany?: Enumerable<CommitUpdateManyWithWhereWithoutProjectInput>
		deleteMany?: Enumerable<CommitScalarWhereInput>
	}

	export type ResourceUncheckedUpdateManyWithoutProjectInput = {
		create?: XOR<Enumerable<ResourceCreateWithoutProjectInput>, Enumerable<ResourceUncheckedCreateWithoutProjectInput>>
		connectOrCreate?: Enumerable<ResourceCreateOrConnectWithoutProjectInput>
		upsert?: Enumerable<ResourceUpsertWithWhereUniqueWithoutProjectInput>
		createMany?: ResourceCreateManyProjectInputEnvelope
		set?: Enumerable<ResourceWhereUniqueInput>
		disconnect?: Enumerable<ResourceWhereUniqueInput>
		delete?: Enumerable<ResourceWhereUniqueInput>
		connect?: Enumerable<ResourceWhereUniqueInput>
		update?: Enumerable<ResourceUpdateWithWhereUniqueWithoutProjectInput>
		updateMany?: Enumerable<ResourceUpdateManyWithWhereWithoutProjectInput>
		deleteMany?: Enumerable<ResourceScalarWhereInput>
	}

	export type CommitUncheckedUpdateManyWithoutProjectInput = {
		create?: XOR<Enumerable<CommitCreateWithoutProjectInput>, Enumerable<CommitUncheckedCreateWithoutProjectInput>>
		connectOrCreate?: Enumerable<CommitCreateOrConnectWithoutProjectInput>
		upsert?: Enumerable<CommitUpsertWithWhereUniqueWithoutProjectInput>
		createMany?: CommitCreateManyProjectInputEnvelope
		set?: Enumerable<CommitWhereUniqueInput>
		disconnect?: Enumerable<CommitWhereUniqueInput>
		delete?: Enumerable<CommitWhereUniqueInput>
		connect?: Enumerable<CommitWhereUniqueInput>
		update?: Enumerable<CommitUpdateWithWhereUniqueWithoutProjectInput>
		updateMany?: Enumerable<CommitUpdateManyWithWhereWithoutProjectInput>
		deleteMany?: Enumerable<CommitScalarWhereInput>
	}

	export type WorkspaceCreateNestedOneWithoutGitOrganizationsInput = {
		create?: XOR<WorkspaceCreateWithoutGitOrganizationsInput, WorkspaceUncheckedCreateWithoutGitOrganizationsInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutGitOrganizationsInput
		connect?: WorkspaceWhereUniqueInput
	}

	export type GitRepositoryCreateNestedManyWithoutGitOrganizationInput = {
		create?: XOR<Enumerable<GitRepositoryCreateWithoutGitOrganizationInput>, Enumerable<GitRepositoryUncheckedCreateWithoutGitOrganizationInput>>
		connectOrCreate?: Enumerable<GitRepositoryCreateOrConnectWithoutGitOrganizationInput>
		createMany?: GitRepositoryCreateManyGitOrganizationInputEnvelope
		connect?: Enumerable<GitRepositoryWhereUniqueInput>
	}

	export type GitRepositoryUncheckedCreateNestedManyWithoutGitOrganizationInput = {
		create?: XOR<Enumerable<GitRepositoryCreateWithoutGitOrganizationInput>, Enumerable<GitRepositoryUncheckedCreateWithoutGitOrganizationInput>>
		connectOrCreate?: Enumerable<GitRepositoryCreateOrConnectWithoutGitOrganizationInput>
		createMany?: GitRepositoryCreateManyGitOrganizationInputEnvelope
		connect?: Enumerable<GitRepositoryWhereUniqueInput>
	}

	export type EnumEnumGitProviderFieldUpdateOperationsInput = {
		set?: EnumGitProvider
	}

	export type NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput = {
		set?: EnumGitOrganizationType | null
	}

	export type WorkspaceUpdateOneRequiredWithoutGitOrganizationsInput = {
		create?: XOR<WorkspaceCreateWithoutGitOrganizationsInput, WorkspaceUncheckedCreateWithoutGitOrganizationsInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutGitOrganizationsInput
		upsert?: WorkspaceUpsertWithoutGitOrganizationsInput
		connect?: WorkspaceWhereUniqueInput
		update?: XOR<WorkspaceUpdateWithoutGitOrganizationsInput, WorkspaceUncheckedUpdateWithoutGitOrganizationsInput>
	}

	export type GitRepositoryUpdateManyWithoutGitOrganizationInput = {
		create?: XOR<Enumerable<GitRepositoryCreateWithoutGitOrganizationInput>, Enumerable<GitRepositoryUncheckedCreateWithoutGitOrganizationInput>>
		connectOrCreate?: Enumerable<GitRepositoryCreateOrConnectWithoutGitOrganizationInput>
		upsert?: Enumerable<GitRepositoryUpsertWithWhereUniqueWithoutGitOrganizationInput>
		createMany?: GitRepositoryCreateManyGitOrganizationInputEnvelope
		set?: Enumerable<GitRepositoryWhereUniqueInput>
		disconnect?: Enumerable<GitRepositoryWhereUniqueInput>
		delete?: Enumerable<GitRepositoryWhereUniqueInput>
		connect?: Enumerable<GitRepositoryWhereUniqueInput>
		update?: Enumerable<GitRepositoryUpdateWithWhereUniqueWithoutGitOrganizationInput>
		updateMany?: Enumerable<GitRepositoryUpdateManyWithWhereWithoutGitOrganizationInput>
		deleteMany?: Enumerable<GitRepositoryScalarWhereInput>
	}

	export type GitRepositoryUncheckedUpdateManyWithoutGitOrganizationInput = {
		create?: XOR<Enumerable<GitRepositoryCreateWithoutGitOrganizationInput>, Enumerable<GitRepositoryUncheckedCreateWithoutGitOrganizationInput>>
		connectOrCreate?: Enumerable<GitRepositoryCreateOrConnectWithoutGitOrganizationInput>
		upsert?: Enumerable<GitRepositoryUpsertWithWhereUniqueWithoutGitOrganizationInput>
		createMany?: GitRepositoryCreateManyGitOrganizationInputEnvelope
		set?: Enumerable<GitRepositoryWhereUniqueInput>
		disconnect?: Enumerable<GitRepositoryWhereUniqueInput>
		delete?: Enumerable<GitRepositoryWhereUniqueInput>
		connect?: Enumerable<GitRepositoryWhereUniqueInput>
		update?: Enumerable<GitRepositoryUpdateWithWhereUniqueWithoutGitOrganizationInput>
		updateMany?: Enumerable<GitRepositoryUpdateManyWithWhereWithoutGitOrganizationInput>
		deleteMany?: Enumerable<GitRepositoryScalarWhereInput>
	}

	export type ResourceCreateNestedManyWithoutGitRepositoryInput = {
		create?: XOR<Enumerable<ResourceCreateWithoutGitRepositoryInput>, Enumerable<ResourceUncheckedCreateWithoutGitRepositoryInput>>
		connectOrCreate?: Enumerable<ResourceCreateOrConnectWithoutGitRepositoryInput>
		createMany?: ResourceCreateManyGitRepositoryInputEnvelope
		connect?: Enumerable<ResourceWhereUniqueInput>
	}

	export type GitOrganizationCreateNestedOneWithoutGitRepositoriesInput = {
		create?: XOR<GitOrganizationCreateWithoutGitRepositoriesInput, GitOrganizationUncheckedCreateWithoutGitRepositoriesInput>
		connectOrCreate?: GitOrganizationCreateOrConnectWithoutGitRepositoriesInput
		connect?: GitOrganizationWhereUniqueInput
	}

	export type ResourceUncheckedCreateNestedManyWithoutGitRepositoryInput = {
		create?: XOR<Enumerable<ResourceCreateWithoutGitRepositoryInput>, Enumerable<ResourceUncheckedCreateWithoutGitRepositoryInput>>
		connectOrCreate?: Enumerable<ResourceCreateOrConnectWithoutGitRepositoryInput>
		createMany?: ResourceCreateManyGitRepositoryInputEnvelope
		connect?: Enumerable<ResourceWhereUniqueInput>
	}

	export type ResourceUpdateManyWithoutGitRepositoryInput = {
		create?: XOR<Enumerable<ResourceCreateWithoutGitRepositoryInput>, Enumerable<ResourceUncheckedCreateWithoutGitRepositoryInput>>
		connectOrCreate?: Enumerable<ResourceCreateOrConnectWithoutGitRepositoryInput>
		upsert?: Enumerable<ResourceUpsertWithWhereUniqueWithoutGitRepositoryInput>
		createMany?: ResourceCreateManyGitRepositoryInputEnvelope
		set?: Enumerable<ResourceWhereUniqueInput>
		disconnect?: Enumerable<ResourceWhereUniqueInput>
		delete?: Enumerable<ResourceWhereUniqueInput>
		connect?: Enumerable<ResourceWhereUniqueInput>
		update?: Enumerable<ResourceUpdateWithWhereUniqueWithoutGitRepositoryInput>
		updateMany?: Enumerable<ResourceUpdateManyWithWhereWithoutGitRepositoryInput>
		deleteMany?: Enumerable<ResourceScalarWhereInput>
	}

	export type GitOrganizationUpdateOneRequiredWithoutGitRepositoriesInput = {
		create?: XOR<GitOrganizationCreateWithoutGitRepositoriesInput, GitOrganizationUncheckedCreateWithoutGitRepositoriesInput>
		connectOrCreate?: GitOrganizationCreateOrConnectWithoutGitRepositoriesInput
		upsert?: GitOrganizationUpsertWithoutGitRepositoriesInput
		connect?: GitOrganizationWhereUniqueInput
		update?: XOR<GitOrganizationUpdateWithoutGitRepositoriesInput, GitOrganizationUncheckedUpdateWithoutGitRepositoriesInput>
	}

	export type ResourceUncheckedUpdateManyWithoutGitRepositoryInput = {
		create?: XOR<Enumerable<ResourceCreateWithoutGitRepositoryInput>, Enumerable<ResourceUncheckedCreateWithoutGitRepositoryInput>>
		connectOrCreate?: Enumerable<ResourceCreateOrConnectWithoutGitRepositoryInput>
		upsert?: Enumerable<ResourceUpsertWithWhereUniqueWithoutGitRepositoryInput>
		createMany?: ResourceCreateManyGitRepositoryInputEnvelope
		set?: Enumerable<ResourceWhereUniqueInput>
		disconnect?: Enumerable<ResourceWhereUniqueInput>
		delete?: Enumerable<ResourceWhereUniqueInput>
		connect?: Enumerable<ResourceWhereUniqueInput>
		update?: Enumerable<ResourceUpdateWithWhereUniqueWithoutGitRepositoryInput>
		updateMany?: Enumerable<ResourceUpdateManyWithWhereWithoutGitRepositoryInput>
		deleteMany?: Enumerable<ResourceScalarWhereInput>
	}

	export type AccountCreateNestedOneWithoutUsersInput = {
		create?: XOR<AccountCreateWithoutUsersInput, AccountUncheckedCreateWithoutUsersInput>
		connectOrCreate?: AccountCreateOrConnectWithoutUsersInput
		connect?: AccountWhereUniqueInput
	}

	export type WorkspaceCreateNestedOneWithoutUsersInput = {
		create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
		connect?: WorkspaceWhereUniqueInput
	}

	export type AccountCreateNestedOneWithoutCurrentUserInput = {
		create?: XOR<AccountCreateWithoutCurrentUserInput, AccountUncheckedCreateWithoutCurrentUserInput>
		connectOrCreate?: AccountCreateOrConnectWithoutCurrentUserInput
		connect?: AccountWhereUniqueInput
	}

	export type ApiTokenCreateNestedManyWithoutUserInput = {
		create?: XOR<Enumerable<ApiTokenCreateWithoutUserInput>, Enumerable<ApiTokenUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<ApiTokenCreateOrConnectWithoutUserInput>
		createMany?: ApiTokenCreateManyUserInputEnvelope
		connect?: Enumerable<ApiTokenWhereUniqueInput>
	}

	export type BlockCreateNestedManyWithoutLockedByUserInput = {
		create?: XOR<Enumerable<BlockCreateWithoutLockedByUserInput>, Enumerable<BlockUncheckedCreateWithoutLockedByUserInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutLockedByUserInput>
		createMany?: BlockCreateManyLockedByUserInputEnvelope
		connect?: Enumerable<BlockWhereUniqueInput>
	}

	export type BuildCreateNestedManyWithoutCreatedByInput = {
		create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
		createMany?: BuildCreateManyCreatedByInputEnvelope
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type CommitCreateNestedManyWithoutUserInput = {
		create?: XOR<Enumerable<CommitCreateWithoutUserInput>, Enumerable<CommitUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<CommitCreateOrConnectWithoutUserInput>
		createMany?: CommitCreateManyUserInputEnvelope
		connect?: Enumerable<CommitWhereUniqueInput>
	}

	export type DeploymentCreateNestedManyWithoutCreatedByInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutCreatedByInput>, Enumerable<DeploymentUncheckedCreateWithoutCreatedByInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutCreatedByInput>
		createMany?: DeploymentCreateManyCreatedByInputEnvelope
		connect?: Enumerable<DeploymentWhereUniqueInput>
	}

	export type EntityCreateNestedManyWithoutLockedByUserInput = {
		create?: XOR<Enumerable<EntityCreateWithoutLockedByUserInput>, Enumerable<EntityUncheckedCreateWithoutLockedByUserInput>>
		connectOrCreate?: Enumerable<EntityCreateOrConnectWithoutLockedByUserInput>
		createMany?: EntityCreateManyLockedByUserInputEnvelope
		connect?: Enumerable<EntityWhereUniqueInput>
	}

	export type UserRoleCreateNestedManyWithoutUserInput = {
		create?: XOR<Enumerable<UserRoleCreateWithoutUserInput>, Enumerable<UserRoleUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<UserRoleCreateOrConnectWithoutUserInput>
		createMany?: UserRoleCreateManyUserInputEnvelope
		connect?: Enumerable<UserRoleWhereUniqueInput>
	}

	export type InvitationCreateNestedManyWithoutInvitedByUserInput = {
		create?: XOR<Enumerable<InvitationCreateWithoutInvitedByUserInput>, Enumerable<InvitationUncheckedCreateWithoutInvitedByUserInput>>
		connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutInvitedByUserInput>
		createMany?: InvitationCreateManyInvitedByUserInputEnvelope
		connect?: Enumerable<InvitationWhereUniqueInput>
	}

	export type InvitationCreateNestedOneWithoutNewUserInput = {
		create?: XOR<InvitationCreateWithoutNewUserInput, InvitationUncheckedCreateWithoutNewUserInput>
		connectOrCreate?: InvitationCreateOrConnectWithoutNewUserInput
		connect?: InvitationWhereUniqueInput
	}

	export type AccountUncheckedCreateNestedOneWithoutCurrentUserInput = {
		create?: XOR<AccountCreateWithoutCurrentUserInput, AccountUncheckedCreateWithoutCurrentUserInput>
		connectOrCreate?: AccountCreateOrConnectWithoutCurrentUserInput
		connect?: AccountWhereUniqueInput
	}

	export type ApiTokenUncheckedCreateNestedManyWithoutUserInput = {
		create?: XOR<Enumerable<ApiTokenCreateWithoutUserInput>, Enumerable<ApiTokenUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<ApiTokenCreateOrConnectWithoutUserInput>
		createMany?: ApiTokenCreateManyUserInputEnvelope
		connect?: Enumerable<ApiTokenWhereUniqueInput>
	}

	export type BlockUncheckedCreateNestedManyWithoutLockedByUserInput = {
		create?: XOR<Enumerable<BlockCreateWithoutLockedByUserInput>, Enumerable<BlockUncheckedCreateWithoutLockedByUserInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutLockedByUserInput>
		createMany?: BlockCreateManyLockedByUserInputEnvelope
		connect?: Enumerable<BlockWhereUniqueInput>
	}

	export type BuildUncheckedCreateNestedManyWithoutCreatedByInput = {
		create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
		createMany?: BuildCreateManyCreatedByInputEnvelope
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type CommitUncheckedCreateNestedManyWithoutUserInput = {
		create?: XOR<Enumerable<CommitCreateWithoutUserInput>, Enumerable<CommitUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<CommitCreateOrConnectWithoutUserInput>
		createMany?: CommitCreateManyUserInputEnvelope
		connect?: Enumerable<CommitWhereUniqueInput>
	}

	export type DeploymentUncheckedCreateNestedManyWithoutCreatedByInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutCreatedByInput>, Enumerable<DeploymentUncheckedCreateWithoutCreatedByInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutCreatedByInput>
		createMany?: DeploymentCreateManyCreatedByInputEnvelope
		connect?: Enumerable<DeploymentWhereUniqueInput>
	}

	export type EntityUncheckedCreateNestedManyWithoutLockedByUserInput = {
		create?: XOR<Enumerable<EntityCreateWithoutLockedByUserInput>, Enumerable<EntityUncheckedCreateWithoutLockedByUserInput>>
		connectOrCreate?: Enumerable<EntityCreateOrConnectWithoutLockedByUserInput>
		createMany?: EntityCreateManyLockedByUserInputEnvelope
		connect?: Enumerable<EntityWhereUniqueInput>
	}

	export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
		create?: XOR<Enumerable<UserRoleCreateWithoutUserInput>, Enumerable<UserRoleUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<UserRoleCreateOrConnectWithoutUserInput>
		createMany?: UserRoleCreateManyUserInputEnvelope
		connect?: Enumerable<UserRoleWhereUniqueInput>
	}

	export type InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput = {
		create?: XOR<Enumerable<InvitationCreateWithoutInvitedByUserInput>, Enumerable<InvitationUncheckedCreateWithoutInvitedByUserInput>>
		connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutInvitedByUserInput>
		createMany?: InvitationCreateManyInvitedByUserInputEnvelope
		connect?: Enumerable<InvitationWhereUniqueInput>
	}

	export type InvitationUncheckedCreateNestedOneWithoutNewUserInput = {
		create?: XOR<InvitationCreateWithoutNewUserInput, InvitationUncheckedCreateWithoutNewUserInput>
		connectOrCreate?: InvitationCreateOrConnectWithoutNewUserInput
		connect?: InvitationWhereUniqueInput
	}

	export type BoolFieldUpdateOperationsInput = {
		set?: boolean
	}

	export type AccountUpdateOneRequiredWithoutUsersInput = {
		create?: XOR<AccountCreateWithoutUsersInput, AccountUncheckedCreateWithoutUsersInput>
		connectOrCreate?: AccountCreateOrConnectWithoutUsersInput
		upsert?: AccountUpsertWithoutUsersInput
		connect?: AccountWhereUniqueInput
		update?: XOR<AccountUpdateWithoutUsersInput, AccountUncheckedUpdateWithoutUsersInput>
	}

	export type WorkspaceUpdateOneRequiredWithoutUsersInput = {
		create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
		upsert?: WorkspaceUpsertWithoutUsersInput
		connect?: WorkspaceWhereUniqueInput
		update?: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
	}

	export type AccountUpdateOneWithoutCurrentUserInput = {
		create?: XOR<AccountCreateWithoutCurrentUserInput, AccountUncheckedCreateWithoutCurrentUserInput>
		connectOrCreate?: AccountCreateOrConnectWithoutCurrentUserInput
		upsert?: AccountUpsertWithoutCurrentUserInput
		disconnect?: boolean
		delete?: boolean
		connect?: AccountWhereUniqueInput
		update?: XOR<AccountUpdateWithoutCurrentUserInput, AccountUncheckedUpdateWithoutCurrentUserInput>
	}

	export type ApiTokenUpdateManyWithoutUserInput = {
		create?: XOR<Enumerable<ApiTokenCreateWithoutUserInput>, Enumerable<ApiTokenUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<ApiTokenCreateOrConnectWithoutUserInput>
		upsert?: Enumerable<ApiTokenUpsertWithWhereUniqueWithoutUserInput>
		createMany?: ApiTokenCreateManyUserInputEnvelope
		set?: Enumerable<ApiTokenWhereUniqueInput>
		disconnect?: Enumerable<ApiTokenWhereUniqueInput>
		delete?: Enumerable<ApiTokenWhereUniqueInput>
		connect?: Enumerable<ApiTokenWhereUniqueInput>
		update?: Enumerable<ApiTokenUpdateWithWhereUniqueWithoutUserInput>
		updateMany?: Enumerable<ApiTokenUpdateManyWithWhereWithoutUserInput>
		deleteMany?: Enumerable<ApiTokenScalarWhereInput>
	}

	export type BlockUpdateManyWithoutLockedByUserInput = {
		create?: XOR<Enumerable<BlockCreateWithoutLockedByUserInput>, Enumerable<BlockUncheckedCreateWithoutLockedByUserInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutLockedByUserInput>
		upsert?: Enumerable<BlockUpsertWithWhereUniqueWithoutLockedByUserInput>
		createMany?: BlockCreateManyLockedByUserInputEnvelope
		set?: Enumerable<BlockWhereUniqueInput>
		disconnect?: Enumerable<BlockWhereUniqueInput>
		delete?: Enumerable<BlockWhereUniqueInput>
		connect?: Enumerable<BlockWhereUniqueInput>
		update?: Enumerable<BlockUpdateWithWhereUniqueWithoutLockedByUserInput>
		updateMany?: Enumerable<BlockUpdateManyWithWhereWithoutLockedByUserInput>
		deleteMany?: Enumerable<BlockScalarWhereInput>
	}

	export type BuildUpdateManyWithoutCreatedByInput = {
		create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutCreatedByInput>
		createMany?: BuildCreateManyCreatedByInputEnvelope
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutCreatedByInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutCreatedByInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type CommitUpdateManyWithoutUserInput = {
		create?: XOR<Enumerable<CommitCreateWithoutUserInput>, Enumerable<CommitUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<CommitCreateOrConnectWithoutUserInput>
		upsert?: Enumerable<CommitUpsertWithWhereUniqueWithoutUserInput>
		createMany?: CommitCreateManyUserInputEnvelope
		set?: Enumerable<CommitWhereUniqueInput>
		disconnect?: Enumerable<CommitWhereUniqueInput>
		delete?: Enumerable<CommitWhereUniqueInput>
		connect?: Enumerable<CommitWhereUniqueInput>
		update?: Enumerable<CommitUpdateWithWhereUniqueWithoutUserInput>
		updateMany?: Enumerable<CommitUpdateManyWithWhereWithoutUserInput>
		deleteMany?: Enumerable<CommitScalarWhereInput>
	}

	export type DeploymentUpdateManyWithoutCreatedByInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutCreatedByInput>, Enumerable<DeploymentUncheckedCreateWithoutCreatedByInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutCreatedByInput>
		upsert?: Enumerable<DeploymentUpsertWithWhereUniqueWithoutCreatedByInput>
		createMany?: DeploymentCreateManyCreatedByInputEnvelope
		set?: Enumerable<DeploymentWhereUniqueInput>
		disconnect?: Enumerable<DeploymentWhereUniqueInput>
		delete?: Enumerable<DeploymentWhereUniqueInput>
		connect?: Enumerable<DeploymentWhereUniqueInput>
		update?: Enumerable<DeploymentUpdateWithWhereUniqueWithoutCreatedByInput>
		updateMany?: Enumerable<DeploymentUpdateManyWithWhereWithoutCreatedByInput>
		deleteMany?: Enumerable<DeploymentScalarWhereInput>
	}

	export type EntityUpdateManyWithoutLockedByUserInput = {
		create?: XOR<Enumerable<EntityCreateWithoutLockedByUserInput>, Enumerable<EntityUncheckedCreateWithoutLockedByUserInput>>
		connectOrCreate?: Enumerable<EntityCreateOrConnectWithoutLockedByUserInput>
		upsert?: Enumerable<EntityUpsertWithWhereUniqueWithoutLockedByUserInput>
		createMany?: EntityCreateManyLockedByUserInputEnvelope
		set?: Enumerable<EntityWhereUniqueInput>
		disconnect?: Enumerable<EntityWhereUniqueInput>
		delete?: Enumerable<EntityWhereUniqueInput>
		connect?: Enumerable<EntityWhereUniqueInput>
		update?: Enumerable<EntityUpdateWithWhereUniqueWithoutLockedByUserInput>
		updateMany?: Enumerable<EntityUpdateManyWithWhereWithoutLockedByUserInput>
		deleteMany?: Enumerable<EntityScalarWhereInput>
	}

	export type UserRoleUpdateManyWithoutUserInput = {
		create?: XOR<Enumerable<UserRoleCreateWithoutUserInput>, Enumerable<UserRoleUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<UserRoleCreateOrConnectWithoutUserInput>
		upsert?: Enumerable<UserRoleUpsertWithWhereUniqueWithoutUserInput>
		createMany?: UserRoleCreateManyUserInputEnvelope
		set?: Enumerable<UserRoleWhereUniqueInput>
		disconnect?: Enumerable<UserRoleWhereUniqueInput>
		delete?: Enumerable<UserRoleWhereUniqueInput>
		connect?: Enumerable<UserRoleWhereUniqueInput>
		update?: Enumerable<UserRoleUpdateWithWhereUniqueWithoutUserInput>
		updateMany?: Enumerable<UserRoleUpdateManyWithWhereWithoutUserInput>
		deleteMany?: Enumerable<UserRoleScalarWhereInput>
	}

	export type InvitationUpdateManyWithoutInvitedByUserInput = {
		create?: XOR<Enumerable<InvitationCreateWithoutInvitedByUserInput>, Enumerable<InvitationUncheckedCreateWithoutInvitedByUserInput>>
		connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutInvitedByUserInput>
		upsert?: Enumerable<InvitationUpsertWithWhereUniqueWithoutInvitedByUserInput>
		createMany?: InvitationCreateManyInvitedByUserInputEnvelope
		set?: Enumerable<InvitationWhereUniqueInput>
		disconnect?: Enumerable<InvitationWhereUniqueInput>
		delete?: Enumerable<InvitationWhereUniqueInput>
		connect?: Enumerable<InvitationWhereUniqueInput>
		update?: Enumerable<InvitationUpdateWithWhereUniqueWithoutInvitedByUserInput>
		updateMany?: Enumerable<InvitationUpdateManyWithWhereWithoutInvitedByUserInput>
		deleteMany?: Enumerable<InvitationScalarWhereInput>
	}

	export type InvitationUpdateOneWithoutNewUserInput = {
		create?: XOR<InvitationCreateWithoutNewUserInput, InvitationUncheckedCreateWithoutNewUserInput>
		connectOrCreate?: InvitationCreateOrConnectWithoutNewUserInput
		upsert?: InvitationUpsertWithoutNewUserInput
		disconnect?: boolean
		delete?: boolean
		connect?: InvitationWhereUniqueInput
		update?: XOR<InvitationUpdateWithoutNewUserInput, InvitationUncheckedUpdateWithoutNewUserInput>
	}

	export type AccountUncheckedUpdateOneWithoutCurrentUserInput = {
		create?: XOR<AccountCreateWithoutCurrentUserInput, AccountUncheckedCreateWithoutCurrentUserInput>
		connectOrCreate?: AccountCreateOrConnectWithoutCurrentUserInput
		upsert?: AccountUpsertWithoutCurrentUserInput
		disconnect?: boolean
		delete?: boolean
		connect?: AccountWhereUniqueInput
		update?: XOR<AccountUpdateWithoutCurrentUserInput, AccountUncheckedUpdateWithoutCurrentUserInput>
	}

	export type ApiTokenUncheckedUpdateManyWithoutUserInput = {
		create?: XOR<Enumerable<ApiTokenCreateWithoutUserInput>, Enumerable<ApiTokenUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<ApiTokenCreateOrConnectWithoutUserInput>
		upsert?: Enumerable<ApiTokenUpsertWithWhereUniqueWithoutUserInput>
		createMany?: ApiTokenCreateManyUserInputEnvelope
		set?: Enumerable<ApiTokenWhereUniqueInput>
		disconnect?: Enumerable<ApiTokenWhereUniqueInput>
		delete?: Enumerable<ApiTokenWhereUniqueInput>
		connect?: Enumerable<ApiTokenWhereUniqueInput>
		update?: Enumerable<ApiTokenUpdateWithWhereUniqueWithoutUserInput>
		updateMany?: Enumerable<ApiTokenUpdateManyWithWhereWithoutUserInput>
		deleteMany?: Enumerable<ApiTokenScalarWhereInput>
	}

	export type BlockUncheckedUpdateManyWithoutLockedByUserInput = {
		create?: XOR<Enumerable<BlockCreateWithoutLockedByUserInput>, Enumerable<BlockUncheckedCreateWithoutLockedByUserInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutLockedByUserInput>
		upsert?: Enumerable<BlockUpsertWithWhereUniqueWithoutLockedByUserInput>
		createMany?: BlockCreateManyLockedByUserInputEnvelope
		set?: Enumerable<BlockWhereUniqueInput>
		disconnect?: Enumerable<BlockWhereUniqueInput>
		delete?: Enumerable<BlockWhereUniqueInput>
		connect?: Enumerable<BlockWhereUniqueInput>
		update?: Enumerable<BlockUpdateWithWhereUniqueWithoutLockedByUserInput>
		updateMany?: Enumerable<BlockUpdateManyWithWhereWithoutLockedByUserInput>
		deleteMany?: Enumerable<BlockScalarWhereInput>
	}

	export type BuildUncheckedUpdateManyWithoutCreatedByInput = {
		create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutCreatedByInput>
		createMany?: BuildCreateManyCreatedByInputEnvelope
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutCreatedByInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutCreatedByInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type CommitUncheckedUpdateManyWithoutUserInput = {
		create?: XOR<Enumerable<CommitCreateWithoutUserInput>, Enumerable<CommitUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<CommitCreateOrConnectWithoutUserInput>
		upsert?: Enumerable<CommitUpsertWithWhereUniqueWithoutUserInput>
		createMany?: CommitCreateManyUserInputEnvelope
		set?: Enumerable<CommitWhereUniqueInput>
		disconnect?: Enumerable<CommitWhereUniqueInput>
		delete?: Enumerable<CommitWhereUniqueInput>
		connect?: Enumerable<CommitWhereUniqueInput>
		update?: Enumerable<CommitUpdateWithWhereUniqueWithoutUserInput>
		updateMany?: Enumerable<CommitUpdateManyWithWhereWithoutUserInput>
		deleteMany?: Enumerable<CommitScalarWhereInput>
	}

	export type DeploymentUncheckedUpdateManyWithoutCreatedByInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutCreatedByInput>, Enumerable<DeploymentUncheckedCreateWithoutCreatedByInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutCreatedByInput>
		upsert?: Enumerable<DeploymentUpsertWithWhereUniqueWithoutCreatedByInput>
		createMany?: DeploymentCreateManyCreatedByInputEnvelope
		set?: Enumerable<DeploymentWhereUniqueInput>
		disconnect?: Enumerable<DeploymentWhereUniqueInput>
		delete?: Enumerable<DeploymentWhereUniqueInput>
		connect?: Enumerable<DeploymentWhereUniqueInput>
		update?: Enumerable<DeploymentUpdateWithWhereUniqueWithoutCreatedByInput>
		updateMany?: Enumerable<DeploymentUpdateManyWithWhereWithoutCreatedByInput>
		deleteMany?: Enumerable<DeploymentScalarWhereInput>
	}

	export type EntityUncheckedUpdateManyWithoutLockedByUserInput = {
		create?: XOR<Enumerable<EntityCreateWithoutLockedByUserInput>, Enumerable<EntityUncheckedCreateWithoutLockedByUserInput>>
		connectOrCreate?: Enumerable<EntityCreateOrConnectWithoutLockedByUserInput>
		upsert?: Enumerable<EntityUpsertWithWhereUniqueWithoutLockedByUserInput>
		createMany?: EntityCreateManyLockedByUserInputEnvelope
		set?: Enumerable<EntityWhereUniqueInput>
		disconnect?: Enumerable<EntityWhereUniqueInput>
		delete?: Enumerable<EntityWhereUniqueInput>
		connect?: Enumerable<EntityWhereUniqueInput>
		update?: Enumerable<EntityUpdateWithWhereUniqueWithoutLockedByUserInput>
		updateMany?: Enumerable<EntityUpdateManyWithWhereWithoutLockedByUserInput>
		deleteMany?: Enumerable<EntityScalarWhereInput>
	}

	export type UserRoleUncheckedUpdateManyWithoutUserInput = {
		create?: XOR<Enumerable<UserRoleCreateWithoutUserInput>, Enumerable<UserRoleUncheckedCreateWithoutUserInput>>
		connectOrCreate?: Enumerable<UserRoleCreateOrConnectWithoutUserInput>
		upsert?: Enumerable<UserRoleUpsertWithWhereUniqueWithoutUserInput>
		createMany?: UserRoleCreateManyUserInputEnvelope
		set?: Enumerable<UserRoleWhereUniqueInput>
		disconnect?: Enumerable<UserRoleWhereUniqueInput>
		delete?: Enumerable<UserRoleWhereUniqueInput>
		connect?: Enumerable<UserRoleWhereUniqueInput>
		update?: Enumerable<UserRoleUpdateWithWhereUniqueWithoutUserInput>
		updateMany?: Enumerable<UserRoleUpdateManyWithWhereWithoutUserInput>
		deleteMany?: Enumerable<UserRoleScalarWhereInput>
	}

	export type InvitationUncheckedUpdateManyWithoutInvitedByUserInput = {
		create?: XOR<Enumerable<InvitationCreateWithoutInvitedByUserInput>, Enumerable<InvitationUncheckedCreateWithoutInvitedByUserInput>>
		connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutInvitedByUserInput>
		upsert?: Enumerable<InvitationUpsertWithWhereUniqueWithoutInvitedByUserInput>
		createMany?: InvitationCreateManyInvitedByUserInputEnvelope
		set?: Enumerable<InvitationWhereUniqueInput>
		disconnect?: Enumerable<InvitationWhereUniqueInput>
		delete?: Enumerable<InvitationWhereUniqueInput>
		connect?: Enumerable<InvitationWhereUniqueInput>
		update?: Enumerable<InvitationUpdateWithWhereUniqueWithoutInvitedByUserInput>
		updateMany?: Enumerable<InvitationUpdateManyWithWhereWithoutInvitedByUserInput>
		deleteMany?: Enumerable<InvitationScalarWhereInput>
	}

	export type InvitationUncheckedUpdateOneWithoutNewUserInput = {
		create?: XOR<InvitationCreateWithoutNewUserInput, InvitationUncheckedCreateWithoutNewUserInput>
		connectOrCreate?: InvitationCreateOrConnectWithoutNewUserInput
		upsert?: InvitationUpsertWithoutNewUserInput
		disconnect?: boolean
		delete?: boolean
		connect?: InvitationWhereUniqueInput
		update?: XOR<InvitationUpdateWithoutNewUserInput, InvitationUncheckedUpdateWithoutNewUserInput>
	}

	export type UserCreateNestedOneWithoutUserRolesInput = {
		create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
		connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
		connect?: UserWhereUniqueInput
	}

	export type UserUpdateOneRequiredWithoutUserRolesInput = {
		create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
		connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
		upsert?: UserUpsertWithoutUserRolesInput
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
	}

	export type UserCreateNestedOneWithoutApiTokensInput = {
		create?: XOR<UserCreateWithoutApiTokensInput, UserUncheckedCreateWithoutApiTokensInput>
		connectOrCreate?: UserCreateOrConnectWithoutApiTokensInput
		connect?: UserWhereUniqueInput
	}

	export type UserUpdateOneRequiredWithoutApiTokensInput = {
		create?: XOR<UserCreateWithoutApiTokensInput, UserUncheckedCreateWithoutApiTokensInput>
		connectOrCreate?: UserCreateOrConnectWithoutApiTokensInput
		upsert?: UserUpsertWithoutApiTokensInput
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutApiTokensInput, UserUncheckedUpdateWithoutApiTokensInput>
	}

	export type ResourceRoleCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<ResourceRoleCreateWithoutResourceInput>, Enumerable<ResourceRoleUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<ResourceRoleCreateOrConnectWithoutResourceInput>
		createMany?: ResourceRoleCreateManyResourceInputEnvelope
		connect?: Enumerable<ResourceRoleWhereUniqueInput>
	}

	export type BlockCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<BlockCreateWithoutResourceInput>, Enumerable<BlockUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutResourceInput>
		createMany?: BlockCreateManyResourceInputEnvelope
		connect?: Enumerable<BlockWhereUniqueInput>
	}

	export type BuildCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<BuildCreateWithoutResourceInput>, Enumerable<BuildUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutResourceInput>
		createMany?: BuildCreateManyResourceInputEnvelope
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type EntityCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<EntityCreateWithoutResourceInput>, Enumerable<EntityUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<EntityCreateOrConnectWithoutResourceInput>
		createMany?: EntityCreateManyResourceInputEnvelope
		connect?: Enumerable<EntityWhereUniqueInput>
	}

	export type EnvironmentCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<EnvironmentCreateWithoutResourceInput>, Enumerable<EnvironmentUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<EnvironmentCreateOrConnectWithoutResourceInput>
		createMany?: EnvironmentCreateManyResourceInputEnvelope
		connect?: Enumerable<EnvironmentWhereUniqueInput>
	}

	export type GitRepositoryCreateNestedOneWithoutResourcesInput = {
		create?: XOR<GitRepositoryCreateWithoutResourcesInput, GitRepositoryUncheckedCreateWithoutResourcesInput>
		connectOrCreate?: GitRepositoryCreateOrConnectWithoutResourcesInput
		connect?: GitRepositoryWhereUniqueInput
	}

	export type ProjectCreateNestedOneWithoutResourcesInput = {
		create?: XOR<ProjectCreateWithoutResourcesInput, ProjectUncheckedCreateWithoutResourcesInput>
		connectOrCreate?: ProjectCreateOrConnectWithoutResourcesInput
		connect?: ProjectWhereUniqueInput
	}

	export type ResourceRoleUncheckedCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<ResourceRoleCreateWithoutResourceInput>, Enumerable<ResourceRoleUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<ResourceRoleCreateOrConnectWithoutResourceInput>
		createMany?: ResourceRoleCreateManyResourceInputEnvelope
		connect?: Enumerable<ResourceRoleWhereUniqueInput>
	}

	export type BlockUncheckedCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<BlockCreateWithoutResourceInput>, Enumerable<BlockUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutResourceInput>
		createMany?: BlockCreateManyResourceInputEnvelope
		connect?: Enumerable<BlockWhereUniqueInput>
	}

	export type BuildUncheckedCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<BuildCreateWithoutResourceInput>, Enumerable<BuildUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutResourceInput>
		createMany?: BuildCreateManyResourceInputEnvelope
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type EntityUncheckedCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<EntityCreateWithoutResourceInput>, Enumerable<EntityUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<EntityCreateOrConnectWithoutResourceInput>
		createMany?: EntityCreateManyResourceInputEnvelope
		connect?: Enumerable<EntityWhereUniqueInput>
	}

	export type EnvironmentUncheckedCreateNestedManyWithoutResourceInput = {
		create?: XOR<Enumerable<EnvironmentCreateWithoutResourceInput>, Enumerable<EnvironmentUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<EnvironmentCreateOrConnectWithoutResourceInput>
		createMany?: EnvironmentCreateManyResourceInputEnvelope
		connect?: Enumerable<EnvironmentWhereUniqueInput>
	}

	export type ResourceRoleUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<ResourceRoleCreateWithoutResourceInput>, Enumerable<ResourceRoleUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<ResourceRoleCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<ResourceRoleUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: ResourceRoleCreateManyResourceInputEnvelope
		set?: Enumerable<ResourceRoleWhereUniqueInput>
		disconnect?: Enumerable<ResourceRoleWhereUniqueInput>
		delete?: Enumerable<ResourceRoleWhereUniqueInput>
		connect?: Enumerable<ResourceRoleWhereUniqueInput>
		update?: Enumerable<ResourceRoleUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<ResourceRoleUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<ResourceRoleScalarWhereInput>
	}

	export type BlockUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<BlockCreateWithoutResourceInput>, Enumerable<BlockUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<BlockUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: BlockCreateManyResourceInputEnvelope
		set?: Enumerable<BlockWhereUniqueInput>
		disconnect?: Enumerable<BlockWhereUniqueInput>
		delete?: Enumerable<BlockWhereUniqueInput>
		connect?: Enumerable<BlockWhereUniqueInput>
		update?: Enumerable<BlockUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<BlockUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<BlockScalarWhereInput>
	}

	export type BuildUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<BuildCreateWithoutResourceInput>, Enumerable<BuildUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: BuildCreateManyResourceInputEnvelope
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type EntityUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<EntityCreateWithoutResourceInput>, Enumerable<EntityUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<EntityCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<EntityUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: EntityCreateManyResourceInputEnvelope
		set?: Enumerable<EntityWhereUniqueInput>
		disconnect?: Enumerable<EntityWhereUniqueInput>
		delete?: Enumerable<EntityWhereUniqueInput>
		connect?: Enumerable<EntityWhereUniqueInput>
		update?: Enumerable<EntityUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<EntityUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<EntityScalarWhereInput>
	}

	export type EnvironmentUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<EnvironmentCreateWithoutResourceInput>, Enumerable<EnvironmentUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<EnvironmentCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<EnvironmentUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: EnvironmentCreateManyResourceInputEnvelope
		set?: Enumerable<EnvironmentWhereUniqueInput>
		disconnect?: Enumerable<EnvironmentWhereUniqueInput>
		delete?: Enumerable<EnvironmentWhereUniqueInput>
		connect?: Enumerable<EnvironmentWhereUniqueInput>
		update?: Enumerable<EnvironmentUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<EnvironmentUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<EnvironmentScalarWhereInput>
	}

	export type GitRepositoryUpdateOneWithoutResourcesInput = {
		create?: XOR<GitRepositoryCreateWithoutResourcesInput, GitRepositoryUncheckedCreateWithoutResourcesInput>
		connectOrCreate?: GitRepositoryCreateOrConnectWithoutResourcesInput
		upsert?: GitRepositoryUpsertWithoutResourcesInput
		disconnect?: boolean
		delete?: boolean
		connect?: GitRepositoryWhereUniqueInput
		update?: XOR<GitRepositoryUpdateWithoutResourcesInput, GitRepositoryUncheckedUpdateWithoutResourcesInput>
	}

	export type ProjectUpdateOneRequiredWithoutResourcesInput = {
		create?: XOR<ProjectCreateWithoutResourcesInput, ProjectUncheckedCreateWithoutResourcesInput>
		connectOrCreate?: ProjectCreateOrConnectWithoutResourcesInput
		upsert?: ProjectUpsertWithoutResourcesInput
		connect?: ProjectWhereUniqueInput
		update?: XOR<ProjectUpdateWithoutResourcesInput, ProjectUncheckedUpdateWithoutResourcesInput>
	}

	export type EnumEnumResourceTypeFieldUpdateOperationsInput = {
		set?: EnumResourceType
	}

	export type ResourceRoleUncheckedUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<ResourceRoleCreateWithoutResourceInput>, Enumerable<ResourceRoleUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<ResourceRoleCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<ResourceRoleUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: ResourceRoleCreateManyResourceInputEnvelope
		set?: Enumerable<ResourceRoleWhereUniqueInput>
		disconnect?: Enumerable<ResourceRoleWhereUniqueInput>
		delete?: Enumerable<ResourceRoleWhereUniqueInput>
		connect?: Enumerable<ResourceRoleWhereUniqueInput>
		update?: Enumerable<ResourceRoleUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<ResourceRoleUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<ResourceRoleScalarWhereInput>
	}

	export type BlockUncheckedUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<BlockCreateWithoutResourceInput>, Enumerable<BlockUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<BlockUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: BlockCreateManyResourceInputEnvelope
		set?: Enumerable<BlockWhereUniqueInput>
		disconnect?: Enumerable<BlockWhereUniqueInput>
		delete?: Enumerable<BlockWhereUniqueInput>
		connect?: Enumerable<BlockWhereUniqueInput>
		update?: Enumerable<BlockUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<BlockUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<BlockScalarWhereInput>
	}

	export type BuildUncheckedUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<BuildCreateWithoutResourceInput>, Enumerable<BuildUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: BuildCreateManyResourceInputEnvelope
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type EntityUncheckedUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<EntityCreateWithoutResourceInput>, Enumerable<EntityUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<EntityCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<EntityUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: EntityCreateManyResourceInputEnvelope
		set?: Enumerable<EntityWhereUniqueInput>
		disconnect?: Enumerable<EntityWhereUniqueInput>
		delete?: Enumerable<EntityWhereUniqueInput>
		connect?: Enumerable<EntityWhereUniqueInput>
		update?: Enumerable<EntityUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<EntityUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<EntityScalarWhereInput>
	}

	export type EnvironmentUncheckedUpdateManyWithoutResourceInput = {
		create?: XOR<Enumerable<EnvironmentCreateWithoutResourceInput>, Enumerable<EnvironmentUncheckedCreateWithoutResourceInput>>
		connectOrCreate?: Enumerable<EnvironmentCreateOrConnectWithoutResourceInput>
		upsert?: Enumerable<EnvironmentUpsertWithWhereUniqueWithoutResourceInput>
		createMany?: EnvironmentCreateManyResourceInputEnvelope
		set?: Enumerable<EnvironmentWhereUniqueInput>
		disconnect?: Enumerable<EnvironmentWhereUniqueInput>
		delete?: Enumerable<EnvironmentWhereUniqueInput>
		connect?: Enumerable<EnvironmentWhereUniqueInput>
		update?: Enumerable<EnvironmentUpdateWithWhereUniqueWithoutResourceInput>
		updateMany?: Enumerable<EnvironmentUpdateManyWithWhereWithoutResourceInput>
		deleteMany?: Enumerable<EnvironmentScalarWhereInput>
	}

	export type ResourceCreateNestedOneWithoutRolesInput = {
		create?: XOR<ResourceCreateWithoutRolesInput, ResourceUncheckedCreateWithoutRolesInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutRolesInput
		connect?: ResourceWhereUniqueInput
	}

	export type EntityPermissionRoleCreateNestedManyWithoutResourceRoleInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutResourceRoleInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutResourceRoleInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutResourceRoleInput>
		createMany?: EntityPermissionRoleCreateManyResourceRoleInputEnvelope
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
	}

	export type EntityPermissionRoleUncheckedCreateNestedManyWithoutResourceRoleInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutResourceRoleInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutResourceRoleInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutResourceRoleInput>
		createMany?: EntityPermissionRoleCreateManyResourceRoleInputEnvelope
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
	}

	export type ResourceUpdateOneRequiredWithoutRolesInput = {
		create?: XOR<ResourceCreateWithoutRolesInput, ResourceUncheckedCreateWithoutRolesInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutRolesInput
		upsert?: ResourceUpsertWithoutRolesInput
		connect?: ResourceWhereUniqueInput
		update?: XOR<ResourceUpdateWithoutRolesInput, ResourceUncheckedUpdateWithoutRolesInput>
	}

	export type EntityPermissionRoleUpdateManyWithoutResourceRoleInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutResourceRoleInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutResourceRoleInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutResourceRoleInput>
		upsert?: Enumerable<EntityPermissionRoleUpsertWithWhereUniqueWithoutResourceRoleInput>
		createMany?: EntityPermissionRoleCreateManyResourceRoleInputEnvelope
		set?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		delete?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		update?: Enumerable<EntityPermissionRoleUpdateWithWhereUniqueWithoutResourceRoleInput>
		updateMany?: Enumerable<EntityPermissionRoleUpdateManyWithWhereWithoutResourceRoleInput>
		deleteMany?: Enumerable<EntityPermissionRoleScalarWhereInput>
	}

	export type EntityPermissionRoleUncheckedUpdateManyWithoutResourceRoleInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutResourceRoleInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutResourceRoleInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutResourceRoleInput>
		upsert?: Enumerable<EntityPermissionRoleUpsertWithWhereUniqueWithoutResourceRoleInput>
		createMany?: EntityPermissionRoleCreateManyResourceRoleInputEnvelope
		set?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		delete?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		update?: Enumerable<EntityPermissionRoleUpdateWithWhereUniqueWithoutResourceRoleInput>
		updateMany?: Enumerable<EntityPermissionRoleUpdateManyWithWhereWithoutResourceRoleInput>
		deleteMany?: Enumerable<EntityPermissionRoleScalarWhereInput>
	}

	export type UserCreateNestedOneWithoutCommitsInput = {
		create?: XOR<UserCreateWithoutCommitsInput, UserUncheckedCreateWithoutCommitsInput>
		connectOrCreate?: UserCreateOrConnectWithoutCommitsInput
		connect?: UserWhereUniqueInput
	}

	export type BlockVersionCreateNestedManyWithoutCommitInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutCommitInput>, Enumerable<BlockVersionUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutCommitInput>
		createMany?: BlockVersionCreateManyCommitInputEnvelope
		connect?: Enumerable<BlockVersionWhereUniqueInput>
	}

	export type BuildCreateNestedManyWithoutCommitInput = {
		create?: XOR<Enumerable<BuildCreateWithoutCommitInput>, Enumerable<BuildUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCommitInput>
		createMany?: BuildCreateManyCommitInputEnvelope
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type EntityVersionCreateNestedManyWithoutCommitInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutCommitInput>, Enumerable<EntityVersionUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutCommitInput>
		createMany?: EntityVersionCreateManyCommitInputEnvelope
		connect?: Enumerable<EntityVersionWhereUniqueInput>
	}

	export type ReleaseCreateNestedManyWithoutCommitInput = {
		create?: XOR<Enumerable<ReleaseCreateWithoutCommitInput>, Enumerable<ReleaseUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<ReleaseCreateOrConnectWithoutCommitInput>
		createMany?: ReleaseCreateManyCommitInputEnvelope
		connect?: Enumerable<ReleaseWhereUniqueInput>
	}

	export type ProjectCreateNestedOneWithoutCommitsInput = {
		create?: XOR<ProjectCreateWithoutCommitsInput, ProjectUncheckedCreateWithoutCommitsInput>
		connectOrCreate?: ProjectCreateOrConnectWithoutCommitsInput
		connect?: ProjectWhereUniqueInput
	}

	export type BlockVersionUncheckedCreateNestedManyWithoutCommitInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutCommitInput>, Enumerable<BlockVersionUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutCommitInput>
		createMany?: BlockVersionCreateManyCommitInputEnvelope
		connect?: Enumerable<BlockVersionWhereUniqueInput>
	}

	export type BuildUncheckedCreateNestedManyWithoutCommitInput = {
		create?: XOR<Enumerable<BuildCreateWithoutCommitInput>, Enumerable<BuildUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCommitInput>
		createMany?: BuildCreateManyCommitInputEnvelope
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type EntityVersionUncheckedCreateNestedManyWithoutCommitInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutCommitInput>, Enumerable<EntityVersionUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutCommitInput>
		createMany?: EntityVersionCreateManyCommitInputEnvelope
		connect?: Enumerable<EntityVersionWhereUniqueInput>
	}

	export type ReleaseUncheckedCreateNestedManyWithoutCommitInput = {
		create?: XOR<Enumerable<ReleaseCreateWithoutCommitInput>, Enumerable<ReleaseUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<ReleaseCreateOrConnectWithoutCommitInput>
		createMany?: ReleaseCreateManyCommitInputEnvelope
		connect?: Enumerable<ReleaseWhereUniqueInput>
	}

	export type UserUpdateOneRequiredWithoutCommitsInput = {
		create?: XOR<UserCreateWithoutCommitsInput, UserUncheckedCreateWithoutCommitsInput>
		connectOrCreate?: UserCreateOrConnectWithoutCommitsInput
		upsert?: UserUpsertWithoutCommitsInput
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutCommitsInput, UserUncheckedUpdateWithoutCommitsInput>
	}

	export type BlockVersionUpdateManyWithoutCommitInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutCommitInput>, Enumerable<BlockVersionUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutCommitInput>
		upsert?: Enumerable<BlockVersionUpsertWithWhereUniqueWithoutCommitInput>
		createMany?: BlockVersionCreateManyCommitInputEnvelope
		set?: Enumerable<BlockVersionWhereUniqueInput>
		disconnect?: Enumerable<BlockVersionWhereUniqueInput>
		delete?: Enumerable<BlockVersionWhereUniqueInput>
		connect?: Enumerable<BlockVersionWhereUniqueInput>
		update?: Enumerable<BlockVersionUpdateWithWhereUniqueWithoutCommitInput>
		updateMany?: Enumerable<BlockVersionUpdateManyWithWhereWithoutCommitInput>
		deleteMany?: Enumerable<BlockVersionScalarWhereInput>
	}

	export type BuildUpdateManyWithoutCommitInput = {
		create?: XOR<Enumerable<BuildCreateWithoutCommitInput>, Enumerable<BuildUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCommitInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutCommitInput>
		createMany?: BuildCreateManyCommitInputEnvelope
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutCommitInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutCommitInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type EntityVersionUpdateManyWithoutCommitInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutCommitInput>, Enumerable<EntityVersionUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutCommitInput>
		upsert?: Enumerable<EntityVersionUpsertWithWhereUniqueWithoutCommitInput>
		createMany?: EntityVersionCreateManyCommitInputEnvelope
		set?: Enumerable<EntityVersionWhereUniqueInput>
		disconnect?: Enumerable<EntityVersionWhereUniqueInput>
		delete?: Enumerable<EntityVersionWhereUniqueInput>
		connect?: Enumerable<EntityVersionWhereUniqueInput>
		update?: Enumerable<EntityVersionUpdateWithWhereUniqueWithoutCommitInput>
		updateMany?: Enumerable<EntityVersionUpdateManyWithWhereWithoutCommitInput>
		deleteMany?: Enumerable<EntityVersionScalarWhereInput>
	}

	export type ReleaseUpdateManyWithoutCommitInput = {
		create?: XOR<Enumerable<ReleaseCreateWithoutCommitInput>, Enumerable<ReleaseUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<ReleaseCreateOrConnectWithoutCommitInput>
		upsert?: Enumerable<ReleaseUpsertWithWhereUniqueWithoutCommitInput>
		createMany?: ReleaseCreateManyCommitInputEnvelope
		set?: Enumerable<ReleaseWhereUniqueInput>
		disconnect?: Enumerable<ReleaseWhereUniqueInput>
		delete?: Enumerable<ReleaseWhereUniqueInput>
		connect?: Enumerable<ReleaseWhereUniqueInput>
		update?: Enumerable<ReleaseUpdateWithWhereUniqueWithoutCommitInput>
		updateMany?: Enumerable<ReleaseUpdateManyWithWhereWithoutCommitInput>
		deleteMany?: Enumerable<ReleaseScalarWhereInput>
	}

	export type ProjectUpdateOneRequiredWithoutCommitsInput = {
		create?: XOR<ProjectCreateWithoutCommitsInput, ProjectUncheckedCreateWithoutCommitsInput>
		connectOrCreate?: ProjectCreateOrConnectWithoutCommitsInput
		upsert?: ProjectUpsertWithoutCommitsInput
		connect?: ProjectWhereUniqueInput
		update?: XOR<ProjectUpdateWithoutCommitsInput, ProjectUncheckedUpdateWithoutCommitsInput>
	}

	export type BlockVersionUncheckedUpdateManyWithoutCommitInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutCommitInput>, Enumerable<BlockVersionUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutCommitInput>
		upsert?: Enumerable<BlockVersionUpsertWithWhereUniqueWithoutCommitInput>
		createMany?: BlockVersionCreateManyCommitInputEnvelope
		set?: Enumerable<BlockVersionWhereUniqueInput>
		disconnect?: Enumerable<BlockVersionWhereUniqueInput>
		delete?: Enumerable<BlockVersionWhereUniqueInput>
		connect?: Enumerable<BlockVersionWhereUniqueInput>
		update?: Enumerable<BlockVersionUpdateWithWhereUniqueWithoutCommitInput>
		updateMany?: Enumerable<BlockVersionUpdateManyWithWhereWithoutCommitInput>
		deleteMany?: Enumerable<BlockVersionScalarWhereInput>
	}

	export type BuildUncheckedUpdateManyWithoutCommitInput = {
		create?: XOR<Enumerable<BuildCreateWithoutCommitInput>, Enumerable<BuildUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCommitInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutCommitInput>
		createMany?: BuildCreateManyCommitInputEnvelope
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutCommitInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutCommitInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type EntityVersionUncheckedUpdateManyWithoutCommitInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutCommitInput>, Enumerable<EntityVersionUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutCommitInput>
		upsert?: Enumerable<EntityVersionUpsertWithWhereUniqueWithoutCommitInput>
		createMany?: EntityVersionCreateManyCommitInputEnvelope
		set?: Enumerable<EntityVersionWhereUniqueInput>
		disconnect?: Enumerable<EntityVersionWhereUniqueInput>
		delete?: Enumerable<EntityVersionWhereUniqueInput>
		connect?: Enumerable<EntityVersionWhereUniqueInput>
		update?: Enumerable<EntityVersionUpdateWithWhereUniqueWithoutCommitInput>
		updateMany?: Enumerable<EntityVersionUpdateManyWithWhereWithoutCommitInput>
		deleteMany?: Enumerable<EntityVersionScalarWhereInput>
	}

	export type ReleaseUncheckedUpdateManyWithoutCommitInput = {
		create?: XOR<Enumerable<ReleaseCreateWithoutCommitInput>, Enumerable<ReleaseUncheckedCreateWithoutCommitInput>>
		connectOrCreate?: Enumerable<ReleaseCreateOrConnectWithoutCommitInput>
		upsert?: Enumerable<ReleaseUpsertWithWhereUniqueWithoutCommitInput>
		createMany?: ReleaseCreateManyCommitInputEnvelope
		set?: Enumerable<ReleaseWhereUniqueInput>
		disconnect?: Enumerable<ReleaseWhereUniqueInput>
		delete?: Enumerable<ReleaseWhereUniqueInput>
		connect?: Enumerable<ReleaseWhereUniqueInput>
		update?: Enumerable<ReleaseUpdateWithWhereUniqueWithoutCommitInput>
		updateMany?: Enumerable<ReleaseUpdateManyWithWhereWithoutCommitInput>
		deleteMany?: Enumerable<ReleaseScalarWhereInput>
	}

	export type ResourceCreateNestedOneWithoutEntitiesInput = {
		create?: XOR<ResourceCreateWithoutEntitiesInput, ResourceUncheckedCreateWithoutEntitiesInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutEntitiesInput
		connect?: ResourceWhereUniqueInput
	}

	export type UserCreateNestedOneWithoutLockedEntitisInput = {
		create?: XOR<UserCreateWithoutLockedEntitisInput, UserUncheckedCreateWithoutLockedEntitisInput>
		connectOrCreate?: UserCreateOrConnectWithoutLockedEntitisInput
		connect?: UserWhereUniqueInput
	}

	export type EntityVersionCreateNestedManyWithoutEntityInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutEntityInput>, Enumerable<EntityVersionUncheckedCreateWithoutEntityInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutEntityInput>
		createMany?: EntityVersionCreateManyEntityInputEnvelope
		connect?: Enumerable<EntityVersionWhereUniqueInput>
	}

	export type EntityVersionUncheckedCreateNestedManyWithoutEntityInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutEntityInput>, Enumerable<EntityVersionUncheckedCreateWithoutEntityInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutEntityInput>
		createMany?: EntityVersionCreateManyEntityInputEnvelope
		connect?: Enumerable<EntityVersionWhereUniqueInput>
	}

	export type ResourceUpdateOneRequiredWithoutEntitiesInput = {
		create?: XOR<ResourceCreateWithoutEntitiesInput, ResourceUncheckedCreateWithoutEntitiesInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutEntitiesInput
		upsert?: ResourceUpsertWithoutEntitiesInput
		connect?: ResourceWhereUniqueInput
		update?: XOR<ResourceUpdateWithoutEntitiesInput, ResourceUncheckedUpdateWithoutEntitiesInput>
	}

	export type UserUpdateOneWithoutLockedEntitisInput = {
		create?: XOR<UserCreateWithoutLockedEntitisInput, UserUncheckedCreateWithoutLockedEntitisInput>
		connectOrCreate?: UserCreateOrConnectWithoutLockedEntitisInput
		upsert?: UserUpsertWithoutLockedEntitisInput
		disconnect?: boolean
		delete?: boolean
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutLockedEntitisInput, UserUncheckedUpdateWithoutLockedEntitisInput>
	}

	export type EntityVersionUpdateManyWithoutEntityInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutEntityInput>, Enumerable<EntityVersionUncheckedCreateWithoutEntityInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutEntityInput>
		upsert?: Enumerable<EntityVersionUpsertWithWhereUniqueWithoutEntityInput>
		createMany?: EntityVersionCreateManyEntityInputEnvelope
		set?: Enumerable<EntityVersionWhereUniqueInput>
		disconnect?: Enumerable<EntityVersionWhereUniqueInput>
		delete?: Enumerable<EntityVersionWhereUniqueInput>
		connect?: Enumerable<EntityVersionWhereUniqueInput>
		update?: Enumerable<EntityVersionUpdateWithWhereUniqueWithoutEntityInput>
		updateMany?: Enumerable<EntityVersionUpdateManyWithWhereWithoutEntityInput>
		deleteMany?: Enumerable<EntityVersionScalarWhereInput>
	}

	export type EntityVersionUncheckedUpdateManyWithoutEntityInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutEntityInput>, Enumerable<EntityVersionUncheckedCreateWithoutEntityInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutEntityInput>
		upsert?: Enumerable<EntityVersionUpsertWithWhereUniqueWithoutEntityInput>
		createMany?: EntityVersionCreateManyEntityInputEnvelope
		set?: Enumerable<EntityVersionWhereUniqueInput>
		disconnect?: Enumerable<EntityVersionWhereUniqueInput>
		delete?: Enumerable<EntityVersionWhereUniqueInput>
		connect?: Enumerable<EntityVersionWhereUniqueInput>
		update?: Enumerable<EntityVersionUpdateWithWhereUniqueWithoutEntityInput>
		updateMany?: Enumerable<EntityVersionUpdateManyWithWhereWithoutEntityInput>
		deleteMany?: Enumerable<EntityVersionScalarWhereInput>
	}

	export type CommitCreateNestedOneWithoutEntityVersionsInput = {
		create?: XOR<CommitCreateWithoutEntityVersionsInput, CommitUncheckedCreateWithoutEntityVersionsInput>
		connectOrCreate?: CommitCreateOrConnectWithoutEntityVersionsInput
		connect?: CommitWhereUniqueInput
	}

	export type EntityCreateNestedOneWithoutVersionsInput = {
		create?: XOR<EntityCreateWithoutVersionsInput, EntityUncheckedCreateWithoutVersionsInput>
		connectOrCreate?: EntityCreateOrConnectWithoutVersionsInput
		connect?: EntityWhereUniqueInput
	}

	export type EntityFieldCreateNestedManyWithoutEntityVersionInput = {
		create?: XOR<Enumerable<EntityFieldCreateWithoutEntityVersionInput>, Enumerable<EntityFieldUncheckedCreateWithoutEntityVersionInput>>
		connectOrCreate?: Enumerable<EntityFieldCreateOrConnectWithoutEntityVersionInput>
		createMany?: EntityFieldCreateManyEntityVersionInputEnvelope
		connect?: Enumerable<EntityFieldWhereUniqueInput>
	}

	export type EntityPermissionCreateNestedManyWithoutEntityVersionInput = {
		create?: XOR<Enumerable<EntityPermissionCreateWithoutEntityVersionInput>, Enumerable<EntityPermissionUncheckedCreateWithoutEntityVersionInput>>
		connectOrCreate?: Enumerable<EntityPermissionCreateOrConnectWithoutEntityVersionInput>
		createMany?: EntityPermissionCreateManyEntityVersionInputEnvelope
		connect?: Enumerable<EntityPermissionWhereUniqueInput>
	}

	export type BuildCreateNestedManyWithoutEntityVersionsInput = {
		create?: XOR<Enumerable<BuildCreateWithoutEntityVersionsInput>, Enumerable<BuildUncheckedCreateWithoutEntityVersionsInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEntityVersionsInput>
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type EntityFieldUncheckedCreateNestedManyWithoutEntityVersionInput = {
		create?: XOR<Enumerable<EntityFieldCreateWithoutEntityVersionInput>, Enumerable<EntityFieldUncheckedCreateWithoutEntityVersionInput>>
		connectOrCreate?: Enumerable<EntityFieldCreateOrConnectWithoutEntityVersionInput>
		createMany?: EntityFieldCreateManyEntityVersionInputEnvelope
		connect?: Enumerable<EntityFieldWhereUniqueInput>
	}

	export type EntityPermissionUncheckedCreateNestedManyWithoutEntityVersionInput = {
		create?: XOR<Enumerable<EntityPermissionCreateWithoutEntityVersionInput>, Enumerable<EntityPermissionUncheckedCreateWithoutEntityVersionInput>>
		connectOrCreate?: Enumerable<EntityPermissionCreateOrConnectWithoutEntityVersionInput>
		createMany?: EntityPermissionCreateManyEntityVersionInputEnvelope
		connect?: Enumerable<EntityPermissionWhereUniqueInput>
	}

	export type BuildUncheckedCreateNestedManyWithoutEntityVersionsInput = {
		create?: XOR<Enumerable<BuildCreateWithoutEntityVersionsInput>, Enumerable<BuildUncheckedCreateWithoutEntityVersionsInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEntityVersionsInput>
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type IntFieldUpdateOperationsInput = {
		set?: number
		increment?: number
		decrement?: number
		multiply?: number
		divide?: number
	}

	export type NullableBoolFieldUpdateOperationsInput = {
		set?: boolean | null
	}

	export type CommitUpdateOneWithoutEntityVersionsInput = {
		create?: XOR<CommitCreateWithoutEntityVersionsInput, CommitUncheckedCreateWithoutEntityVersionsInput>
		connectOrCreate?: CommitCreateOrConnectWithoutEntityVersionsInput
		upsert?: CommitUpsertWithoutEntityVersionsInput
		disconnect?: boolean
		delete?: boolean
		connect?: CommitWhereUniqueInput
		update?: XOR<CommitUpdateWithoutEntityVersionsInput, CommitUncheckedUpdateWithoutEntityVersionsInput>
	}

	export type EntityUpdateOneRequiredWithoutVersionsInput = {
		create?: XOR<EntityCreateWithoutVersionsInput, EntityUncheckedCreateWithoutVersionsInput>
		connectOrCreate?: EntityCreateOrConnectWithoutVersionsInput
		upsert?: EntityUpsertWithoutVersionsInput
		connect?: EntityWhereUniqueInput
		update?: XOR<EntityUpdateWithoutVersionsInput, EntityUncheckedUpdateWithoutVersionsInput>
	}

	export type EntityFieldUpdateManyWithoutEntityVersionInput = {
		create?: XOR<Enumerable<EntityFieldCreateWithoutEntityVersionInput>, Enumerable<EntityFieldUncheckedCreateWithoutEntityVersionInput>>
		connectOrCreate?: Enumerable<EntityFieldCreateOrConnectWithoutEntityVersionInput>
		upsert?: Enumerable<EntityFieldUpsertWithWhereUniqueWithoutEntityVersionInput>
		createMany?: EntityFieldCreateManyEntityVersionInputEnvelope
		set?: Enumerable<EntityFieldWhereUniqueInput>
		disconnect?: Enumerable<EntityFieldWhereUniqueInput>
		delete?: Enumerable<EntityFieldWhereUniqueInput>
		connect?: Enumerable<EntityFieldWhereUniqueInput>
		update?: Enumerable<EntityFieldUpdateWithWhereUniqueWithoutEntityVersionInput>
		updateMany?: Enumerable<EntityFieldUpdateManyWithWhereWithoutEntityVersionInput>
		deleteMany?: Enumerable<EntityFieldScalarWhereInput>
	}

	export type EntityPermissionUpdateManyWithoutEntityVersionInput = {
		create?: XOR<Enumerable<EntityPermissionCreateWithoutEntityVersionInput>, Enumerable<EntityPermissionUncheckedCreateWithoutEntityVersionInput>>
		connectOrCreate?: Enumerable<EntityPermissionCreateOrConnectWithoutEntityVersionInput>
		upsert?: Enumerable<EntityPermissionUpsertWithWhereUniqueWithoutEntityVersionInput>
		createMany?: EntityPermissionCreateManyEntityVersionInputEnvelope
		set?: Enumerable<EntityPermissionWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionWhereUniqueInput>
		delete?: Enumerable<EntityPermissionWhereUniqueInput>
		connect?: Enumerable<EntityPermissionWhereUniqueInput>
		update?: Enumerable<EntityPermissionUpdateWithWhereUniqueWithoutEntityVersionInput>
		updateMany?: Enumerable<EntityPermissionUpdateManyWithWhereWithoutEntityVersionInput>
		deleteMany?: Enumerable<EntityPermissionScalarWhereInput>
	}

	export type BuildUpdateManyWithoutEntityVersionsInput = {
		create?: XOR<Enumerable<BuildCreateWithoutEntityVersionsInput>, Enumerable<BuildUncheckedCreateWithoutEntityVersionsInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEntityVersionsInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutEntityVersionsInput>
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutEntityVersionsInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutEntityVersionsInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type EntityFieldUncheckedUpdateManyWithoutEntityVersionInput = {
		create?: XOR<Enumerable<EntityFieldCreateWithoutEntityVersionInput>, Enumerable<EntityFieldUncheckedCreateWithoutEntityVersionInput>>
		connectOrCreate?: Enumerable<EntityFieldCreateOrConnectWithoutEntityVersionInput>
		upsert?: Enumerable<EntityFieldUpsertWithWhereUniqueWithoutEntityVersionInput>
		createMany?: EntityFieldCreateManyEntityVersionInputEnvelope
		set?: Enumerable<EntityFieldWhereUniqueInput>
		disconnect?: Enumerable<EntityFieldWhereUniqueInput>
		delete?: Enumerable<EntityFieldWhereUniqueInput>
		connect?: Enumerable<EntityFieldWhereUniqueInput>
		update?: Enumerable<EntityFieldUpdateWithWhereUniqueWithoutEntityVersionInput>
		updateMany?: Enumerable<EntityFieldUpdateManyWithWhereWithoutEntityVersionInput>
		deleteMany?: Enumerable<EntityFieldScalarWhereInput>
	}

	export type EntityPermissionUncheckedUpdateManyWithoutEntityVersionInput = {
		create?: XOR<Enumerable<EntityPermissionCreateWithoutEntityVersionInput>, Enumerable<EntityPermissionUncheckedCreateWithoutEntityVersionInput>>
		connectOrCreate?: Enumerable<EntityPermissionCreateOrConnectWithoutEntityVersionInput>
		upsert?: Enumerable<EntityPermissionUpsertWithWhereUniqueWithoutEntityVersionInput>
		createMany?: EntityPermissionCreateManyEntityVersionInputEnvelope
		set?: Enumerable<EntityPermissionWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionWhereUniqueInput>
		delete?: Enumerable<EntityPermissionWhereUniqueInput>
		connect?: Enumerable<EntityPermissionWhereUniqueInput>
		update?: Enumerable<EntityPermissionUpdateWithWhereUniqueWithoutEntityVersionInput>
		updateMany?: Enumerable<EntityPermissionUpdateManyWithWhereWithoutEntityVersionInput>
		deleteMany?: Enumerable<EntityPermissionScalarWhereInput>
	}

	export type BuildUncheckedUpdateManyWithoutEntityVersionsInput = {
		create?: XOR<Enumerable<BuildCreateWithoutEntityVersionsInput>, Enumerable<BuildUncheckedCreateWithoutEntityVersionsInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEntityVersionsInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutEntityVersionsInput>
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutEntityVersionsInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutEntityVersionsInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type EntityVersionCreateNestedOneWithoutPermissionsInput = {
		create?: XOR<EntityVersionCreateWithoutPermissionsInput, EntityVersionUncheckedCreateWithoutPermissionsInput>
		connectOrCreate?: EntityVersionCreateOrConnectWithoutPermissionsInput
		connect?: EntityVersionWhereUniqueInput
	}

	export type EntityPermissionFieldCreateNestedManyWithoutPermissionInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutPermissionInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutPermissionInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutPermissionInput>
		createMany?: EntityPermissionFieldCreateManyPermissionInputEnvelope
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
	}

	export type EntityPermissionRoleCreateNestedManyWithoutPermissionInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutPermissionInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutPermissionInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutPermissionInput>
		createMany?: EntityPermissionRoleCreateManyPermissionInputEnvelope
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
	}

	export type EntityPermissionFieldUncheckedCreateNestedManyWithoutPermissionInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutPermissionInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutPermissionInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutPermissionInput>
		createMany?: EntityPermissionFieldCreateManyPermissionInputEnvelope
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
	}

	export type EntityPermissionRoleUncheckedCreateNestedManyWithoutPermissionInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutPermissionInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutPermissionInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutPermissionInput>
		createMany?: EntityPermissionRoleCreateManyPermissionInputEnvelope
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
	}

	export type EnumEnumEntityActionFieldUpdateOperationsInput = {
		set?: EnumEntityAction
	}

	export type EnumEnumEntityPermissionTypeFieldUpdateOperationsInput = {
		set?: EnumEntityPermissionType
	}

	export type EntityVersionUpdateOneRequiredWithoutPermissionsInput = {
		create?: XOR<EntityVersionCreateWithoutPermissionsInput, EntityVersionUncheckedCreateWithoutPermissionsInput>
		connectOrCreate?: EntityVersionCreateOrConnectWithoutPermissionsInput
		upsert?: EntityVersionUpsertWithoutPermissionsInput
		connect?: EntityVersionWhereUniqueInput
		update?: XOR<EntityVersionUpdateWithoutPermissionsInput, EntityVersionUncheckedUpdateWithoutPermissionsInput>
	}

	export type EntityPermissionFieldUpdateManyWithoutPermissionInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutPermissionInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutPermissionInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutPermissionInput>
		upsert?: Enumerable<EntityPermissionFieldUpsertWithWhereUniqueWithoutPermissionInput>
		createMany?: EntityPermissionFieldCreateManyPermissionInputEnvelope
		set?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		delete?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		update?: Enumerable<EntityPermissionFieldUpdateWithWhereUniqueWithoutPermissionInput>
		updateMany?: Enumerable<EntityPermissionFieldUpdateManyWithWhereWithoutPermissionInput>
		deleteMany?: Enumerable<EntityPermissionFieldScalarWhereInput>
	}

	export type EntityPermissionRoleUpdateManyWithoutPermissionInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutPermissionInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutPermissionInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutPermissionInput>
		upsert?: Enumerable<EntityPermissionRoleUpsertWithWhereUniqueWithoutPermissionInput>
		createMany?: EntityPermissionRoleCreateManyPermissionInputEnvelope
		set?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		delete?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		update?: Enumerable<EntityPermissionRoleUpdateWithWhereUniqueWithoutPermissionInput>
		updateMany?: Enumerable<EntityPermissionRoleUpdateManyWithWhereWithoutPermissionInput>
		deleteMany?: Enumerable<EntityPermissionRoleScalarWhereInput>
	}

	export type EntityPermissionFieldUncheckedUpdateManyWithoutPermissionInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutPermissionInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutPermissionInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutPermissionInput>
		upsert?: Enumerable<EntityPermissionFieldUpsertWithWhereUniqueWithoutPermissionInput>
		createMany?: EntityPermissionFieldCreateManyPermissionInputEnvelope
		set?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		delete?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		update?: Enumerable<EntityPermissionFieldUpdateWithWhereUniqueWithoutPermissionInput>
		updateMany?: Enumerable<EntityPermissionFieldUpdateManyWithWhereWithoutPermissionInput>
		deleteMany?: Enumerable<EntityPermissionFieldScalarWhereInput>
	}

	export type EntityPermissionRoleUncheckedUpdateManyWithoutPermissionInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutPermissionInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutPermissionInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutPermissionInput>
		upsert?: Enumerable<EntityPermissionRoleUpsertWithWhereUniqueWithoutPermissionInput>
		createMany?: EntityPermissionRoleCreateManyPermissionInputEnvelope
		set?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		delete?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		update?: Enumerable<EntityPermissionRoleUpdateWithWhereUniqueWithoutPermissionInput>
		updateMany?: Enumerable<EntityPermissionRoleUpdateManyWithWhereWithoutPermissionInput>
		deleteMany?: Enumerable<EntityPermissionRoleScalarWhereInput>
	}

	export type ResourceRoleCreateNestedOneWithoutEntityPermissionRolesInput = {
		create?: XOR<ResourceRoleCreateWithoutEntityPermissionRolesInput, ResourceRoleUncheckedCreateWithoutEntityPermissionRolesInput>
		connectOrCreate?: ResourceRoleCreateOrConnectWithoutEntityPermissionRolesInput
		connect?: ResourceRoleWhereUniqueInput
	}

	export type EntityPermissionCreateNestedOneWithoutPermissionRolesInput = {
		create?: XOR<EntityPermissionCreateWithoutPermissionRolesInput, EntityPermissionUncheckedCreateWithoutPermissionRolesInput>
		connectOrCreate?: EntityPermissionCreateOrConnectWithoutPermissionRolesInput
		connect?: EntityPermissionWhereUniqueInput
	}

	export type EntityPermissionFieldCreateNestedManyWithoutPermissionRolesInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutPermissionRolesInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutPermissionRolesInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutPermissionRolesInput>
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
	}

	export type EntityPermissionFieldUncheckedCreateNestedManyWithoutPermissionRolesInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutPermissionRolesInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutPermissionRolesInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutPermissionRolesInput>
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
	}

	export type ResourceRoleUpdateOneRequiredWithoutEntityPermissionRolesInput = {
		create?: XOR<ResourceRoleCreateWithoutEntityPermissionRolesInput, ResourceRoleUncheckedCreateWithoutEntityPermissionRolesInput>
		connectOrCreate?: ResourceRoleCreateOrConnectWithoutEntityPermissionRolesInput
		upsert?: ResourceRoleUpsertWithoutEntityPermissionRolesInput
		connect?: ResourceRoleWhereUniqueInput
		update?: XOR<ResourceRoleUpdateWithoutEntityPermissionRolesInput, ResourceRoleUncheckedUpdateWithoutEntityPermissionRolesInput>
	}

	export type EntityPermissionUpdateOneRequiredWithoutPermissionRolesInput = {
		create?: XOR<EntityPermissionCreateWithoutPermissionRolesInput, EntityPermissionUncheckedCreateWithoutPermissionRolesInput>
		connectOrCreate?: EntityPermissionCreateOrConnectWithoutPermissionRolesInput
		upsert?: EntityPermissionUpsertWithoutPermissionRolesInput
		connect?: EntityPermissionWhereUniqueInput
		update?: XOR<EntityPermissionUpdateWithoutPermissionRolesInput, EntityPermissionUncheckedUpdateWithoutPermissionRolesInput>
	}

	export type EntityPermissionFieldUpdateManyWithoutPermissionRolesInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutPermissionRolesInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutPermissionRolesInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutPermissionRolesInput>
		upsert?: Enumerable<EntityPermissionFieldUpsertWithWhereUniqueWithoutPermissionRolesInput>
		set?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		delete?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		update?: Enumerable<EntityPermissionFieldUpdateWithWhereUniqueWithoutPermissionRolesInput>
		updateMany?: Enumerable<EntityPermissionFieldUpdateManyWithWhereWithoutPermissionRolesInput>
		deleteMany?: Enumerable<EntityPermissionFieldScalarWhereInput>
	}

	export type EntityPermissionFieldUncheckedUpdateManyWithoutPermissionRolesInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutPermissionRolesInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutPermissionRolesInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutPermissionRolesInput>
		upsert?: Enumerable<EntityPermissionFieldUpsertWithWhereUniqueWithoutPermissionRolesInput>
		set?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		delete?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		update?: Enumerable<EntityPermissionFieldUpdateWithWhereUniqueWithoutPermissionRolesInput>
		updateMany?: Enumerable<EntityPermissionFieldUpdateManyWithWhereWithoutPermissionRolesInput>
		deleteMany?: Enumerable<EntityPermissionFieldScalarWhereInput>
	}

	export type EntityFieldCreateNestedOneWithoutPermissionFieldInput = {
		create?: XOR<EntityFieldCreateWithoutPermissionFieldInput, EntityFieldUncheckedCreateWithoutPermissionFieldInput>
		connectOrCreate?: EntityFieldCreateOrConnectWithoutPermissionFieldInput
		connect?: EntityFieldWhereUniqueInput
	}

	export type EntityPermissionCreateNestedOneWithoutPermissionFieldsInput = {
		create?: XOR<EntityPermissionCreateWithoutPermissionFieldsInput, EntityPermissionUncheckedCreateWithoutPermissionFieldsInput>
		connectOrCreate?: EntityPermissionCreateOrConnectWithoutPermissionFieldsInput
		connect?: EntityPermissionWhereUniqueInput
	}

	export type EntityPermissionRoleCreateNestedManyWithoutPermissionFieldsInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutPermissionFieldsInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutPermissionFieldsInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutPermissionFieldsInput>
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
	}

	export type EntityPermissionRoleUncheckedCreateNestedManyWithoutPermissionFieldsInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutPermissionFieldsInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutPermissionFieldsInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutPermissionFieldsInput>
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
	}

	export type EntityFieldUpdateOneRequiredWithoutPermissionFieldInput = {
		create?: XOR<EntityFieldCreateWithoutPermissionFieldInput, EntityFieldUncheckedCreateWithoutPermissionFieldInput>
		connectOrCreate?: EntityFieldCreateOrConnectWithoutPermissionFieldInput
		upsert?: EntityFieldUpsertWithoutPermissionFieldInput
		connect?: EntityFieldWhereUniqueInput
		update?: XOR<EntityFieldUpdateWithoutPermissionFieldInput, EntityFieldUncheckedUpdateWithoutPermissionFieldInput>
	}

	export type EntityPermissionUpdateOneRequiredWithoutPermissionFieldsInput = {
		create?: XOR<EntityPermissionCreateWithoutPermissionFieldsInput, EntityPermissionUncheckedCreateWithoutPermissionFieldsInput>
		connectOrCreate?: EntityPermissionCreateOrConnectWithoutPermissionFieldsInput
		upsert?: EntityPermissionUpsertWithoutPermissionFieldsInput
		connect?: EntityPermissionWhereUniqueInput
		update?: XOR<EntityPermissionUpdateWithoutPermissionFieldsInput, EntityPermissionUncheckedUpdateWithoutPermissionFieldsInput>
	}

	export type EntityPermissionRoleUpdateManyWithoutPermissionFieldsInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutPermissionFieldsInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutPermissionFieldsInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutPermissionFieldsInput>
		upsert?: Enumerable<EntityPermissionRoleUpsertWithWhereUniqueWithoutPermissionFieldsInput>
		set?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		delete?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		update?: Enumerable<EntityPermissionRoleUpdateWithWhereUniqueWithoutPermissionFieldsInput>
		updateMany?: Enumerable<EntityPermissionRoleUpdateManyWithWhereWithoutPermissionFieldsInput>
		deleteMany?: Enumerable<EntityPermissionRoleScalarWhereInput>
	}

	export type EntityPermissionRoleUncheckedUpdateManyWithoutPermissionFieldsInput = {
		create?: XOR<Enumerable<EntityPermissionRoleCreateWithoutPermissionFieldsInput>, Enumerable<EntityPermissionRoleUncheckedCreateWithoutPermissionFieldsInput>>
		connectOrCreate?: Enumerable<EntityPermissionRoleCreateOrConnectWithoutPermissionFieldsInput>
		upsert?: Enumerable<EntityPermissionRoleUpsertWithWhereUniqueWithoutPermissionFieldsInput>
		set?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		delete?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		connect?: Enumerable<EntityPermissionRoleWhereUniqueInput>
		update?: Enumerable<EntityPermissionRoleUpdateWithWhereUniqueWithoutPermissionFieldsInput>
		updateMany?: Enumerable<EntityPermissionRoleUpdateManyWithWhereWithoutPermissionFieldsInput>
		deleteMany?: Enumerable<EntityPermissionRoleScalarWhereInput>
	}

	export type EntityVersionCreateNestedOneWithoutFieldsInput = {
		create?: XOR<EntityVersionCreateWithoutFieldsInput, EntityVersionUncheckedCreateWithoutFieldsInput>
		connectOrCreate?: EntityVersionCreateOrConnectWithoutFieldsInput
		connect?: EntityVersionWhereUniqueInput
	}

	export type EntityPermissionFieldCreateNestedManyWithoutFieldInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutFieldInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutFieldInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutFieldInput>
		createMany?: EntityPermissionFieldCreateManyFieldInputEnvelope
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
	}

	export type EntityPermissionFieldUncheckedCreateNestedManyWithoutFieldInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutFieldInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutFieldInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutFieldInput>
		createMany?: EntityPermissionFieldCreateManyFieldInputEnvelope
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
	}

	export type EnumEnumDataTypeFieldUpdateOperationsInput = {
		set?: EnumDataType
	}

	export type NullableIntFieldUpdateOperationsInput = {
		set?: number | null
		increment?: number
		decrement?: number
		multiply?: number
		divide?: number
	}

	export type EntityVersionUpdateOneRequiredWithoutFieldsInput = {
		create?: XOR<EntityVersionCreateWithoutFieldsInput, EntityVersionUncheckedCreateWithoutFieldsInput>
		connectOrCreate?: EntityVersionCreateOrConnectWithoutFieldsInput
		upsert?: EntityVersionUpsertWithoutFieldsInput
		connect?: EntityVersionWhereUniqueInput
		update?: XOR<EntityVersionUpdateWithoutFieldsInput, EntityVersionUncheckedUpdateWithoutFieldsInput>
	}

	export type EntityPermissionFieldUpdateManyWithoutFieldInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutFieldInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutFieldInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutFieldInput>
		upsert?: Enumerable<EntityPermissionFieldUpsertWithWhereUniqueWithoutFieldInput>
		createMany?: EntityPermissionFieldCreateManyFieldInputEnvelope
		set?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		delete?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		update?: Enumerable<EntityPermissionFieldUpdateWithWhereUniqueWithoutFieldInput>
		updateMany?: Enumerable<EntityPermissionFieldUpdateManyWithWhereWithoutFieldInput>
		deleteMany?: Enumerable<EntityPermissionFieldScalarWhereInput>
	}

	export type EntityPermissionFieldUncheckedUpdateManyWithoutFieldInput = {
		create?: XOR<Enumerable<EntityPermissionFieldCreateWithoutFieldInput>, Enumerable<EntityPermissionFieldUncheckedCreateWithoutFieldInput>>
		connectOrCreate?: Enumerable<EntityPermissionFieldCreateOrConnectWithoutFieldInput>
		upsert?: Enumerable<EntityPermissionFieldUpsertWithWhereUniqueWithoutFieldInput>
		createMany?: EntityPermissionFieldCreateManyFieldInputEnvelope
		set?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		disconnect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		delete?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		connect?: Enumerable<EntityPermissionFieldWhereUniqueInput>
		update?: Enumerable<EntityPermissionFieldUpdateWithWhereUniqueWithoutFieldInput>
		updateMany?: Enumerable<EntityPermissionFieldUpdateManyWithWhereWithoutFieldInput>
		deleteMany?: Enumerable<EntityPermissionFieldScalarWhereInput>
	}

	export type ResourceCreateNestedOneWithoutBlocksInput = {
		create?: XOR<ResourceCreateWithoutBlocksInput, ResourceUncheckedCreateWithoutBlocksInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutBlocksInput
		connect?: ResourceWhereUniqueInput
	}

	export type UserCreateNestedOneWithoutLockedBlocksInput = {
		create?: XOR<UserCreateWithoutLockedBlocksInput, UserUncheckedCreateWithoutLockedBlocksInput>
		connectOrCreate?: UserCreateOrConnectWithoutLockedBlocksInput
		connect?: UserWhereUniqueInput
	}

	export type BlockCreateNestedOneWithoutBlocksInput = {
		create?: XOR<BlockCreateWithoutBlocksInput, BlockUncheckedCreateWithoutBlocksInput>
		connectOrCreate?: BlockCreateOrConnectWithoutBlocksInput
		connect?: BlockWhereUniqueInput
	}

	export type BlockCreateNestedManyWithoutParentBlockInput = {
		create?: XOR<Enumerable<BlockCreateWithoutParentBlockInput>, Enumerable<BlockUncheckedCreateWithoutParentBlockInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutParentBlockInput>
		createMany?: BlockCreateManyParentBlockInputEnvelope
		connect?: Enumerable<BlockWhereUniqueInput>
	}

	export type BlockVersionCreateNestedManyWithoutBlockInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutBlockInput>, Enumerable<BlockVersionUncheckedCreateWithoutBlockInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutBlockInput>
		createMany?: BlockVersionCreateManyBlockInputEnvelope
		connect?: Enumerable<BlockVersionWhereUniqueInput>
	}

	export type BlockUncheckedCreateNestedManyWithoutParentBlockInput = {
		create?: XOR<Enumerable<BlockCreateWithoutParentBlockInput>, Enumerable<BlockUncheckedCreateWithoutParentBlockInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutParentBlockInput>
		createMany?: BlockCreateManyParentBlockInputEnvelope
		connect?: Enumerable<BlockWhereUniqueInput>
	}

	export type BlockVersionUncheckedCreateNestedManyWithoutBlockInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutBlockInput>, Enumerable<BlockVersionUncheckedCreateWithoutBlockInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutBlockInput>
		createMany?: BlockVersionCreateManyBlockInputEnvelope
		connect?: Enumerable<BlockVersionWhereUniqueInput>
	}

	export type EnumEnumBlockTypeFieldUpdateOperationsInput = {
		set?: EnumBlockType
	}

	export type ResourceUpdateOneRequiredWithoutBlocksInput = {
		create?: XOR<ResourceCreateWithoutBlocksInput, ResourceUncheckedCreateWithoutBlocksInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutBlocksInput
		upsert?: ResourceUpsertWithoutBlocksInput
		connect?: ResourceWhereUniqueInput
		update?: XOR<ResourceUpdateWithoutBlocksInput, ResourceUncheckedUpdateWithoutBlocksInput>
	}

	export type UserUpdateOneWithoutLockedBlocksInput = {
		create?: XOR<UserCreateWithoutLockedBlocksInput, UserUncheckedCreateWithoutLockedBlocksInput>
		connectOrCreate?: UserCreateOrConnectWithoutLockedBlocksInput
		upsert?: UserUpsertWithoutLockedBlocksInput
		disconnect?: boolean
		delete?: boolean
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutLockedBlocksInput, UserUncheckedUpdateWithoutLockedBlocksInput>
	}

	export type BlockUpdateOneWithoutBlocksInput = {
		create?: XOR<BlockCreateWithoutBlocksInput, BlockUncheckedCreateWithoutBlocksInput>
		connectOrCreate?: BlockCreateOrConnectWithoutBlocksInput
		upsert?: BlockUpsertWithoutBlocksInput
		disconnect?: boolean
		delete?: boolean
		connect?: BlockWhereUniqueInput
		update?: XOR<BlockUpdateWithoutBlocksInput, BlockUncheckedUpdateWithoutBlocksInput>
	}

	export type BlockUpdateManyWithoutParentBlockInput = {
		create?: XOR<Enumerable<BlockCreateWithoutParentBlockInput>, Enumerable<BlockUncheckedCreateWithoutParentBlockInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutParentBlockInput>
		upsert?: Enumerable<BlockUpsertWithWhereUniqueWithoutParentBlockInput>
		createMany?: BlockCreateManyParentBlockInputEnvelope
		set?: Enumerable<BlockWhereUniqueInput>
		disconnect?: Enumerable<BlockWhereUniqueInput>
		delete?: Enumerable<BlockWhereUniqueInput>
		connect?: Enumerable<BlockWhereUniqueInput>
		update?: Enumerable<BlockUpdateWithWhereUniqueWithoutParentBlockInput>
		updateMany?: Enumerable<BlockUpdateManyWithWhereWithoutParentBlockInput>
		deleteMany?: Enumerable<BlockScalarWhereInput>
	}

	export type BlockVersionUpdateManyWithoutBlockInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutBlockInput>, Enumerable<BlockVersionUncheckedCreateWithoutBlockInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutBlockInput>
		upsert?: Enumerable<BlockVersionUpsertWithWhereUniqueWithoutBlockInput>
		createMany?: BlockVersionCreateManyBlockInputEnvelope
		set?: Enumerable<BlockVersionWhereUniqueInput>
		disconnect?: Enumerable<BlockVersionWhereUniqueInput>
		delete?: Enumerable<BlockVersionWhereUniqueInput>
		connect?: Enumerable<BlockVersionWhereUniqueInput>
		update?: Enumerable<BlockVersionUpdateWithWhereUniqueWithoutBlockInput>
		updateMany?: Enumerable<BlockVersionUpdateManyWithWhereWithoutBlockInput>
		deleteMany?: Enumerable<BlockVersionScalarWhereInput>
	}

	export type BlockUncheckedUpdateManyWithoutParentBlockInput = {
		create?: XOR<Enumerable<BlockCreateWithoutParentBlockInput>, Enumerable<BlockUncheckedCreateWithoutParentBlockInput>>
		connectOrCreate?: Enumerable<BlockCreateOrConnectWithoutParentBlockInput>
		upsert?: Enumerable<BlockUpsertWithWhereUniqueWithoutParentBlockInput>
		createMany?: BlockCreateManyParentBlockInputEnvelope
		set?: Enumerable<BlockWhereUniqueInput>
		disconnect?: Enumerable<BlockWhereUniqueInput>
		delete?: Enumerable<BlockWhereUniqueInput>
		connect?: Enumerable<BlockWhereUniqueInput>
		update?: Enumerable<BlockUpdateWithWhereUniqueWithoutParentBlockInput>
		updateMany?: Enumerable<BlockUpdateManyWithWhereWithoutParentBlockInput>
		deleteMany?: Enumerable<BlockScalarWhereInput>
	}

	export type BlockVersionUncheckedUpdateManyWithoutBlockInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutBlockInput>, Enumerable<BlockVersionUncheckedCreateWithoutBlockInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutBlockInput>
		upsert?: Enumerable<BlockVersionUpsertWithWhereUniqueWithoutBlockInput>
		createMany?: BlockVersionCreateManyBlockInputEnvelope
		set?: Enumerable<BlockVersionWhereUniqueInput>
		disconnect?: Enumerable<BlockVersionWhereUniqueInput>
		delete?: Enumerable<BlockVersionWhereUniqueInput>
		connect?: Enumerable<BlockVersionWhereUniqueInput>
		update?: Enumerable<BlockVersionUpdateWithWhereUniqueWithoutBlockInput>
		updateMany?: Enumerable<BlockVersionUpdateManyWithWhereWithoutBlockInput>
		deleteMany?: Enumerable<BlockVersionScalarWhereInput>
	}

	export type BlockCreateNestedOneWithoutVersionsInput = {
		create?: XOR<BlockCreateWithoutVersionsInput, BlockUncheckedCreateWithoutVersionsInput>
		connectOrCreate?: BlockCreateOrConnectWithoutVersionsInput
		connect?: BlockWhereUniqueInput
	}

	export type CommitCreateNestedOneWithoutBlockVersionsInput = {
		create?: XOR<CommitCreateWithoutBlockVersionsInput, CommitUncheckedCreateWithoutBlockVersionsInput>
		connectOrCreate?: CommitCreateOrConnectWithoutBlockVersionsInput
		connect?: CommitWhereUniqueInput
	}

	export type BuildCreateNestedManyWithoutBlockVersionsInput = {
		create?: XOR<Enumerable<BuildCreateWithoutBlockVersionsInput>, Enumerable<BuildUncheckedCreateWithoutBlockVersionsInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutBlockVersionsInput>
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type BuildUncheckedCreateNestedManyWithoutBlockVersionsInput = {
		create?: XOR<Enumerable<BuildCreateWithoutBlockVersionsInput>, Enumerable<BuildUncheckedCreateWithoutBlockVersionsInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutBlockVersionsInput>
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type BlockUpdateOneRequiredWithoutVersionsInput = {
		create?: XOR<BlockCreateWithoutVersionsInput, BlockUncheckedCreateWithoutVersionsInput>
		connectOrCreate?: BlockCreateOrConnectWithoutVersionsInput
		upsert?: BlockUpsertWithoutVersionsInput
		connect?: BlockWhereUniqueInput
		update?: XOR<BlockUpdateWithoutVersionsInput, BlockUncheckedUpdateWithoutVersionsInput>
	}

	export type CommitUpdateOneWithoutBlockVersionsInput = {
		create?: XOR<CommitCreateWithoutBlockVersionsInput, CommitUncheckedCreateWithoutBlockVersionsInput>
		connectOrCreate?: CommitCreateOrConnectWithoutBlockVersionsInput
		upsert?: CommitUpsertWithoutBlockVersionsInput
		disconnect?: boolean
		delete?: boolean
		connect?: CommitWhereUniqueInput
		update?: XOR<CommitUpdateWithoutBlockVersionsInput, CommitUncheckedUpdateWithoutBlockVersionsInput>
	}

	export type BuildUpdateManyWithoutBlockVersionsInput = {
		create?: XOR<Enumerable<BuildCreateWithoutBlockVersionsInput>, Enumerable<BuildUncheckedCreateWithoutBlockVersionsInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutBlockVersionsInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutBlockVersionsInput>
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutBlockVersionsInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutBlockVersionsInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type BuildUncheckedUpdateManyWithoutBlockVersionsInput = {
		create?: XOR<Enumerable<BuildCreateWithoutBlockVersionsInput>, Enumerable<BuildUncheckedCreateWithoutBlockVersionsInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutBlockVersionsInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutBlockVersionsInput>
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutBlockVersionsInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutBlockVersionsInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type ActionStepCreateNestedManyWithoutActionInput = {
		create?: XOR<Enumerable<ActionStepCreateWithoutActionInput>, Enumerable<ActionStepUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<ActionStepCreateOrConnectWithoutActionInput>
		createMany?: ActionStepCreateManyActionInputEnvelope
		connect?: Enumerable<ActionStepWhereUniqueInput>
	}

	export type BuildCreateNestedManyWithoutActionInput = {
		create?: XOR<Enumerable<BuildCreateWithoutActionInput>, Enumerable<BuildUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutActionInput>
		createMany?: BuildCreateManyActionInputEnvelope
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type DeploymentCreateNestedManyWithoutActionInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutActionInput>, Enumerable<DeploymentUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutActionInput>
		createMany?: DeploymentCreateManyActionInputEnvelope
		connect?: Enumerable<DeploymentWhereUniqueInput>
	}

	export type ActionStepUncheckedCreateNestedManyWithoutActionInput = {
		create?: XOR<Enumerable<ActionStepCreateWithoutActionInput>, Enumerable<ActionStepUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<ActionStepCreateOrConnectWithoutActionInput>
		createMany?: ActionStepCreateManyActionInputEnvelope
		connect?: Enumerable<ActionStepWhereUniqueInput>
	}

	export type BuildUncheckedCreateNestedManyWithoutActionInput = {
		create?: XOR<Enumerable<BuildCreateWithoutActionInput>, Enumerable<BuildUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutActionInput>
		createMany?: BuildCreateManyActionInputEnvelope
		connect?: Enumerable<BuildWhereUniqueInput>
	}

	export type DeploymentUncheckedCreateNestedManyWithoutActionInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutActionInput>, Enumerable<DeploymentUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutActionInput>
		createMany?: DeploymentCreateManyActionInputEnvelope
		connect?: Enumerable<DeploymentWhereUniqueInput>
	}

	export type ActionStepUpdateManyWithoutActionInput = {
		create?: XOR<Enumerable<ActionStepCreateWithoutActionInput>, Enumerable<ActionStepUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<ActionStepCreateOrConnectWithoutActionInput>
		upsert?: Enumerable<ActionStepUpsertWithWhereUniqueWithoutActionInput>
		createMany?: ActionStepCreateManyActionInputEnvelope
		set?: Enumerable<ActionStepWhereUniqueInput>
		disconnect?: Enumerable<ActionStepWhereUniqueInput>
		delete?: Enumerable<ActionStepWhereUniqueInput>
		connect?: Enumerable<ActionStepWhereUniqueInput>
		update?: Enumerable<ActionStepUpdateWithWhereUniqueWithoutActionInput>
		updateMany?: Enumerable<ActionStepUpdateManyWithWhereWithoutActionInput>
		deleteMany?: Enumerable<ActionStepScalarWhereInput>
	}

	export type BuildUpdateManyWithoutActionInput = {
		create?: XOR<Enumerable<BuildCreateWithoutActionInput>, Enumerable<BuildUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutActionInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutActionInput>
		createMany?: BuildCreateManyActionInputEnvelope
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutActionInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutActionInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type DeploymentUpdateManyWithoutActionInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutActionInput>, Enumerable<DeploymentUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutActionInput>
		upsert?: Enumerable<DeploymentUpsertWithWhereUniqueWithoutActionInput>
		createMany?: DeploymentCreateManyActionInputEnvelope
		set?: Enumerable<DeploymentWhereUniqueInput>
		disconnect?: Enumerable<DeploymentWhereUniqueInput>
		delete?: Enumerable<DeploymentWhereUniqueInput>
		connect?: Enumerable<DeploymentWhereUniqueInput>
		update?: Enumerable<DeploymentUpdateWithWhereUniqueWithoutActionInput>
		updateMany?: Enumerable<DeploymentUpdateManyWithWhereWithoutActionInput>
		deleteMany?: Enumerable<DeploymentScalarWhereInput>
	}

	export type ActionStepUncheckedUpdateManyWithoutActionInput = {
		create?: XOR<Enumerable<ActionStepCreateWithoutActionInput>, Enumerable<ActionStepUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<ActionStepCreateOrConnectWithoutActionInput>
		upsert?: Enumerable<ActionStepUpsertWithWhereUniqueWithoutActionInput>
		createMany?: ActionStepCreateManyActionInputEnvelope
		set?: Enumerable<ActionStepWhereUniqueInput>
		disconnect?: Enumerable<ActionStepWhereUniqueInput>
		delete?: Enumerable<ActionStepWhereUniqueInput>
		connect?: Enumerable<ActionStepWhereUniqueInput>
		update?: Enumerable<ActionStepUpdateWithWhereUniqueWithoutActionInput>
		updateMany?: Enumerable<ActionStepUpdateManyWithWhereWithoutActionInput>
		deleteMany?: Enumerable<ActionStepScalarWhereInput>
	}

	export type BuildUncheckedUpdateManyWithoutActionInput = {
		create?: XOR<Enumerable<BuildCreateWithoutActionInput>, Enumerable<BuildUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutActionInput>
		upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutActionInput>
		createMany?: BuildCreateManyActionInputEnvelope
		set?: Enumerable<BuildWhereUniqueInput>
		disconnect?: Enumerable<BuildWhereUniqueInput>
		delete?: Enumerable<BuildWhereUniqueInput>
		connect?: Enumerable<BuildWhereUniqueInput>
		update?: Enumerable<BuildUpdateWithWhereUniqueWithoutActionInput>
		updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutActionInput>
		deleteMany?: Enumerable<BuildScalarWhereInput>
	}

	export type DeploymentUncheckedUpdateManyWithoutActionInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutActionInput>, Enumerable<DeploymentUncheckedCreateWithoutActionInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutActionInput>
		upsert?: Enumerable<DeploymentUpsertWithWhereUniqueWithoutActionInput>
		createMany?: DeploymentCreateManyActionInputEnvelope
		set?: Enumerable<DeploymentWhereUniqueInput>
		disconnect?: Enumerable<DeploymentWhereUniqueInput>
		delete?: Enumerable<DeploymentWhereUniqueInput>
		connect?: Enumerable<DeploymentWhereUniqueInput>
		update?: Enumerable<DeploymentUpdateWithWhereUniqueWithoutActionInput>
		updateMany?: Enumerable<DeploymentUpdateManyWithWhereWithoutActionInput>
		deleteMany?: Enumerable<DeploymentScalarWhereInput>
	}

	export type ActionCreateNestedOneWithoutStepsInput = {
		create?: XOR<ActionCreateWithoutStepsInput, ActionUncheckedCreateWithoutStepsInput>
		connectOrCreate?: ActionCreateOrConnectWithoutStepsInput
		connect?: ActionWhereUniqueInput
	}

	export type ActionLogCreateNestedManyWithoutStepInput = {
		create?: XOR<Enumerable<ActionLogCreateWithoutStepInput>, Enumerable<ActionLogUncheckedCreateWithoutStepInput>>
		connectOrCreate?: Enumerable<ActionLogCreateOrConnectWithoutStepInput>
		createMany?: ActionLogCreateManyStepInputEnvelope
		connect?: Enumerable<ActionLogWhereUniqueInput>
	}

	export type ActionLogUncheckedCreateNestedManyWithoutStepInput = {
		create?: XOR<Enumerable<ActionLogCreateWithoutStepInput>, Enumerable<ActionLogUncheckedCreateWithoutStepInput>>
		connectOrCreate?: Enumerable<ActionLogCreateOrConnectWithoutStepInput>
		createMany?: ActionLogCreateManyStepInputEnvelope
		connect?: Enumerable<ActionLogWhereUniqueInput>
	}

	export type EnumActionStepStatusFieldUpdateOperationsInput = {
		set?: ActionStepStatus
	}

	export type ActionUpdateOneRequiredWithoutStepsInput = {
		create?: XOR<ActionCreateWithoutStepsInput, ActionUncheckedCreateWithoutStepsInput>
		connectOrCreate?: ActionCreateOrConnectWithoutStepsInput
		upsert?: ActionUpsertWithoutStepsInput
		connect?: ActionWhereUniqueInput
		update?: XOR<ActionUpdateWithoutStepsInput, ActionUncheckedUpdateWithoutStepsInput>
	}

	export type ActionLogUpdateManyWithoutStepInput = {
		create?: XOR<Enumerable<ActionLogCreateWithoutStepInput>, Enumerable<ActionLogUncheckedCreateWithoutStepInput>>
		connectOrCreate?: Enumerable<ActionLogCreateOrConnectWithoutStepInput>
		upsert?: Enumerable<ActionLogUpsertWithWhereUniqueWithoutStepInput>
		createMany?: ActionLogCreateManyStepInputEnvelope
		set?: Enumerable<ActionLogWhereUniqueInput>
		disconnect?: Enumerable<ActionLogWhereUniqueInput>
		delete?: Enumerable<ActionLogWhereUniqueInput>
		connect?: Enumerable<ActionLogWhereUniqueInput>
		update?: Enumerable<ActionLogUpdateWithWhereUniqueWithoutStepInput>
		updateMany?: Enumerable<ActionLogUpdateManyWithWhereWithoutStepInput>
		deleteMany?: Enumerable<ActionLogScalarWhereInput>
	}

	export type ActionLogUncheckedUpdateManyWithoutStepInput = {
		create?: XOR<Enumerable<ActionLogCreateWithoutStepInput>, Enumerable<ActionLogUncheckedCreateWithoutStepInput>>
		connectOrCreate?: Enumerable<ActionLogCreateOrConnectWithoutStepInput>
		upsert?: Enumerable<ActionLogUpsertWithWhereUniqueWithoutStepInput>
		createMany?: ActionLogCreateManyStepInputEnvelope
		set?: Enumerable<ActionLogWhereUniqueInput>
		disconnect?: Enumerable<ActionLogWhereUniqueInput>
		delete?: Enumerable<ActionLogWhereUniqueInput>
		connect?: Enumerable<ActionLogWhereUniqueInput>
		update?: Enumerable<ActionLogUpdateWithWhereUniqueWithoutStepInput>
		updateMany?: Enumerable<ActionLogUpdateManyWithWhereWithoutStepInput>
		deleteMany?: Enumerable<ActionLogScalarWhereInput>
	}

	export type ActionStepCreateNestedOneWithoutLogsInput = {
		create?: XOR<ActionStepCreateWithoutLogsInput, ActionStepUncheckedCreateWithoutLogsInput>
		connectOrCreate?: ActionStepCreateOrConnectWithoutLogsInput
		connect?: ActionStepWhereUniqueInput
	}

	export type EnumEnumLogLevelFieldUpdateOperationsInput = {
		set?: EnumLogLevel
	}

	export type ActionStepUpdateOneRequiredWithoutLogsInput = {
		create?: XOR<ActionStepCreateWithoutLogsInput, ActionStepUncheckedCreateWithoutLogsInput>
		connectOrCreate?: ActionStepCreateOrConnectWithoutLogsInput
		upsert?: ActionStepUpsertWithoutLogsInput
		connect?: ActionStepWhereUniqueInput
		update?: XOR<ActionStepUpdateWithoutLogsInput, ActionStepUncheckedUpdateWithoutLogsInput>
	}

	export type BuildCreateimagesInput = {
		set: Enumerable<string>
	}

	export type ActionCreateNestedOneWithoutBuildsInput = {
		create?: XOR<ActionCreateWithoutBuildsInput, ActionUncheckedCreateWithoutBuildsInput>
		connectOrCreate?: ActionCreateOrConnectWithoutBuildsInput
		connect?: ActionWhereUniqueInput
	}

	export type ResourceCreateNestedOneWithoutBuildsInput = {
		create?: XOR<ResourceCreateWithoutBuildsInput, ResourceUncheckedCreateWithoutBuildsInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutBuildsInput
		connect?: ResourceWhereUniqueInput
	}

	export type CommitCreateNestedOneWithoutBuildsInput = {
		create?: XOR<CommitCreateWithoutBuildsInput, CommitUncheckedCreateWithoutBuildsInput>
		connectOrCreate?: CommitCreateOrConnectWithoutBuildsInput
		connect?: CommitWhereUniqueInput
	}

	export type UserCreateNestedOneWithoutBuildsInput = {
		create?: XOR<UserCreateWithoutBuildsInput, UserUncheckedCreateWithoutBuildsInput>
		connectOrCreate?: UserCreateOrConnectWithoutBuildsInput
		connect?: UserWhereUniqueInput
	}

	export type DeploymentCreateNestedManyWithoutBuildInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutBuildInput>, Enumerable<DeploymentUncheckedCreateWithoutBuildInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutBuildInput>
		createMany?: DeploymentCreateManyBuildInputEnvelope
		connect?: Enumerable<DeploymentWhereUniqueInput>
	}

	export type BlockVersionCreateNestedManyWithoutBuildsInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutBuildsInput>, Enumerable<BlockVersionUncheckedCreateWithoutBuildsInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutBuildsInput>
		connect?: Enumerable<BlockVersionWhereUniqueInput>
	}

	export type EntityVersionCreateNestedManyWithoutBuildsInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutBuildsInput>, Enumerable<EntityVersionUncheckedCreateWithoutBuildsInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutBuildsInput>
		connect?: Enumerable<EntityVersionWhereUniqueInput>
	}

	export type DeploymentUncheckedCreateNestedManyWithoutBuildInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutBuildInput>, Enumerable<DeploymentUncheckedCreateWithoutBuildInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutBuildInput>
		createMany?: DeploymentCreateManyBuildInputEnvelope
		connect?: Enumerable<DeploymentWhereUniqueInput>
	}

	export type BlockVersionUncheckedCreateNestedManyWithoutBuildsInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutBuildsInput>, Enumerable<BlockVersionUncheckedCreateWithoutBuildsInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutBuildsInput>
		connect?: Enumerable<BlockVersionWhereUniqueInput>
	}

	export type EntityVersionUncheckedCreateNestedManyWithoutBuildsInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutBuildsInput>, Enumerable<EntityVersionUncheckedCreateWithoutBuildsInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutBuildsInput>
		connect?: Enumerable<EntityVersionWhereUniqueInput>
	}

	export type BuildUpdateimagesInput = {
		set?: Enumerable<string>
		push?: string | Enumerable<string>
	}

	export type ActionUpdateOneRequiredWithoutBuildsInput = {
		create?: XOR<ActionCreateWithoutBuildsInput, ActionUncheckedCreateWithoutBuildsInput>
		connectOrCreate?: ActionCreateOrConnectWithoutBuildsInput
		upsert?: ActionUpsertWithoutBuildsInput
		connect?: ActionWhereUniqueInput
		update?: XOR<ActionUpdateWithoutBuildsInput, ActionUncheckedUpdateWithoutBuildsInput>
	}

	export type ResourceUpdateOneRequiredWithoutBuildsInput = {
		create?: XOR<ResourceCreateWithoutBuildsInput, ResourceUncheckedCreateWithoutBuildsInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutBuildsInput
		upsert?: ResourceUpsertWithoutBuildsInput
		connect?: ResourceWhereUniqueInput
		update?: XOR<ResourceUpdateWithoutBuildsInput, ResourceUncheckedUpdateWithoutBuildsInput>
	}

	export type CommitUpdateOneWithoutBuildsInput = {
		create?: XOR<CommitCreateWithoutBuildsInput, CommitUncheckedCreateWithoutBuildsInput>
		connectOrCreate?: CommitCreateOrConnectWithoutBuildsInput
		upsert?: CommitUpsertWithoutBuildsInput
		disconnect?: boolean
		delete?: boolean
		connect?: CommitWhereUniqueInput
		update?: XOR<CommitUpdateWithoutBuildsInput, CommitUncheckedUpdateWithoutBuildsInput>
	}

	export type UserUpdateOneRequiredWithoutBuildsInput = {
		create?: XOR<UserCreateWithoutBuildsInput, UserUncheckedCreateWithoutBuildsInput>
		connectOrCreate?: UserCreateOrConnectWithoutBuildsInput
		upsert?: UserUpsertWithoutBuildsInput
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutBuildsInput, UserUncheckedUpdateWithoutBuildsInput>
	}

	export type DeploymentUpdateManyWithoutBuildInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutBuildInput>, Enumerable<DeploymentUncheckedCreateWithoutBuildInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutBuildInput>
		upsert?: Enumerable<DeploymentUpsertWithWhereUniqueWithoutBuildInput>
		createMany?: DeploymentCreateManyBuildInputEnvelope
		set?: Enumerable<DeploymentWhereUniqueInput>
		disconnect?: Enumerable<DeploymentWhereUniqueInput>
		delete?: Enumerable<DeploymentWhereUniqueInput>
		connect?: Enumerable<DeploymentWhereUniqueInput>
		update?: Enumerable<DeploymentUpdateWithWhereUniqueWithoutBuildInput>
		updateMany?: Enumerable<DeploymentUpdateManyWithWhereWithoutBuildInput>
		deleteMany?: Enumerable<DeploymentScalarWhereInput>
	}

	export type BlockVersionUpdateManyWithoutBuildsInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutBuildsInput>, Enumerable<BlockVersionUncheckedCreateWithoutBuildsInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutBuildsInput>
		upsert?: Enumerable<BlockVersionUpsertWithWhereUniqueWithoutBuildsInput>
		set?: Enumerable<BlockVersionWhereUniqueInput>
		disconnect?: Enumerable<BlockVersionWhereUniqueInput>
		delete?: Enumerable<BlockVersionWhereUniqueInput>
		connect?: Enumerable<BlockVersionWhereUniqueInput>
		update?: Enumerable<BlockVersionUpdateWithWhereUniqueWithoutBuildsInput>
		updateMany?: Enumerable<BlockVersionUpdateManyWithWhereWithoutBuildsInput>
		deleteMany?: Enumerable<BlockVersionScalarWhereInput>
	}

	export type EntityVersionUpdateManyWithoutBuildsInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutBuildsInput>, Enumerable<EntityVersionUncheckedCreateWithoutBuildsInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutBuildsInput>
		upsert?: Enumerable<EntityVersionUpsertWithWhereUniqueWithoutBuildsInput>
		set?: Enumerable<EntityVersionWhereUniqueInput>
		disconnect?: Enumerable<EntityVersionWhereUniqueInput>
		delete?: Enumerable<EntityVersionWhereUniqueInput>
		connect?: Enumerable<EntityVersionWhereUniqueInput>
		update?: Enumerable<EntityVersionUpdateWithWhereUniqueWithoutBuildsInput>
		updateMany?: Enumerable<EntityVersionUpdateManyWithWhereWithoutBuildsInput>
		deleteMany?: Enumerable<EntityVersionScalarWhereInput>
	}

	export type DeploymentUncheckedUpdateManyWithoutBuildInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutBuildInput>, Enumerable<DeploymentUncheckedCreateWithoutBuildInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutBuildInput>
		upsert?: Enumerable<DeploymentUpsertWithWhereUniqueWithoutBuildInput>
		createMany?: DeploymentCreateManyBuildInputEnvelope
		set?: Enumerable<DeploymentWhereUniqueInput>
		disconnect?: Enumerable<DeploymentWhereUniqueInput>
		delete?: Enumerable<DeploymentWhereUniqueInput>
		connect?: Enumerable<DeploymentWhereUniqueInput>
		update?: Enumerable<DeploymentUpdateWithWhereUniqueWithoutBuildInput>
		updateMany?: Enumerable<DeploymentUpdateManyWithWhereWithoutBuildInput>
		deleteMany?: Enumerable<DeploymentScalarWhereInput>
	}

	export type BlockVersionUncheckedUpdateManyWithoutBuildsInput = {
		create?: XOR<Enumerable<BlockVersionCreateWithoutBuildsInput>, Enumerable<BlockVersionUncheckedCreateWithoutBuildsInput>>
		connectOrCreate?: Enumerable<BlockVersionCreateOrConnectWithoutBuildsInput>
		upsert?: Enumerable<BlockVersionUpsertWithWhereUniqueWithoutBuildsInput>
		set?: Enumerable<BlockVersionWhereUniqueInput>
		disconnect?: Enumerable<BlockVersionWhereUniqueInput>
		delete?: Enumerable<BlockVersionWhereUniqueInput>
		connect?: Enumerable<BlockVersionWhereUniqueInput>
		update?: Enumerable<BlockVersionUpdateWithWhereUniqueWithoutBuildsInput>
		updateMany?: Enumerable<BlockVersionUpdateManyWithWhereWithoutBuildsInput>
		deleteMany?: Enumerable<BlockVersionScalarWhereInput>
	}

	export type EntityVersionUncheckedUpdateManyWithoutBuildsInput = {
		create?: XOR<Enumerable<EntityVersionCreateWithoutBuildsInput>, Enumerable<EntityVersionUncheckedCreateWithoutBuildsInput>>
		connectOrCreate?: Enumerable<EntityVersionCreateOrConnectWithoutBuildsInput>
		upsert?: Enumerable<EntityVersionUpsertWithWhereUniqueWithoutBuildsInput>
		set?: Enumerable<EntityVersionWhereUniqueInput>
		disconnect?: Enumerable<EntityVersionWhereUniqueInput>
		delete?: Enumerable<EntityVersionWhereUniqueInput>
		connect?: Enumerable<EntityVersionWhereUniqueInput>
		update?: Enumerable<EntityVersionUpdateWithWhereUniqueWithoutBuildsInput>
		updateMany?: Enumerable<EntityVersionUpdateManyWithWhereWithoutBuildsInput>
		deleteMany?: Enumerable<EntityVersionScalarWhereInput>
	}

	export type CommitCreateNestedOneWithoutReleasesInput = {
		create?: XOR<CommitCreateWithoutReleasesInput, CommitUncheckedCreateWithoutReleasesInput>
		connectOrCreate?: CommitCreateOrConnectWithoutReleasesInput
		connect?: CommitWhereUniqueInput
	}

	export type CommitUpdateOneRequiredWithoutReleasesInput = {
		create?: XOR<CommitCreateWithoutReleasesInput, CommitUncheckedCreateWithoutReleasesInput>
		connectOrCreate?: CommitCreateOrConnectWithoutReleasesInput
		upsert?: CommitUpsertWithoutReleasesInput
		connect?: CommitWhereUniqueInput
		update?: XOR<CommitUpdateWithoutReleasesInput, CommitUncheckedUpdateWithoutReleasesInput>
	}

	export type ResourceCreateNestedOneWithoutEnvironmentsInput = {
		create?: XOR<ResourceCreateWithoutEnvironmentsInput, ResourceUncheckedCreateWithoutEnvironmentsInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutEnvironmentsInput
		connect?: ResourceWhereUniqueInput
	}

	export type DeploymentCreateNestedManyWithoutEnvironmentInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutEnvironmentInput>, Enumerable<DeploymentUncheckedCreateWithoutEnvironmentInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutEnvironmentInput>
		createMany?: DeploymentCreateManyEnvironmentInputEnvelope
		connect?: Enumerable<DeploymentWhereUniqueInput>
	}

	export type DeploymentUncheckedCreateNestedManyWithoutEnvironmentInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutEnvironmentInput>, Enumerable<DeploymentUncheckedCreateWithoutEnvironmentInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutEnvironmentInput>
		createMany?: DeploymentCreateManyEnvironmentInputEnvelope
		connect?: Enumerable<DeploymentWhereUniqueInput>
	}

	export type ResourceUpdateOneRequiredWithoutEnvironmentsInput = {
		create?: XOR<ResourceCreateWithoutEnvironmentsInput, ResourceUncheckedCreateWithoutEnvironmentsInput>
		connectOrCreate?: ResourceCreateOrConnectWithoutEnvironmentsInput
		upsert?: ResourceUpsertWithoutEnvironmentsInput
		connect?: ResourceWhereUniqueInput
		update?: XOR<ResourceUpdateWithoutEnvironmentsInput, ResourceUncheckedUpdateWithoutEnvironmentsInput>
	}

	export type DeploymentUpdateManyWithoutEnvironmentInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutEnvironmentInput>, Enumerable<DeploymentUncheckedCreateWithoutEnvironmentInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutEnvironmentInput>
		upsert?: Enumerable<DeploymentUpsertWithWhereUniqueWithoutEnvironmentInput>
		createMany?: DeploymentCreateManyEnvironmentInputEnvelope
		set?: Enumerable<DeploymentWhereUniqueInput>
		disconnect?: Enumerable<DeploymentWhereUniqueInput>
		delete?: Enumerable<DeploymentWhereUniqueInput>
		connect?: Enumerable<DeploymentWhereUniqueInput>
		update?: Enumerable<DeploymentUpdateWithWhereUniqueWithoutEnvironmentInput>
		updateMany?: Enumerable<DeploymentUpdateManyWithWhereWithoutEnvironmentInput>
		deleteMany?: Enumerable<DeploymentScalarWhereInput>
	}

	export type DeploymentUncheckedUpdateManyWithoutEnvironmentInput = {
		create?: XOR<Enumerable<DeploymentCreateWithoutEnvironmentInput>, Enumerable<DeploymentUncheckedCreateWithoutEnvironmentInput>>
		connectOrCreate?: Enumerable<DeploymentCreateOrConnectWithoutEnvironmentInput>
		upsert?: Enumerable<DeploymentUpsertWithWhereUniqueWithoutEnvironmentInput>
		createMany?: DeploymentCreateManyEnvironmentInputEnvelope
		set?: Enumerable<DeploymentWhereUniqueInput>
		disconnect?: Enumerable<DeploymentWhereUniqueInput>
		delete?: Enumerable<DeploymentWhereUniqueInput>
		connect?: Enumerable<DeploymentWhereUniqueInput>
		update?: Enumerable<DeploymentUpdateWithWhereUniqueWithoutEnvironmentInput>
		updateMany?: Enumerable<DeploymentUpdateManyWithWhereWithoutEnvironmentInput>
		deleteMany?: Enumerable<DeploymentScalarWhereInput>
	}

	export type ActionCreateNestedOneWithoutDeploymentsInput = {
		create?: XOR<ActionCreateWithoutDeploymentsInput, ActionUncheckedCreateWithoutDeploymentsInput>
		connectOrCreate?: ActionCreateOrConnectWithoutDeploymentsInput
		connect?: ActionWhereUniqueInput
	}

	export type BuildCreateNestedOneWithoutDeploymentsInput = {
		create?: XOR<BuildCreateWithoutDeploymentsInput, BuildUncheckedCreateWithoutDeploymentsInput>
		connectOrCreate?: BuildCreateOrConnectWithoutDeploymentsInput
		connect?: BuildWhereUniqueInput
	}

	export type EnvironmentCreateNestedOneWithoutDeploymentsInput = {
		create?: XOR<EnvironmentCreateWithoutDeploymentsInput, EnvironmentUncheckedCreateWithoutDeploymentsInput>
		connectOrCreate?: EnvironmentCreateOrConnectWithoutDeploymentsInput
		connect?: EnvironmentWhereUniqueInput
	}

	export type UserCreateNestedOneWithoutDeploymentsInput = {
		create?: XOR<UserCreateWithoutDeploymentsInput, UserUncheckedCreateWithoutDeploymentsInput>
		connectOrCreate?: UserCreateOrConnectWithoutDeploymentsInput
		connect?: UserWhereUniqueInput
	}

	export type EnumEnumDeploymentStatusFieldUpdateOperationsInput = {
		set?: EnumDeploymentStatus
	}

	export type ActionUpdateOneRequiredWithoutDeploymentsInput = {
		create?: XOR<ActionCreateWithoutDeploymentsInput, ActionUncheckedCreateWithoutDeploymentsInput>
		connectOrCreate?: ActionCreateOrConnectWithoutDeploymentsInput
		upsert?: ActionUpsertWithoutDeploymentsInput
		connect?: ActionWhereUniqueInput
		update?: XOR<ActionUpdateWithoutDeploymentsInput, ActionUncheckedUpdateWithoutDeploymentsInput>
	}

	export type BuildUpdateOneRequiredWithoutDeploymentsInput = {
		create?: XOR<BuildCreateWithoutDeploymentsInput, BuildUncheckedCreateWithoutDeploymentsInput>
		connectOrCreate?: BuildCreateOrConnectWithoutDeploymentsInput
		upsert?: BuildUpsertWithoutDeploymentsInput
		connect?: BuildWhereUniqueInput
		update?: XOR<BuildUpdateWithoutDeploymentsInput, BuildUncheckedUpdateWithoutDeploymentsInput>
	}

	export type EnvironmentUpdateOneRequiredWithoutDeploymentsInput = {
		create?: XOR<EnvironmentCreateWithoutDeploymentsInput, EnvironmentUncheckedCreateWithoutDeploymentsInput>
		connectOrCreate?: EnvironmentCreateOrConnectWithoutDeploymentsInput
		upsert?: EnvironmentUpsertWithoutDeploymentsInput
		connect?: EnvironmentWhereUniqueInput
		update?: XOR<EnvironmentUpdateWithoutDeploymentsInput, EnvironmentUncheckedUpdateWithoutDeploymentsInput>
	}

	export type UserUpdateOneRequiredWithoutDeploymentsInput = {
		create?: XOR<UserCreateWithoutDeploymentsInput, UserUncheckedCreateWithoutDeploymentsInput>
		connectOrCreate?: UserCreateOrConnectWithoutDeploymentsInput
		upsert?: UserUpsertWithoutDeploymentsInput
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutDeploymentsInput, UserUncheckedUpdateWithoutDeploymentsInput>
	}

	export type UserCreateNestedOneWithoutSentInvitationsInput = {
		create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
		connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
		connect?: UserWhereUniqueInput
	}

	export type WorkspaceCreateNestedOneWithoutInvitationsInput = {
		create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
		connect?: WorkspaceWhereUniqueInput
	}

	export type UserCreateNestedOneWithoutCreatedFromInvitationInput = {
		create?: XOR<UserCreateWithoutCreatedFromInvitationInput, UserUncheckedCreateWithoutCreatedFromInvitationInput>
		connectOrCreate?: UserCreateOrConnectWithoutCreatedFromInvitationInput
		connect?: UserWhereUniqueInput
	}

	export type UserUpdateOneRequiredWithoutSentInvitationsInput = {
		create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
		connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
		upsert?: UserUpsertWithoutSentInvitationsInput
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
	}

	export type WorkspaceUpdateOneRequiredWithoutInvitationsInput = {
		create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
		upsert?: WorkspaceUpsertWithoutInvitationsInput
		connect?: WorkspaceWhereUniqueInput
		update?: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
	}

	export type UserUpdateOneWithoutCreatedFromInvitationInput = {
		create?: XOR<UserCreateWithoutCreatedFromInvitationInput, UserUncheckedCreateWithoutCreatedFromInvitationInput>
		connectOrCreate?: UserCreateOrConnectWithoutCreatedFromInvitationInput
		upsert?: UserUpsertWithoutCreatedFromInvitationInput
		disconnect?: boolean
		delete?: boolean
		connect?: UserWhereUniqueInput
		update?: XOR<UserUpdateWithoutCreatedFromInvitationInput, UserUncheckedUpdateWithoutCreatedFromInvitationInput>
	}

	export type WorkspaceCreateNestedOneWithoutSubscriptionsInput = {
		create?: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionsInput
		connect?: WorkspaceWhereUniqueInput
	}

	export type WorkspaceUpdateOneRequiredWithoutSubscriptionsInput = {
		create?: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
		connectOrCreate?: WorkspaceCreateOrConnectWithoutSubscriptionsInput
		upsert?: WorkspaceUpsertWithoutSubscriptionsInput
		connect?: WorkspaceWhereUniqueInput
		update?: XOR<WorkspaceUpdateWithoutSubscriptionsInput, WorkspaceUncheckedUpdateWithoutSubscriptionsInput>
	}

	export type EnumEnumSubscriptionPlanFieldUpdateOperationsInput = {
		set?: EnumSubscriptionPlan
	}

	export type EnumEnumSubscriptionStatusFieldUpdateOperationsInput = {
		set?: EnumSubscriptionStatus
	}

	export type NestedStringFilter = {
		equals?: string
		in?: Enumerable<string>
		notIn?: Enumerable<string>
		lt?: string
		lte?: string
		gt?: string
		gte?: string
		contains?: string
		startsWith?: string
		endsWith?: string
		not?: NestedStringFilter | string
	}

	export type NestedDateTimeFilter = {
		equals?: Date | string
		in?: Enumerable<Date> | Enumerable<string>
		notIn?: Enumerable<Date> | Enumerable<string>
		lt?: Date | string
		lte?: Date | string
		gt?: Date | string
		gte?: Date | string
		not?: NestedDateTimeFilter | Date | string
	}

	export type NestedStringNullableFilter = {
		equals?: string | null
		in?: Enumerable<string> | null
		notIn?: Enumerable<string> | null
		lt?: string
		lte?: string
		gt?: string
		gte?: string
		contains?: string
		startsWith?: string
		endsWith?: string
		not?: NestedStringNullableFilter | string | null
	}

	export type NestedStringWithAggregatesFilter = {
		equals?: string
		in?: Enumerable<string>
		notIn?: Enumerable<string>
		lt?: string
		lte?: string
		gt?: string
		gte?: string
		contains?: string
		startsWith?: string
		endsWith?: string
		not?: NestedStringWithAggregatesFilter | string
		_count?: NestedIntFilter
		_min?: NestedStringFilter
		_max?: NestedStringFilter
	}

	export type NestedIntFilter = {
		equals?: number
		in?: Enumerable<number>
		notIn?: Enumerable<number>
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedIntFilter | number
	}

	export type NestedDateTimeWithAggregatesFilter = {
		equals?: Date | string
		in?: Enumerable<Date> | Enumerable<string>
		notIn?: Enumerable<Date> | Enumerable<string>
		lt?: Date | string
		lte?: Date | string
		gt?: Date | string
		gte?: Date | string
		not?: NestedDateTimeWithAggregatesFilter | Date | string
		_count?: NestedIntFilter
		_min?: NestedDateTimeFilter
		_max?: NestedDateTimeFilter
	}

	export type NestedStringNullableWithAggregatesFilter = {
		equals?: string | null
		in?: Enumerable<string> | null
		notIn?: Enumerable<string> | null
		lt?: string
		lte?: string
		gt?: string
		gte?: string
		contains?: string
		startsWith?: string
		endsWith?: string
		not?: NestedStringNullableWithAggregatesFilter | string | null
		_count?: NestedIntNullableFilter
		_min?: NestedStringNullableFilter
		_max?: NestedStringNullableFilter
	}

	export type NestedIntNullableFilter = {
		equals?: number | null
		in?: Enumerable<number> | null
		notIn?: Enumerable<number> | null
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedIntNullableFilter | number | null
	}

	export type NestedDateTimeNullableFilter = {
		equals?: Date | string | null
		in?: Enumerable<Date> | Enumerable<string> | null
		notIn?: Enumerable<Date> | Enumerable<string> | null
		lt?: Date | string
		lte?: Date | string
		gt?: Date | string
		gte?: Date | string
		not?: NestedDateTimeNullableFilter | Date | string | null
	}

	export type NestedDateTimeNullableWithAggregatesFilter = {
		equals?: Date | string | null
		in?: Enumerable<Date> | Enumerable<string> | null
		notIn?: Enumerable<Date> | Enumerable<string> | null
		lt?: Date | string
		lte?: Date | string
		gt?: Date | string
		gte?: Date | string
		not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
		_count?: NestedIntNullableFilter
		_min?: NestedDateTimeNullableFilter
		_max?: NestedDateTimeNullableFilter
	}

	export type NestedEnumEnumGitProviderFilter = {
		equals?: EnumGitProvider
		in?: Enumerable<EnumGitProvider>
		notIn?: Enumerable<EnumGitProvider>
		not?: NestedEnumEnumGitProviderFilter | EnumGitProvider
	}

	export type NestedEnumEnumGitOrganizationTypeNullableFilter = {
		equals?: EnumGitOrganizationType | null
		in?: Enumerable<EnumGitOrganizationType> | null
		notIn?: Enumerable<EnumGitOrganizationType> | null
		not?: NestedEnumEnumGitOrganizationTypeNullableFilter | EnumGitOrganizationType | null
	}

	export type NestedEnumEnumGitProviderWithAggregatesFilter = {
		equals?: EnumGitProvider
		in?: Enumerable<EnumGitProvider>
		notIn?: Enumerable<EnumGitProvider>
		not?: NestedEnumEnumGitProviderWithAggregatesFilter | EnumGitProvider
		_count?: NestedIntFilter
		_min?: NestedEnumEnumGitProviderFilter
		_max?: NestedEnumEnumGitProviderFilter
	}

	export type NestedEnumEnumGitOrganizationTypeNullableWithAggregatesFilter = {
		equals?: EnumGitOrganizationType | null
		in?: Enumerable<EnumGitOrganizationType> | null
		notIn?: Enumerable<EnumGitOrganizationType> | null
		not?: NestedEnumEnumGitOrganizationTypeNullableWithAggregatesFilter | EnumGitOrganizationType | null
		_count?: NestedIntNullableFilter
		_min?: NestedEnumEnumGitOrganizationTypeNullableFilter
		_max?: NestedEnumEnumGitOrganizationTypeNullableFilter
	}

	export type NestedBoolFilter = {
		equals?: boolean
		not?: NestedBoolFilter | boolean
	}

	export type NestedBoolWithAggregatesFilter = {
		equals?: boolean
		not?: NestedBoolWithAggregatesFilter | boolean
		_count?: NestedIntFilter
		_min?: NestedBoolFilter
		_max?: NestedBoolFilter
	}

	export type NestedEnumEnumResourceTypeFilter = {
		equals?: EnumResourceType
		in?: Enumerable<EnumResourceType>
		notIn?: Enumerable<EnumResourceType>
		not?: NestedEnumEnumResourceTypeFilter | EnumResourceType
	}

	export type NestedEnumEnumResourceTypeWithAggregatesFilter = {
		equals?: EnumResourceType
		in?: Enumerable<EnumResourceType>
		notIn?: Enumerable<EnumResourceType>
		not?: NestedEnumEnumResourceTypeWithAggregatesFilter | EnumResourceType
		_count?: NestedIntFilter
		_min?: NestedEnumEnumResourceTypeFilter
		_max?: NestedEnumEnumResourceTypeFilter
	}

	export type NestedBoolNullableFilter = {
		equals?: boolean | null
		not?: NestedBoolNullableFilter | boolean | null
	}

	export type NestedIntWithAggregatesFilter = {
		equals?: number
		in?: Enumerable<number>
		notIn?: Enumerable<number>
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedIntWithAggregatesFilter | number
		_count?: NestedIntFilter
		_avg?: NestedFloatFilter
		_sum?: NestedIntFilter
		_min?: NestedIntFilter
		_max?: NestedIntFilter
	}

	export type NestedFloatFilter = {
		equals?: number
		in?: Enumerable<number>
		notIn?: Enumerable<number>
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedFloatFilter | number
	}

	export type NestedBoolNullableWithAggregatesFilter = {
		equals?: boolean | null
		not?: NestedBoolNullableWithAggregatesFilter | boolean | null
		_count?: NestedIntNullableFilter
		_min?: NestedBoolNullableFilter
		_max?: NestedBoolNullableFilter
	}

	export type NestedEnumEnumEntityActionFilter = {
		equals?: EnumEntityAction
		in?: Enumerable<EnumEntityAction>
		notIn?: Enumerable<EnumEntityAction>
		not?: NestedEnumEnumEntityActionFilter | EnumEntityAction
	}

	export type NestedEnumEnumEntityPermissionTypeFilter = {
		equals?: EnumEntityPermissionType
		in?: Enumerable<EnumEntityPermissionType>
		notIn?: Enumerable<EnumEntityPermissionType>
		not?: NestedEnumEnumEntityPermissionTypeFilter | EnumEntityPermissionType
	}

	export type NestedEnumEnumEntityActionWithAggregatesFilter = {
		equals?: EnumEntityAction
		in?: Enumerable<EnumEntityAction>
		notIn?: Enumerable<EnumEntityAction>
		not?: NestedEnumEnumEntityActionWithAggregatesFilter | EnumEntityAction
		_count?: NestedIntFilter
		_min?: NestedEnumEnumEntityActionFilter
		_max?: NestedEnumEnumEntityActionFilter
	}

	export type NestedEnumEnumEntityPermissionTypeWithAggregatesFilter = {
		equals?: EnumEntityPermissionType
		in?: Enumerable<EnumEntityPermissionType>
		notIn?: Enumerable<EnumEntityPermissionType>
		not?: NestedEnumEnumEntityPermissionTypeWithAggregatesFilter | EnumEntityPermissionType
		_count?: NestedIntFilter
		_min?: NestedEnumEnumEntityPermissionTypeFilter
		_max?: NestedEnumEnumEntityPermissionTypeFilter
	}

	export type NestedEnumEnumDataTypeFilter = {
		equals?: EnumDataType
		in?: Enumerable<EnumDataType>
		notIn?: Enumerable<EnumDataType>
		not?: NestedEnumEnumDataTypeFilter | EnumDataType
	}

	export type NestedEnumEnumDataTypeWithAggregatesFilter = {
		equals?: EnumDataType
		in?: Enumerable<EnumDataType>
		notIn?: Enumerable<EnumDataType>
		not?: NestedEnumEnumDataTypeWithAggregatesFilter | EnumDataType
		_count?: NestedIntFilter
		_min?: NestedEnumEnumDataTypeFilter
		_max?: NestedEnumEnumDataTypeFilter
	}
	export type NestedJsonFilter =
		| PatchUndefined<
		Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
		Required<NestedJsonFilterBase>
		>
		| OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

	export type NestedJsonFilterBase = {
		equals?: JsonNullValueFilter | InputJsonValue
		not?: JsonNullValueFilter | InputJsonValue
	}

	export type NestedIntNullableWithAggregatesFilter = {
		equals?: number | null
		in?: Enumerable<number> | null
		notIn?: Enumerable<number> | null
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedIntNullableWithAggregatesFilter | number | null
		_count?: NestedIntNullableFilter
		_avg?: NestedFloatNullableFilter
		_sum?: NestedIntNullableFilter
		_min?: NestedIntNullableFilter
		_max?: NestedIntNullableFilter
	}

	export type NestedFloatNullableFilter = {
		equals?: number | null
		in?: Enumerable<number> | null
		notIn?: Enumerable<number> | null
		lt?: number
		lte?: number
		gt?: number
		gte?: number
		not?: NestedFloatNullableFilter | number | null
	}

	export type NestedEnumEnumBlockTypeFilter = {
		equals?: EnumBlockType
		in?: Enumerable<EnumBlockType>
		notIn?: Enumerable<EnumBlockType>
		not?: NestedEnumEnumBlockTypeFilter | EnumBlockType
	}

	export type NestedEnumEnumBlockTypeWithAggregatesFilter = {
		equals?: EnumBlockType
		in?: Enumerable<EnumBlockType>
		notIn?: Enumerable<EnumBlockType>
		not?: NestedEnumEnumBlockTypeWithAggregatesFilter | EnumBlockType
		_count?: NestedIntFilter
		_min?: NestedEnumEnumBlockTypeFilter
		_max?: NestedEnumEnumBlockTypeFilter
	}
	export type NestedJsonNullableFilter =
		| PatchUndefined<
		Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
		Required<NestedJsonNullableFilterBase>
		>
		| OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

	export type NestedJsonNullableFilterBase = {
		equals?: JsonNullValueFilter | InputJsonValue
		not?: JsonNullValueFilter | InputJsonValue
	}

	export type NestedEnumActionStepStatusFilter = {
		equals?: ActionStepStatus
		in?: Enumerable<ActionStepStatus>
		notIn?: Enumerable<ActionStepStatus>
		not?: NestedEnumActionStepStatusFilter | ActionStepStatus
	}

	export type NestedEnumActionStepStatusWithAggregatesFilter = {
		equals?: ActionStepStatus
		in?: Enumerable<ActionStepStatus>
		notIn?: Enumerable<ActionStepStatus>
		not?: NestedEnumActionStepStatusWithAggregatesFilter | ActionStepStatus
		_count?: NestedIntFilter
		_min?: NestedEnumActionStepStatusFilter
		_max?: NestedEnumActionStepStatusFilter
	}

	export type NestedEnumEnumLogLevelFilter = {
		equals?: EnumLogLevel
		in?: Enumerable<EnumLogLevel>
		notIn?: Enumerable<EnumLogLevel>
		not?: NestedEnumEnumLogLevelFilter | EnumLogLevel
	}

	export type NestedEnumEnumLogLevelWithAggregatesFilter = {
		equals?: EnumLogLevel
		in?: Enumerable<EnumLogLevel>
		notIn?: Enumerable<EnumLogLevel>
		not?: NestedEnumEnumLogLevelWithAggregatesFilter | EnumLogLevel
		_count?: NestedIntFilter
		_min?: NestedEnumEnumLogLevelFilter
		_max?: NestedEnumEnumLogLevelFilter
	}

	export type NestedEnumEnumDeploymentStatusFilter = {
		equals?: EnumDeploymentStatus
		in?: Enumerable<EnumDeploymentStatus>
		notIn?: Enumerable<EnumDeploymentStatus>
		not?: NestedEnumEnumDeploymentStatusFilter | EnumDeploymentStatus
	}

	export type NestedEnumEnumDeploymentStatusWithAggregatesFilter = {
		equals?: EnumDeploymentStatus
		in?: Enumerable<EnumDeploymentStatus>
		notIn?: Enumerable<EnumDeploymentStatus>
		not?: NestedEnumEnumDeploymentStatusWithAggregatesFilter | EnumDeploymentStatus
		_count?: NestedIntFilter
		_min?: NestedEnumEnumDeploymentStatusFilter
		_max?: NestedEnumEnumDeploymentStatusFilter
	}

	export type NestedEnumEnumSubscriptionPlanFilter = {
		equals?: EnumSubscriptionPlan
		in?: Enumerable<EnumSubscriptionPlan>
		notIn?: Enumerable<EnumSubscriptionPlan>
		not?: NestedEnumEnumSubscriptionPlanFilter | EnumSubscriptionPlan
	}

	export type NestedEnumEnumSubscriptionStatusFilter = {
		equals?: EnumSubscriptionStatus
		in?: Enumerable<EnumSubscriptionStatus>
		notIn?: Enumerable<EnumSubscriptionStatus>
		not?: NestedEnumEnumSubscriptionStatusFilter | EnumSubscriptionStatus
	}

	export type NestedEnumEnumSubscriptionPlanWithAggregatesFilter = {
		equals?: EnumSubscriptionPlan
		in?: Enumerable<EnumSubscriptionPlan>
		notIn?: Enumerable<EnumSubscriptionPlan>
		not?: NestedEnumEnumSubscriptionPlanWithAggregatesFilter | EnumSubscriptionPlan
		_count?: NestedIntFilter
		_min?: NestedEnumEnumSubscriptionPlanFilter
		_max?: NestedEnumEnumSubscriptionPlanFilter
	}

	export type NestedEnumEnumSubscriptionStatusWithAggregatesFilter = {
		equals?: EnumSubscriptionStatus
		in?: Enumerable<EnumSubscriptionStatus>
		notIn?: Enumerable<EnumSubscriptionStatus>
		not?: NestedEnumEnumSubscriptionStatusWithAggregatesFilter | EnumSubscriptionStatus
		_count?: NestedIntFilter
		_min?: NestedEnumEnumSubscriptionStatusFilter
		_max?: NestedEnumEnumSubscriptionStatusFilter
	}

	export type UserCreateWithoutAssignedCurrentToInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutAssignedCurrentToInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutAssignedCurrentToInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutAssignedCurrentToInput, UserUncheckedCreateWithoutAssignedCurrentToInput>
	}

	export type UserCreateWithoutAccountInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutAccountInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutAccountInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
	}

	export type UserCreateManyAccountInputEnvelope = {
		data: Enumerable<UserCreateManyAccountInput>
		skipDuplicates?: boolean
	}

	export type UserUpsertWithoutAssignedCurrentToInput = {
		update: XOR<UserUpdateWithoutAssignedCurrentToInput, UserUncheckedUpdateWithoutAssignedCurrentToInput>
		create: XOR<UserCreateWithoutAssignedCurrentToInput, UserUncheckedCreateWithoutAssignedCurrentToInput>
	}

	export type UserUpdateWithoutAssignedCurrentToInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutAssignedCurrentToInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUpsertWithWhereUniqueWithoutAccountInput = {
		where: UserWhereUniqueInput
		update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
		create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
	}

	export type UserUpdateWithWhereUniqueWithoutAccountInput = {
		where: UserWhereUniqueInput
		data: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
	}

	export type UserUpdateManyWithWhereWithoutAccountInput = {
		where: UserScalarWhereInput
		data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
	}

	export type UserScalarWhereInput = {
		AND?: Enumerable<UserScalarWhereInput>
		OR?: Enumerable<UserScalarWhereInput>
		NOT?: Enumerable<UserScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		accountId?: StringFilter | string
		workspaceId?: StringFilter | string
		isOwner?: BoolFilter | boolean
		deletedAt?: DateTimeNullableFilter | Date | string | null
	}

	export type UserCreateWithoutWorkspaceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutWorkspaceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutWorkspaceInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutWorkspaceInput, UserUncheckedCreateWithoutWorkspaceInput>
	}

	export type UserCreateManyWorkspaceInputEnvelope = {
		data: Enumerable<UserCreateManyWorkspaceInput>
		skipDuplicates?: boolean
	}

	export type InvitationCreateWithoutWorkspaceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		invitedByUser: UserCreateNestedOneWithoutSentInvitationsInput
		newUser?: UserCreateNestedOneWithoutCreatedFromInvitationInput
		token: string
		tokenExpiration: Date | string
	}

	export type InvitationUncheckedCreateWithoutWorkspaceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		invitedByUserId: string
		newUserId?: string | null
		token: string
		tokenExpiration: Date | string
	}

	export type InvitationCreateOrConnectWithoutWorkspaceInput = {
		where: InvitationWhereUniqueInput
		create: XOR<InvitationCreateWithoutWorkspaceInput, InvitationUncheckedCreateWithoutWorkspaceInput>
	}

	export type InvitationCreateManyWorkspaceInputEnvelope = {
		data: Enumerable<InvitationCreateManyWorkspaceInput>
		skipDuplicates?: boolean
	}

	export type SubscriptionCreateWithoutWorkspaceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		subscriptionPlan: EnumSubscriptionPlan
		status: EnumSubscriptionStatus
		subscriptionData: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: Date | string | null
	}

	export type SubscriptionUncheckedCreateWithoutWorkspaceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		subscriptionPlan: EnumSubscriptionPlan
		status: EnumSubscriptionStatus
		subscriptionData: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: Date | string | null
	}

	export type SubscriptionCreateOrConnectWithoutWorkspaceInput = {
		where: SubscriptionWhereUniqueInput
		create: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
	}

	export type SubscriptionCreateManyWorkspaceInputEnvelope = {
		data: Enumerable<SubscriptionCreateManyWorkspaceInput>
		skipDuplicates?: boolean
	}

	export type GitOrganizationCreateWithoutWorkspaceInput = {
		id?: string
		provider: EnumGitProvider
		name: string
		installationId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		type?: EnumGitOrganizationType | null
		gitRepositories?: GitRepositoryCreateNestedManyWithoutGitOrganizationInput
	}

	export type GitOrganizationUncheckedCreateWithoutWorkspaceInput = {
		id?: string
		provider: EnumGitProvider
		name: string
		installationId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		type?: EnumGitOrganizationType | null
		gitRepositories?: GitRepositoryUncheckedCreateNestedManyWithoutGitOrganizationInput
	}

	export type GitOrganizationCreateOrConnectWithoutWorkspaceInput = {
		where: GitOrganizationWhereUniqueInput
		create: XOR<GitOrganizationCreateWithoutWorkspaceInput, GitOrganizationUncheckedCreateWithoutWorkspaceInput>
	}

	export type GitOrganizationCreateManyWorkspaceInputEnvelope = {
		data: Enumerable<GitOrganizationCreateManyWorkspaceInput>
		skipDuplicates?: boolean
	}

	export type ProjectCreateWithoutWorkspaceInput = {
		id?: string
		name: string
		resources?: ResourceCreateNestedManyWithoutProjectInput
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
		commits?: CommitCreateNestedManyWithoutProjectInput
	}

	export type ProjectUncheckedCreateWithoutWorkspaceInput = {
		id?: string
		name: string
		resources?: ResourceUncheckedCreateNestedManyWithoutProjectInput
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
		commits?: CommitUncheckedCreateNestedManyWithoutProjectInput
	}

	export type ProjectCreateOrConnectWithoutWorkspaceInput = {
		where: ProjectWhereUniqueInput
		create: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput>
	}

	export type ProjectCreateManyWorkspaceInputEnvelope = {
		data: Enumerable<ProjectCreateManyWorkspaceInput>
		skipDuplicates?: boolean
	}

	export type UserUpsertWithWhereUniqueWithoutWorkspaceInput = {
		where: UserWhereUniqueInput
		update: XOR<UserUpdateWithoutWorkspaceInput, UserUncheckedUpdateWithoutWorkspaceInput>
		create: XOR<UserCreateWithoutWorkspaceInput, UserUncheckedCreateWithoutWorkspaceInput>
	}

	export type UserUpdateWithWhereUniqueWithoutWorkspaceInput = {
		where: UserWhereUniqueInput
		data: XOR<UserUpdateWithoutWorkspaceInput, UserUncheckedUpdateWithoutWorkspaceInput>
	}

	export type UserUpdateManyWithWhereWithoutWorkspaceInput = {
		where: UserScalarWhereInput
		data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
	}

	export type InvitationUpsertWithWhereUniqueWithoutWorkspaceInput = {
		where: InvitationWhereUniqueInput
		update: XOR<InvitationUpdateWithoutWorkspaceInput, InvitationUncheckedUpdateWithoutWorkspaceInput>
		create: XOR<InvitationCreateWithoutWorkspaceInput, InvitationUncheckedCreateWithoutWorkspaceInput>
	}

	export type InvitationUpdateWithWhereUniqueWithoutWorkspaceInput = {
		where: InvitationWhereUniqueInput
		data: XOR<InvitationUpdateWithoutWorkspaceInput, InvitationUncheckedUpdateWithoutWorkspaceInput>
	}

	export type InvitationUpdateManyWithWhereWithoutWorkspaceInput = {
		where: InvitationScalarWhereInput
		data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutInvitationsInput>
	}

	export type InvitationScalarWhereInput = {
		AND?: Enumerable<InvitationScalarWhereInput>
		OR?: Enumerable<InvitationScalarWhereInput>
		NOT?: Enumerable<InvitationScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		email?: StringFilter | string
		invitedByUserId?: StringFilter | string
		workspaceId?: StringFilter | string
		newUserId?: StringNullableFilter | string | null
		token?: StringFilter | string
		tokenExpiration?: DateTimeFilter | Date | string
	}

	export type SubscriptionUpsertWithWhereUniqueWithoutWorkspaceInput = {
		where: SubscriptionWhereUniqueInput
		update: XOR<SubscriptionUpdateWithoutWorkspaceInput, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
		create: XOR<SubscriptionCreateWithoutWorkspaceInput, SubscriptionUncheckedCreateWithoutWorkspaceInput>
	}

	export type SubscriptionUpdateWithWhereUniqueWithoutWorkspaceInput = {
		where: SubscriptionWhereUniqueInput
		data: XOR<SubscriptionUpdateWithoutWorkspaceInput, SubscriptionUncheckedUpdateWithoutWorkspaceInput>
	}

	export type SubscriptionUpdateManyWithWhereWithoutWorkspaceInput = {
		where: SubscriptionScalarWhereInput
		data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput>
	}

	export type SubscriptionScalarWhereInput = {
		AND?: Enumerable<SubscriptionScalarWhereInput>
		OR?: Enumerable<SubscriptionScalarWhereInput>
		NOT?: Enumerable<SubscriptionScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		workspaceId?: StringFilter | string
		subscriptionPlan?: EnumEnumSubscriptionPlanFilter | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusFilter | EnumSubscriptionStatus
		subscriptionData?: JsonFilter
		cancellationEffectiveDate?: DateTimeNullableFilter | Date | string | null
	}

	export type GitOrganizationUpsertWithWhereUniqueWithoutWorkspaceInput = {
		where: GitOrganizationWhereUniqueInput
		update: XOR<GitOrganizationUpdateWithoutWorkspaceInput, GitOrganizationUncheckedUpdateWithoutWorkspaceInput>
		create: XOR<GitOrganizationCreateWithoutWorkspaceInput, GitOrganizationUncheckedCreateWithoutWorkspaceInput>
	}

	export type GitOrganizationUpdateWithWhereUniqueWithoutWorkspaceInput = {
		where: GitOrganizationWhereUniqueInput
		data: XOR<GitOrganizationUpdateWithoutWorkspaceInput, GitOrganizationUncheckedUpdateWithoutWorkspaceInput>
	}

	export type GitOrganizationUpdateManyWithWhereWithoutWorkspaceInput = {
		where: GitOrganizationScalarWhereInput
		data: XOR<GitOrganizationUpdateManyMutationInput, GitOrganizationUncheckedUpdateManyWithoutGitOrganizationsInput>
	}

	export type GitOrganizationScalarWhereInput = {
		AND?: Enumerable<GitOrganizationScalarWhereInput>
		OR?: Enumerable<GitOrganizationScalarWhereInput>
		NOT?: Enumerable<GitOrganizationScalarWhereInput>
		id?: StringFilter | string
		provider?: EnumEnumGitProviderFilter | EnumGitProvider
		name?: StringFilter | string
		installationId?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		workspaceId?: StringFilter | string
		type?: EnumEnumGitOrganizationTypeNullableFilter | EnumGitOrganizationType | null
	}

	export type ProjectUpsertWithWhereUniqueWithoutWorkspaceInput = {
		where: ProjectWhereUniqueInput
		update: XOR<ProjectUpdateWithoutWorkspaceInput, ProjectUncheckedUpdateWithoutWorkspaceInput>
		create: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput>
	}

	export type ProjectUpdateWithWhereUniqueWithoutWorkspaceInput = {
		where: ProjectWhereUniqueInput
		data: XOR<ProjectUpdateWithoutWorkspaceInput, ProjectUncheckedUpdateWithoutWorkspaceInput>
	}

	export type ProjectUpdateManyWithWhereWithoutWorkspaceInput = {
		where: ProjectScalarWhereInput
		data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectsInput>
	}

	export type ProjectScalarWhereInput = {
		AND?: Enumerable<ProjectScalarWhereInput>
		OR?: Enumerable<ProjectScalarWhereInput>
		NOT?: Enumerable<ProjectScalarWhereInput>
		id?: StringFilter | string
		name?: StringFilter | string
		workspaceId?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		deletedAt?: DateTimeNullableFilter | Date | string | null
	}

	export type WorkspaceCreateWithoutProjectsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserCreateNestedManyWithoutWorkspaceInput
		invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedCreateWithoutProjectsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserUncheckedCreateNestedManyWithoutWorkspaceInput
		invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceCreateOrConnectWithoutProjectsInput = {
		where: WorkspaceWhereUniqueInput
		create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
	}

	export type ResourceCreateWithoutProjectInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		roles?: ResourceRoleCreateNestedManyWithoutResourceInput
		blocks?: BlockCreateNestedManyWithoutResourceInput
		builds?: BuildCreateNestedManyWithoutResourceInput
		entities?: EntityCreateNestedManyWithoutResourceInput
		environments?: EnvironmentCreateNestedManyWithoutResourceInput
		gitRepository?: GitRepositoryCreateNestedOneWithoutResourcesInput
		resourceType: EnumResourceType
	}

	export type ResourceUncheckedCreateWithoutProjectInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		gitRepositoryId?: string | null
		roles?: ResourceRoleUncheckedCreateNestedManyWithoutResourceInput
		blocks?: BlockUncheckedCreateNestedManyWithoutResourceInput
		builds?: BuildUncheckedCreateNestedManyWithoutResourceInput
		entities?: EntityUncheckedCreateNestedManyWithoutResourceInput
		environments?: EnvironmentUncheckedCreateNestedManyWithoutResourceInput
		resourceType: EnumResourceType
	}

	export type ResourceCreateOrConnectWithoutProjectInput = {
		where: ResourceWhereUniqueInput
		create: XOR<ResourceCreateWithoutProjectInput, ResourceUncheckedCreateWithoutProjectInput>
	}

	export type ResourceCreateManyProjectInputEnvelope = {
		data: Enumerable<ResourceCreateManyProjectInput>
		skipDuplicates?: boolean
	}

	export type CommitCreateWithoutProjectInput = {
		id?: string
		createdAt?: Date | string
		message: string
		user: UserCreateNestedOneWithoutCommitsInput
		blockVersions?: BlockVersionCreateNestedManyWithoutCommitInput
		builds?: BuildCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionCreateNestedManyWithoutCommitInput
		releases?: ReleaseCreateNestedManyWithoutCommitInput
	}

	export type CommitUncheckedCreateWithoutProjectInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		message: string
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutCommitInput
		builds?: BuildUncheckedCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutCommitInput
		releases?: ReleaseUncheckedCreateNestedManyWithoutCommitInput
	}

	export type CommitCreateOrConnectWithoutProjectInput = {
		where: CommitWhereUniqueInput
		create: XOR<CommitCreateWithoutProjectInput, CommitUncheckedCreateWithoutProjectInput>
	}

	export type CommitCreateManyProjectInputEnvelope = {
		data: Enumerable<CommitCreateManyProjectInput>
		skipDuplicates?: boolean
	}

	export type WorkspaceUpsertWithoutProjectsInput = {
		update: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
		create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
	}

	export type WorkspaceUpdateWithoutProjectsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUpdateManyWithoutWorkspaceInput
		invitations?: InvitationUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUpdateManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedUpdateWithoutProjectsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUncheckedUpdateManyWithoutWorkspaceInput
		invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedUpdateManyWithoutWorkspaceInput
	}

	export type ResourceUpsertWithWhereUniqueWithoutProjectInput = {
		where: ResourceWhereUniqueInput
		update: XOR<ResourceUpdateWithoutProjectInput, ResourceUncheckedUpdateWithoutProjectInput>
		create: XOR<ResourceCreateWithoutProjectInput, ResourceUncheckedCreateWithoutProjectInput>
	}

	export type ResourceUpdateWithWhereUniqueWithoutProjectInput = {
		where: ResourceWhereUniqueInput
		data: XOR<ResourceUpdateWithoutProjectInput, ResourceUncheckedUpdateWithoutProjectInput>
	}

	export type ResourceUpdateManyWithWhereWithoutProjectInput = {
		where: ResourceScalarWhereInput
		data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutResourcesInput>
	}

	export type ResourceScalarWhereInput = {
		AND?: Enumerable<ResourceScalarWhereInput>
		OR?: Enumerable<ResourceScalarWhereInput>
		NOT?: Enumerable<ResourceScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		name?: StringFilter | string
		description?: StringFilter | string
		gitRepositoryOverride?: BoolFilter | boolean
		githubLastSync?: DateTimeNullableFilter | Date | string | null
		githubLastMessage?: StringNullableFilter | string | null
		deletedAt?: DateTimeNullableFilter | Date | string | null
		gitRepositoryId?: StringNullableFilter | string | null
		projectId?: StringFilter | string
		resourceType?: EnumEnumResourceTypeFilter | EnumResourceType
	}

	export type CommitUpsertWithWhereUniqueWithoutProjectInput = {
		where: CommitWhereUniqueInput
		update: XOR<CommitUpdateWithoutProjectInput, CommitUncheckedUpdateWithoutProjectInput>
		create: XOR<CommitCreateWithoutProjectInput, CommitUncheckedCreateWithoutProjectInput>
	}

	export type CommitUpdateWithWhereUniqueWithoutProjectInput = {
		where: CommitWhereUniqueInput
		data: XOR<CommitUpdateWithoutProjectInput, CommitUncheckedUpdateWithoutProjectInput>
	}

	export type CommitUpdateManyWithWhereWithoutProjectInput = {
		where: CommitScalarWhereInput
		data: XOR<CommitUpdateManyMutationInput, CommitUncheckedUpdateManyWithoutCommitsInput>
	}

	export type CommitScalarWhereInput = {
		AND?: Enumerable<CommitScalarWhereInput>
		OR?: Enumerable<CommitScalarWhereInput>
		NOT?: Enumerable<CommitScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		userId?: StringFilter | string
		message?: StringFilter | string
		projectId?: StringFilter | string
	}

	export type WorkspaceCreateWithoutGitOrganizationsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserCreateNestedManyWithoutWorkspaceInput
		invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedCreateWithoutGitOrganizationsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserUncheckedCreateNestedManyWithoutWorkspaceInput
		invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceCreateOrConnectWithoutGitOrganizationsInput = {
		where: WorkspaceWhereUniqueInput
		create: XOR<WorkspaceCreateWithoutGitOrganizationsInput, WorkspaceUncheckedCreateWithoutGitOrganizationsInput>
	}

	export type GitRepositoryCreateWithoutGitOrganizationInput = {
		id?: string
		name: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resources?: ResourceCreateNestedManyWithoutGitRepositoryInput
	}

	export type GitRepositoryUncheckedCreateWithoutGitOrganizationInput = {
		id?: string
		name: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resources?: ResourceUncheckedCreateNestedManyWithoutGitRepositoryInput
	}

	export type GitRepositoryCreateOrConnectWithoutGitOrganizationInput = {
		where: GitRepositoryWhereUniqueInput
		create: XOR<GitRepositoryCreateWithoutGitOrganizationInput, GitRepositoryUncheckedCreateWithoutGitOrganizationInput>
	}

	export type GitRepositoryCreateManyGitOrganizationInputEnvelope = {
		data: Enumerable<GitRepositoryCreateManyGitOrganizationInput>
		skipDuplicates?: boolean
	}

	export type WorkspaceUpsertWithoutGitOrganizationsInput = {
		update: XOR<WorkspaceUpdateWithoutGitOrganizationsInput, WorkspaceUncheckedUpdateWithoutGitOrganizationsInput>
		create: XOR<WorkspaceCreateWithoutGitOrganizationsInput, WorkspaceUncheckedCreateWithoutGitOrganizationsInput>
	}

	export type WorkspaceUpdateWithoutGitOrganizationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUpdateManyWithoutWorkspaceInput
		invitations?: InvitationUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUpdateManyWithoutWorkspaceInput
		projects?: ProjectUpdateManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedUpdateWithoutGitOrganizationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUncheckedUpdateManyWithoutWorkspaceInput
		invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedUpdateManyWithoutWorkspaceInput
		projects?: ProjectUncheckedUpdateManyWithoutWorkspaceInput
	}

	export type GitRepositoryUpsertWithWhereUniqueWithoutGitOrganizationInput = {
		where: GitRepositoryWhereUniqueInput
		update: XOR<GitRepositoryUpdateWithoutGitOrganizationInput, GitRepositoryUncheckedUpdateWithoutGitOrganizationInput>
		create: XOR<GitRepositoryCreateWithoutGitOrganizationInput, GitRepositoryUncheckedCreateWithoutGitOrganizationInput>
	}

	export type GitRepositoryUpdateWithWhereUniqueWithoutGitOrganizationInput = {
		where: GitRepositoryWhereUniqueInput
		data: XOR<GitRepositoryUpdateWithoutGitOrganizationInput, GitRepositoryUncheckedUpdateWithoutGitOrganizationInput>
	}

	export type GitRepositoryUpdateManyWithWhereWithoutGitOrganizationInput = {
		where: GitRepositoryScalarWhereInput
		data: XOR<GitRepositoryUpdateManyMutationInput, GitRepositoryUncheckedUpdateManyWithoutGitRepositoriesInput>
	}

	export type GitRepositoryScalarWhereInput = {
		AND?: Enumerable<GitRepositoryScalarWhereInput>
		OR?: Enumerable<GitRepositoryScalarWhereInput>
		NOT?: Enumerable<GitRepositoryScalarWhereInput>
		id?: StringFilter | string
		name?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		gitOrganizationId?: StringFilter | string
	}

	export type ResourceCreateWithoutGitRepositoryInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		roles?: ResourceRoleCreateNestedManyWithoutResourceInput
		blocks?: BlockCreateNestedManyWithoutResourceInput
		builds?: BuildCreateNestedManyWithoutResourceInput
		entities?: EntityCreateNestedManyWithoutResourceInput
		environments?: EnvironmentCreateNestedManyWithoutResourceInput
		project: ProjectCreateNestedOneWithoutResourcesInput
		resourceType: EnumResourceType
	}

	export type ResourceUncheckedCreateWithoutGitRepositoryInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		roles?: ResourceRoleUncheckedCreateNestedManyWithoutResourceInput
		blocks?: BlockUncheckedCreateNestedManyWithoutResourceInput
		builds?: BuildUncheckedCreateNestedManyWithoutResourceInput
		entities?: EntityUncheckedCreateNestedManyWithoutResourceInput
		environments?: EnvironmentUncheckedCreateNestedManyWithoutResourceInput
		projectId: string
		resourceType: EnumResourceType
	}

	export type ResourceCreateOrConnectWithoutGitRepositoryInput = {
		where: ResourceWhereUniqueInput
		create: XOR<ResourceCreateWithoutGitRepositoryInput, ResourceUncheckedCreateWithoutGitRepositoryInput>
	}

	export type ResourceCreateManyGitRepositoryInputEnvelope = {
		data: Enumerable<ResourceCreateManyGitRepositoryInput>
		skipDuplicates?: boolean
	}

	export type GitOrganizationCreateWithoutGitRepositoriesInput = {
		id?: string
		provider: EnumGitProvider
		name: string
		installationId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		type?: EnumGitOrganizationType | null
		workspace: WorkspaceCreateNestedOneWithoutGitOrganizationsInput
	}

	export type GitOrganizationUncheckedCreateWithoutGitRepositoriesInput = {
		id?: string
		provider: EnumGitProvider
		name: string
		installationId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		workspaceId: string
		type?: EnumGitOrganizationType | null
	}

	export type GitOrganizationCreateOrConnectWithoutGitRepositoriesInput = {
		where: GitOrganizationWhereUniqueInput
		create: XOR<GitOrganizationCreateWithoutGitRepositoriesInput, GitOrganizationUncheckedCreateWithoutGitRepositoriesInput>
	}

	export type ResourceUpsertWithWhereUniqueWithoutGitRepositoryInput = {
		where: ResourceWhereUniqueInput
		update: XOR<ResourceUpdateWithoutGitRepositoryInput, ResourceUncheckedUpdateWithoutGitRepositoryInput>
		create: XOR<ResourceCreateWithoutGitRepositoryInput, ResourceUncheckedCreateWithoutGitRepositoryInput>
	}

	export type ResourceUpdateWithWhereUniqueWithoutGitRepositoryInput = {
		where: ResourceWhereUniqueInput
		data: XOR<ResourceUpdateWithoutGitRepositoryInput, ResourceUncheckedUpdateWithoutGitRepositoryInput>
	}

	export type ResourceUpdateManyWithWhereWithoutGitRepositoryInput = {
		where: ResourceScalarWhereInput
		data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutResourcesInput>
	}

	export type GitOrganizationUpsertWithoutGitRepositoriesInput = {
		update: XOR<GitOrganizationUpdateWithoutGitRepositoriesInput, GitOrganizationUncheckedUpdateWithoutGitRepositoriesInput>
		create: XOR<GitOrganizationCreateWithoutGitRepositoriesInput, GitOrganizationUncheckedCreateWithoutGitRepositoriesInput>
	}

	export type GitOrganizationUpdateWithoutGitRepositoriesInput = {
		id?: StringFieldUpdateOperationsInput | string
		provider?: EnumEnumGitProviderFieldUpdateOperationsInput | EnumGitProvider
		name?: StringFieldUpdateOperationsInput | string
		installationId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		type?: NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput | EnumGitOrganizationType | null
		workspace?: WorkspaceUpdateOneRequiredWithoutGitOrganizationsInput
	}

	export type GitOrganizationUncheckedUpdateWithoutGitRepositoriesInput = {
		id?: StringFieldUpdateOperationsInput | string
		provider?: EnumEnumGitProviderFieldUpdateOperationsInput | EnumGitProvider
		name?: StringFieldUpdateOperationsInput | string
		installationId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		type?: NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput | EnumGitOrganizationType | null
	}

	export type AccountCreateWithoutUsersInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		firstName: string
		lastName: string
		password: string
		githubId?: string | null
		currentUser?: UserCreateNestedOneWithoutAssignedCurrentToInput
	}

	export type AccountUncheckedCreateWithoutUsersInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		firstName: string
		lastName: string
		password: string
		currentUserId?: string | null
		githubId?: string | null
	}

	export type AccountCreateOrConnectWithoutUsersInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutUsersInput, AccountUncheckedCreateWithoutUsersInput>
	}

	export type WorkspaceCreateWithoutUsersInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedCreateWithoutUsersInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceCreateOrConnectWithoutUsersInput = {
		where: WorkspaceWhereUniqueInput
		create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
	}

	export type AccountCreateWithoutCurrentUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		firstName: string
		lastName: string
		password: string
		githubId?: string | null
		users?: UserCreateNestedManyWithoutAccountInput
	}

	export type AccountUncheckedCreateWithoutCurrentUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		firstName: string
		lastName: string
		password: string
		githubId?: string | null
		users?: UserUncheckedCreateNestedManyWithoutAccountInput
	}

	export type AccountCreateOrConnectWithoutCurrentUserInput = {
		where: AccountWhereUniqueInput
		create: XOR<AccountCreateWithoutCurrentUserInput, AccountUncheckedCreateWithoutCurrentUserInput>
	}

	export type ApiTokenCreateWithoutUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		token: string
		previewChars: string
		lastAccessAt: Date | string
	}

	export type ApiTokenUncheckedCreateWithoutUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		token: string
		previewChars: string
		lastAccessAt: Date | string
	}

	export type ApiTokenCreateOrConnectWithoutUserInput = {
		where: ApiTokenWhereUniqueInput
		create: XOR<ApiTokenCreateWithoutUserInput, ApiTokenUncheckedCreateWithoutUserInput>
	}

	export type ApiTokenCreateManyUserInputEnvelope = {
		data: Enumerable<ApiTokenCreateManyUserInput>
		skipDuplicates?: boolean
	}

	export type BlockCreateWithoutLockedByUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		resource: ResourceCreateNestedOneWithoutBlocksInput
		parentBlock?: BlockCreateNestedOneWithoutBlocksInput
		blocks?: BlockCreateNestedManyWithoutParentBlockInput
		versions?: BlockVersionCreateNestedManyWithoutBlockInput
	}

	export type BlockUncheckedCreateWithoutLockedByUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		parentBlockId?: string | null
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		blocks?: BlockUncheckedCreateNestedManyWithoutParentBlockInput
		versions?: BlockVersionUncheckedCreateNestedManyWithoutBlockInput
	}

	export type BlockCreateOrConnectWithoutLockedByUserInput = {
		where: BlockWhereUniqueInput
		create: XOR<BlockCreateWithoutLockedByUserInput, BlockUncheckedCreateWithoutLockedByUserInput>
	}

	export type BlockCreateManyLockedByUserInputEnvelope = {
		data: Enumerable<BlockCreateManyLockedByUserInput>
		skipDuplicates?: boolean
	}

	export type BuildCreateWithoutCreatedByInput = {
		id?: string
		createdAt?: Date | string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutBuildsInput
		resource: ResourceCreateNestedOneWithoutBuildsInput
		commit?: CommitCreateNestedOneWithoutBuildsInput
		deployments?: DeploymentCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionCreateNestedManyWithoutBuildsInput
	}

	export type BuildUncheckedCreateWithoutCreatedByInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
		deployments?: DeploymentUncheckedCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutBuildsInput
	}

	export type BuildCreateOrConnectWithoutCreatedByInput = {
		where: BuildWhereUniqueInput
		create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
	}

	export type BuildCreateManyCreatedByInputEnvelope = {
		data: Enumerable<BuildCreateManyCreatedByInput>
		skipDuplicates?: boolean
	}

	export type CommitCreateWithoutUserInput = {
		id?: string
		createdAt?: Date | string
		message: string
		blockVersions?: BlockVersionCreateNestedManyWithoutCommitInput
		builds?: BuildCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionCreateNestedManyWithoutCommitInput
		releases?: ReleaseCreateNestedManyWithoutCommitInput
		project: ProjectCreateNestedOneWithoutCommitsInput
	}

	export type CommitUncheckedCreateWithoutUserInput = {
		id?: string
		createdAt?: Date | string
		message: string
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutCommitInput
		builds?: BuildUncheckedCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutCommitInput
		releases?: ReleaseUncheckedCreateNestedManyWithoutCommitInput
		projectId: string
	}

	export type CommitCreateOrConnectWithoutUserInput = {
		where: CommitWhereUniqueInput
		create: XOR<CommitCreateWithoutUserInput, CommitUncheckedCreateWithoutUserInput>
	}

	export type CommitCreateManyUserInputEnvelope = {
		data: Enumerable<CommitCreateManyUserInput>
		skipDuplicates?: boolean
	}

	export type DeploymentCreateWithoutCreatedByInput = {
		id?: string
		createdAt?: Date | string
		status: EnumDeploymentStatus
		message?: string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutDeploymentsInput
		build: BuildCreateNestedOneWithoutDeploymentsInput
		environment: EnvironmentCreateNestedOneWithoutDeploymentsInput
	}

	export type DeploymentUncheckedCreateWithoutCreatedByInput = {
		id?: string
		createdAt?: Date | string
		buildId: string
		environmentId: string
		status: EnumDeploymentStatus
		message?: string | null
		actionId: string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type DeploymentCreateOrConnectWithoutCreatedByInput = {
		where: DeploymentWhereUniqueInput
		create: XOR<DeploymentCreateWithoutCreatedByInput, DeploymentUncheckedCreateWithoutCreatedByInput>
	}

	export type DeploymentCreateManyCreatedByInputEnvelope = {
		data: Enumerable<DeploymentCreateManyCreatedByInput>
		skipDuplicates?: boolean
	}

	export type EntityCreateWithoutLockedByUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		resource: ResourceCreateNestedOneWithoutEntitiesInput
		versions?: EntityVersionCreateNestedManyWithoutEntityInput
	}

	export type EntityUncheckedCreateWithoutLockedByUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		versions?: EntityVersionUncheckedCreateNestedManyWithoutEntityInput
	}

	export type EntityCreateOrConnectWithoutLockedByUserInput = {
		where: EntityWhereUniqueInput
		create: XOR<EntityCreateWithoutLockedByUserInput, EntityUncheckedCreateWithoutLockedByUserInput>
	}

	export type EntityCreateManyLockedByUserInputEnvelope = {
		data: Enumerable<EntityCreateManyLockedByUserInput>
		skipDuplicates?: boolean
	}

	export type UserRoleCreateWithoutUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		role: string
	}

	export type UserRoleUncheckedCreateWithoutUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		role: string
	}

	export type UserRoleCreateOrConnectWithoutUserInput = {
		where: UserRoleWhereUniqueInput
		create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
	}

	export type UserRoleCreateManyUserInputEnvelope = {
		data: Enumerable<UserRoleCreateManyUserInput>
		skipDuplicates?: boolean
	}

	export type InvitationCreateWithoutInvitedByUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
		newUser?: UserCreateNestedOneWithoutCreatedFromInvitationInput
		token: string
		tokenExpiration: Date | string
	}

	export type InvitationUncheckedCreateWithoutInvitedByUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		workspaceId: string
		newUserId?: string | null
		token: string
		tokenExpiration: Date | string
	}

	export type InvitationCreateOrConnectWithoutInvitedByUserInput = {
		where: InvitationWhereUniqueInput
		create: XOR<InvitationCreateWithoutInvitedByUserInput, InvitationUncheckedCreateWithoutInvitedByUserInput>
	}

	export type InvitationCreateManyInvitedByUserInputEnvelope = {
		data: Enumerable<InvitationCreateManyInvitedByUserInput>
		skipDuplicates?: boolean
	}

	export type InvitationCreateWithoutNewUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		invitedByUser: UserCreateNestedOneWithoutSentInvitationsInput
		workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
		token: string
		tokenExpiration: Date | string
	}

	export type InvitationUncheckedCreateWithoutNewUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		invitedByUserId: string
		workspaceId: string
		token: string
		tokenExpiration: Date | string
	}

	export type InvitationCreateOrConnectWithoutNewUserInput = {
		where: InvitationWhereUniqueInput
		create: XOR<InvitationCreateWithoutNewUserInput, InvitationUncheckedCreateWithoutNewUserInput>
	}

	export type AccountUpsertWithoutUsersInput = {
		update: XOR<AccountUpdateWithoutUsersInput, AccountUncheckedUpdateWithoutUsersInput>
		create: XOR<AccountCreateWithoutUsersInput, AccountUncheckedCreateWithoutUsersInput>
	}

	export type AccountUpdateWithoutUsersInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		githubId?: NullableStringFieldUpdateOperationsInput | string | null
		currentUser?: UserUpdateOneWithoutAssignedCurrentToInput
	}

	export type AccountUncheckedUpdateWithoutUsersInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		currentUserId?: NullableStringFieldUpdateOperationsInput | string | null
		githubId?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type WorkspaceUpsertWithoutUsersInput = {
		update: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
		create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
	}

	export type WorkspaceUpdateWithoutUsersInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		invitations?: InvitationUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUpdateManyWithoutWorkspaceInput
		projects?: ProjectUpdateManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedUpdateWithoutUsersInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedUpdateManyWithoutWorkspaceInput
		projects?: ProjectUncheckedUpdateManyWithoutWorkspaceInput
	}

	export type AccountUpsertWithoutCurrentUserInput = {
		update: XOR<AccountUpdateWithoutCurrentUserInput, AccountUncheckedUpdateWithoutCurrentUserInput>
		create: XOR<AccountCreateWithoutCurrentUserInput, AccountUncheckedCreateWithoutCurrentUserInput>
	}

	export type AccountUpdateWithoutCurrentUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		githubId?: NullableStringFieldUpdateOperationsInput | string | null
		users?: UserUpdateManyWithoutAccountInput
	}

	export type AccountUncheckedUpdateWithoutCurrentUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		firstName?: StringFieldUpdateOperationsInput | string
		lastName?: StringFieldUpdateOperationsInput | string
		password?: StringFieldUpdateOperationsInput | string
		githubId?: NullableStringFieldUpdateOperationsInput | string | null
		users?: UserUncheckedUpdateManyWithoutAccountInput
	}

	export type ApiTokenUpsertWithWhereUniqueWithoutUserInput = {
		where: ApiTokenWhereUniqueInput
		update: XOR<ApiTokenUpdateWithoutUserInput, ApiTokenUncheckedUpdateWithoutUserInput>
		create: XOR<ApiTokenCreateWithoutUserInput, ApiTokenUncheckedCreateWithoutUserInput>
	}

	export type ApiTokenUpdateWithWhereUniqueWithoutUserInput = {
		where: ApiTokenWhereUniqueInput
		data: XOR<ApiTokenUpdateWithoutUserInput, ApiTokenUncheckedUpdateWithoutUserInput>
	}

	export type ApiTokenUpdateManyWithWhereWithoutUserInput = {
		where: ApiTokenScalarWhereInput
		data: XOR<ApiTokenUpdateManyMutationInput, ApiTokenUncheckedUpdateManyWithoutApiTokensInput>
	}

	export type ApiTokenScalarWhereInput = {
		AND?: Enumerable<ApiTokenScalarWhereInput>
		OR?: Enumerable<ApiTokenScalarWhereInput>
		NOT?: Enumerable<ApiTokenScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		name?: StringFilter | string
		userId?: StringFilter | string
		token?: StringFilter | string
		previewChars?: StringFilter | string
		lastAccessAt?: DateTimeFilter | Date | string
	}

	export type BlockUpsertWithWhereUniqueWithoutLockedByUserInput = {
		where: BlockWhereUniqueInput
		update: XOR<BlockUpdateWithoutLockedByUserInput, BlockUncheckedUpdateWithoutLockedByUserInput>
		create: XOR<BlockCreateWithoutLockedByUserInput, BlockUncheckedCreateWithoutLockedByUserInput>
	}

	export type BlockUpdateWithWhereUniqueWithoutLockedByUserInput = {
		where: BlockWhereUniqueInput
		data: XOR<BlockUpdateWithoutLockedByUserInput, BlockUncheckedUpdateWithoutLockedByUserInput>
	}

	export type BlockUpdateManyWithWhereWithoutLockedByUserInput = {
		where: BlockScalarWhereInput
		data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutLockedBlocksInput>
	}

	export type BlockScalarWhereInput = {
		AND?: Enumerable<BlockScalarWhereInput>
		OR?: Enumerable<BlockScalarWhereInput>
		NOT?: Enumerable<BlockScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		parentBlockId?: StringNullableFilter | string | null
		blockType?: EnumEnumBlockTypeFilter | EnumBlockType
		displayName?: StringFilter | string
		description?: StringNullableFilter | string | null
		lockedByUserId?: StringNullableFilter | string | null
		lockedAt?: DateTimeNullableFilter | Date | string | null
		deletedAt?: DateTimeNullableFilter | Date | string | null
	}

	export type BuildUpsertWithWhereUniqueWithoutCreatedByInput = {
		where: BuildWhereUniqueInput
		update: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
		create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
	}

	export type BuildUpdateWithWhereUniqueWithoutCreatedByInput = {
		where: BuildWhereUniqueInput
		data: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
	}

	export type BuildUpdateManyWithWhereWithoutCreatedByInput = {
		where: BuildScalarWhereInput
		data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildsInput>
	}

	export type BuildScalarWhereInput = {
		AND?: Enumerable<BuildScalarWhereInput>
		OR?: Enumerable<BuildScalarWhereInput>
		NOT?: Enumerable<BuildScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		userId?: StringFilter | string
		version?: StringFilter | string
		message?: StringNullableFilter | string | null
		actionId?: StringFilter | string
		images?: StringNullableListFilter
		containerStatusQuery?: JsonNullableFilter
		containerStatusUpdatedAt?: DateTimeNullableFilter | Date | string | null
		commitId?: StringNullableFilter | string | null
	}

	export type CommitUpsertWithWhereUniqueWithoutUserInput = {
		where: CommitWhereUniqueInput
		update: XOR<CommitUpdateWithoutUserInput, CommitUncheckedUpdateWithoutUserInput>
		create: XOR<CommitCreateWithoutUserInput, CommitUncheckedCreateWithoutUserInput>
	}

	export type CommitUpdateWithWhereUniqueWithoutUserInput = {
		where: CommitWhereUniqueInput
		data: XOR<CommitUpdateWithoutUserInput, CommitUncheckedUpdateWithoutUserInput>
	}

	export type CommitUpdateManyWithWhereWithoutUserInput = {
		where: CommitScalarWhereInput
		data: XOR<CommitUpdateManyMutationInput, CommitUncheckedUpdateManyWithoutCommitsInput>
	}

	export type DeploymentUpsertWithWhereUniqueWithoutCreatedByInput = {
		where: DeploymentWhereUniqueInput
		update: XOR<DeploymentUpdateWithoutCreatedByInput, DeploymentUncheckedUpdateWithoutCreatedByInput>
		create: XOR<DeploymentCreateWithoutCreatedByInput, DeploymentUncheckedCreateWithoutCreatedByInput>
	}

	export type DeploymentUpdateWithWhereUniqueWithoutCreatedByInput = {
		where: DeploymentWhereUniqueInput
		data: XOR<DeploymentUpdateWithoutCreatedByInput, DeploymentUncheckedUpdateWithoutCreatedByInput>
	}

	export type DeploymentUpdateManyWithWhereWithoutCreatedByInput = {
		where: DeploymentScalarWhereInput
		data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutDeploymentsInput>
	}

	export type DeploymentScalarWhereInput = {
		AND?: Enumerable<DeploymentScalarWhereInput>
		OR?: Enumerable<DeploymentScalarWhereInput>
		NOT?: Enumerable<DeploymentScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		userId?: StringFilter | string
		buildId?: StringFilter | string
		environmentId?: StringFilter | string
		status?: EnumEnumDeploymentStatusFilter | EnumDeploymentStatus
		message?: StringNullableFilter | string | null
		actionId?: StringFilter | string
		statusQuery?: JsonNullableFilter
		statusUpdatedAt?: DateTimeNullableFilter | Date | string | null
	}

	export type EntityUpsertWithWhereUniqueWithoutLockedByUserInput = {
		where: EntityWhereUniqueInput
		update: XOR<EntityUpdateWithoutLockedByUserInput, EntityUncheckedUpdateWithoutLockedByUserInput>
		create: XOR<EntityCreateWithoutLockedByUserInput, EntityUncheckedCreateWithoutLockedByUserInput>
	}

	export type EntityUpdateWithWhereUniqueWithoutLockedByUserInput = {
		where: EntityWhereUniqueInput
		data: XOR<EntityUpdateWithoutLockedByUserInput, EntityUncheckedUpdateWithoutLockedByUserInput>
	}

	export type EntityUpdateManyWithWhereWithoutLockedByUserInput = {
		where: EntityScalarWhereInput
		data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyWithoutLockedEntitisInput>
	}

	export type EntityScalarWhereInput = {
		AND?: Enumerable<EntityScalarWhereInput>
		OR?: Enumerable<EntityScalarWhereInput>
		NOT?: Enumerable<EntityScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		name?: StringFilter | string
		displayName?: StringFilter | string
		pluralDisplayName?: StringFilter | string
		description?: StringNullableFilter | string | null
		lockedByUserId?: StringNullableFilter | string | null
		lockedAt?: DateTimeNullableFilter | Date | string | null
		deletedAt?: DateTimeNullableFilter | Date | string | null
	}

	export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
		where: UserRoleWhereUniqueInput
		update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
		create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
	}

	export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
		where: UserRoleWhereUniqueInput
		data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
	}

	export type UserRoleUpdateManyWithWhereWithoutUserInput = {
		where: UserRoleScalarWhereInput
		data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserRolesInput>
	}

	export type UserRoleScalarWhereInput = {
		AND?: Enumerable<UserRoleScalarWhereInput>
		OR?: Enumerable<UserRoleScalarWhereInput>
		NOT?: Enumerable<UserRoleScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		userId?: StringFilter | string
		role?: StringFilter | string
	}

	export type InvitationUpsertWithWhereUniqueWithoutInvitedByUserInput = {
		where: InvitationWhereUniqueInput
		update: XOR<InvitationUpdateWithoutInvitedByUserInput, InvitationUncheckedUpdateWithoutInvitedByUserInput>
		create: XOR<InvitationCreateWithoutInvitedByUserInput, InvitationUncheckedCreateWithoutInvitedByUserInput>
	}

	export type InvitationUpdateWithWhereUniqueWithoutInvitedByUserInput = {
		where: InvitationWhereUniqueInput
		data: XOR<InvitationUpdateWithoutInvitedByUserInput, InvitationUncheckedUpdateWithoutInvitedByUserInput>
	}

	export type InvitationUpdateManyWithWhereWithoutInvitedByUserInput = {
		where: InvitationScalarWhereInput
		data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutSentInvitationsInput>
	}

	export type InvitationUpsertWithoutNewUserInput = {
		update: XOR<InvitationUpdateWithoutNewUserInput, InvitationUncheckedUpdateWithoutNewUserInput>
		create: XOR<InvitationCreateWithoutNewUserInput, InvitationUncheckedCreateWithoutNewUserInput>
	}

	export type InvitationUpdateWithoutNewUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		invitedByUser?: UserUpdateOneRequiredWithoutSentInvitationsInput
		workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsInput
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type InvitationUncheckedUpdateWithoutNewUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		invitedByUserId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type UserCreateWithoutUserRolesInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutUserRolesInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutUserRolesInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
	}

	export type UserUpsertWithoutUserRolesInput = {
		update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
		create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
	}

	export type UserUpdateWithoutUserRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutUserRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserCreateWithoutApiTokensInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutApiTokensInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutApiTokensInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutApiTokensInput, UserUncheckedCreateWithoutApiTokensInput>
	}

	export type UserUpsertWithoutApiTokensInput = {
		update: XOR<UserUpdateWithoutApiTokensInput, UserUncheckedUpdateWithoutApiTokensInput>
		create: XOR<UserCreateWithoutApiTokensInput, UserUncheckedCreateWithoutApiTokensInput>
	}

	export type UserUpdateWithoutApiTokensInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutApiTokensInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type ResourceRoleCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		description?: string | null
		entityPermissionRoles?: EntityPermissionRoleCreateNestedManyWithoutResourceRoleInput
	}

	export type ResourceRoleUncheckedCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		description?: string | null
		entityPermissionRoles?: EntityPermissionRoleUncheckedCreateNestedManyWithoutResourceRoleInput
	}

	export type ResourceRoleCreateOrConnectWithoutResourceInput = {
		where: ResourceRoleWhereUniqueInput
		create: XOR<ResourceRoleCreateWithoutResourceInput, ResourceRoleUncheckedCreateWithoutResourceInput>
	}

	export type ResourceRoleCreateManyResourceInputEnvelope = {
		data: Enumerable<ResourceRoleCreateManyResourceInput>
		skipDuplicates?: boolean
	}

	export type BlockCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		lockedByUser?: UserCreateNestedOneWithoutLockedBlocksInput
		parentBlock?: BlockCreateNestedOneWithoutBlocksInput
		blocks?: BlockCreateNestedManyWithoutParentBlockInput
		versions?: BlockVersionCreateNestedManyWithoutBlockInput
	}

	export type BlockUncheckedCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		parentBlockId?: string | null
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		blocks?: BlockUncheckedCreateNestedManyWithoutParentBlockInput
		versions?: BlockVersionUncheckedCreateNestedManyWithoutBlockInput
	}

	export type BlockCreateOrConnectWithoutResourceInput = {
		where: BlockWhereUniqueInput
		create: XOR<BlockCreateWithoutResourceInput, BlockUncheckedCreateWithoutResourceInput>
	}

	export type BlockCreateManyResourceInputEnvelope = {
		data: Enumerable<BlockCreateManyResourceInput>
		skipDuplicates?: boolean
	}

	export type BuildCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutBuildsInput
		commit?: CommitCreateNestedOneWithoutBuildsInput
		createdBy: UserCreateNestedOneWithoutBuildsInput
		deployments?: DeploymentCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionCreateNestedManyWithoutBuildsInput
	}

	export type BuildUncheckedCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
		deployments?: DeploymentUncheckedCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutBuildsInput
	}

	export type BuildCreateOrConnectWithoutResourceInput = {
		where: BuildWhereUniqueInput
		create: XOR<BuildCreateWithoutResourceInput, BuildUncheckedCreateWithoutResourceInput>
	}

	export type BuildCreateManyResourceInputEnvelope = {
		data: Enumerable<BuildCreateManyResourceInput>
		skipDuplicates?: boolean
	}

	export type EntityCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		lockedByUser?: UserCreateNestedOneWithoutLockedEntitisInput
		versions?: EntityVersionCreateNestedManyWithoutEntityInput
	}

	export type EntityUncheckedCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		versions?: EntityVersionUncheckedCreateNestedManyWithoutEntityInput
	}

	export type EntityCreateOrConnectWithoutResourceInput = {
		where: EntityWhereUniqueInput
		create: XOR<EntityCreateWithoutResourceInput, EntityUncheckedCreateWithoutResourceInput>
	}

	export type EntityCreateManyResourceInputEnvelope = {
		data: Enumerable<EntityCreateManyResourceInput>
		skipDuplicates?: boolean
	}

	export type EnvironmentCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description?: string | null
		address: string
		deployments?: DeploymentCreateNestedManyWithoutEnvironmentInput
	}

	export type EnvironmentUncheckedCreateWithoutResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description?: string | null
		address: string
		deployments?: DeploymentUncheckedCreateNestedManyWithoutEnvironmentInput
	}

	export type EnvironmentCreateOrConnectWithoutResourceInput = {
		where: EnvironmentWhereUniqueInput
		create: XOR<EnvironmentCreateWithoutResourceInput, EnvironmentUncheckedCreateWithoutResourceInput>
	}

	export type EnvironmentCreateManyResourceInputEnvelope = {
		data: Enumerable<EnvironmentCreateManyResourceInput>
		skipDuplicates?: boolean
	}

	export type GitRepositoryCreateWithoutResourcesInput = {
		id?: string
		name: string
		createdAt?: Date | string
		updatedAt?: Date | string
		gitOrganization: GitOrganizationCreateNestedOneWithoutGitRepositoriesInput
	}

	export type GitRepositoryUncheckedCreateWithoutResourcesInput = {
		id?: string
		name: string
		createdAt?: Date | string
		updatedAt?: Date | string
		gitOrganizationId: string
	}

	export type GitRepositoryCreateOrConnectWithoutResourcesInput = {
		where: GitRepositoryWhereUniqueInput
		create: XOR<GitRepositoryCreateWithoutResourcesInput, GitRepositoryUncheckedCreateWithoutResourcesInput>
	}

	export type ProjectCreateWithoutResourcesInput = {
		id?: string
		name: string
		workspace: WorkspaceCreateNestedOneWithoutProjectsInput
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
		commits?: CommitCreateNestedManyWithoutProjectInput
	}

	export type ProjectUncheckedCreateWithoutResourcesInput = {
		id?: string
		name: string
		workspaceId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
		commits?: CommitUncheckedCreateNestedManyWithoutProjectInput
	}

	export type ProjectCreateOrConnectWithoutResourcesInput = {
		where: ProjectWhereUniqueInput
		create: XOR<ProjectCreateWithoutResourcesInput, ProjectUncheckedCreateWithoutResourcesInput>
	}

	export type ResourceRoleUpsertWithWhereUniqueWithoutResourceInput = {
		where: ResourceRoleWhereUniqueInput
		update: XOR<ResourceRoleUpdateWithoutResourceInput, ResourceRoleUncheckedUpdateWithoutResourceInput>
		create: XOR<ResourceRoleCreateWithoutResourceInput, ResourceRoleUncheckedCreateWithoutResourceInput>
	}

	export type ResourceRoleUpdateWithWhereUniqueWithoutResourceInput = {
		where: ResourceRoleWhereUniqueInput
		data: XOR<ResourceRoleUpdateWithoutResourceInput, ResourceRoleUncheckedUpdateWithoutResourceInput>
	}

	export type ResourceRoleUpdateManyWithWhereWithoutResourceInput = {
		where: ResourceRoleScalarWhereInput
		data: XOR<ResourceRoleUpdateManyMutationInput, ResourceRoleUncheckedUpdateManyWithoutRolesInput>
	}

	export type ResourceRoleScalarWhereInput = {
		AND?: Enumerable<ResourceRoleScalarWhereInput>
		OR?: Enumerable<ResourceRoleScalarWhereInput>
		NOT?: Enumerable<ResourceRoleScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		name?: StringFilter | string
		displayName?: StringFilter | string
		description?: StringNullableFilter | string | null
	}

	export type BlockUpsertWithWhereUniqueWithoutResourceInput = {
		where: BlockWhereUniqueInput
		update: XOR<BlockUpdateWithoutResourceInput, BlockUncheckedUpdateWithoutResourceInput>
		create: XOR<BlockCreateWithoutResourceInput, BlockUncheckedCreateWithoutResourceInput>
	}

	export type BlockUpdateWithWhereUniqueWithoutResourceInput = {
		where: BlockWhereUniqueInput
		data: XOR<BlockUpdateWithoutResourceInput, BlockUncheckedUpdateWithoutResourceInput>
	}

	export type BlockUpdateManyWithWhereWithoutResourceInput = {
		where: BlockScalarWhereInput
		data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlocksInput>
	}

	export type BuildUpsertWithWhereUniqueWithoutResourceInput = {
		where: BuildWhereUniqueInput
		update: XOR<BuildUpdateWithoutResourceInput, BuildUncheckedUpdateWithoutResourceInput>
		create: XOR<BuildCreateWithoutResourceInput, BuildUncheckedCreateWithoutResourceInput>
	}

	export type BuildUpdateWithWhereUniqueWithoutResourceInput = {
		where: BuildWhereUniqueInput
		data: XOR<BuildUpdateWithoutResourceInput, BuildUncheckedUpdateWithoutResourceInput>
	}

	export type BuildUpdateManyWithWhereWithoutResourceInput = {
		where: BuildScalarWhereInput
		data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildsInput>
	}

	export type EntityUpsertWithWhereUniqueWithoutResourceInput = {
		where: EntityWhereUniqueInput
		update: XOR<EntityUpdateWithoutResourceInput, EntityUncheckedUpdateWithoutResourceInput>
		create: XOR<EntityCreateWithoutResourceInput, EntityUncheckedCreateWithoutResourceInput>
	}

	export type EntityUpdateWithWhereUniqueWithoutResourceInput = {
		where: EntityWhereUniqueInput
		data: XOR<EntityUpdateWithoutResourceInput, EntityUncheckedUpdateWithoutResourceInput>
	}

	export type EntityUpdateManyWithWhereWithoutResourceInput = {
		where: EntityScalarWhereInput
		data: XOR<EntityUpdateManyMutationInput, EntityUncheckedUpdateManyWithoutEntitiesInput>
	}

	export type EnvironmentUpsertWithWhereUniqueWithoutResourceInput = {
		where: EnvironmentWhereUniqueInput
		update: XOR<EnvironmentUpdateWithoutResourceInput, EnvironmentUncheckedUpdateWithoutResourceInput>
		create: XOR<EnvironmentCreateWithoutResourceInput, EnvironmentUncheckedCreateWithoutResourceInput>
	}

	export type EnvironmentUpdateWithWhereUniqueWithoutResourceInput = {
		where: EnvironmentWhereUniqueInput
		data: XOR<EnvironmentUpdateWithoutResourceInput, EnvironmentUncheckedUpdateWithoutResourceInput>
	}

	export type EnvironmentUpdateManyWithWhereWithoutResourceInput = {
		where: EnvironmentScalarWhereInput
		data: XOR<EnvironmentUpdateManyMutationInput, EnvironmentUncheckedUpdateManyWithoutEnvironmentsInput>
	}

	export type EnvironmentScalarWhereInput = {
		AND?: Enumerable<EnvironmentScalarWhereInput>
		OR?: Enumerable<EnvironmentScalarWhereInput>
		NOT?: Enumerable<EnvironmentScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		resourceId?: StringFilter | string
		name?: StringFilter | string
		description?: StringNullableFilter | string | null
		address?: StringFilter | string
	}

	export type GitRepositoryUpsertWithoutResourcesInput = {
		update: XOR<GitRepositoryUpdateWithoutResourcesInput, GitRepositoryUncheckedUpdateWithoutResourcesInput>
		create: XOR<GitRepositoryCreateWithoutResourcesInput, GitRepositoryUncheckedCreateWithoutResourcesInput>
	}

	export type GitRepositoryUpdateWithoutResourcesInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		gitOrganization?: GitOrganizationUpdateOneRequiredWithoutGitRepositoriesInput
	}

	export type GitRepositoryUncheckedUpdateWithoutResourcesInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		gitOrganizationId?: StringFieldUpdateOperationsInput | string
	}

	export type ProjectUpsertWithoutResourcesInput = {
		update: XOR<ProjectUpdateWithoutResourcesInput, ProjectUncheckedUpdateWithoutResourcesInput>
		create: XOR<ProjectCreateWithoutResourcesInput, ProjectUncheckedCreateWithoutResourcesInput>
	}

	export type ProjectUpdateWithoutResourcesInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		workspace?: WorkspaceUpdateOneRequiredWithoutProjectsInput
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commits?: CommitUpdateManyWithoutProjectInput
	}

	export type ProjectUncheckedUpdateWithoutResourcesInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commits?: CommitUncheckedUpdateManyWithoutProjectInput
	}

	export type ResourceCreateWithoutRolesInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		blocks?: BlockCreateNestedManyWithoutResourceInput
		builds?: BuildCreateNestedManyWithoutResourceInput
		entities?: EntityCreateNestedManyWithoutResourceInput
		environments?: EnvironmentCreateNestedManyWithoutResourceInput
		gitRepository?: GitRepositoryCreateNestedOneWithoutResourcesInput
		project: ProjectCreateNestedOneWithoutResourcesInput
		resourceType: EnumResourceType
	}

	export type ResourceUncheckedCreateWithoutRolesInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		gitRepositoryId?: string | null
		blocks?: BlockUncheckedCreateNestedManyWithoutResourceInput
		builds?: BuildUncheckedCreateNestedManyWithoutResourceInput
		entities?: EntityUncheckedCreateNestedManyWithoutResourceInput
		environments?: EnvironmentUncheckedCreateNestedManyWithoutResourceInput
		projectId: string
		resourceType: EnumResourceType
	}

	export type ResourceCreateOrConnectWithoutRolesInput = {
		where: ResourceWhereUniqueInput
		create: XOR<ResourceCreateWithoutRolesInput, ResourceUncheckedCreateWithoutRolesInput>
	}

	export type EntityPermissionRoleCreateWithoutResourceRoleInput = {
		id?: string
		permission: EntityPermissionCreateNestedOneWithoutPermissionRolesInput
		permissionFields?: EntityPermissionFieldCreateNestedManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedCreateWithoutResourceRoleInput = {
		id?: string
		entityVersionId: string
		action: EnumEntityAction
		permissionFields?: EntityPermissionFieldUncheckedCreateNestedManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleCreateOrConnectWithoutResourceRoleInput = {
		where: EntityPermissionRoleWhereUniqueInput
		create: XOR<EntityPermissionRoleCreateWithoutResourceRoleInput, EntityPermissionRoleUncheckedCreateWithoutResourceRoleInput>
	}

	export type EntityPermissionRoleCreateManyResourceRoleInputEnvelope = {
		data: Enumerable<EntityPermissionRoleCreateManyResourceRoleInput>
		skipDuplicates?: boolean
	}

	export type ResourceUpsertWithoutRolesInput = {
		update: XOR<ResourceUpdateWithoutRolesInput, ResourceUncheckedUpdateWithoutRolesInput>
		create: XOR<ResourceCreateWithoutRolesInput, ResourceUncheckedCreateWithoutRolesInput>
	}

	export type ResourceUpdateWithoutRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		blocks?: BlockUpdateManyWithoutResourceInput
		builds?: BuildUpdateManyWithoutResourceInput
		entities?: EntityUpdateManyWithoutResourceInput
		environments?: EnvironmentUpdateManyWithoutResourceInput
		gitRepository?: GitRepositoryUpdateOneWithoutResourcesInput
		project?: ProjectUpdateOneRequiredWithoutResourcesInput
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateWithoutRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		gitRepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
		blocks?: BlockUncheckedUpdateManyWithoutResourceInput
		builds?: BuildUncheckedUpdateManyWithoutResourceInput
		entities?: EntityUncheckedUpdateManyWithoutResourceInput
		environments?: EnvironmentUncheckedUpdateManyWithoutResourceInput
		projectId?: StringFieldUpdateOperationsInput | string
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type EntityPermissionRoleUpsertWithWhereUniqueWithoutResourceRoleInput = {
		where: EntityPermissionRoleWhereUniqueInput
		update: XOR<EntityPermissionRoleUpdateWithoutResourceRoleInput, EntityPermissionRoleUncheckedUpdateWithoutResourceRoleInput>
		create: XOR<EntityPermissionRoleCreateWithoutResourceRoleInput, EntityPermissionRoleUncheckedCreateWithoutResourceRoleInput>
	}

	export type EntityPermissionRoleUpdateWithWhereUniqueWithoutResourceRoleInput = {
		where: EntityPermissionRoleWhereUniqueInput
		data: XOR<EntityPermissionRoleUpdateWithoutResourceRoleInput, EntityPermissionRoleUncheckedUpdateWithoutResourceRoleInput>
	}

	export type EntityPermissionRoleUpdateManyWithWhereWithoutResourceRoleInput = {
		where: EntityPermissionRoleScalarWhereInput
		data: XOR<EntityPermissionRoleUpdateManyMutationInput, EntityPermissionRoleUncheckedUpdateManyWithoutEntityPermissionRolesInput>
	}

	export type EntityPermissionRoleScalarWhereInput = {
		AND?: Enumerable<EntityPermissionRoleScalarWhereInput>
		OR?: Enumerable<EntityPermissionRoleScalarWhereInput>
		NOT?: Enumerable<EntityPermissionRoleScalarWhereInput>
		id?: StringFilter | string
		entityVersionId?: StringFilter | string
		action?: EnumEnumEntityActionFilter | EnumEntityAction
		resourceRoleId?: StringFilter | string
	}

	export type UserCreateWithoutCommitsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutCommitsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutCommitsInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutCommitsInput, UserUncheckedCreateWithoutCommitsInput>
	}

	export type BlockVersionCreateWithoutCommitInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		deleted?: boolean | null
		block: BlockCreateNestedOneWithoutVersionsInput
		builds?: BuildCreateNestedManyWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedCreateWithoutCommitInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockId: string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		deleted?: boolean | null
		builds?: BuildUncheckedCreateNestedManyWithoutBlockVersionsInput
	}

	export type BlockVersionCreateOrConnectWithoutCommitInput = {
		where: BlockVersionWhereUniqueInput
		create: XOR<BlockVersionCreateWithoutCommitInput, BlockVersionUncheckedCreateWithoutCommitInput>
	}

	export type BlockVersionCreateManyCommitInputEnvelope = {
		data: Enumerable<BlockVersionCreateManyCommitInput>
		skipDuplicates?: boolean
	}

	export type BuildCreateWithoutCommitInput = {
		id?: string
		createdAt?: Date | string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutBuildsInput
		resource: ResourceCreateNestedOneWithoutBuildsInput
		createdBy: UserCreateNestedOneWithoutBuildsInput
		deployments?: DeploymentCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionCreateNestedManyWithoutBuildsInput
	}

	export type BuildUncheckedCreateWithoutCommitInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		userId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		deployments?: DeploymentUncheckedCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutBuildsInput
	}

	export type BuildCreateOrConnectWithoutCommitInput = {
		where: BuildWhereUniqueInput
		create: XOR<BuildCreateWithoutCommitInput, BuildUncheckedCreateWithoutCommitInput>
	}

	export type BuildCreateManyCommitInputEnvelope = {
		data: Enumerable<BuildCreateManyCommitInput>
		skipDuplicates?: boolean
	}

	export type EntityVersionCreateWithoutCommitInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		deleted?: boolean | null
		entity: EntityCreateNestedOneWithoutVersionsInput
		fields?: EntityFieldCreateNestedManyWithoutEntityVersionInput
		permissions?: EntityPermissionCreateNestedManyWithoutEntityVersionInput
		builds?: BuildCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedCreateWithoutCommitInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityId: string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		deleted?: boolean | null
		fields?: EntityFieldUncheckedCreateNestedManyWithoutEntityVersionInput
		permissions?: EntityPermissionUncheckedCreateNestedManyWithoutEntityVersionInput
		builds?: BuildUncheckedCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionCreateOrConnectWithoutCommitInput = {
		where: EntityVersionWhereUniqueInput
		create: XOR<EntityVersionCreateWithoutCommitInput, EntityVersionUncheckedCreateWithoutCommitInput>
	}

	export type EntityVersionCreateManyCommitInputEnvelope = {
		data: Enumerable<EntityVersionCreateManyCommitInput>
		skipDuplicates?: boolean
	}

	export type ReleaseCreateWithoutCommitInput = {
		id?: string
		createdAt?: Date | string
		version: string
		description?: string | null
	}

	export type ReleaseUncheckedCreateWithoutCommitInput = {
		id?: string
		createdAt?: Date | string
		version: string
		description?: string | null
	}

	export type ReleaseCreateOrConnectWithoutCommitInput = {
		where: ReleaseWhereUniqueInput
		create: XOR<ReleaseCreateWithoutCommitInput, ReleaseUncheckedCreateWithoutCommitInput>
	}

	export type ReleaseCreateManyCommitInputEnvelope = {
		data: Enumerable<ReleaseCreateManyCommitInput>
		skipDuplicates?: boolean
	}

	export type ProjectCreateWithoutCommitsInput = {
		id?: string
		name: string
		workspace: WorkspaceCreateNestedOneWithoutProjectsInput
		resources?: ResourceCreateNestedManyWithoutProjectInput
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
	}

	export type ProjectUncheckedCreateWithoutCommitsInput = {
		id?: string
		name: string
		workspaceId: string
		resources?: ResourceUncheckedCreateNestedManyWithoutProjectInput
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
	}

	export type ProjectCreateOrConnectWithoutCommitsInput = {
		where: ProjectWhereUniqueInput
		create: XOR<ProjectCreateWithoutCommitsInput, ProjectUncheckedCreateWithoutCommitsInput>
	}

	export type UserUpsertWithoutCommitsInput = {
		update: XOR<UserUpdateWithoutCommitsInput, UserUncheckedUpdateWithoutCommitsInput>
		create: XOR<UserCreateWithoutCommitsInput, UserUncheckedCreateWithoutCommitsInput>
	}

	export type UserUpdateWithoutCommitsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutCommitsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type BlockVersionUpsertWithWhereUniqueWithoutCommitInput = {
		where: BlockVersionWhereUniqueInput
		update: XOR<BlockVersionUpdateWithoutCommitInput, BlockVersionUncheckedUpdateWithoutCommitInput>
		create: XOR<BlockVersionCreateWithoutCommitInput, BlockVersionUncheckedCreateWithoutCommitInput>
	}

	export type BlockVersionUpdateWithWhereUniqueWithoutCommitInput = {
		where: BlockVersionWhereUniqueInput
		data: XOR<BlockVersionUpdateWithoutCommitInput, BlockVersionUncheckedUpdateWithoutCommitInput>
	}

	export type BlockVersionUpdateManyWithWhereWithoutCommitInput = {
		where: BlockVersionScalarWhereInput
		data: XOR<BlockVersionUpdateManyMutationInput, BlockVersionUncheckedUpdateManyWithoutBlockVersionsInput>
	}

	export type BlockVersionScalarWhereInput = {
		AND?: Enumerable<BlockVersionScalarWhereInput>
		OR?: Enumerable<BlockVersionScalarWhereInput>
		NOT?: Enumerable<BlockVersionScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		blockId?: StringFilter | string
		versionNumber?: IntFilter | number
		inputParameters?: JsonNullableFilter
		outputParameters?: JsonNullableFilter
		settings?: JsonFilter
		displayName?: StringFilter | string
		description?: StringNullableFilter | string | null
		commitId?: StringNullableFilter | string | null
		deleted?: BoolNullableFilter | boolean | null
	}

	export type BuildUpsertWithWhereUniqueWithoutCommitInput = {
		where: BuildWhereUniqueInput
		update: XOR<BuildUpdateWithoutCommitInput, BuildUncheckedUpdateWithoutCommitInput>
		create: XOR<BuildCreateWithoutCommitInput, BuildUncheckedCreateWithoutCommitInput>
	}

	export type BuildUpdateWithWhereUniqueWithoutCommitInput = {
		where: BuildWhereUniqueInput
		data: XOR<BuildUpdateWithoutCommitInput, BuildUncheckedUpdateWithoutCommitInput>
	}

	export type BuildUpdateManyWithWhereWithoutCommitInput = {
		where: BuildScalarWhereInput
		data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildsInput>
	}

	export type EntityVersionUpsertWithWhereUniqueWithoutCommitInput = {
		where: EntityVersionWhereUniqueInput
		update: XOR<EntityVersionUpdateWithoutCommitInput, EntityVersionUncheckedUpdateWithoutCommitInput>
		create: XOR<EntityVersionCreateWithoutCommitInput, EntityVersionUncheckedCreateWithoutCommitInput>
	}

	export type EntityVersionUpdateWithWhereUniqueWithoutCommitInput = {
		where: EntityVersionWhereUniqueInput
		data: XOR<EntityVersionUpdateWithoutCommitInput, EntityVersionUncheckedUpdateWithoutCommitInput>
	}

	export type EntityVersionUpdateManyWithWhereWithoutCommitInput = {
		where: EntityVersionScalarWhereInput
		data: XOR<EntityVersionUpdateManyMutationInput, EntityVersionUncheckedUpdateManyWithoutEntityVersionsInput>
	}

	export type EntityVersionScalarWhereInput = {
		AND?: Enumerable<EntityVersionScalarWhereInput>
		OR?: Enumerable<EntityVersionScalarWhereInput>
		NOT?: Enumerable<EntityVersionScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		entityId?: StringFilter | string
		versionNumber?: IntFilter | number
		name?: StringFilter | string
		displayName?: StringFilter | string
		pluralDisplayName?: StringFilter | string
		description?: StringNullableFilter | string | null
		commitId?: StringNullableFilter | string | null
		deleted?: BoolNullableFilter | boolean | null
	}

	export type ReleaseUpsertWithWhereUniqueWithoutCommitInput = {
		where: ReleaseWhereUniqueInput
		update: XOR<ReleaseUpdateWithoutCommitInput, ReleaseUncheckedUpdateWithoutCommitInput>
		create: XOR<ReleaseCreateWithoutCommitInput, ReleaseUncheckedCreateWithoutCommitInput>
	}

	export type ReleaseUpdateWithWhereUniqueWithoutCommitInput = {
		where: ReleaseWhereUniqueInput
		data: XOR<ReleaseUpdateWithoutCommitInput, ReleaseUncheckedUpdateWithoutCommitInput>
	}

	export type ReleaseUpdateManyWithWhereWithoutCommitInput = {
		where: ReleaseScalarWhereInput
		data: XOR<ReleaseUpdateManyMutationInput, ReleaseUncheckedUpdateManyWithoutReleasesInput>
	}

	export type ReleaseScalarWhereInput = {
		AND?: Enumerable<ReleaseScalarWhereInput>
		OR?: Enumerable<ReleaseScalarWhereInput>
		NOT?: Enumerable<ReleaseScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		version?: StringFilter | string
		description?: StringNullableFilter | string | null
		commitId?: StringFilter | string
	}

	export type ProjectUpsertWithoutCommitsInput = {
		update: XOR<ProjectUpdateWithoutCommitsInput, ProjectUncheckedUpdateWithoutCommitsInput>
		create: XOR<ProjectCreateWithoutCommitsInput, ProjectUncheckedCreateWithoutCommitsInput>
	}

	export type ProjectUpdateWithoutCommitsInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		workspace?: WorkspaceUpdateOneRequiredWithoutProjectsInput
		resources?: ResourceUpdateManyWithoutProjectInput
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type ProjectUncheckedUpdateWithoutCommitsInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		resources?: ResourceUncheckedUpdateManyWithoutProjectInput
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type ResourceCreateWithoutEntitiesInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		roles?: ResourceRoleCreateNestedManyWithoutResourceInput
		blocks?: BlockCreateNestedManyWithoutResourceInput
		builds?: BuildCreateNestedManyWithoutResourceInput
		environments?: EnvironmentCreateNestedManyWithoutResourceInput
		gitRepository?: GitRepositoryCreateNestedOneWithoutResourcesInput
		project: ProjectCreateNestedOneWithoutResourcesInput
		resourceType: EnumResourceType
	}

	export type ResourceUncheckedCreateWithoutEntitiesInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		gitRepositoryId?: string | null
		roles?: ResourceRoleUncheckedCreateNestedManyWithoutResourceInput
		blocks?: BlockUncheckedCreateNestedManyWithoutResourceInput
		builds?: BuildUncheckedCreateNestedManyWithoutResourceInput
		environments?: EnvironmentUncheckedCreateNestedManyWithoutResourceInput
		projectId: string
		resourceType: EnumResourceType
	}

	export type ResourceCreateOrConnectWithoutEntitiesInput = {
		where: ResourceWhereUniqueInput
		create: XOR<ResourceCreateWithoutEntitiesInput, ResourceUncheckedCreateWithoutEntitiesInput>
	}

	export type UserCreateWithoutLockedEntitisInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutLockedEntitisInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutLockedEntitisInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutLockedEntitisInput, UserUncheckedCreateWithoutLockedEntitisInput>
	}

	export type EntityVersionCreateWithoutEntityInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		deleted?: boolean | null
		commit?: CommitCreateNestedOneWithoutEntityVersionsInput
		fields?: EntityFieldCreateNestedManyWithoutEntityVersionInput
		permissions?: EntityPermissionCreateNestedManyWithoutEntityVersionInput
		builds?: BuildCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedCreateWithoutEntityInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
		fields?: EntityFieldUncheckedCreateNestedManyWithoutEntityVersionInput
		permissions?: EntityPermissionUncheckedCreateNestedManyWithoutEntityVersionInput
		builds?: BuildUncheckedCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionCreateOrConnectWithoutEntityInput = {
		where: EntityVersionWhereUniqueInput
		create: XOR<EntityVersionCreateWithoutEntityInput, EntityVersionUncheckedCreateWithoutEntityInput>
	}

	export type EntityVersionCreateManyEntityInputEnvelope = {
		data: Enumerable<EntityVersionCreateManyEntityInput>
		skipDuplicates?: boolean
	}

	export type ResourceUpsertWithoutEntitiesInput = {
		update: XOR<ResourceUpdateWithoutEntitiesInput, ResourceUncheckedUpdateWithoutEntitiesInput>
		create: XOR<ResourceCreateWithoutEntitiesInput, ResourceUncheckedCreateWithoutEntitiesInput>
	}

	export type ResourceUpdateWithoutEntitiesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		roles?: ResourceRoleUpdateManyWithoutResourceInput
		blocks?: BlockUpdateManyWithoutResourceInput
		builds?: BuildUpdateManyWithoutResourceInput
		environments?: EnvironmentUpdateManyWithoutResourceInput
		gitRepository?: GitRepositoryUpdateOneWithoutResourcesInput
		project?: ProjectUpdateOneRequiredWithoutResourcesInput
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateWithoutEntitiesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		gitRepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
		roles?: ResourceRoleUncheckedUpdateManyWithoutResourceInput
		blocks?: BlockUncheckedUpdateManyWithoutResourceInput
		builds?: BuildUncheckedUpdateManyWithoutResourceInput
		environments?: EnvironmentUncheckedUpdateManyWithoutResourceInput
		projectId?: StringFieldUpdateOperationsInput | string
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type UserUpsertWithoutLockedEntitisInput = {
		update: XOR<UserUpdateWithoutLockedEntitisInput, UserUncheckedUpdateWithoutLockedEntitisInput>
		create: XOR<UserCreateWithoutLockedEntitisInput, UserUncheckedCreateWithoutLockedEntitisInput>
	}

	export type UserUpdateWithoutLockedEntitisInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutLockedEntitisInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type EntityVersionUpsertWithWhereUniqueWithoutEntityInput = {
		where: EntityVersionWhereUniqueInput
		update: XOR<EntityVersionUpdateWithoutEntityInput, EntityVersionUncheckedUpdateWithoutEntityInput>
		create: XOR<EntityVersionCreateWithoutEntityInput, EntityVersionUncheckedCreateWithoutEntityInput>
	}

	export type EntityVersionUpdateWithWhereUniqueWithoutEntityInput = {
		where: EntityVersionWhereUniqueInput
		data: XOR<EntityVersionUpdateWithoutEntityInput, EntityVersionUncheckedUpdateWithoutEntityInput>
	}

	export type EntityVersionUpdateManyWithWhereWithoutEntityInput = {
		where: EntityVersionScalarWhereInput
		data: XOR<EntityVersionUpdateManyMutationInput, EntityVersionUncheckedUpdateManyWithoutVersionsInput>
	}

	export type CommitCreateWithoutEntityVersionsInput = {
		id?: string
		createdAt?: Date | string
		message: string
		user: UserCreateNestedOneWithoutCommitsInput
		blockVersions?: BlockVersionCreateNestedManyWithoutCommitInput
		builds?: BuildCreateNestedManyWithoutCommitInput
		releases?: ReleaseCreateNestedManyWithoutCommitInput
		project: ProjectCreateNestedOneWithoutCommitsInput
	}

	export type CommitUncheckedCreateWithoutEntityVersionsInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		message: string
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutCommitInput
		builds?: BuildUncheckedCreateNestedManyWithoutCommitInput
		releases?: ReleaseUncheckedCreateNestedManyWithoutCommitInput
		projectId: string
	}

	export type CommitCreateOrConnectWithoutEntityVersionsInput = {
		where: CommitWhereUniqueInput
		create: XOR<CommitCreateWithoutEntityVersionsInput, CommitUncheckedCreateWithoutEntityVersionsInput>
	}

	export type EntityCreateWithoutVersionsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		resource: ResourceCreateNestedOneWithoutEntitiesInput
		lockedByUser?: UserCreateNestedOneWithoutLockedEntitisInput
	}

	export type EntityUncheckedCreateWithoutVersionsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
	}

	export type EntityCreateOrConnectWithoutVersionsInput = {
		where: EntityWhereUniqueInput
		create: XOR<EntityCreateWithoutVersionsInput, EntityUncheckedCreateWithoutVersionsInput>
	}

	export type EntityFieldCreateWithoutEntityVersionInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		permanentId?: string
		name: string
		displayName: string
		dataType: EnumDataType
		properties: JsonNullValueInput | InputJsonValue
		required: boolean
		searchable: boolean
		description: string
		position?: number | null
		unique?: boolean
		permissionField?: EntityPermissionFieldCreateNestedManyWithoutFieldInput
	}

	export type EntityFieldUncheckedCreateWithoutEntityVersionInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		permanentId?: string
		name: string
		displayName: string
		dataType: EnumDataType
		properties: JsonNullValueInput | InputJsonValue
		required: boolean
		searchable: boolean
		description: string
		position?: number | null
		unique?: boolean
		permissionField?: EntityPermissionFieldUncheckedCreateNestedManyWithoutFieldInput
	}

	export type EntityFieldCreateOrConnectWithoutEntityVersionInput = {
		where: EntityFieldWhereUniqueInput
		create: XOR<EntityFieldCreateWithoutEntityVersionInput, EntityFieldUncheckedCreateWithoutEntityVersionInput>
	}

	export type EntityFieldCreateManyEntityVersionInputEnvelope = {
		data: Enumerable<EntityFieldCreateManyEntityVersionInput>
		skipDuplicates?: boolean
	}

	export type EntityPermissionCreateWithoutEntityVersionInput = {
		id?: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
		permissionFields?: EntityPermissionFieldCreateNestedManyWithoutPermissionInput
		permissionRoles?: EntityPermissionRoleCreateNestedManyWithoutPermissionInput
	}

	export type EntityPermissionUncheckedCreateWithoutEntityVersionInput = {
		id?: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
		permissionFields?: EntityPermissionFieldUncheckedCreateNestedManyWithoutPermissionInput
		permissionRoles?: EntityPermissionRoleUncheckedCreateNestedManyWithoutPermissionInput
	}

	export type EntityPermissionCreateOrConnectWithoutEntityVersionInput = {
		where: EntityPermissionWhereUniqueInput
		create: XOR<EntityPermissionCreateWithoutEntityVersionInput, EntityPermissionUncheckedCreateWithoutEntityVersionInput>
	}

	export type EntityPermissionCreateManyEntityVersionInputEnvelope = {
		data: Enumerable<EntityPermissionCreateManyEntityVersionInput>
		skipDuplicates?: boolean
	}

	export type BuildCreateWithoutEntityVersionsInput = {
		id?: string
		createdAt?: Date | string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutBuildsInput
		resource: ResourceCreateNestedOneWithoutBuildsInput
		commit?: CommitCreateNestedOneWithoutBuildsInput
		createdBy: UserCreateNestedOneWithoutBuildsInput
		deployments?: DeploymentCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionCreateNestedManyWithoutBuildsInput
	}

	export type BuildUncheckedCreateWithoutEntityVersionsInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		userId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
		deployments?: DeploymentUncheckedCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutBuildsInput
	}

	export type BuildCreateOrConnectWithoutEntityVersionsInput = {
		where: BuildWhereUniqueInput
		create: XOR<BuildCreateWithoutEntityVersionsInput, BuildUncheckedCreateWithoutEntityVersionsInput>
	}

	export type CommitUpsertWithoutEntityVersionsInput = {
		update: XOR<CommitUpdateWithoutEntityVersionsInput, CommitUncheckedUpdateWithoutEntityVersionsInput>
		create: XOR<CommitCreateWithoutEntityVersionsInput, CommitUncheckedCreateWithoutEntityVersionsInput>
	}

	export type CommitUpdateWithoutEntityVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		user?: UserUpdateOneRequiredWithoutCommitsInput
		blockVersions?: BlockVersionUpdateManyWithoutCommitInput
		builds?: BuildUpdateManyWithoutCommitInput
		releases?: ReleaseUpdateManyWithoutCommitInput
		project?: ProjectUpdateOneRequiredWithoutCommitsInput
	}

	export type CommitUncheckedUpdateWithoutEntityVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutCommitInput
		builds?: BuildUncheckedUpdateManyWithoutCommitInput
		releases?: ReleaseUncheckedUpdateManyWithoutCommitInput
		projectId?: StringFieldUpdateOperationsInput | string
	}

	export type EntityUpsertWithoutVersionsInput = {
		update: XOR<EntityUpdateWithoutVersionsInput, EntityUncheckedUpdateWithoutVersionsInput>
		create: XOR<EntityCreateWithoutVersionsInput, EntityUncheckedCreateWithoutVersionsInput>
	}

	export type EntityUpdateWithoutVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resource?: ResourceUpdateOneRequiredWithoutEntitiesInput
		lockedByUser?: UserUpdateOneWithoutLockedEntitisInput
	}

	export type EntityUncheckedUpdateWithoutVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type EntityFieldUpsertWithWhereUniqueWithoutEntityVersionInput = {
		where: EntityFieldWhereUniqueInput
		update: XOR<EntityFieldUpdateWithoutEntityVersionInput, EntityFieldUncheckedUpdateWithoutEntityVersionInput>
		create: XOR<EntityFieldCreateWithoutEntityVersionInput, EntityFieldUncheckedCreateWithoutEntityVersionInput>
	}

	export type EntityFieldUpdateWithWhereUniqueWithoutEntityVersionInput = {
		where: EntityFieldWhereUniqueInput
		data: XOR<EntityFieldUpdateWithoutEntityVersionInput, EntityFieldUncheckedUpdateWithoutEntityVersionInput>
	}

	export type EntityFieldUpdateManyWithWhereWithoutEntityVersionInput = {
		where: EntityFieldScalarWhereInput
		data: XOR<EntityFieldUpdateManyMutationInput, EntityFieldUncheckedUpdateManyWithoutFieldsInput>
	}

	export type EntityFieldScalarWhereInput = {
		AND?: Enumerable<EntityFieldScalarWhereInput>
		OR?: Enumerable<EntityFieldScalarWhereInput>
		NOT?: Enumerable<EntityFieldScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		updatedAt?: DateTimeFilter | Date | string
		entityVersionId?: StringFilter | string
		permanentId?: StringFilter | string
		name?: StringFilter | string
		displayName?: StringFilter | string
		dataType?: EnumEnumDataTypeFilter | EnumDataType
		properties?: JsonFilter
		required?: BoolFilter | boolean
		searchable?: BoolFilter | boolean
		description?: StringFilter | string
		position?: IntNullableFilter | number | null
		unique?: BoolFilter | boolean
	}

	export type EntityPermissionUpsertWithWhereUniqueWithoutEntityVersionInput = {
		where: EntityPermissionWhereUniqueInput
		update: XOR<EntityPermissionUpdateWithoutEntityVersionInput, EntityPermissionUncheckedUpdateWithoutEntityVersionInput>
		create: XOR<EntityPermissionCreateWithoutEntityVersionInput, EntityPermissionUncheckedCreateWithoutEntityVersionInput>
	}

	export type EntityPermissionUpdateWithWhereUniqueWithoutEntityVersionInput = {
		where: EntityPermissionWhereUniqueInput
		data: XOR<EntityPermissionUpdateWithoutEntityVersionInput, EntityPermissionUncheckedUpdateWithoutEntityVersionInput>
	}

	export type EntityPermissionUpdateManyWithWhereWithoutEntityVersionInput = {
		where: EntityPermissionScalarWhereInput
		data: XOR<EntityPermissionUpdateManyMutationInput, EntityPermissionUncheckedUpdateManyWithoutPermissionsInput>
	}

	export type EntityPermissionScalarWhereInput = {
		AND?: Enumerable<EntityPermissionScalarWhereInput>
		OR?: Enumerable<EntityPermissionScalarWhereInput>
		NOT?: Enumerable<EntityPermissionScalarWhereInput>
		id?: StringFilter | string
		entityVersionId?: StringFilter | string
		action?: EnumEnumEntityActionFilter | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFilter | EnumEntityPermissionType
	}

	export type BuildUpsertWithWhereUniqueWithoutEntityVersionsInput = {
		where: BuildWhereUniqueInput
		update: XOR<BuildUpdateWithoutEntityVersionsInput, BuildUncheckedUpdateWithoutEntityVersionsInput>
		create: XOR<BuildCreateWithoutEntityVersionsInput, BuildUncheckedCreateWithoutEntityVersionsInput>
	}

	export type BuildUpdateWithWhereUniqueWithoutEntityVersionsInput = {
		where: BuildWhereUniqueInput
		data: XOR<BuildUpdateWithoutEntityVersionsInput, BuildUncheckedUpdateWithoutEntityVersionsInput>
	}

	export type BuildUpdateManyWithWhereWithoutEntityVersionsInput = {
		where: BuildScalarWhereInput
		data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildsInput>
	}

	export type EntityVersionCreateWithoutPermissionsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		deleted?: boolean | null
		commit?: CommitCreateNestedOneWithoutEntityVersionsInput
		entity: EntityCreateNestedOneWithoutVersionsInput
		fields?: EntityFieldCreateNestedManyWithoutEntityVersionInput
		builds?: BuildCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedCreateWithoutPermissionsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityId: string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
		fields?: EntityFieldUncheckedCreateNestedManyWithoutEntityVersionInput
		builds?: BuildUncheckedCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionCreateOrConnectWithoutPermissionsInput = {
		where: EntityVersionWhereUniqueInput
		create: XOR<EntityVersionCreateWithoutPermissionsInput, EntityVersionUncheckedCreateWithoutPermissionsInput>
	}

	export type EntityPermissionFieldCreateWithoutPermissionInput = {
		id?: string
		field: EntityFieldCreateNestedOneWithoutPermissionFieldInput
		permissionRoles?: EntityPermissionRoleCreateNestedManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedCreateWithoutPermissionInput = {
		id?: string
		fieldPermanentId: string
		entityVersionId: string
		permissionRoles?: EntityPermissionRoleUncheckedCreateNestedManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldCreateOrConnectWithoutPermissionInput = {
		where: EntityPermissionFieldWhereUniqueInput
		create: XOR<EntityPermissionFieldCreateWithoutPermissionInput, EntityPermissionFieldUncheckedCreateWithoutPermissionInput>
	}

	export type EntityPermissionFieldCreateManyPermissionInputEnvelope = {
		data: Enumerable<EntityPermissionFieldCreateManyPermissionInput>
		skipDuplicates?: boolean
	}

	export type EntityPermissionRoleCreateWithoutPermissionInput = {
		id?: string
		resourceRole: ResourceRoleCreateNestedOneWithoutEntityPermissionRolesInput
		permissionFields?: EntityPermissionFieldCreateNestedManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedCreateWithoutPermissionInput = {
		id?: string
		resourceRoleId: string
		permissionFields?: EntityPermissionFieldUncheckedCreateNestedManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleCreateOrConnectWithoutPermissionInput = {
		where: EntityPermissionRoleWhereUniqueInput
		create: XOR<EntityPermissionRoleCreateWithoutPermissionInput, EntityPermissionRoleUncheckedCreateWithoutPermissionInput>
	}

	export type EntityPermissionRoleCreateManyPermissionInputEnvelope = {
		data: Enumerable<EntityPermissionRoleCreateManyPermissionInput>
		skipDuplicates?: boolean
	}

	export type EntityVersionUpsertWithoutPermissionsInput = {
		update: XOR<EntityVersionUpdateWithoutPermissionsInput, EntityVersionUncheckedUpdateWithoutPermissionsInput>
		create: XOR<EntityVersionCreateWithoutPermissionsInput, EntityVersionUncheckedCreateWithoutPermissionsInput>
	}

	export type EntityVersionUpdateWithoutPermissionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		commit?: CommitUpdateOneWithoutEntityVersionsInput
		entity?: EntityUpdateOneRequiredWithoutVersionsInput
		fields?: EntityFieldUpdateManyWithoutEntityVersionInput
		builds?: BuildUpdateManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedUpdateWithoutPermissionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		fields?: EntityFieldUncheckedUpdateManyWithoutEntityVersionInput
		builds?: BuildUncheckedUpdateManyWithoutEntityVersionsInput
	}

	export type EntityPermissionFieldUpsertWithWhereUniqueWithoutPermissionInput = {
		where: EntityPermissionFieldWhereUniqueInput
		update: XOR<EntityPermissionFieldUpdateWithoutPermissionInput, EntityPermissionFieldUncheckedUpdateWithoutPermissionInput>
		create: XOR<EntityPermissionFieldCreateWithoutPermissionInput, EntityPermissionFieldUncheckedCreateWithoutPermissionInput>
	}

	export type EntityPermissionFieldUpdateWithWhereUniqueWithoutPermissionInput = {
		where: EntityPermissionFieldWhereUniqueInput
		data: XOR<EntityPermissionFieldUpdateWithoutPermissionInput, EntityPermissionFieldUncheckedUpdateWithoutPermissionInput>
	}

	export type EntityPermissionFieldUpdateManyWithWhereWithoutPermissionInput = {
		where: EntityPermissionFieldScalarWhereInput
		data: XOR<EntityPermissionFieldUpdateManyMutationInput, EntityPermissionFieldUncheckedUpdateManyWithoutPermissionFieldsInput>
	}

	export type EntityPermissionFieldScalarWhereInput = {
		AND?: Enumerable<EntityPermissionFieldScalarWhereInput>
		OR?: Enumerable<EntityPermissionFieldScalarWhereInput>
		NOT?: Enumerable<EntityPermissionFieldScalarWhereInput>
		id?: StringFilter | string
		permissionId?: StringFilter | string
		fieldPermanentId?: StringFilter | string
		entityVersionId?: StringFilter | string
	}

	export type EntityPermissionRoleUpsertWithWhereUniqueWithoutPermissionInput = {
		where: EntityPermissionRoleWhereUniqueInput
		update: XOR<EntityPermissionRoleUpdateWithoutPermissionInput, EntityPermissionRoleUncheckedUpdateWithoutPermissionInput>
		create: XOR<EntityPermissionRoleCreateWithoutPermissionInput, EntityPermissionRoleUncheckedCreateWithoutPermissionInput>
	}

	export type EntityPermissionRoleUpdateWithWhereUniqueWithoutPermissionInput = {
		where: EntityPermissionRoleWhereUniqueInput
		data: XOR<EntityPermissionRoleUpdateWithoutPermissionInput, EntityPermissionRoleUncheckedUpdateWithoutPermissionInput>
	}

	export type EntityPermissionRoleUpdateManyWithWhereWithoutPermissionInput = {
		where: EntityPermissionRoleScalarWhereInput
		data: XOR<EntityPermissionRoleUpdateManyMutationInput, EntityPermissionRoleUncheckedUpdateManyWithoutPermissionRolesInput>
	}

	export type ResourceRoleCreateWithoutEntityPermissionRolesInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		description?: string | null
		resource: ResourceCreateNestedOneWithoutRolesInput
	}

	export type ResourceRoleUncheckedCreateWithoutEntityPermissionRolesInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		displayName: string
		description?: string | null
	}

	export type ResourceRoleCreateOrConnectWithoutEntityPermissionRolesInput = {
		where: ResourceRoleWhereUniqueInput
		create: XOR<ResourceRoleCreateWithoutEntityPermissionRolesInput, ResourceRoleUncheckedCreateWithoutEntityPermissionRolesInput>
	}

	export type EntityPermissionCreateWithoutPermissionRolesInput = {
		id?: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
		entityVersion: EntityVersionCreateNestedOneWithoutPermissionsInput
		permissionFields?: EntityPermissionFieldCreateNestedManyWithoutPermissionInput
	}

	export type EntityPermissionUncheckedCreateWithoutPermissionRolesInput = {
		id?: string
		entityVersionId: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
		permissionFields?: EntityPermissionFieldUncheckedCreateNestedManyWithoutPermissionInput
	}

	export type EntityPermissionCreateOrConnectWithoutPermissionRolesInput = {
		where: EntityPermissionWhereUniqueInput
		create: XOR<EntityPermissionCreateWithoutPermissionRolesInput, EntityPermissionUncheckedCreateWithoutPermissionRolesInput>
	}

	export type EntityPermissionFieldCreateWithoutPermissionRolesInput = {
		id?: string
		field: EntityFieldCreateNestedOneWithoutPermissionFieldInput
		permission: EntityPermissionCreateNestedOneWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedCreateWithoutPermissionRolesInput = {
		id?: string
		permissionId: string
		fieldPermanentId: string
		entityVersionId: string
	}

	export type EntityPermissionFieldCreateOrConnectWithoutPermissionRolesInput = {
		where: EntityPermissionFieldWhereUniqueInput
		create: XOR<EntityPermissionFieldCreateWithoutPermissionRolesInput, EntityPermissionFieldUncheckedCreateWithoutPermissionRolesInput>
	}

	export type ResourceRoleUpsertWithoutEntityPermissionRolesInput = {
		update: XOR<ResourceRoleUpdateWithoutEntityPermissionRolesInput, ResourceRoleUncheckedUpdateWithoutEntityPermissionRolesInput>
		create: XOR<ResourceRoleCreateWithoutEntityPermissionRolesInput, ResourceRoleUncheckedCreateWithoutEntityPermissionRolesInput>
	}

	export type ResourceRoleUpdateWithoutEntityPermissionRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		resource?: ResourceUpdateOneRequiredWithoutRolesInput
	}

	export type ResourceRoleUncheckedUpdateWithoutEntityPermissionRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type EntityPermissionUpsertWithoutPermissionRolesInput = {
		update: XOR<EntityPermissionUpdateWithoutPermissionRolesInput, EntityPermissionUncheckedUpdateWithoutPermissionRolesInput>
		create: XOR<EntityPermissionCreateWithoutPermissionRolesInput, EntityPermissionUncheckedCreateWithoutPermissionRolesInput>
	}

	export type EntityPermissionUpdateWithoutPermissionRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
		entityVersion?: EntityVersionUpdateOneRequiredWithoutPermissionsInput
		permissionFields?: EntityPermissionFieldUpdateManyWithoutPermissionInput
	}

	export type EntityPermissionUncheckedUpdateWithoutPermissionRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
		permissionFields?: EntityPermissionFieldUncheckedUpdateManyWithoutPermissionInput
	}

	export type EntityPermissionFieldUpsertWithWhereUniqueWithoutPermissionRolesInput = {
		where: EntityPermissionFieldWhereUniqueInput
		update: XOR<EntityPermissionFieldUpdateWithoutPermissionRolesInput, EntityPermissionFieldUncheckedUpdateWithoutPermissionRolesInput>
		create: XOR<EntityPermissionFieldCreateWithoutPermissionRolesInput, EntityPermissionFieldUncheckedCreateWithoutPermissionRolesInput>
	}

	export type EntityPermissionFieldUpdateWithWhereUniqueWithoutPermissionRolesInput = {
		where: EntityPermissionFieldWhereUniqueInput
		data: XOR<EntityPermissionFieldUpdateWithoutPermissionRolesInput, EntityPermissionFieldUncheckedUpdateWithoutPermissionRolesInput>
	}

	export type EntityPermissionFieldUpdateManyWithWhereWithoutPermissionRolesInput = {
		where: EntityPermissionFieldScalarWhereInput
		data: XOR<EntityPermissionFieldUpdateManyMutationInput, EntityPermissionFieldUncheckedUpdateManyWithoutPermissionFieldsInput>
	}

	export type EntityFieldCreateWithoutPermissionFieldInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		permanentId?: string
		name: string
		displayName: string
		dataType: EnumDataType
		properties: JsonNullValueInput | InputJsonValue
		required: boolean
		searchable: boolean
		description: string
		position?: number | null
		unique?: boolean
		entityVersion: EntityVersionCreateNestedOneWithoutFieldsInput
	}

	export type EntityFieldUncheckedCreateWithoutPermissionFieldInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityVersionId: string
		permanentId?: string
		name: string
		displayName: string
		dataType: EnumDataType
		properties: JsonNullValueInput | InputJsonValue
		required: boolean
		searchable: boolean
		description: string
		position?: number | null
		unique?: boolean
	}

	export type EntityFieldCreateOrConnectWithoutPermissionFieldInput = {
		where: EntityFieldWhereUniqueInput
		create: XOR<EntityFieldCreateWithoutPermissionFieldInput, EntityFieldUncheckedCreateWithoutPermissionFieldInput>
	}

	export type EntityPermissionCreateWithoutPermissionFieldsInput = {
		id?: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
		entityVersion: EntityVersionCreateNestedOneWithoutPermissionsInput
		permissionRoles?: EntityPermissionRoleCreateNestedManyWithoutPermissionInput
	}

	export type EntityPermissionUncheckedCreateWithoutPermissionFieldsInput = {
		id?: string
		entityVersionId: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
		permissionRoles?: EntityPermissionRoleUncheckedCreateNestedManyWithoutPermissionInput
	}

	export type EntityPermissionCreateOrConnectWithoutPermissionFieldsInput = {
		where: EntityPermissionWhereUniqueInput
		create: XOR<EntityPermissionCreateWithoutPermissionFieldsInput, EntityPermissionUncheckedCreateWithoutPermissionFieldsInput>
	}

	export type EntityPermissionRoleCreateWithoutPermissionFieldsInput = {
		id?: string
		resourceRole: ResourceRoleCreateNestedOneWithoutEntityPermissionRolesInput
		permission: EntityPermissionCreateNestedOneWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedCreateWithoutPermissionFieldsInput = {
		id?: string
		entityVersionId: string
		action: EnumEntityAction
		resourceRoleId: string
	}

	export type EntityPermissionRoleCreateOrConnectWithoutPermissionFieldsInput = {
		where: EntityPermissionRoleWhereUniqueInput
		create: XOR<EntityPermissionRoleCreateWithoutPermissionFieldsInput, EntityPermissionRoleUncheckedCreateWithoutPermissionFieldsInput>
	}

	export type EntityFieldUpsertWithoutPermissionFieldInput = {
		update: XOR<EntityFieldUpdateWithoutPermissionFieldInput, EntityFieldUncheckedUpdateWithoutPermissionFieldInput>
		create: XOR<EntityFieldCreateWithoutPermissionFieldInput, EntityFieldUncheckedCreateWithoutPermissionFieldInput>
	}

	export type EntityFieldUpdateWithoutPermissionFieldInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		permanentId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		dataType?: EnumEnumDataTypeFieldUpdateOperationsInput | EnumDataType
		properties?: JsonNullValueInput | InputJsonValue
		required?: BoolFieldUpdateOperationsInput | boolean
		searchable?: BoolFieldUpdateOperationsInput | boolean
		description?: StringFieldUpdateOperationsInput | string
		position?: NullableIntFieldUpdateOperationsInput | number | null
		unique?: BoolFieldUpdateOperationsInput | boolean
		entityVersion?: EntityVersionUpdateOneRequiredWithoutFieldsInput
	}

	export type EntityFieldUncheckedUpdateWithoutPermissionFieldInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		permanentId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		dataType?: EnumEnumDataTypeFieldUpdateOperationsInput | EnumDataType
		properties?: JsonNullValueInput | InputJsonValue
		required?: BoolFieldUpdateOperationsInput | boolean
		searchable?: BoolFieldUpdateOperationsInput | boolean
		description?: StringFieldUpdateOperationsInput | string
		position?: NullableIntFieldUpdateOperationsInput | number | null
		unique?: BoolFieldUpdateOperationsInput | boolean
	}

	export type EntityPermissionUpsertWithoutPermissionFieldsInput = {
		update: XOR<EntityPermissionUpdateWithoutPermissionFieldsInput, EntityPermissionUncheckedUpdateWithoutPermissionFieldsInput>
		create: XOR<EntityPermissionCreateWithoutPermissionFieldsInput, EntityPermissionUncheckedCreateWithoutPermissionFieldsInput>
	}

	export type EntityPermissionUpdateWithoutPermissionFieldsInput = {
		id?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
		entityVersion?: EntityVersionUpdateOneRequiredWithoutPermissionsInput
		permissionRoles?: EntityPermissionRoleUpdateManyWithoutPermissionInput
	}

	export type EntityPermissionUncheckedUpdateWithoutPermissionFieldsInput = {
		id?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
		permissionRoles?: EntityPermissionRoleUncheckedUpdateManyWithoutPermissionInput
	}

	export type EntityPermissionRoleUpsertWithWhereUniqueWithoutPermissionFieldsInput = {
		where: EntityPermissionRoleWhereUniqueInput
		update: XOR<EntityPermissionRoleUpdateWithoutPermissionFieldsInput, EntityPermissionRoleUncheckedUpdateWithoutPermissionFieldsInput>
		create: XOR<EntityPermissionRoleCreateWithoutPermissionFieldsInput, EntityPermissionRoleUncheckedCreateWithoutPermissionFieldsInput>
	}

	export type EntityPermissionRoleUpdateWithWhereUniqueWithoutPermissionFieldsInput = {
		where: EntityPermissionRoleWhereUniqueInput
		data: XOR<EntityPermissionRoleUpdateWithoutPermissionFieldsInput, EntityPermissionRoleUncheckedUpdateWithoutPermissionFieldsInput>
	}

	export type EntityPermissionRoleUpdateManyWithWhereWithoutPermissionFieldsInput = {
		where: EntityPermissionRoleScalarWhereInput
		data: XOR<EntityPermissionRoleUpdateManyMutationInput, EntityPermissionRoleUncheckedUpdateManyWithoutPermissionRolesInput>
	}

	export type EntityVersionCreateWithoutFieldsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		deleted?: boolean | null
		commit?: CommitCreateNestedOneWithoutEntityVersionsInput
		entity: EntityCreateNestedOneWithoutVersionsInput
		permissions?: EntityPermissionCreateNestedManyWithoutEntityVersionInput
		builds?: BuildCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedCreateWithoutFieldsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityId: string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
		permissions?: EntityPermissionUncheckedCreateNestedManyWithoutEntityVersionInput
		builds?: BuildUncheckedCreateNestedManyWithoutEntityVersionsInput
	}

	export type EntityVersionCreateOrConnectWithoutFieldsInput = {
		where: EntityVersionWhereUniqueInput
		create: XOR<EntityVersionCreateWithoutFieldsInput, EntityVersionUncheckedCreateWithoutFieldsInput>
	}

	export type EntityPermissionFieldCreateWithoutFieldInput = {
		id?: string
		permission: EntityPermissionCreateNestedOneWithoutPermissionFieldsInput
		permissionRoles?: EntityPermissionRoleCreateNestedManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedCreateWithoutFieldInput = {
		id?: string
		permissionId: string
		permissionRoles?: EntityPermissionRoleUncheckedCreateNestedManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldCreateOrConnectWithoutFieldInput = {
		where: EntityPermissionFieldWhereUniqueInput
		create: XOR<EntityPermissionFieldCreateWithoutFieldInput, EntityPermissionFieldUncheckedCreateWithoutFieldInput>
	}

	export type EntityPermissionFieldCreateManyFieldInputEnvelope = {
		data: Enumerable<EntityPermissionFieldCreateManyFieldInput>
		skipDuplicates?: boolean
	}

	export type EntityVersionUpsertWithoutFieldsInput = {
		update: XOR<EntityVersionUpdateWithoutFieldsInput, EntityVersionUncheckedUpdateWithoutFieldsInput>
		create: XOR<EntityVersionCreateWithoutFieldsInput, EntityVersionUncheckedCreateWithoutFieldsInput>
	}

	export type EntityVersionUpdateWithoutFieldsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		commit?: CommitUpdateOneWithoutEntityVersionsInput
		entity?: EntityUpdateOneRequiredWithoutVersionsInput
		permissions?: EntityPermissionUpdateManyWithoutEntityVersionInput
		builds?: BuildUpdateManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedUpdateWithoutFieldsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		permissions?: EntityPermissionUncheckedUpdateManyWithoutEntityVersionInput
		builds?: BuildUncheckedUpdateManyWithoutEntityVersionsInput
	}

	export type EntityPermissionFieldUpsertWithWhereUniqueWithoutFieldInput = {
		where: EntityPermissionFieldWhereUniqueInput
		update: XOR<EntityPermissionFieldUpdateWithoutFieldInput, EntityPermissionFieldUncheckedUpdateWithoutFieldInput>
		create: XOR<EntityPermissionFieldCreateWithoutFieldInput, EntityPermissionFieldUncheckedCreateWithoutFieldInput>
	}

	export type EntityPermissionFieldUpdateWithWhereUniqueWithoutFieldInput = {
		where: EntityPermissionFieldWhereUniqueInput
		data: XOR<EntityPermissionFieldUpdateWithoutFieldInput, EntityPermissionFieldUncheckedUpdateWithoutFieldInput>
	}

	export type EntityPermissionFieldUpdateManyWithWhereWithoutFieldInput = {
		where: EntityPermissionFieldScalarWhereInput
		data: XOR<EntityPermissionFieldUpdateManyMutationInput, EntityPermissionFieldUncheckedUpdateManyWithoutPermissionFieldInput>
	}

	export type ResourceCreateWithoutBlocksInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		roles?: ResourceRoleCreateNestedManyWithoutResourceInput
		builds?: BuildCreateNestedManyWithoutResourceInput
		entities?: EntityCreateNestedManyWithoutResourceInput
		environments?: EnvironmentCreateNestedManyWithoutResourceInput
		gitRepository?: GitRepositoryCreateNestedOneWithoutResourcesInput
		project: ProjectCreateNestedOneWithoutResourcesInput
		resourceType: EnumResourceType
	}

	export type ResourceUncheckedCreateWithoutBlocksInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		gitRepositoryId?: string | null
		roles?: ResourceRoleUncheckedCreateNestedManyWithoutResourceInput
		builds?: BuildUncheckedCreateNestedManyWithoutResourceInput
		entities?: EntityUncheckedCreateNestedManyWithoutResourceInput
		environments?: EnvironmentUncheckedCreateNestedManyWithoutResourceInput
		projectId: string
		resourceType: EnumResourceType
	}

	export type ResourceCreateOrConnectWithoutBlocksInput = {
		where: ResourceWhereUniqueInput
		create: XOR<ResourceCreateWithoutBlocksInput, ResourceUncheckedCreateWithoutBlocksInput>
	}

	export type UserCreateWithoutLockedBlocksInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutLockedBlocksInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutLockedBlocksInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutLockedBlocksInput, UserUncheckedCreateWithoutLockedBlocksInput>
	}

	export type BlockCreateWithoutBlocksInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		resource: ResourceCreateNestedOneWithoutBlocksInput
		lockedByUser?: UserCreateNestedOneWithoutLockedBlocksInput
		parentBlock?: BlockCreateNestedOneWithoutBlocksInput
		versions?: BlockVersionCreateNestedManyWithoutBlockInput
	}

	export type BlockUncheckedCreateWithoutBlocksInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		parentBlockId?: string | null
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		versions?: BlockVersionUncheckedCreateNestedManyWithoutBlockInput
	}

	export type BlockCreateOrConnectWithoutBlocksInput = {
		where: BlockWhereUniqueInput
		create: XOR<BlockCreateWithoutBlocksInput, BlockUncheckedCreateWithoutBlocksInput>
	}

	export type BlockCreateWithoutParentBlockInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		resource: ResourceCreateNestedOneWithoutBlocksInput
		lockedByUser?: UserCreateNestedOneWithoutLockedBlocksInput
		blocks?: BlockCreateNestedManyWithoutParentBlockInput
		versions?: BlockVersionCreateNestedManyWithoutBlockInput
	}

	export type BlockUncheckedCreateWithoutParentBlockInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		blocks?: BlockUncheckedCreateNestedManyWithoutParentBlockInput
		versions?: BlockVersionUncheckedCreateNestedManyWithoutBlockInput
	}

	export type BlockCreateOrConnectWithoutParentBlockInput = {
		where: BlockWhereUniqueInput
		create: XOR<BlockCreateWithoutParentBlockInput, BlockUncheckedCreateWithoutParentBlockInput>
	}

	export type BlockCreateManyParentBlockInputEnvelope = {
		data: Enumerable<BlockCreateManyParentBlockInput>
		skipDuplicates?: boolean
	}

	export type BlockVersionCreateWithoutBlockInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		deleted?: boolean | null
		commit?: CommitCreateNestedOneWithoutBlockVersionsInput
		builds?: BuildCreateNestedManyWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedCreateWithoutBlockInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
		builds?: BuildUncheckedCreateNestedManyWithoutBlockVersionsInput
	}

	export type BlockVersionCreateOrConnectWithoutBlockInput = {
		where: BlockVersionWhereUniqueInput
		create: XOR<BlockVersionCreateWithoutBlockInput, BlockVersionUncheckedCreateWithoutBlockInput>
	}

	export type BlockVersionCreateManyBlockInputEnvelope = {
		data: Enumerable<BlockVersionCreateManyBlockInput>
		skipDuplicates?: boolean
	}

	export type ResourceUpsertWithoutBlocksInput = {
		update: XOR<ResourceUpdateWithoutBlocksInput, ResourceUncheckedUpdateWithoutBlocksInput>
		create: XOR<ResourceCreateWithoutBlocksInput, ResourceUncheckedCreateWithoutBlocksInput>
	}

	export type ResourceUpdateWithoutBlocksInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		roles?: ResourceRoleUpdateManyWithoutResourceInput
		builds?: BuildUpdateManyWithoutResourceInput
		entities?: EntityUpdateManyWithoutResourceInput
		environments?: EnvironmentUpdateManyWithoutResourceInput
		gitRepository?: GitRepositoryUpdateOneWithoutResourcesInput
		project?: ProjectUpdateOneRequiredWithoutResourcesInput
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateWithoutBlocksInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		gitRepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
		roles?: ResourceRoleUncheckedUpdateManyWithoutResourceInput
		builds?: BuildUncheckedUpdateManyWithoutResourceInput
		entities?: EntityUncheckedUpdateManyWithoutResourceInput
		environments?: EnvironmentUncheckedUpdateManyWithoutResourceInput
		projectId?: StringFieldUpdateOperationsInput | string
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type UserUpsertWithoutLockedBlocksInput = {
		update: XOR<UserUpdateWithoutLockedBlocksInput, UserUncheckedUpdateWithoutLockedBlocksInput>
		create: XOR<UserCreateWithoutLockedBlocksInput, UserUncheckedCreateWithoutLockedBlocksInput>
	}

	export type UserUpdateWithoutLockedBlocksInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutLockedBlocksInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type BlockUpsertWithoutBlocksInput = {
		update: XOR<BlockUpdateWithoutBlocksInput, BlockUncheckedUpdateWithoutBlocksInput>
		create: XOR<BlockCreateWithoutBlocksInput, BlockUncheckedCreateWithoutBlocksInput>
	}

	export type BlockUpdateWithoutBlocksInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resource?: ResourceUpdateOneRequiredWithoutBlocksInput
		lockedByUser?: UserUpdateOneWithoutLockedBlocksInput
		parentBlock?: BlockUpdateOneWithoutBlocksInput
		versions?: BlockVersionUpdateManyWithoutBlockInput
	}

	export type BlockUncheckedUpdateWithoutBlocksInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		parentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		versions?: BlockVersionUncheckedUpdateManyWithoutBlockInput
	}

	export type BlockUpsertWithWhereUniqueWithoutParentBlockInput = {
		where: BlockWhereUniqueInput
		update: XOR<BlockUpdateWithoutParentBlockInput, BlockUncheckedUpdateWithoutParentBlockInput>
		create: XOR<BlockCreateWithoutParentBlockInput, BlockUncheckedCreateWithoutParentBlockInput>
	}

	export type BlockUpdateWithWhereUniqueWithoutParentBlockInput = {
		where: BlockWhereUniqueInput
		data: XOR<BlockUpdateWithoutParentBlockInput, BlockUncheckedUpdateWithoutParentBlockInput>
	}

	export type BlockUpdateManyWithWhereWithoutParentBlockInput = {
		where: BlockScalarWhereInput
		data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlocksInput>
	}

	export type BlockVersionUpsertWithWhereUniqueWithoutBlockInput = {
		where: BlockVersionWhereUniqueInput
		update: XOR<BlockVersionUpdateWithoutBlockInput, BlockVersionUncheckedUpdateWithoutBlockInput>
		create: XOR<BlockVersionCreateWithoutBlockInput, BlockVersionUncheckedCreateWithoutBlockInput>
	}

	export type BlockVersionUpdateWithWhereUniqueWithoutBlockInput = {
		where: BlockVersionWhereUniqueInput
		data: XOR<BlockVersionUpdateWithoutBlockInput, BlockVersionUncheckedUpdateWithoutBlockInput>
	}

	export type BlockVersionUpdateManyWithWhereWithoutBlockInput = {
		where: BlockVersionScalarWhereInput
		data: XOR<BlockVersionUpdateManyMutationInput, BlockVersionUncheckedUpdateManyWithoutVersionsInput>
	}

	export type BlockCreateWithoutVersionsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		resource: ResourceCreateNestedOneWithoutBlocksInput
		lockedByUser?: UserCreateNestedOneWithoutLockedBlocksInput
		parentBlock?: BlockCreateNestedOneWithoutBlocksInput
		blocks?: BlockCreateNestedManyWithoutParentBlockInput
	}

	export type BlockUncheckedCreateWithoutVersionsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		parentBlockId?: string | null
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
		blocks?: BlockUncheckedCreateNestedManyWithoutParentBlockInput
	}

	export type BlockCreateOrConnectWithoutVersionsInput = {
		where: BlockWhereUniqueInput
		create: XOR<BlockCreateWithoutVersionsInput, BlockUncheckedCreateWithoutVersionsInput>
	}

	export type CommitCreateWithoutBlockVersionsInput = {
		id?: string
		createdAt?: Date | string
		message: string
		user: UserCreateNestedOneWithoutCommitsInput
		builds?: BuildCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionCreateNestedManyWithoutCommitInput
		releases?: ReleaseCreateNestedManyWithoutCommitInput
		project: ProjectCreateNestedOneWithoutCommitsInput
	}

	export type CommitUncheckedCreateWithoutBlockVersionsInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		message: string
		builds?: BuildUncheckedCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutCommitInput
		releases?: ReleaseUncheckedCreateNestedManyWithoutCommitInput
		projectId: string
	}

	export type CommitCreateOrConnectWithoutBlockVersionsInput = {
		where: CommitWhereUniqueInput
		create: XOR<CommitCreateWithoutBlockVersionsInput, CommitUncheckedCreateWithoutBlockVersionsInput>
	}

	export type BuildCreateWithoutBlockVersionsInput = {
		id?: string
		createdAt?: Date | string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutBuildsInput
		resource: ResourceCreateNestedOneWithoutBuildsInput
		commit?: CommitCreateNestedOneWithoutBuildsInput
		createdBy: UserCreateNestedOneWithoutBuildsInput
		deployments?: DeploymentCreateNestedManyWithoutBuildInput
		entityVersions?: EntityVersionCreateNestedManyWithoutBuildsInput
	}

	export type BuildUncheckedCreateWithoutBlockVersionsInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		userId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
		deployments?: DeploymentUncheckedCreateNestedManyWithoutBuildInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutBuildsInput
	}

	export type BuildCreateOrConnectWithoutBlockVersionsInput = {
		where: BuildWhereUniqueInput
		create: XOR<BuildCreateWithoutBlockVersionsInput, BuildUncheckedCreateWithoutBlockVersionsInput>
	}

	export type BlockUpsertWithoutVersionsInput = {
		update: XOR<BlockUpdateWithoutVersionsInput, BlockUncheckedUpdateWithoutVersionsInput>
		create: XOR<BlockCreateWithoutVersionsInput, BlockUncheckedCreateWithoutVersionsInput>
	}

	export type BlockUpdateWithoutVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resource?: ResourceUpdateOneRequiredWithoutBlocksInput
		lockedByUser?: UserUpdateOneWithoutLockedBlocksInput
		parentBlock?: BlockUpdateOneWithoutBlocksInput
		blocks?: BlockUpdateManyWithoutParentBlockInput
	}

	export type BlockUncheckedUpdateWithoutVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		parentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		blocks?: BlockUncheckedUpdateManyWithoutParentBlockInput
	}

	export type CommitUpsertWithoutBlockVersionsInput = {
		update: XOR<CommitUpdateWithoutBlockVersionsInput, CommitUncheckedUpdateWithoutBlockVersionsInput>
		create: XOR<CommitCreateWithoutBlockVersionsInput, CommitUncheckedCreateWithoutBlockVersionsInput>
	}

	export type CommitUpdateWithoutBlockVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		user?: UserUpdateOneRequiredWithoutCommitsInput
		builds?: BuildUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUpdateManyWithoutCommitInput
		releases?: ReleaseUpdateManyWithoutCommitInput
		project?: ProjectUpdateOneRequiredWithoutCommitsInput
	}

	export type CommitUncheckedUpdateWithoutBlockVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		builds?: BuildUncheckedUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutCommitInput
		releases?: ReleaseUncheckedUpdateManyWithoutCommitInput
		projectId?: StringFieldUpdateOperationsInput | string
	}

	export type BuildUpsertWithWhereUniqueWithoutBlockVersionsInput = {
		where: BuildWhereUniqueInput
		update: XOR<BuildUpdateWithoutBlockVersionsInput, BuildUncheckedUpdateWithoutBlockVersionsInput>
		create: XOR<BuildCreateWithoutBlockVersionsInput, BuildUncheckedCreateWithoutBlockVersionsInput>
	}

	export type BuildUpdateWithWhereUniqueWithoutBlockVersionsInput = {
		where: BuildWhereUniqueInput
		data: XOR<BuildUpdateWithoutBlockVersionsInput, BuildUncheckedUpdateWithoutBlockVersionsInput>
	}

	export type BuildUpdateManyWithWhereWithoutBlockVersionsInput = {
		where: BuildScalarWhereInput
		data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildsInput>
	}

	export type ActionStepCreateWithoutActionInput = {
		id?: string
		createdAt?: Date | string
		message: string
		status: ActionStepStatus
		completedAt?: Date | string | null
		name?: string
		logs?: ActionLogCreateNestedManyWithoutStepInput
	}

	export type ActionStepUncheckedCreateWithoutActionInput = {
		id?: string
		createdAt?: Date | string
		message: string
		status: ActionStepStatus
		completedAt?: Date | string | null
		name?: string
		logs?: ActionLogUncheckedCreateNestedManyWithoutStepInput
	}

	export type ActionStepCreateOrConnectWithoutActionInput = {
		where: ActionStepWhereUniqueInput
		create: XOR<ActionStepCreateWithoutActionInput, ActionStepUncheckedCreateWithoutActionInput>
	}

	export type ActionStepCreateManyActionInputEnvelope = {
		data: Enumerable<ActionStepCreateManyActionInput>
		skipDuplicates?: boolean
	}

	export type BuildCreateWithoutActionInput = {
		id?: string
		createdAt?: Date | string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		resource: ResourceCreateNestedOneWithoutBuildsInput
		commit?: CommitCreateNestedOneWithoutBuildsInput
		createdBy: UserCreateNestedOneWithoutBuildsInput
		deployments?: DeploymentCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionCreateNestedManyWithoutBuildsInput
	}

	export type BuildUncheckedCreateWithoutActionInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		userId: string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
		deployments?: DeploymentUncheckedCreateNestedManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutBuildsInput
	}

	export type BuildCreateOrConnectWithoutActionInput = {
		where: BuildWhereUniqueInput
		create: XOR<BuildCreateWithoutActionInput, BuildUncheckedCreateWithoutActionInput>
	}

	export type BuildCreateManyActionInputEnvelope = {
		data: Enumerable<BuildCreateManyActionInput>
		skipDuplicates?: boolean
	}

	export type DeploymentCreateWithoutActionInput = {
		id?: string
		createdAt?: Date | string
		status: EnumDeploymentStatus
		message?: string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
		build: BuildCreateNestedOneWithoutDeploymentsInput
		environment: EnvironmentCreateNestedOneWithoutDeploymentsInput
		createdBy: UserCreateNestedOneWithoutDeploymentsInput
	}

	export type DeploymentUncheckedCreateWithoutActionInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		buildId: string
		environmentId: string
		status: EnumDeploymentStatus
		message?: string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type DeploymentCreateOrConnectWithoutActionInput = {
		where: DeploymentWhereUniqueInput
		create: XOR<DeploymentCreateWithoutActionInput, DeploymentUncheckedCreateWithoutActionInput>
	}

	export type DeploymentCreateManyActionInputEnvelope = {
		data: Enumerable<DeploymentCreateManyActionInput>
		skipDuplicates?: boolean
	}

	export type ActionStepUpsertWithWhereUniqueWithoutActionInput = {
		where: ActionStepWhereUniqueInput
		update: XOR<ActionStepUpdateWithoutActionInput, ActionStepUncheckedUpdateWithoutActionInput>
		create: XOR<ActionStepCreateWithoutActionInput, ActionStepUncheckedCreateWithoutActionInput>
	}

	export type ActionStepUpdateWithWhereUniqueWithoutActionInput = {
		where: ActionStepWhereUniqueInput
		data: XOR<ActionStepUpdateWithoutActionInput, ActionStepUncheckedUpdateWithoutActionInput>
	}

	export type ActionStepUpdateManyWithWhereWithoutActionInput = {
		where: ActionStepScalarWhereInput
		data: XOR<ActionStepUpdateManyMutationInput, ActionStepUncheckedUpdateManyWithoutStepsInput>
	}

	export type ActionStepScalarWhereInput = {
		AND?: Enumerable<ActionStepScalarWhereInput>
		OR?: Enumerable<ActionStepScalarWhereInput>
		NOT?: Enumerable<ActionStepScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		message?: StringFilter | string
		status?: EnumActionStepStatusFilter | ActionStepStatus
		completedAt?: DateTimeNullableFilter | Date | string | null
		actionId?: StringFilter | string
		name?: StringFilter | string
	}

	export type BuildUpsertWithWhereUniqueWithoutActionInput = {
		where: BuildWhereUniqueInput
		update: XOR<BuildUpdateWithoutActionInput, BuildUncheckedUpdateWithoutActionInput>
		create: XOR<BuildCreateWithoutActionInput, BuildUncheckedCreateWithoutActionInput>
	}

	export type BuildUpdateWithWhereUniqueWithoutActionInput = {
		where: BuildWhereUniqueInput
		data: XOR<BuildUpdateWithoutActionInput, BuildUncheckedUpdateWithoutActionInput>
	}

	export type BuildUpdateManyWithWhereWithoutActionInput = {
		where: BuildScalarWhereInput
		data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildsInput>
	}

	export type DeploymentUpsertWithWhereUniqueWithoutActionInput = {
		where: DeploymentWhereUniqueInput
		update: XOR<DeploymentUpdateWithoutActionInput, DeploymentUncheckedUpdateWithoutActionInput>
		create: XOR<DeploymentCreateWithoutActionInput, DeploymentUncheckedCreateWithoutActionInput>
	}

	export type DeploymentUpdateWithWhereUniqueWithoutActionInput = {
		where: DeploymentWhereUniqueInput
		data: XOR<DeploymentUpdateWithoutActionInput, DeploymentUncheckedUpdateWithoutActionInput>
	}

	export type DeploymentUpdateManyWithWhereWithoutActionInput = {
		where: DeploymentScalarWhereInput
		data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutDeploymentsInput>
	}

	export type ActionCreateWithoutStepsInput = {
		id?: string
		createdAt?: Date | string
		builds?: BuildCreateNestedManyWithoutActionInput
		deployments?: DeploymentCreateNestedManyWithoutActionInput
	}

	export type ActionUncheckedCreateWithoutStepsInput = {
		id?: string
		createdAt?: Date | string
		builds?: BuildUncheckedCreateNestedManyWithoutActionInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutActionInput
	}

	export type ActionCreateOrConnectWithoutStepsInput = {
		where: ActionWhereUniqueInput
		create: XOR<ActionCreateWithoutStepsInput, ActionUncheckedCreateWithoutStepsInput>
	}

	export type ActionLogCreateWithoutStepInput = {
		id?: string
		createdAt?: Date | string
		message: string
		meta: JsonNullValueInput | InputJsonValue
		level: EnumLogLevel
	}

	export type ActionLogUncheckedCreateWithoutStepInput = {
		id?: string
		createdAt?: Date | string
		message: string
		meta: JsonNullValueInput | InputJsonValue
		level: EnumLogLevel
	}

	export type ActionLogCreateOrConnectWithoutStepInput = {
		where: ActionLogWhereUniqueInput
		create: XOR<ActionLogCreateWithoutStepInput, ActionLogUncheckedCreateWithoutStepInput>
	}

	export type ActionLogCreateManyStepInputEnvelope = {
		data: Enumerable<ActionLogCreateManyStepInput>
		skipDuplicates?: boolean
	}

	export type ActionUpsertWithoutStepsInput = {
		update: XOR<ActionUpdateWithoutStepsInput, ActionUncheckedUpdateWithoutStepsInput>
		create: XOR<ActionCreateWithoutStepsInput, ActionUncheckedCreateWithoutStepsInput>
	}

	export type ActionUpdateWithoutStepsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		builds?: BuildUpdateManyWithoutActionInput
		deployments?: DeploymentUpdateManyWithoutActionInput
	}

	export type ActionUncheckedUpdateWithoutStepsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		builds?: BuildUncheckedUpdateManyWithoutActionInput
		deployments?: DeploymentUncheckedUpdateManyWithoutActionInput
	}

	export type ActionLogUpsertWithWhereUniqueWithoutStepInput = {
		where: ActionLogWhereUniqueInput
		update: XOR<ActionLogUpdateWithoutStepInput, ActionLogUncheckedUpdateWithoutStepInput>
		create: XOR<ActionLogCreateWithoutStepInput, ActionLogUncheckedCreateWithoutStepInput>
	}

	export type ActionLogUpdateWithWhereUniqueWithoutStepInput = {
		where: ActionLogWhereUniqueInput
		data: XOR<ActionLogUpdateWithoutStepInput, ActionLogUncheckedUpdateWithoutStepInput>
	}

	export type ActionLogUpdateManyWithWhereWithoutStepInput = {
		where: ActionLogScalarWhereInput
		data: XOR<ActionLogUpdateManyMutationInput, ActionLogUncheckedUpdateManyWithoutLogsInput>
	}

	export type ActionLogScalarWhereInput = {
		AND?: Enumerable<ActionLogScalarWhereInput>
		OR?: Enumerable<ActionLogScalarWhereInput>
		NOT?: Enumerable<ActionLogScalarWhereInput>
		id?: StringFilter | string
		createdAt?: DateTimeFilter | Date | string
		message?: StringFilter | string
		meta?: JsonFilter
		level?: EnumEnumLogLevelFilter | EnumLogLevel
		stepId?: StringFilter | string
	}

	export type ActionStepCreateWithoutLogsInput = {
		id?: string
		createdAt?: Date | string
		message: string
		status: ActionStepStatus
		completedAt?: Date | string | null
		name?: string
		action: ActionCreateNestedOneWithoutStepsInput
	}

	export type ActionStepUncheckedCreateWithoutLogsInput = {
		id?: string
		createdAt?: Date | string
		message: string
		status: ActionStepStatus
		completedAt?: Date | string | null
		actionId: string
		name?: string
	}

	export type ActionStepCreateOrConnectWithoutLogsInput = {
		where: ActionStepWhereUniqueInput
		create: XOR<ActionStepCreateWithoutLogsInput, ActionStepUncheckedCreateWithoutLogsInput>
	}

	export type ActionStepUpsertWithoutLogsInput = {
		update: XOR<ActionStepUpdateWithoutLogsInput, ActionStepUncheckedUpdateWithoutLogsInput>
		create: XOR<ActionStepCreateWithoutLogsInput, ActionStepUncheckedCreateWithoutLogsInput>
	}

	export type ActionStepUpdateWithoutLogsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		status?: EnumActionStepStatusFieldUpdateOperationsInput | ActionStepStatus
		completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		name?: StringFieldUpdateOperationsInput | string
		action?: ActionUpdateOneRequiredWithoutStepsInput
	}

	export type ActionStepUncheckedUpdateWithoutLogsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		status?: EnumActionStepStatusFieldUpdateOperationsInput | ActionStepStatus
		completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
	}

	export type ActionCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		steps?: ActionStepCreateNestedManyWithoutActionInput
		deployments?: DeploymentCreateNestedManyWithoutActionInput
	}

	export type ActionUncheckedCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		steps?: ActionStepUncheckedCreateNestedManyWithoutActionInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutActionInput
	}

	export type ActionCreateOrConnectWithoutBuildsInput = {
		where: ActionWhereUniqueInput
		create: XOR<ActionCreateWithoutBuildsInput, ActionUncheckedCreateWithoutBuildsInput>
	}

	export type ResourceCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		roles?: ResourceRoleCreateNestedManyWithoutResourceInput
		blocks?: BlockCreateNestedManyWithoutResourceInput
		entities?: EntityCreateNestedManyWithoutResourceInput
		environments?: EnvironmentCreateNestedManyWithoutResourceInput
		gitRepository?: GitRepositoryCreateNestedOneWithoutResourcesInput
		project: ProjectCreateNestedOneWithoutResourcesInput
		resourceType: EnumResourceType
	}

	export type ResourceUncheckedCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		gitRepositoryId?: string | null
		roles?: ResourceRoleUncheckedCreateNestedManyWithoutResourceInput
		blocks?: BlockUncheckedCreateNestedManyWithoutResourceInput
		entities?: EntityUncheckedCreateNestedManyWithoutResourceInput
		environments?: EnvironmentUncheckedCreateNestedManyWithoutResourceInput
		projectId: string
		resourceType: EnumResourceType
	}

	export type ResourceCreateOrConnectWithoutBuildsInput = {
		where: ResourceWhereUniqueInput
		create: XOR<ResourceCreateWithoutBuildsInput, ResourceUncheckedCreateWithoutBuildsInput>
	}

	export type CommitCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		message: string
		user: UserCreateNestedOneWithoutCommitsInput
		blockVersions?: BlockVersionCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionCreateNestedManyWithoutCommitInput
		releases?: ReleaseCreateNestedManyWithoutCommitInput
		project: ProjectCreateNestedOneWithoutCommitsInput
	}

	export type CommitUncheckedCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		message: string
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutCommitInput
		releases?: ReleaseUncheckedCreateNestedManyWithoutCommitInput
		projectId: string
	}

	export type CommitCreateOrConnectWithoutBuildsInput = {
		where: CommitWhereUniqueInput
		create: XOR<CommitCreateWithoutBuildsInput, CommitUncheckedCreateWithoutBuildsInput>
	}

	export type UserCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutBuildsInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutBuildsInput, UserUncheckedCreateWithoutBuildsInput>
	}

	export type DeploymentCreateWithoutBuildInput = {
		id?: string
		createdAt?: Date | string
		status: EnumDeploymentStatus
		message?: string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutDeploymentsInput
		environment: EnvironmentCreateNestedOneWithoutDeploymentsInput
		createdBy: UserCreateNestedOneWithoutDeploymentsInput
	}

	export type DeploymentUncheckedCreateWithoutBuildInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		environmentId: string
		status: EnumDeploymentStatus
		message?: string | null
		actionId: string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type DeploymentCreateOrConnectWithoutBuildInput = {
		where: DeploymentWhereUniqueInput
		create: XOR<DeploymentCreateWithoutBuildInput, DeploymentUncheckedCreateWithoutBuildInput>
	}

	export type DeploymentCreateManyBuildInputEnvelope = {
		data: Enumerable<DeploymentCreateManyBuildInput>
		skipDuplicates?: boolean
	}

	export type BlockVersionCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		deleted?: boolean | null
		block: BlockCreateNestedOneWithoutVersionsInput
		commit?: CommitCreateNestedOneWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockId: string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
	}

	export type BlockVersionCreateOrConnectWithoutBuildsInput = {
		where: BlockVersionWhereUniqueInput
		create: XOR<BlockVersionCreateWithoutBuildsInput, BlockVersionUncheckedCreateWithoutBuildsInput>
	}

	export type EntityVersionCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		deleted?: boolean | null
		commit?: CommitCreateNestedOneWithoutEntityVersionsInput
		entity: EntityCreateNestedOneWithoutVersionsInput
		fields?: EntityFieldCreateNestedManyWithoutEntityVersionInput
		permissions?: EntityPermissionCreateNestedManyWithoutEntityVersionInput
	}

	export type EntityVersionUncheckedCreateWithoutBuildsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityId: string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
		fields?: EntityFieldUncheckedCreateNestedManyWithoutEntityVersionInput
		permissions?: EntityPermissionUncheckedCreateNestedManyWithoutEntityVersionInput
	}

	export type EntityVersionCreateOrConnectWithoutBuildsInput = {
		where: EntityVersionWhereUniqueInput
		create: XOR<EntityVersionCreateWithoutBuildsInput, EntityVersionUncheckedCreateWithoutBuildsInput>
	}

	export type ActionUpsertWithoutBuildsInput = {
		update: XOR<ActionUpdateWithoutBuildsInput, ActionUncheckedUpdateWithoutBuildsInput>
		create: XOR<ActionCreateWithoutBuildsInput, ActionUncheckedCreateWithoutBuildsInput>
	}

	export type ActionUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		steps?: ActionStepUpdateManyWithoutActionInput
		deployments?: DeploymentUpdateManyWithoutActionInput
	}

	export type ActionUncheckedUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		steps?: ActionStepUncheckedUpdateManyWithoutActionInput
		deployments?: DeploymentUncheckedUpdateManyWithoutActionInput
	}

	export type ResourceUpsertWithoutBuildsInput = {
		update: XOR<ResourceUpdateWithoutBuildsInput, ResourceUncheckedUpdateWithoutBuildsInput>
		create: XOR<ResourceCreateWithoutBuildsInput, ResourceUncheckedCreateWithoutBuildsInput>
	}

	export type ResourceUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		roles?: ResourceRoleUpdateManyWithoutResourceInput
		blocks?: BlockUpdateManyWithoutResourceInput
		entities?: EntityUpdateManyWithoutResourceInput
		environments?: EnvironmentUpdateManyWithoutResourceInput
		gitRepository?: GitRepositoryUpdateOneWithoutResourcesInput
		project?: ProjectUpdateOneRequiredWithoutResourcesInput
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		gitRepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
		roles?: ResourceRoleUncheckedUpdateManyWithoutResourceInput
		blocks?: BlockUncheckedUpdateManyWithoutResourceInput
		entities?: EntityUncheckedUpdateManyWithoutResourceInput
		environments?: EnvironmentUncheckedUpdateManyWithoutResourceInput
		projectId?: StringFieldUpdateOperationsInput | string
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type CommitUpsertWithoutBuildsInput = {
		update: XOR<CommitUpdateWithoutBuildsInput, CommitUncheckedUpdateWithoutBuildsInput>
		create: XOR<CommitCreateWithoutBuildsInput, CommitUncheckedCreateWithoutBuildsInput>
	}

	export type CommitUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		user?: UserUpdateOneRequiredWithoutCommitsInput
		blockVersions?: BlockVersionUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUpdateManyWithoutCommitInput
		releases?: ReleaseUpdateManyWithoutCommitInput
		project?: ProjectUpdateOneRequiredWithoutCommitsInput
	}

	export type CommitUncheckedUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutCommitInput
		releases?: ReleaseUncheckedUpdateManyWithoutCommitInput
		projectId?: StringFieldUpdateOperationsInput | string
	}

	export type UserUpsertWithoutBuildsInput = {
		update: XOR<UserUpdateWithoutBuildsInput, UserUncheckedUpdateWithoutBuildsInput>
		create: XOR<UserCreateWithoutBuildsInput, UserUncheckedCreateWithoutBuildsInput>
	}

	export type UserUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type DeploymentUpsertWithWhereUniqueWithoutBuildInput = {
		where: DeploymentWhereUniqueInput
		update: XOR<DeploymentUpdateWithoutBuildInput, DeploymentUncheckedUpdateWithoutBuildInput>
		create: XOR<DeploymentCreateWithoutBuildInput, DeploymentUncheckedCreateWithoutBuildInput>
	}

	export type DeploymentUpdateWithWhereUniqueWithoutBuildInput = {
		where: DeploymentWhereUniqueInput
		data: XOR<DeploymentUpdateWithoutBuildInput, DeploymentUncheckedUpdateWithoutBuildInput>
	}

	export type DeploymentUpdateManyWithWhereWithoutBuildInput = {
		where: DeploymentScalarWhereInput
		data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutDeploymentsInput>
	}

	export type BlockVersionUpsertWithWhereUniqueWithoutBuildsInput = {
		where: BlockVersionWhereUniqueInput
		update: XOR<BlockVersionUpdateWithoutBuildsInput, BlockVersionUncheckedUpdateWithoutBuildsInput>
		create: XOR<BlockVersionCreateWithoutBuildsInput, BlockVersionUncheckedCreateWithoutBuildsInput>
	}

	export type BlockVersionUpdateWithWhereUniqueWithoutBuildsInput = {
		where: BlockVersionWhereUniqueInput
		data: XOR<BlockVersionUpdateWithoutBuildsInput, BlockVersionUncheckedUpdateWithoutBuildsInput>
	}

	export type BlockVersionUpdateManyWithWhereWithoutBuildsInput = {
		where: BlockVersionScalarWhereInput
		data: XOR<BlockVersionUpdateManyMutationInput, BlockVersionUncheckedUpdateManyWithoutBlockVersionsInput>
	}

	export type EntityVersionUpsertWithWhereUniqueWithoutBuildsInput = {
		where: EntityVersionWhereUniqueInput
		update: XOR<EntityVersionUpdateWithoutBuildsInput, EntityVersionUncheckedUpdateWithoutBuildsInput>
		create: XOR<EntityVersionCreateWithoutBuildsInput, EntityVersionUncheckedCreateWithoutBuildsInput>
	}

	export type EntityVersionUpdateWithWhereUniqueWithoutBuildsInput = {
		where: EntityVersionWhereUniqueInput
		data: XOR<EntityVersionUpdateWithoutBuildsInput, EntityVersionUncheckedUpdateWithoutBuildsInput>
	}

	export type EntityVersionUpdateManyWithWhereWithoutBuildsInput = {
		where: EntityVersionScalarWhereInput
		data: XOR<EntityVersionUpdateManyMutationInput, EntityVersionUncheckedUpdateManyWithoutEntityVersionsInput>
	}

	export type CommitCreateWithoutReleasesInput = {
		id?: string
		createdAt?: Date | string
		message: string
		user: UserCreateNestedOneWithoutCommitsInput
		blockVersions?: BlockVersionCreateNestedManyWithoutCommitInput
		builds?: BuildCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionCreateNestedManyWithoutCommitInput
		project: ProjectCreateNestedOneWithoutCommitsInput
	}

	export type CommitUncheckedCreateWithoutReleasesInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		message: string
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutCommitInput
		builds?: BuildUncheckedCreateNestedManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutCommitInput
		projectId: string
	}

	export type CommitCreateOrConnectWithoutReleasesInput = {
		where: CommitWhereUniqueInput
		create: XOR<CommitCreateWithoutReleasesInput, CommitUncheckedCreateWithoutReleasesInput>
	}

	export type CommitUpsertWithoutReleasesInput = {
		update: XOR<CommitUpdateWithoutReleasesInput, CommitUncheckedUpdateWithoutReleasesInput>
		create: XOR<CommitCreateWithoutReleasesInput, CommitUncheckedCreateWithoutReleasesInput>
	}

	export type CommitUpdateWithoutReleasesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		user?: UserUpdateOneRequiredWithoutCommitsInput
		blockVersions?: BlockVersionUpdateManyWithoutCommitInput
		builds?: BuildUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUpdateManyWithoutCommitInput
		project?: ProjectUpdateOneRequiredWithoutCommitsInput
	}

	export type CommitUncheckedUpdateWithoutReleasesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutCommitInput
		builds?: BuildUncheckedUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutCommitInput
		projectId?: StringFieldUpdateOperationsInput | string
	}

	export type ResourceCreateWithoutEnvironmentsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		roles?: ResourceRoleCreateNestedManyWithoutResourceInput
		blocks?: BlockCreateNestedManyWithoutResourceInput
		builds?: BuildCreateNestedManyWithoutResourceInput
		entities?: EntityCreateNestedManyWithoutResourceInput
		gitRepository?: GitRepositoryCreateNestedOneWithoutResourcesInput
		project: ProjectCreateNestedOneWithoutResourcesInput
		resourceType: EnumResourceType
	}

	export type ResourceUncheckedCreateWithoutEnvironmentsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		gitRepositoryId?: string | null
		roles?: ResourceRoleUncheckedCreateNestedManyWithoutResourceInput
		blocks?: BlockUncheckedCreateNestedManyWithoutResourceInput
		builds?: BuildUncheckedCreateNestedManyWithoutResourceInput
		entities?: EntityUncheckedCreateNestedManyWithoutResourceInput
		projectId: string
		resourceType: EnumResourceType
	}

	export type ResourceCreateOrConnectWithoutEnvironmentsInput = {
		where: ResourceWhereUniqueInput
		create: XOR<ResourceCreateWithoutEnvironmentsInput, ResourceUncheckedCreateWithoutEnvironmentsInput>
	}

	export type DeploymentCreateWithoutEnvironmentInput = {
		id?: string
		createdAt?: Date | string
		status: EnumDeploymentStatus
		message?: string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutDeploymentsInput
		build: BuildCreateNestedOneWithoutDeploymentsInput
		createdBy: UserCreateNestedOneWithoutDeploymentsInput
	}

	export type DeploymentUncheckedCreateWithoutEnvironmentInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		buildId: string
		status: EnumDeploymentStatus
		message?: string | null
		actionId: string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type DeploymentCreateOrConnectWithoutEnvironmentInput = {
		where: DeploymentWhereUniqueInput
		create: XOR<DeploymentCreateWithoutEnvironmentInput, DeploymentUncheckedCreateWithoutEnvironmentInput>
	}

	export type DeploymentCreateManyEnvironmentInputEnvelope = {
		data: Enumerable<DeploymentCreateManyEnvironmentInput>
		skipDuplicates?: boolean
	}

	export type ResourceUpsertWithoutEnvironmentsInput = {
		update: XOR<ResourceUpdateWithoutEnvironmentsInput, ResourceUncheckedUpdateWithoutEnvironmentsInput>
		create: XOR<ResourceCreateWithoutEnvironmentsInput, ResourceUncheckedCreateWithoutEnvironmentsInput>
	}

	export type ResourceUpdateWithoutEnvironmentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		roles?: ResourceRoleUpdateManyWithoutResourceInput
		blocks?: BlockUpdateManyWithoutResourceInput
		builds?: BuildUpdateManyWithoutResourceInput
		entities?: EntityUpdateManyWithoutResourceInput
		gitRepository?: GitRepositoryUpdateOneWithoutResourcesInput
		project?: ProjectUpdateOneRequiredWithoutResourcesInput
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateWithoutEnvironmentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		gitRepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
		roles?: ResourceRoleUncheckedUpdateManyWithoutResourceInput
		blocks?: BlockUncheckedUpdateManyWithoutResourceInput
		builds?: BuildUncheckedUpdateManyWithoutResourceInput
		entities?: EntityUncheckedUpdateManyWithoutResourceInput
		projectId?: StringFieldUpdateOperationsInput | string
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type DeploymentUpsertWithWhereUniqueWithoutEnvironmentInput = {
		where: DeploymentWhereUniqueInput
		update: XOR<DeploymentUpdateWithoutEnvironmentInput, DeploymentUncheckedUpdateWithoutEnvironmentInput>
		create: XOR<DeploymentCreateWithoutEnvironmentInput, DeploymentUncheckedCreateWithoutEnvironmentInput>
	}

	export type DeploymentUpdateWithWhereUniqueWithoutEnvironmentInput = {
		where: DeploymentWhereUniqueInput
		data: XOR<DeploymentUpdateWithoutEnvironmentInput, DeploymentUncheckedUpdateWithoutEnvironmentInput>
	}

	export type DeploymentUpdateManyWithWhereWithoutEnvironmentInput = {
		where: DeploymentScalarWhereInput
		data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutDeploymentsInput>
	}

	export type ActionCreateWithoutDeploymentsInput = {
		id?: string
		createdAt?: Date | string
		steps?: ActionStepCreateNestedManyWithoutActionInput
		builds?: BuildCreateNestedManyWithoutActionInput
	}

	export type ActionUncheckedCreateWithoutDeploymentsInput = {
		id?: string
		createdAt?: Date | string
		steps?: ActionStepUncheckedCreateNestedManyWithoutActionInput
		builds?: BuildUncheckedCreateNestedManyWithoutActionInput
	}

	export type ActionCreateOrConnectWithoutDeploymentsInput = {
		where: ActionWhereUniqueInput
		create: XOR<ActionCreateWithoutDeploymentsInput, ActionUncheckedCreateWithoutDeploymentsInput>
	}

	export type BuildCreateWithoutDeploymentsInput = {
		id?: string
		createdAt?: Date | string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		action: ActionCreateNestedOneWithoutBuildsInput
		resource: ResourceCreateNestedOneWithoutBuildsInput
		commit?: CommitCreateNestedOneWithoutBuildsInput
		createdBy: UserCreateNestedOneWithoutBuildsInput
		blockVersions?: BlockVersionCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionCreateNestedManyWithoutBuildsInput
	}

	export type BuildUncheckedCreateWithoutDeploymentsInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		userId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
		blockVersions?: BlockVersionUncheckedCreateNestedManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedCreateNestedManyWithoutBuildsInput
	}

	export type BuildCreateOrConnectWithoutDeploymentsInput = {
		where: BuildWhereUniqueInput
		create: XOR<BuildCreateWithoutDeploymentsInput, BuildUncheckedCreateWithoutDeploymentsInput>
	}

	export type EnvironmentCreateWithoutDeploymentsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description?: string | null
		address: string
		resource: ResourceCreateNestedOneWithoutEnvironmentsInput
	}

	export type EnvironmentUncheckedCreateWithoutDeploymentsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		description?: string | null
		address: string
	}

	export type EnvironmentCreateOrConnectWithoutDeploymentsInput = {
		where: EnvironmentWhereUniqueInput
		create: XOR<EnvironmentCreateWithoutDeploymentsInput, EnvironmentUncheckedCreateWithoutDeploymentsInput>
	}

	export type UserCreateWithoutDeploymentsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutDeploymentsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutDeploymentsInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutDeploymentsInput, UserUncheckedCreateWithoutDeploymentsInput>
	}

	export type ActionUpsertWithoutDeploymentsInput = {
		update: XOR<ActionUpdateWithoutDeploymentsInput, ActionUncheckedUpdateWithoutDeploymentsInput>
		create: XOR<ActionCreateWithoutDeploymentsInput, ActionUncheckedCreateWithoutDeploymentsInput>
	}

	export type ActionUpdateWithoutDeploymentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		steps?: ActionStepUpdateManyWithoutActionInput
		builds?: BuildUpdateManyWithoutActionInput
	}

	export type ActionUncheckedUpdateWithoutDeploymentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		steps?: ActionStepUncheckedUpdateManyWithoutActionInput
		builds?: BuildUncheckedUpdateManyWithoutActionInput
	}

	export type BuildUpsertWithoutDeploymentsInput = {
		update: XOR<BuildUpdateWithoutDeploymentsInput, BuildUncheckedUpdateWithoutDeploymentsInput>
		create: XOR<BuildCreateWithoutDeploymentsInput, BuildUncheckedCreateWithoutDeploymentsInput>
	}

	export type BuildUpdateWithoutDeploymentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutBuildsInput
		resource?: ResourceUpdateOneRequiredWithoutBuildsInput
		commit?: CommitUpdateOneWithoutBuildsInput
		createdBy?: UserUpdateOneRequiredWithoutBuildsInput
		blockVersions?: BlockVersionUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUpdateManyWithoutBuildsInput
	}

	export type BuildUncheckedUpdateWithoutDeploymentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		userId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutBuildsInput
	}

	export type EnvironmentUpsertWithoutDeploymentsInput = {
		update: XOR<EnvironmentUpdateWithoutDeploymentsInput, EnvironmentUncheckedUpdateWithoutDeploymentsInput>
		create: XOR<EnvironmentCreateWithoutDeploymentsInput, EnvironmentUncheckedCreateWithoutDeploymentsInput>
	}

	export type EnvironmentUpdateWithoutDeploymentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		address?: StringFieldUpdateOperationsInput | string
		resource?: ResourceUpdateOneRequiredWithoutEnvironmentsInput
	}

	export type EnvironmentUncheckedUpdateWithoutDeploymentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		address?: StringFieldUpdateOperationsInput | string
	}

	export type UserUpsertWithoutDeploymentsInput = {
		update: XOR<UserUpdateWithoutDeploymentsInput, UserUncheckedUpdateWithoutDeploymentsInput>
		create: XOR<UserCreateWithoutDeploymentsInput, UserUncheckedCreateWithoutDeploymentsInput>
	}

	export type UserUpdateWithoutDeploymentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutDeploymentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserCreateWithoutSentInvitationsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		createdFromInvitation?: InvitationCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutSentInvitationsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		createdFromInvitation?: InvitationUncheckedCreateNestedOneWithoutNewUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutSentInvitationsInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
	}

	export type WorkspaceCreateWithoutInvitationsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedCreateWithoutInvitationsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserUncheckedCreateNestedManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceCreateOrConnectWithoutInvitationsInput = {
		where: WorkspaceWhereUniqueInput
		create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
	}

	export type UserCreateWithoutCreatedFromInvitationInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		isOwner?: boolean
		account: AccountCreateNestedOneWithoutUsersInput
		workspace: WorkspaceCreateNestedOneWithoutUsersInput
		assignedCurrentTo?: AccountCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockCreateNestedManyWithoutLockedByUserInput
		builds?: BuildCreateNestedManyWithoutCreatedByInput
		commits?: CommitCreateNestedManyWithoutUserInput
		deployments?: DeploymentCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationCreateNestedManyWithoutInvitedByUserInput
		deletedAt?: Date | string | null
	}

	export type UserUncheckedCreateWithoutCreatedFromInvitationInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		workspaceId: string
		isOwner?: boolean
		assignedCurrentTo?: AccountUncheckedCreateNestedOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedCreateNestedManyWithoutUserInput
		lockedBlocks?: BlockUncheckedCreateNestedManyWithoutLockedByUserInput
		builds?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
		commits?: CommitUncheckedCreateNestedManyWithoutUserInput
		deployments?: DeploymentUncheckedCreateNestedManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedCreateNestedManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
		sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
		deletedAt?: Date | string | null
	}

	export type UserCreateOrConnectWithoutCreatedFromInvitationInput = {
		where: UserWhereUniqueInput
		create: XOR<UserCreateWithoutCreatedFromInvitationInput, UserUncheckedCreateWithoutCreatedFromInvitationInput>
	}

	export type UserUpsertWithoutSentInvitationsInput = {
		update: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
		create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
	}

	export type UserUpdateWithoutSentInvitationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutSentInvitationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type WorkspaceUpsertWithoutInvitationsInput = {
		update: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
		create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
	}

	export type WorkspaceUpdateWithoutInvitationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUpdateManyWithoutWorkspaceInput
		projects?: ProjectUpdateManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedUpdateWithoutInvitationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUncheckedUpdateManyWithoutWorkspaceInput
		subscriptions?: SubscriptionUncheckedUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedUpdateManyWithoutWorkspaceInput
		projects?: ProjectUncheckedUpdateManyWithoutWorkspaceInput
	}

	export type UserUpsertWithoutCreatedFromInvitationInput = {
		update: XOR<UserUpdateWithoutCreatedFromInvitationInput, UserUncheckedUpdateWithoutCreatedFromInvitationInput>
		create: XOR<UserCreateWithoutCreatedFromInvitationInput, UserUncheckedCreateWithoutCreatedFromInvitationInput>
	}

	export type UserUpdateWithoutCreatedFromInvitationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutCreatedFromInvitationInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type WorkspaceCreateWithoutSubscriptionsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserCreateNestedManyWithoutWorkspaceInput
		invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedCreateWithoutSubscriptionsInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		users?: UserUncheckedCreateNestedManyWithoutWorkspaceInput
		invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedCreateNestedManyWithoutWorkspaceInput
		projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
	}

	export type WorkspaceCreateOrConnectWithoutSubscriptionsInput = {
		where: WorkspaceWhereUniqueInput
		create: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
	}

	export type WorkspaceUpsertWithoutSubscriptionsInput = {
		update: XOR<WorkspaceUpdateWithoutSubscriptionsInput, WorkspaceUncheckedUpdateWithoutSubscriptionsInput>
		create: XOR<WorkspaceCreateWithoutSubscriptionsInput, WorkspaceUncheckedCreateWithoutSubscriptionsInput>
	}

	export type WorkspaceUpdateWithoutSubscriptionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUpdateManyWithoutWorkspaceInput
		invitations?: InvitationUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUpdateManyWithoutWorkspaceInput
		projects?: ProjectUpdateManyWithoutWorkspaceInput
	}

	export type WorkspaceUncheckedUpdateWithoutSubscriptionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		users?: UserUncheckedUpdateManyWithoutWorkspaceInput
		invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceInput
		gitOrganizations?: GitOrganizationUncheckedUpdateManyWithoutWorkspaceInput
		projects?: ProjectUncheckedUpdateManyWithoutWorkspaceInput
	}

	export type UserCreateManyAccountInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		workspaceId: string
		isOwner?: boolean
		deletedAt?: Date | string | null
	}

	export type UserUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutAccountInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateManyWithoutUsersInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserCreateManyWorkspaceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		accountId: string
		isOwner?: boolean
		deletedAt?: Date | string | null
	}

	export type InvitationCreateManyWorkspaceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		invitedByUserId: string
		newUserId?: string | null
		token: string
		tokenExpiration: Date | string
	}

	export type SubscriptionCreateManyWorkspaceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		subscriptionPlan: EnumSubscriptionPlan
		status: EnumSubscriptionStatus
		subscriptionData: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: Date | string | null
	}

	export type GitOrganizationCreateManyWorkspaceInput = {
		id?: string
		provider: EnumGitProvider
		name: string
		installationId: string
		createdAt?: Date | string
		updatedAt?: Date | string
		type?: EnumGitOrganizationType | null
	}

	export type ProjectCreateManyWorkspaceInput = {
		id?: string
		name: string
		createdAt?: Date | string
		updatedAt?: Date | string
		deletedAt?: Date | string | null
	}

	export type UserUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		account?: AccountUpdateOneRequiredWithoutUsersInput
		assignedCurrentTo?: AccountUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUpdateManyWithoutUserInput
		lockedBlocks?: BlockUpdateManyWithoutLockedByUserInput
		builds?: BuildUpdateManyWithoutCreatedByInput
		commits?: CommitUpdateManyWithoutUserInput
		deployments?: DeploymentUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUpdateManyWithoutUserInput
		sentInvitations?: InvitationUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserUncheckedUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		accountId?: StringFieldUpdateOperationsInput | string
		isOwner?: BoolFieldUpdateOperationsInput | boolean
		assignedCurrentTo?: AccountUncheckedUpdateOneWithoutCurrentUserInput
		apiTokens?: ApiTokenUncheckedUpdateManyWithoutUserInput
		lockedBlocks?: BlockUncheckedUpdateManyWithoutLockedByUserInput
		builds?: BuildUncheckedUpdateManyWithoutCreatedByInput
		commits?: CommitUncheckedUpdateManyWithoutUserInput
		deployments?: DeploymentUncheckedUpdateManyWithoutCreatedByInput
		lockedEntitis?: EntityUncheckedUpdateManyWithoutLockedByUserInput
		userRoles?: UserRoleUncheckedUpdateManyWithoutUserInput
		sentInvitations?: InvitationUncheckedUpdateManyWithoutInvitedByUserInput
		createdFromInvitation?: InvitationUncheckedUpdateOneWithoutNewUserInput
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type InvitationUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		invitedByUser?: UserUpdateOneRequiredWithoutSentInvitationsInput
		newUser?: UserUpdateOneWithoutCreatedFromInvitationInput
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type InvitationUncheckedUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		invitedByUserId?: StringFieldUpdateOperationsInput | string
		newUserId?: NullableStringFieldUpdateOperationsInput | string | null
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type InvitationUncheckedUpdateManyWithoutInvitationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		invitedByUserId?: StringFieldUpdateOperationsInput | string
		newUserId?: NullableStringFieldUpdateOperationsInput | string | null
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type SubscriptionUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		subscriptionPlan?: EnumEnumSubscriptionPlanFieldUpdateOperationsInput | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusFieldUpdateOperationsInput | EnumSubscriptionStatus
		subscriptionData?: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type SubscriptionUncheckedUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		subscriptionPlan?: EnumEnumSubscriptionPlanFieldUpdateOperationsInput | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusFieldUpdateOperationsInput | EnumSubscriptionStatus
		subscriptionData?: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		subscriptionPlan?: EnumEnumSubscriptionPlanFieldUpdateOperationsInput | EnumSubscriptionPlan
		status?: EnumEnumSubscriptionStatusFieldUpdateOperationsInput | EnumSubscriptionStatus
		subscriptionData?: JsonNullValueInput | InputJsonValue
		cancellationEffectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type GitOrganizationUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		provider?: EnumEnumGitProviderFieldUpdateOperationsInput | EnumGitProvider
		name?: StringFieldUpdateOperationsInput | string
		installationId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		type?: NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput | EnumGitOrganizationType | null
		gitRepositories?: GitRepositoryUpdateManyWithoutGitOrganizationInput
	}

	export type GitOrganizationUncheckedUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		provider?: EnumEnumGitProviderFieldUpdateOperationsInput | EnumGitProvider
		name?: StringFieldUpdateOperationsInput | string
		installationId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		type?: NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput | EnumGitOrganizationType | null
		gitRepositories?: GitRepositoryUncheckedUpdateManyWithoutGitOrganizationInput
	}

	export type GitOrganizationUncheckedUpdateManyWithoutGitOrganizationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		provider?: EnumEnumGitProviderFieldUpdateOperationsInput | EnumGitProvider
		name?: StringFieldUpdateOperationsInput | string
		installationId?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		type?: NullableEnumEnumGitOrganizationTypeFieldUpdateOperationsInput | EnumGitOrganizationType | null
	}

	export type ProjectUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		resources?: ResourceUpdateManyWithoutProjectInput
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commits?: CommitUpdateManyWithoutProjectInput
	}

	export type ProjectUncheckedUpdateWithoutWorkspaceInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		resources?: ResourceUncheckedUpdateManyWithoutProjectInput
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commits?: CommitUncheckedUpdateManyWithoutProjectInput
	}

	export type ProjectUncheckedUpdateManyWithoutProjectsInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type ResourceCreateManyProjectInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		gitRepositoryId?: string | null
		resourceType: EnumResourceType
	}

	export type CommitCreateManyProjectInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		message: string
	}

	export type ResourceUpdateWithoutProjectInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		roles?: ResourceRoleUpdateManyWithoutResourceInput
		blocks?: BlockUpdateManyWithoutResourceInput
		builds?: BuildUpdateManyWithoutResourceInput
		entities?: EntityUpdateManyWithoutResourceInput
		environments?: EnvironmentUpdateManyWithoutResourceInput
		gitRepository?: GitRepositoryUpdateOneWithoutResourcesInput
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateWithoutProjectInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		gitRepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
		roles?: ResourceRoleUncheckedUpdateManyWithoutResourceInput
		blocks?: BlockUncheckedUpdateManyWithoutResourceInput
		builds?: BuildUncheckedUpdateManyWithoutResourceInput
		entities?: EntityUncheckedUpdateManyWithoutResourceInput
		environments?: EnvironmentUncheckedUpdateManyWithoutResourceInput
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateManyWithoutResourcesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		gitRepositoryId?: NullableStringFieldUpdateOperationsInput | string | null
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type CommitUpdateWithoutProjectInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		user?: UserUpdateOneRequiredWithoutCommitsInput
		blockVersions?: BlockVersionUpdateManyWithoutCommitInput
		builds?: BuildUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUpdateManyWithoutCommitInput
		releases?: ReleaseUpdateManyWithoutCommitInput
	}

	export type CommitUncheckedUpdateWithoutProjectInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutCommitInput
		builds?: BuildUncheckedUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutCommitInput
		releases?: ReleaseUncheckedUpdateManyWithoutCommitInput
	}

	export type CommitUncheckedUpdateManyWithoutCommitsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		message?: StringFieldUpdateOperationsInput | string
	}

	export type GitRepositoryCreateManyGitOrganizationInput = {
		id?: string
		name: string
		createdAt?: Date | string
		updatedAt?: Date | string
	}

	export type GitRepositoryUpdateWithoutGitOrganizationInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resources?: ResourceUpdateManyWithoutGitRepositoryInput
	}

	export type GitRepositoryUncheckedUpdateWithoutGitOrganizationInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resources?: ResourceUncheckedUpdateManyWithoutGitRepositoryInput
	}

	export type GitRepositoryUncheckedUpdateManyWithoutGitRepositoriesInput = {
		id?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ResourceCreateManyGitRepositoryInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description: string
		gitRepositoryOverride?: boolean
		githubLastSync?: Date | string | null
		githubLastMessage?: string | null
		deletedAt?: Date | string | null
		projectId: string
		resourceType: EnumResourceType
	}

	export type ResourceUpdateWithoutGitRepositoryInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		roles?: ResourceRoleUpdateManyWithoutResourceInput
		blocks?: BlockUpdateManyWithoutResourceInput
		builds?: BuildUpdateManyWithoutResourceInput
		entities?: EntityUpdateManyWithoutResourceInput
		environments?: EnvironmentUpdateManyWithoutResourceInput
		project?: ProjectUpdateOneRequiredWithoutResourcesInput
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ResourceUncheckedUpdateWithoutGitRepositoryInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: StringFieldUpdateOperationsInput | string
		gitRepositoryOverride?: BoolFieldUpdateOperationsInput | boolean
		githubLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		githubLastMessage?: NullableStringFieldUpdateOperationsInput | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		roles?: ResourceRoleUncheckedUpdateManyWithoutResourceInput
		blocks?: BlockUncheckedUpdateManyWithoutResourceInput
		builds?: BuildUncheckedUpdateManyWithoutResourceInput
		entities?: EntityUncheckedUpdateManyWithoutResourceInput
		environments?: EnvironmentUncheckedUpdateManyWithoutResourceInput
		projectId?: StringFieldUpdateOperationsInput | string
		resourceType?: EnumEnumResourceTypeFieldUpdateOperationsInput | EnumResourceType
	}

	export type ApiTokenCreateManyUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		token: string
		previewChars: string
		lastAccessAt: Date | string
	}

	export type BlockCreateManyLockedByUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		parentBlockId?: string | null
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
	}

	export type BuildCreateManyCreatedByInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
	}

	export type CommitCreateManyUserInput = {
		id?: string
		createdAt?: Date | string
		message: string
		projectId: string
	}

	export type DeploymentCreateManyCreatedByInput = {
		id?: string
		createdAt?: Date | string
		buildId: string
		environmentId: string
		status: EnumDeploymentStatus
		message?: string | null
		actionId: string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type EntityCreateManyLockedByUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
	}

	export type UserRoleCreateManyUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		role: string
	}

	export type InvitationCreateManyInvitedByUserInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		email: string
		workspaceId: string
		newUserId?: string | null
		token: string
		tokenExpiration: Date | string
	}

	export type ApiTokenUpdateWithoutUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		previewChars?: StringFieldUpdateOperationsInput | string
		lastAccessAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ApiTokenUncheckedUpdateWithoutUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		previewChars?: StringFieldUpdateOperationsInput | string
		lastAccessAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ApiTokenUncheckedUpdateManyWithoutApiTokensInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		token?: StringFieldUpdateOperationsInput | string
		previewChars?: StringFieldUpdateOperationsInput | string
		lastAccessAt?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type BlockUpdateWithoutLockedByUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resource?: ResourceUpdateOneRequiredWithoutBlocksInput
		parentBlock?: BlockUpdateOneWithoutBlocksInput
		blocks?: BlockUpdateManyWithoutParentBlockInput
		versions?: BlockVersionUpdateManyWithoutBlockInput
	}

	export type BlockUncheckedUpdateWithoutLockedByUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		parentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		blocks?: BlockUncheckedUpdateManyWithoutParentBlockInput
		versions?: BlockVersionUncheckedUpdateManyWithoutBlockInput
	}

	export type BlockUncheckedUpdateManyWithoutLockedBlocksInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		parentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type BuildUpdateWithoutCreatedByInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutBuildsInput
		resource?: ResourceUpdateOneRequiredWithoutBuildsInput
		commit?: CommitUpdateOneWithoutBuildsInput
		deployments?: DeploymentUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUpdateManyWithoutBuildsInput
	}

	export type BuildUncheckedUpdateWithoutCreatedByInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deployments?: DeploymentUncheckedUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutBuildsInput
	}

	export type BuildUncheckedUpdateManyWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type CommitUpdateWithoutUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		blockVersions?: BlockVersionUpdateManyWithoutCommitInput
		builds?: BuildUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUpdateManyWithoutCommitInput
		releases?: ReleaseUpdateManyWithoutCommitInput
		project?: ProjectUpdateOneRequiredWithoutCommitsInput
	}

	export type CommitUncheckedUpdateWithoutUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutCommitInput
		builds?: BuildUncheckedUpdateManyWithoutCommitInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutCommitInput
		releases?: ReleaseUncheckedUpdateManyWithoutCommitInput
		projectId?: StringFieldUpdateOperationsInput | string
	}

	export type DeploymentUpdateWithoutCreatedByInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutDeploymentsInput
		build?: BuildUpdateOneRequiredWithoutDeploymentsInput
		environment?: EnvironmentUpdateOneRequiredWithoutDeploymentsInput
	}

	export type DeploymentUncheckedUpdateWithoutCreatedByInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		buildId?: StringFieldUpdateOperationsInput | string
		environmentId?: StringFieldUpdateOperationsInput | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type DeploymentUncheckedUpdateManyWithoutDeploymentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		buildId?: StringFieldUpdateOperationsInput | string
		environmentId?: StringFieldUpdateOperationsInput | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type EntityUpdateWithoutLockedByUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resource?: ResourceUpdateOneRequiredWithoutEntitiesInput
		versions?: EntityVersionUpdateManyWithoutEntityInput
	}

	export type EntityUncheckedUpdateWithoutLockedByUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		versions?: EntityVersionUncheckedUpdateManyWithoutEntityInput
	}

	export type EntityUncheckedUpdateManyWithoutLockedEntitisInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type UserRoleUpdateWithoutUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		role?: StringFieldUpdateOperationsInput | string
	}

	export type UserRoleUncheckedUpdateWithoutUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		role?: StringFieldUpdateOperationsInput | string
	}

	export type UserRoleUncheckedUpdateManyWithoutUserRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		role?: StringFieldUpdateOperationsInput | string
	}

	export type InvitationUpdateWithoutInvitedByUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsInput
		newUser?: UserUpdateOneWithoutCreatedFromInvitationInput
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type InvitationUncheckedUpdateWithoutInvitedByUserInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		newUserId?: NullableStringFieldUpdateOperationsInput | string | null
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type InvitationUncheckedUpdateManyWithoutSentInvitationsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		email?: StringFieldUpdateOperationsInput | string
		workspaceId?: StringFieldUpdateOperationsInput | string
		newUserId?: NullableStringFieldUpdateOperationsInput | string | null
		token?: StringFieldUpdateOperationsInput | string
		tokenExpiration?: DateTimeFieldUpdateOperationsInput | Date | string
	}

	export type ResourceRoleCreateManyResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		description?: string | null
	}

	export type BlockCreateManyResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		parentBlockId?: string | null
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
	}

	export type BuildCreateManyResourceInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
	}

	export type EntityCreateManyResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
	}

	export type EnvironmentCreateManyResourceInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		name: string
		description?: string | null
		address: string
	}

	export type ResourceRoleUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		entityPermissionRoles?: EntityPermissionRoleUpdateManyWithoutResourceRoleInput
	}

	export type ResourceRoleUncheckedUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		entityPermissionRoles?: EntityPermissionRoleUncheckedUpdateManyWithoutResourceRoleInput
	}

	export type ResourceRoleUncheckedUpdateManyWithoutRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type BlockUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		lockedByUser?: UserUpdateOneWithoutLockedBlocksInput
		parentBlock?: BlockUpdateOneWithoutBlocksInput
		blocks?: BlockUpdateManyWithoutParentBlockInput
		versions?: BlockVersionUpdateManyWithoutBlockInput
	}

	export type BlockUncheckedUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		parentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		blocks?: BlockUncheckedUpdateManyWithoutParentBlockInput
		versions?: BlockVersionUncheckedUpdateManyWithoutBlockInput
	}

	export type BlockUncheckedUpdateManyWithoutBlocksInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		parentBlockId?: NullableStringFieldUpdateOperationsInput | string | null
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type BuildUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutBuildsInput
		commit?: CommitUpdateOneWithoutBuildsInput
		createdBy?: UserUpdateOneRequiredWithoutBuildsInput
		deployments?: DeploymentUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUpdateManyWithoutBuildsInput
	}

	export type BuildUncheckedUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deployments?: DeploymentUncheckedUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutBuildsInput
	}

	export type EntityUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		lockedByUser?: UserUpdateOneWithoutLockedEntitisInput
		versions?: EntityVersionUpdateManyWithoutEntityInput
	}

	export type EntityUncheckedUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		versions?: EntityVersionUncheckedUpdateManyWithoutEntityInput
	}

	export type EntityUncheckedUpdateManyWithoutEntitiesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type EnvironmentUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		address?: StringFieldUpdateOperationsInput | string
		deployments?: DeploymentUpdateManyWithoutEnvironmentInput
	}

	export type EnvironmentUncheckedUpdateWithoutResourceInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		address?: StringFieldUpdateOperationsInput | string
		deployments?: DeploymentUncheckedUpdateManyWithoutEnvironmentInput
	}

	export type EnvironmentUncheckedUpdateManyWithoutEnvironmentsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		name?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		address?: StringFieldUpdateOperationsInput | string
	}

	export type EntityPermissionRoleCreateManyResourceRoleInput = {
		id?: string
		entityVersionId: string
		action: EnumEntityAction
	}

	export type EntityPermissionRoleUpdateWithoutResourceRoleInput = {
		id?: StringFieldUpdateOperationsInput | string
		permission?: EntityPermissionUpdateOneRequiredWithoutPermissionRolesInput
		permissionFields?: EntityPermissionFieldUpdateManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedUpdateWithoutResourceRoleInput = {
		id?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		permissionFields?: EntityPermissionFieldUncheckedUpdateManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedUpdateManyWithoutEntityPermissionRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
	}

	export type BlockVersionCreateManyCommitInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		blockId: string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		deleted?: boolean | null
	}

	export type BuildCreateManyCommitInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		userId: string
		version: string
		message?: string | null
		actionId: string
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
	}

	export type EntityVersionCreateManyCommitInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		entityId: string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		deleted?: boolean | null
	}

	export type ReleaseCreateManyCommitInput = {
		id?: string
		createdAt?: Date | string
		version: string
		description?: string | null
	}

	export type BlockVersionUpdateWithoutCommitInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		block?: BlockUpdateOneRequiredWithoutVersionsInput
		builds?: BuildUpdateManyWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedUpdateWithoutCommitInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		builds?: BuildUncheckedUpdateManyWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedUpdateManyWithoutBlockVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
	}

	export type BuildUpdateWithoutCommitInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutBuildsInput
		resource?: ResourceUpdateOneRequiredWithoutBuildsInput
		createdBy?: UserUpdateOneRequiredWithoutBuildsInput
		deployments?: DeploymentUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUpdateManyWithoutBuildsInput
	}

	export type BuildUncheckedUpdateWithoutCommitInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		userId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deployments?: DeploymentUncheckedUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutBuildsInput
	}

	export type EntityVersionUpdateWithoutCommitInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		entity?: EntityUpdateOneRequiredWithoutVersionsInput
		fields?: EntityFieldUpdateManyWithoutEntityVersionInput
		permissions?: EntityPermissionUpdateManyWithoutEntityVersionInput
		builds?: BuildUpdateManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedUpdateWithoutCommitInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		fields?: EntityFieldUncheckedUpdateManyWithoutEntityVersionInput
		permissions?: EntityPermissionUncheckedUpdateManyWithoutEntityVersionInput
		builds?: BuildUncheckedUpdateManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedUpdateManyWithoutEntityVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
	}

	export type ReleaseUpdateWithoutCommitInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type ReleaseUncheckedUpdateWithoutCommitInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type ReleaseUncheckedUpdateManyWithoutReleasesInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
	}

	export type EntityVersionCreateManyEntityInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		name: string
		displayName: string
		pluralDisplayName: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
	}

	export type EntityVersionUpdateWithoutEntityInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		commit?: CommitUpdateOneWithoutEntityVersionsInput
		fields?: EntityFieldUpdateManyWithoutEntityVersionInput
		permissions?: EntityPermissionUpdateManyWithoutEntityVersionInput
		builds?: BuildUpdateManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedUpdateWithoutEntityInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		fields?: EntityFieldUncheckedUpdateManyWithoutEntityVersionInput
		permissions?: EntityPermissionUncheckedUpdateManyWithoutEntityVersionInput
		builds?: BuildUncheckedUpdateManyWithoutEntityVersionsInput
	}

	export type EntityVersionUncheckedUpdateManyWithoutVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
	}

	export type EntityFieldCreateManyEntityVersionInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		permanentId?: string
		name: string
		displayName: string
		dataType: EnumDataType
		properties: JsonNullValueInput | InputJsonValue
		required: boolean
		searchable: boolean
		description: string
		position?: number | null
		unique?: boolean
	}

	export type EntityPermissionCreateManyEntityVersionInput = {
		id?: string
		action: EnumEntityAction
		type: EnumEntityPermissionType
	}

	export type EntityFieldUpdateWithoutEntityVersionInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		permanentId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		dataType?: EnumEnumDataTypeFieldUpdateOperationsInput | EnumDataType
		properties?: JsonNullValueInput | InputJsonValue
		required?: BoolFieldUpdateOperationsInput | boolean
		searchable?: BoolFieldUpdateOperationsInput | boolean
		description?: StringFieldUpdateOperationsInput | string
		position?: NullableIntFieldUpdateOperationsInput | number | null
		unique?: BoolFieldUpdateOperationsInput | boolean
		permissionField?: EntityPermissionFieldUpdateManyWithoutFieldInput
	}

	export type EntityFieldUncheckedUpdateWithoutEntityVersionInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		permanentId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		dataType?: EnumEnumDataTypeFieldUpdateOperationsInput | EnumDataType
		properties?: JsonNullValueInput | InputJsonValue
		required?: BoolFieldUpdateOperationsInput | boolean
		searchable?: BoolFieldUpdateOperationsInput | boolean
		description?: StringFieldUpdateOperationsInput | string
		position?: NullableIntFieldUpdateOperationsInput | number | null
		unique?: BoolFieldUpdateOperationsInput | boolean
		permissionField?: EntityPermissionFieldUncheckedUpdateManyWithoutFieldInput
	}

	export type EntityFieldUncheckedUpdateManyWithoutFieldsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		permanentId?: StringFieldUpdateOperationsInput | string
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		dataType?: EnumEnumDataTypeFieldUpdateOperationsInput | EnumDataType
		properties?: JsonNullValueInput | InputJsonValue
		required?: BoolFieldUpdateOperationsInput | boolean
		searchable?: BoolFieldUpdateOperationsInput | boolean
		description?: StringFieldUpdateOperationsInput | string
		position?: NullableIntFieldUpdateOperationsInput | number | null
		unique?: BoolFieldUpdateOperationsInput | boolean
	}

	export type EntityPermissionUpdateWithoutEntityVersionInput = {
		id?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
		permissionFields?: EntityPermissionFieldUpdateManyWithoutPermissionInput
		permissionRoles?: EntityPermissionRoleUpdateManyWithoutPermissionInput
	}

	export type EntityPermissionUncheckedUpdateWithoutEntityVersionInput = {
		id?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
		permissionFields?: EntityPermissionFieldUncheckedUpdateManyWithoutPermissionInput
		permissionRoles?: EntityPermissionRoleUncheckedUpdateManyWithoutPermissionInput
	}

	export type EntityPermissionUncheckedUpdateManyWithoutPermissionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		type?: EnumEnumEntityPermissionTypeFieldUpdateOperationsInput | EnumEntityPermissionType
	}

	export type BuildUpdateWithoutEntityVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutBuildsInput
		resource?: ResourceUpdateOneRequiredWithoutBuildsInput
		commit?: CommitUpdateOneWithoutBuildsInput
		createdBy?: UserUpdateOneRequiredWithoutBuildsInput
		deployments?: DeploymentUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUpdateManyWithoutBuildsInput
	}

	export type BuildUncheckedUpdateWithoutEntityVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		userId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deployments?: DeploymentUncheckedUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutBuildsInput
	}

	export type EntityPermissionFieldCreateManyPermissionInput = {
		id?: string
		fieldPermanentId: string
		entityVersionId: string
	}

	export type EntityPermissionRoleCreateManyPermissionInput = {
		id?: string
		resourceRoleId: string
	}

	export type EntityPermissionFieldUpdateWithoutPermissionInput = {
		id?: StringFieldUpdateOperationsInput | string
		field?: EntityFieldUpdateOneRequiredWithoutPermissionFieldInput
		permissionRoles?: EntityPermissionRoleUpdateManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedUpdateWithoutPermissionInput = {
		id?: StringFieldUpdateOperationsInput | string
		fieldPermanentId?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		permissionRoles?: EntityPermissionRoleUncheckedUpdateManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedUpdateManyWithoutPermissionFieldsInput = {
		id?: StringFieldUpdateOperationsInput | string
		fieldPermanentId?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
	}

	export type EntityPermissionRoleUpdateWithoutPermissionInput = {
		id?: StringFieldUpdateOperationsInput | string
		resourceRole?: ResourceRoleUpdateOneRequiredWithoutEntityPermissionRolesInput
		permissionFields?: EntityPermissionFieldUpdateManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedUpdateWithoutPermissionInput = {
		id?: StringFieldUpdateOperationsInput | string
		resourceRoleId?: StringFieldUpdateOperationsInput | string
		permissionFields?: EntityPermissionFieldUncheckedUpdateManyWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedUpdateManyWithoutPermissionRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		resourceRoleId?: StringFieldUpdateOperationsInput | string
	}

	export type EntityPermissionFieldUpdateWithoutPermissionRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		field?: EntityFieldUpdateOneRequiredWithoutPermissionFieldInput
		permission?: EntityPermissionUpdateOneRequiredWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedUpdateWithoutPermissionRolesInput = {
		id?: StringFieldUpdateOperationsInput | string
		permissionId?: StringFieldUpdateOperationsInput | string
		fieldPermanentId?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
	}

	export type EntityPermissionRoleUpdateWithoutPermissionFieldsInput = {
		id?: StringFieldUpdateOperationsInput | string
		resourceRole?: ResourceRoleUpdateOneRequiredWithoutEntityPermissionRolesInput
		permission?: EntityPermissionUpdateOneRequiredWithoutPermissionRolesInput
	}

	export type EntityPermissionRoleUncheckedUpdateWithoutPermissionFieldsInput = {
		id?: StringFieldUpdateOperationsInput | string
		entityVersionId?: StringFieldUpdateOperationsInput | string
		action?: EnumEnumEntityActionFieldUpdateOperationsInput | EnumEntityAction
		resourceRoleId?: StringFieldUpdateOperationsInput | string
	}

	export type EntityPermissionFieldCreateManyFieldInput = {
		id?: string
		permissionId: string
	}

	export type EntityPermissionFieldUpdateWithoutFieldInput = {
		id?: StringFieldUpdateOperationsInput | string
		permission?: EntityPermissionUpdateOneRequiredWithoutPermissionFieldsInput
		permissionRoles?: EntityPermissionRoleUpdateManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedUpdateWithoutFieldInput = {
		id?: StringFieldUpdateOperationsInput | string
		permissionId?: StringFieldUpdateOperationsInput | string
		permissionRoles?: EntityPermissionRoleUncheckedUpdateManyWithoutPermissionFieldsInput
	}

	export type EntityPermissionFieldUncheckedUpdateManyWithoutPermissionFieldInput = {
		id?: StringFieldUpdateOperationsInput | string
		permissionId?: StringFieldUpdateOperationsInput | string
	}

	export type BlockCreateManyParentBlockInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		resourceId: string
		blockType: EnumBlockType
		displayName: string
		description?: string | null
		lockedByUserId?: string | null
		lockedAt?: Date | string | null
		deletedAt?: Date | string | null
	}

	export type BlockVersionCreateManyBlockInput = {
		id?: string
		createdAt?: Date | string
		updatedAt?: Date | string
		versionNumber: number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings: JsonNullValueInput | InputJsonValue
		displayName?: string
		description?: string | null
		commitId?: string | null
		deleted?: boolean | null
	}

	export type BlockUpdateWithoutParentBlockInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resource?: ResourceUpdateOneRequiredWithoutBlocksInput
		lockedByUser?: UserUpdateOneWithoutLockedBlocksInput
		blocks?: BlockUpdateManyWithoutParentBlockInput
		versions?: BlockVersionUpdateManyWithoutBlockInput
	}

	export type BlockUncheckedUpdateWithoutParentBlockInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		blockType?: EnumEnumBlockTypeFieldUpdateOperationsInput | EnumBlockType
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		lockedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
		lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		blocks?: BlockUncheckedUpdateManyWithoutParentBlockInput
		versions?: BlockVersionUncheckedUpdateManyWithoutBlockInput
	}

	export type BlockVersionUpdateWithoutBlockInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		commit?: CommitUpdateOneWithoutBlockVersionsInput
		builds?: BuildUpdateManyWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedUpdateWithoutBlockInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		builds?: BuildUncheckedUpdateManyWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedUpdateManyWithoutVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
	}

	export type BuildUpdateWithoutBlockVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutBuildsInput
		resource?: ResourceUpdateOneRequiredWithoutBuildsInput
		commit?: CommitUpdateOneWithoutBuildsInput
		createdBy?: UserUpdateOneRequiredWithoutBuildsInput
		deployments?: DeploymentUpdateManyWithoutBuildInput
		entityVersions?: EntityVersionUpdateManyWithoutBuildsInput
	}

	export type BuildUncheckedUpdateWithoutBlockVersionsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		userId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deployments?: DeploymentUncheckedUpdateManyWithoutBuildInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutBuildsInput
	}

	export type ActionStepCreateManyActionInput = {
		id?: string
		createdAt?: Date | string
		message: string
		status: ActionStepStatus
		completedAt?: Date | string | null
		name?: string
	}

	export type BuildCreateManyActionInput = {
		id?: string
		createdAt?: Date | string
		resourceId: string
		userId: string
		version: string
		message?: string | null
		images?: BuildCreateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: Date | string | null
		commitId?: string | null
	}

	export type DeploymentCreateManyActionInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		buildId: string
		environmentId: string
		status: EnumDeploymentStatus
		message?: string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type ActionStepUpdateWithoutActionInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		status?: EnumActionStepStatusFieldUpdateOperationsInput | ActionStepStatus
		completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		name?: StringFieldUpdateOperationsInput | string
		logs?: ActionLogUpdateManyWithoutStepInput
	}

	export type ActionStepUncheckedUpdateWithoutActionInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		status?: EnumActionStepStatusFieldUpdateOperationsInput | ActionStepStatus
		completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		name?: StringFieldUpdateOperationsInput | string
		logs?: ActionLogUncheckedUpdateManyWithoutStepInput
	}

	export type ActionStepUncheckedUpdateManyWithoutStepsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		status?: EnumActionStepStatusFieldUpdateOperationsInput | ActionStepStatus
		completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		name?: StringFieldUpdateOperationsInput | string
	}

	export type BuildUpdateWithoutActionInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		resource?: ResourceUpdateOneRequiredWithoutBuildsInput
		commit?: CommitUpdateOneWithoutBuildsInput
		createdBy?: UserUpdateOneRequiredWithoutBuildsInput
		deployments?: DeploymentUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUpdateManyWithoutBuildsInput
	}

	export type BuildUncheckedUpdateWithoutActionInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		resourceId?: StringFieldUpdateOperationsInput | string
		userId?: StringFieldUpdateOperationsInput | string
		version?: StringFieldUpdateOperationsInput | string
		message?: NullableStringFieldUpdateOperationsInput | string | null
		images?: BuildUpdateimagesInput | Enumerable<string>
		containerStatusQuery?: NullableJsonNullValueInput | InputJsonValue
		containerStatusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deployments?: DeploymentUncheckedUpdateManyWithoutBuildInput
		blockVersions?: BlockVersionUncheckedUpdateManyWithoutBuildsInput
		entityVersions?: EntityVersionUncheckedUpdateManyWithoutBuildsInput
	}

	export type DeploymentUpdateWithoutActionInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		build?: BuildUpdateOneRequiredWithoutDeploymentsInput
		environment?: EnvironmentUpdateOneRequiredWithoutDeploymentsInput
		createdBy?: UserUpdateOneRequiredWithoutDeploymentsInput
	}

	export type DeploymentUncheckedUpdateWithoutActionInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		buildId?: StringFieldUpdateOperationsInput | string
		environmentId?: StringFieldUpdateOperationsInput | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type ActionLogCreateManyStepInput = {
		id?: string
		createdAt?: Date | string
		message: string
		meta: JsonNullValueInput | InputJsonValue
		level: EnumLogLevel
	}

	export type ActionLogUpdateWithoutStepInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		meta?: JsonNullValueInput | InputJsonValue
		level?: EnumEnumLogLevelFieldUpdateOperationsInput | EnumLogLevel
	}

	export type ActionLogUncheckedUpdateWithoutStepInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		meta?: JsonNullValueInput | InputJsonValue
		level?: EnumEnumLogLevelFieldUpdateOperationsInput | EnumLogLevel
	}

	export type ActionLogUncheckedUpdateManyWithoutLogsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		message?: StringFieldUpdateOperationsInput | string
		meta?: JsonNullValueInput | InputJsonValue
		level?: EnumEnumLogLevelFieldUpdateOperationsInput | EnumLogLevel
	}

	export type DeploymentCreateManyBuildInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		environmentId: string
		status: EnumDeploymentStatus
		message?: string | null
		actionId: string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type DeploymentUpdateWithoutBuildInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutDeploymentsInput
		environment?: EnvironmentUpdateOneRequiredWithoutDeploymentsInput
		createdBy?: UserUpdateOneRequiredWithoutDeploymentsInput
	}

	export type DeploymentUncheckedUpdateWithoutBuildInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		environmentId?: StringFieldUpdateOperationsInput | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}

	export type BlockVersionUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		block?: BlockUpdateOneRequiredWithoutVersionsInput
		commit?: CommitUpdateOneWithoutBlockVersionsInput
	}

	export type BlockVersionUncheckedUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		blockId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		inputParameters?: NullableJsonNullValueInput | InputJsonValue
		outputParameters?: NullableJsonNullValueInput | InputJsonValue
		settings?: JsonNullValueInput | InputJsonValue
		displayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
	}

	export type EntityVersionUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		commit?: CommitUpdateOneWithoutEntityVersionsInput
		entity?: EntityUpdateOneRequiredWithoutVersionsInput
		fields?: EntityFieldUpdateManyWithoutEntityVersionInput
		permissions?: EntityPermissionUpdateManyWithoutEntityVersionInput
	}

	export type EntityVersionUncheckedUpdateWithoutBuildsInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
		entityId?: StringFieldUpdateOperationsInput | string
		versionNumber?: IntFieldUpdateOperationsInput | number
		name?: StringFieldUpdateOperationsInput | string
		displayName?: StringFieldUpdateOperationsInput | string
		pluralDisplayName?: StringFieldUpdateOperationsInput | string
		description?: NullableStringFieldUpdateOperationsInput | string | null
		commitId?: NullableStringFieldUpdateOperationsInput | string | null
		deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
		fields?: EntityFieldUncheckedUpdateManyWithoutEntityVersionInput
		permissions?: EntityPermissionUncheckedUpdateManyWithoutEntityVersionInput
	}

	export type DeploymentCreateManyEnvironmentInput = {
		id?: string
		createdAt?: Date | string
		userId: string
		buildId: string
		status: EnumDeploymentStatus
		message?: string | null
		actionId: string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: Date | string | null
	}

	export type DeploymentUpdateWithoutEnvironmentInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
		action?: ActionUpdateOneRequiredWithoutDeploymentsInput
		build?: BuildUpdateOneRequiredWithoutDeploymentsInput
		createdBy?: UserUpdateOneRequiredWithoutDeploymentsInput
	}

	export type DeploymentUncheckedUpdateWithoutEnvironmentInput = {
		id?: StringFieldUpdateOperationsInput | string
		createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
		userId?: StringFieldUpdateOperationsInput | string
		buildId?: StringFieldUpdateOperationsInput | string
		status?: EnumEnumDeploymentStatusFieldUpdateOperationsInput | EnumDeploymentStatus
		message?: NullableStringFieldUpdateOperationsInput | string | null
		actionId?: StringFieldUpdateOperationsInput | string
		statusQuery?: NullableJsonNullValueInput | InputJsonValue
		statusUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
	}



	/**
	 * Batch Payload for updateMany & deleteMany & createMany
	 */

	export type BatchPayload = {
		count: number
	}

	/**
	 * DMMF
	 */
	export const dmmf: runtime.DMMF.Document;
}
